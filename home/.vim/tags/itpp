!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A	/usr/include/itpp/signal/fastica.h	/^  mat mixedSig, A, W, icasig;$/;"	m	class:itpp::Fast_ICA	access:private
A	/usr/include/itpp/signal/source.h	/^  double A, pos, dtheta;$/;"	m	class:itpp::Impulse_Source	access:private
A	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Sawtooth_Source	access:private
A	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Sine_Source	access:private
A	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Square_Source	access:private
A	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Triangle_Source	access:private
ACK	/usr/include/itpp/protocol/packet.h	/^  ACK(const int Seq_no = -1, const int Id = 0) { seq_no = Seq_no; id = Id; }$/;"	f	class:itpp::ACK	access:public	signature:(const int Seq_no = -1, const int Id = 0)
ACK	/usr/include/itpp/protocol/packet.h	/^class ACK : public Packet$/;"	c	namespace:itpp	inherits:Packet
ACK_Channel	/usr/include/itpp/protocol/packet_channel.h	/^  ACK_Channel();$/;"	p	class:itpp::ACK_Channel	access:public	signature:()
ACK_Channel	/usr/include/itpp/protocol/packet_channel.h	/^  ACK_Channel(const double Pr, const Ttype Delay);$/;"	p	class:itpp::ACK_Channel	access:public	signature:(const double Pr, const Ttype Delay)
ACK_Channel	/usr/include/itpp/protocol/packet_channel.h	/^class ACK_Channel$/;"	c	namespace:itpp
APPROX	/usr/include/itpp/comm/modulator.h	/^  APPROX   \/\/!< Approximate faster method$/;"	e	enum:itpp::Soft_Method
AR1_Gauss_RNG	/usr/include/itpp/base/random.h	/^typedef AR1_Normal_RNG AR1_Gauss_RNG;$/;"	t	namespace:itpp
AR1_Normal_RNG	/usr/include/itpp/base/random.h	/^  AR1_Normal_RNG(double meanval = 0.0, double variance = 1.0,$/;"	p	class:itpp::AR1_Normal_RNG	access:public	signature:(double meanval = 0.0, double variance = 1.0, double rho = 0.0)
AR1_Normal_RNG	/usr/include/itpp/base/random.h	/^class AR1_Normal_RNG$/;"	c	namespace:itpp
ARMA_Filter	/usr/include/itpp/signal/filter.h	/^  explicit ARMA_Filter();$/;"	p	class:itpp::ARMA_Filter	access:public	signature:()
ARMA_Filter	/usr/include/itpp/signal/filter.h	/^  explicit ARMA_Filter(const Vec<T2> &b, const Vec<T2> &a);$/;"	p	class:itpp::ARMA_Filter	access:public	signature:(const Vec<T2> &b, const Vec<T2> &a)
ARMA_Filter	/usr/include/itpp/signal/filter.h	/^ARMA_Filter<T1, T2, T3>::ARMA_Filter() : Filter<T1, T2, T3>()$/;"	f	class:itpp::ARMA_Filter	signature:()
ARMA_Filter	/usr/include/itpp/signal/filter.h	/^ARMA_Filter<T1, T2, T3>::ARMA_Filter(const Vec<T2> &b, const Vec<T2> &a) : Filter<T1, T2, T3>()$/;"	f	class:itpp::ARMA_Filter	signature:(const Vec<T2> &b, const Vec<T2> &a)
ARMA_Filter	/usr/include/itpp/signal/filter.h	/^class ARMA_Filter : public Filter<T1, T2, T3>$/;"	c	namespace:itpp	inherits:Filter
ARRAY_H	/usr/include/itpp/base/array.h	31;"	d
AR_Filter	/usr/include/itpp/signal/filter.h	/^  explicit AR_Filter();$/;"	p	class:itpp::AR_Filter	access:public	signature:()
AR_Filter	/usr/include/itpp/signal/filter.h	/^  explicit AR_Filter(const Vec<T2> &a);$/;"	p	class:itpp::AR_Filter	access:public	signature:(const Vec<T2> &a)
AR_Filter	/usr/include/itpp/signal/filter.h	/^AR_Filter<T1, T2, T3>::AR_Filter() : Filter<T1, T2, T3>()$/;"	f	class:itpp::AR_Filter	signature:()
AR_Filter	/usr/include/itpp/signal/filter.h	/^AR_Filter<T1, T2, T3>::AR_Filter(const Vec<T2> &a) : Filter<T1, T2, T3>()$/;"	f	class:itpp::AR_Filter	signature:(const Vec<T2> &a)
AR_Filter	/usr/include/itpp/signal/filter.h	/^class AR_Filter : public Filter<T1, T2, T3>$/;"	c	namespace:itpp	inherits:Filter
ATimer	/usr/include/itpp/protocol/signals_slots.h	/^  ATimer(const std::string Name = "Unamed ATimer") {$/;"	f	class:itpp::ATimer	access:public	signature:(const std::string Name = Ó)
ATimer	/usr/include/itpp/protocol/signals_slots.h	/^class ATimer$/;"	c	namespace:itpp
AUDIOFILE_H	/usr/include/itpp/srccode/audiofile.h	31;"	d
AWGN_Channel	/usr/include/itpp/comm/channel.h	/^  AWGN_Channel(double noisevar = 0.0): sigma(std::sqrt(noisevar)) {}$/;"	f	class:itpp::AWGN_Channel	access:public	signature:(double noisevar = 0.0)
AWGN_Channel	/usr/include/itpp/comm/channel.h	/^class AWGN_Channel$/;"	c	namespace:itpp
Array	/usr/include/itpp/base/array.h	/^  Array(const Array<T> &a, const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Array	access:public	signature:(const Array<T> &a, const Factory &f = DEFAULT_FACTORY)
Array	/usr/include/itpp/base/array.h	/^  Array(const char* values, const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Array	access:public	signature:(const char* values, const Factory &f = DEFAULT_FACTORY)
Array	/usr/include/itpp/base/array.h	/^  Array(const std::string& values, const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Array	access:public	signature:(const std::string& values, const Factory &f = DEFAULT_FACTORY)
Array	/usr/include/itpp/base/array.h	/^  Array(int n, const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Array	access:public	signature:(int n, const Factory &f = DEFAULT_FACTORY)
Array	/usr/include/itpp/base/array.h	/^  explicit Array(const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Array	access:public	signature:(const Factory &f = DEFAULT_FACTORY)
Array	/usr/include/itpp/base/array.h	/^Array<T>::Array(const Array<T> &a, const Factory &f)$/;"	f	class:itpp::Array	signature:(const Array<T> &a, const Factory &f)
Array	/usr/include/itpp/base/array.h	/^Array<T>::Array(const Factory &f) : ndata(0), data(0), factory(f) {}$/;"	f	class:itpp::Array	signature:(const Factory &f)
Array	/usr/include/itpp/base/array.h	/^Array<T>::Array(const char* values, const Factory &f)$/;"	f	class:itpp::Array	signature:(const char* values, const Factory &f)
Array	/usr/include/itpp/base/array.h	/^Array<T>::Array(const int n, const Factory &f) : ndata(0), data(0), factory(f)$/;"	f	class:itpp::Array	signature:(const int n, const Factory &f)
Array	/usr/include/itpp/base/array.h	/^Array<T>::Array(const std::string& values, const Factory &f)$/;"	f	class:itpp::Array	signature:(const std::string& values, const Factory &f)
Array	/usr/include/itpp/base/array.h	/^class Array$/;"	c	namespace:itpp
Audio_File	/usr/include/itpp/srccode/audiofile.h	/^  Audio_File();$/;"	p	class:itpp::Audio_File	access:public	signature:()
Audio_File	/usr/include/itpp/srccode/audiofile.h	/^class Audio_File$/;"	c	namespace:itpp
B	/usr/include/itpp/comm/egolay.h	/^  bmat B, G;$/;"	m	class:itpp::Extended_Golay	access:private
B	/usr/include/itpp/signal/freq_filt.h	/^  cvec B; \/\/ FFT of impulse vector$/;"	m	class:itpp::Freq_Filt	access:private
BCH	/usr/include/itpp/comm/bch.h	/^  BCH(int in_n, int in_k, int in_t, ivec genpolynom, bool sys = false);$/;"	p	class:itpp::BCH	access:public	signature:(int in_n, int in_k, int in_t, ivec genpolynom, bool sys = false)
BCH	/usr/include/itpp/comm/bch.h	/^class BCH : public Channel_Code$/;"	c	namespace:itpp	inherits:Channel_Code
BCH_H	/usr/include/itpp/comm/bch.h	31;"	d
BERC	/usr/include/itpp/comm/error_counters.h	/^  BERC(int indelay = 0, int inignorefirst = 0, int inignorelast = 0);$/;"	p	class:itpp::BERC	access:public	signature:(int indelay = 0, int inignorefirst = 0, int inignorelast = 0)
BERC	/usr/include/itpp/comm/error_counters.h	/^class BERC$/;"	c	namespace:itpp
BESSEL_H	/usr/include/itpp/base/bessel.h	31;"	d
BFGS	/usr/include/itpp/optim/newton_search.h	/^enum Newton_Search_Method {BFGS};$/;"	e	enum:itpp::Newton_Search_Method
BINARY_H	/usr/include/itpp/base/binary.h	31;"	d
BINFILE_H	/usr/include/itpp/base/binfile.h	31;"	d
BLAS_H	/usr/include/itpp/base/blas.h	31;"	d
BLDPC_Generator	/usr/include/itpp/comm/ldpc.h	/^  BLDPC_Generator(const BLDPC_Parity* const H,$/;"	p	class:itpp::BLDPC_Generator	access:public	signature:(const BLDPC_Parity* const H, const std::string type = Ó)
BLDPC_Generator	/usr/include/itpp/comm/ldpc.h	/^  BLDPC_Generator(const std::string type = "BLDPC"):$/;"	f	class:itpp::BLDPC_Generator	access:public	signature:(const std::string type = Ó)
BLDPC_Generator	/usr/include/itpp/comm/ldpc.h	/^class BLDPC_Generator : public LDPC_Generator$/;"	c	namespace:itpp	inherits:LDPC_Generator
BLDPC_Parity	/usr/include/itpp/comm/ldpc.h	/^  BLDPC_Parity(): LDPC_Parity(), Z(0), H_b(), H_b_valid(false) {}$/;"	f	class:itpp::BLDPC_Parity	access:public	signature:()
BLDPC_Parity	/usr/include/itpp/comm/ldpc.h	/^  BLDPC_Parity(const imat &base_matrix, int exp_factor);$/;"	p	class:itpp::BLDPC_Parity	access:public	signature:(const imat &base_matrix, int exp_factor)
BLDPC_Parity	/usr/include/itpp/comm/ldpc.h	/^  BLDPC_Parity(const std::string &filename, int exp_factor);$/;"	p	class:itpp::BLDPC_Parity	access:public	signature:(const std::string &filename, int exp_factor)
BLDPC_Parity	/usr/include/itpp/comm/ldpc.h	/^class BLDPC_Parity : public LDPC_Parity$/;"	c	namespace:itpp	inherits:LDPC_Parity
BLERC	/usr/include/itpp/comm/error_counters.h	/^  BLERC(int blocksize);$/;"	p	class:itpp::BLERC	access:public	signature:(int blocksize)
BLERC	/usr/include/itpp/comm/error_counters.h	/^  BLERC(void);$/;"	p	class:itpp::BLERC	access:public	signature:(void)
BLERC	/usr/include/itpp/comm/error_counters.h	/^class BLERC$/;"	c	namespace:itpp
BPSK	/usr/include/itpp/comm/modulator.h	/^  BPSK(): Modulator<double>("1.0 -1.0", "0 1") {}$/;"	f	class:itpp::BPSK	access:public	signature:()
BPSK	/usr/include/itpp/comm/modulator.h	/^class BPSK : public Modulator<double>$/;"	c	namespace:itpp	inherits:Modulator
BPSK_c	/usr/include/itpp/comm/modulator.h	/^  BPSK_c(): PSK(2) {}$/;"	f	class:itpp::BPSK_c	access:public	signature:()
BPSK_c	/usr/include/itpp/comm/modulator.h	/^class BPSK_c : public PSK$/;"	c	namespace:itpp	inherits:PSK
BSC	/usr/include/itpp/comm/channel.h	/^  BSC(double in_p = 0.0) : u(0.0, 1.0) { p = in_p; };$/;"	f	class:itpp::BSC	access:public	signature:(double in_p = 0.0)
BSC	/usr/include/itpp/comm/channel.h	/^class BSC$/;"	c	namespace:itpp
Base_Event	/usr/include/itpp/protocol/events.h	/^  Base_Event(const Ttype delta_time) {  \/\/ The event will occur in 'delta_time' time units from now!$/;"	f	class:itpp::Base_Event	access:public	signature:(const Ttype delta_time)
Base_Event	/usr/include/itpp/protocol/events.h	/^class Base_Event$/;"	c	namespace:itpp
Base_Event_Iterator	/usr/include/itpp/protocol/events.h	/^  typedef std::deque<Base_Event*, std::allocator< Base_Event* > >::iterator Base_Event_Iterator;$/;"	t	class:itpp::Event_Queue	access:private
Base_Slot	/usr/include/itpp/protocol/signals_slots.h	/^  Base_Slot(const std::string slot_name = "Unamed Base_Slot");$/;"	p	class:itpp::Base_Slot	access:public	signature:(const std::string slot_name = Ó)
Base_Slot	/usr/include/itpp/protocol/signals_slots.h	/^Base_Slot<DataType>::Base_Slot(const std::string slot_name)$/;"	f	class:itpp::Base_Slot	signature:(const std::string slot_name)
Base_Slot	/usr/include/itpp/protocol/signals_slots.h	/^class Base_Slot$/;"	c	namespace:itpp
Base_Slot_Iterator	/usr/include/itpp/protocol/signals_slots.h	/^  typedef typename std::list<Base_Slot<DataType>*, std::allocator< Base_Slot<DataType>* > >::iterator Base_Slot_Iterator;$/;"	t	class:itpp::Signal	access:protected
Bernoulli_RNG	/usr/include/itpp/base/random.h	/^  Bernoulli_RNG() { p = 0.5; }$/;"	f	class:itpp::Bernoulli_RNG	access:public	signature:()
Bernoulli_RNG	/usr/include/itpp/base/random.h	/^  Bernoulli_RNG(double prob) { setup(prob); }$/;"	f	class:itpp::Bernoulli_RNG	access:public	signature:(double prob)
Bernoulli_RNG	/usr/include/itpp/base/random.h	/^class Bernoulli_RNG$/;"	c	namespace:itpp
Block_Interleaver	/usr/include/itpp/comm/interleave.h	/^  Block_Interleaver(int in_rows, int in_cols);$/;"	p	class:itpp::Block_Interleaver	access:public	signature:(int in_rows, int in_cols)
Block_Interleaver	/usr/include/itpp/comm/interleave.h	/^  Block_Interleaver(void) {rows = 0; cols = 0;};$/;"	f	class:itpp::Block_Interleaver	access:public	signature:(void)
Block_Interleaver	/usr/include/itpp/comm/interleave.h	/^Block_Interleaver<T>::Block_Interleaver(int in_rows, int in_cols)$/;"	f	class:itpp::Block_Interleaver	signature:(int in_rows, int in_cols)
Block_Interleaver	/usr/include/itpp/comm/interleave.h	/^class Block_Interleaver$/;"	c	namespace:itpp
Boxplus	/usr/include/itpp/comm/llr.h	/^  QLLR Boxplus(QLLR a, QLLR b) const;$/;"	p	class:itpp::LLR_calc_unit	access:public	signature:(QLLR a, QLLR b) const
Burst_WWW_Packet_Generator	/usr/include/itpp/protocol/packet_generator.h	/^  Burst_WWW_Packet_Generator(const double Avg_bit_rate = 1.0, const int Packet_size = 150, const int Max_packets = 0);$/;"	p	class:itpp::Burst_WWW_Packet_Generator	access:public	signature:(const double Avg_bit_rate = 1.0, const int Packet_size = 150, const int Max_packets = 0)
Burst_WWW_Packet_Generator	/usr/include/itpp/protocol/packet_generator.h	/^class Burst_WWW_Packet_Generator : public Poisson_Packet_Generator$/;"	c	namespace:itpp	inherits:Poisson_Packet_Generator
C	/usr/include/itpp/comm/channel.h	/^  Jakes = 0, J = 0, Classic = 0, C = 0,$/;"	e	enum:itpp::DOPPLER_SPECTRUM
C	/usr/include/itpp/comm/ldpc.h	/^  ivec C, V, sumX1, sumX2, iind, jind;$/;"	m	class:itpp::LDPC_Code	access:private
CFIXED_H	/usr/include/itpp/fixed/cfixed.h	31;"	d
CFIX_H	/usr/include/itpp/fixed/cfix.h	31;"	d
CFix	/usr/include/itpp/fixed/cfix.h	/^  CFix(const CFix &x, double, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)$/;"	f	class:itpp::CFix	access:public	signature:(const CFix &x, double, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)
CFix	/usr/include/itpp/fixed/cfix.h	/^  CFix(const Fix &r, const Fix &i = 0.0, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)$/;"	f	class:itpp::CFix	access:public	signature:(const Fix &r, const Fix &i = 0.0, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)
CFix	/usr/include/itpp/fixed/cfix.h	/^  CFix(double r = 0.0, double i = 0.0, int s = 0, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)$/;"	f	class:itpp::CFix	access:public	signature:(double r = 0.0, double i = 0.0, int s = 0, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)
CFix	/usr/include/itpp/fixed/cfix.h	/^  CFix(fixrep r, fixrep i, int s, int, int)$/;"	f	class:itpp::CFix	access:public	signature:(fixrep r, fixrep i, int s, int, int)
CFix	/usr/include/itpp/fixed/cfix.h	/^  CFix(std::complex<double> x, double, int s = 0, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)$/;"	f	class:itpp::CFix	access:public	signature:(std::complex<double> x, double, int s = 0, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)
CFix	/usr/include/itpp/fixed/cfix.h	/^  explicit CFix(const Fix_Factory &f)$/;"	f	class:itpp::CFix	access:public	signature:(const Fix_Factory &f)
CFix	/usr/include/itpp/fixed/cfix.h	/^class CFix : public Fix_Base$/;"	c	namespace:itpp	inherits:Fix_Base
CFixed	/usr/include/itpp/fixed/cfixed.h	/^  CFixed(const CFix &x, double, Stat *ptr = 0)$/;"	f	class:itpp::CFixed	access:public	signature:(const CFix &x, double, Stat *ptr = 0)
CFixed	/usr/include/itpp/fixed/cfixed.h	/^  CFixed(const Fix &r, const Fix &i = 0.0, Stat *ptr = 0)$/;"	f	class:itpp::CFixed	access:public	signature:(const Fix &r, const Fix &i = 0.0, Stat *ptr = 0)
CFixed	/usr/include/itpp/fixed/cfixed.h	/^  CFixed(double r = 0.0, double i = 0.0, int s = 0, Stat *ptr = 0)$/;"	f	class:itpp::CFixed	access:public	signature:(double r = 0.0, double i = 0.0, int s = 0, Stat *ptr = 0)
CFixed	/usr/include/itpp/fixed/cfixed.h	/^  CFixed(std::complex<double> x, double, int s = 0, Stat *ptr = 0)$/;"	f	class:itpp::CFixed	access:public	signature:(std::complex<double> x, double, int s = 0, Stat *ptr = 0)
CFixed	/usr/include/itpp/fixed/cfixed.h	/^  explicit CFixed(Stat *ptr)$/;"	f	class:itpp::CFixed	access:public	signature:(Stat *ptr)
CFixed	/usr/include/itpp/fixed/cfixed.h	/^class CFixed : public CFix$/;"	c	namespace:itpp	inherits:CFix
CHANNEL_CODE_H	/usr/include/itpp/comm/channel_code.h	31;"	d
CHANNEL_H	/usr/include/itpp/comm/channel.h	31;"	d
CHANNEL_PROFILE	/usr/include/itpp/comm/channel.h	/^enum CHANNEL_PROFILE {$/;"	g	namespace:itpp
CHOLESKY_H	/usr/include/itpp/base/algebra/cholesky.h	31;"	d
CIRCULAR_BUFFER_H	/usr/include/itpp/base/circular_buffer.h	37;"	d
COMMFUNC_H	/usr/include/itpp/comm/commfunc.h	31;"	d
CONFIG_H	/usr/include/itpp/config.h	6;"	d
CONVCODE_H	/usr/include/itpp/comm/convcode.h	31;"	d
CONVERTERS_H	/usr/include/itpp/base/converters.h	31;"	d
CONVOLUTIONAL_CODE_METHOD	/usr/include/itpp/comm/convcode.h	/^enum CONVOLUTIONAL_CODE_METHOD {Trunc, Tail, Tailbite};$/;"	g	namespace:itpp
CONVOLUTIONAL_CODE_TYPE	/usr/include/itpp/comm/convcode.h	/^enum CONVOLUTIONAL_CODE_TYPE {MFD, ODS};$/;"	g	namespace:itpp
COPY_VECTOR_H	/usr/include/itpp/base/copy_vector.h	31;"	d
CORR	/usr/include/itpp/comm/error_counters.h	/^  bool CORR;$/;"	m	class:itpp::BLERC	access:private
CORRELATED_METHOD	/usr/include/itpp/comm/channel.h	/^enum CORRELATED_METHOD { Rice_MEDS, IFFT, FIR };$/;"	g	namespace:itpp
COST207_BU	/usr/include/itpp/comm/channel.h	/^  COST207_BU, COST207_BU6alt, COST207_BU12, COST207_BU12alt,$/;"	e	enum:itpp::CHANNEL_PROFILE
COST207_BU12	/usr/include/itpp/comm/channel.h	/^  COST207_BU, COST207_BU6alt, COST207_BU12, COST207_BU12alt,$/;"	e	enum:itpp::CHANNEL_PROFILE
COST207_BU12alt	/usr/include/itpp/comm/channel.h	/^  COST207_BU, COST207_BU6alt, COST207_BU12, COST207_BU12alt,$/;"	e	enum:itpp::CHANNEL_PROFILE
COST207_BU6alt	/usr/include/itpp/comm/channel.h	/^  COST207_BU, COST207_BU6alt, COST207_BU12, COST207_BU12alt,$/;"	e	enum:itpp::CHANNEL_PROFILE
COST207_HT	/usr/include/itpp/comm/channel.h	/^  COST207_HT, COST207_HT6alt, COST207_HT12, COST207_HT12alt,$/;"	e	enum:itpp::CHANNEL_PROFILE
COST207_HT12	/usr/include/itpp/comm/channel.h	/^  COST207_HT, COST207_HT6alt, COST207_HT12, COST207_HT12alt,$/;"	e	enum:itpp::CHANNEL_PROFILE
COST207_HT12alt	/usr/include/itpp/comm/channel.h	/^  COST207_HT, COST207_HT6alt, COST207_HT12, COST207_HT12alt,$/;"	e	enum:itpp::CHANNEL_PROFILE
COST207_HT6alt	/usr/include/itpp/comm/channel.h	/^  COST207_HT, COST207_HT6alt, COST207_HT12, COST207_HT12alt,$/;"	e	enum:itpp::CHANNEL_PROFILE
COST207_RA	/usr/include/itpp/comm/channel.h	/^  COST207_RA, COST207_RA6,$/;"	e	enum:itpp::CHANNEL_PROFILE
COST207_RA6	/usr/include/itpp/comm/channel.h	/^  COST207_RA, COST207_RA6,$/;"	e	enum:itpp::CHANNEL_PROFILE
COST207_TU	/usr/include/itpp/comm/channel.h	/^  COST207_TU, COST207_TU6alt, COST207_TU12, COST207_TU12alt,$/;"	e	enum:itpp::CHANNEL_PROFILE
COST207_TU12	/usr/include/itpp/comm/channel.h	/^  COST207_TU, COST207_TU6alt, COST207_TU12, COST207_TU12alt,$/;"	e	enum:itpp::CHANNEL_PROFILE
COST207_TU12alt	/usr/include/itpp/comm/channel.h	/^  COST207_TU, COST207_TU6alt, COST207_TU12, COST207_TU12alt,$/;"	e	enum:itpp::CHANNEL_PROFILE
COST207_TU6alt	/usr/include/itpp/comm/channel.h	/^  COST207_TU, COST207_TU6alt, COST207_TU12, COST207_TU12alt,$/;"	e	enum:itpp::CHANNEL_PROFILE
COST259_HTx	/usr/include/itpp/comm/channel.h	/^  COST259_TUx, COST259_RAx, COST259_HTx$/;"	e	enum:itpp::CHANNEL_PROFILE
COST259_RAx	/usr/include/itpp/comm/channel.h	/^  COST259_TUx, COST259_RAx, COST259_HTx$/;"	e	enum:itpp::CHANNEL_PROFILE
COST259_TUx	/usr/include/itpp/comm/channel.h	/^  COST259_TUx, COST259_RAx, COST259_HTx$/;"	e	enum:itpp::CHANNEL_PROFILE
CPU_Timer	/usr/include/itpp/base/timing.h	/^  CPU_Timer() { }$/;"	f	class:itpp::CPU_Timer	access:public	signature:()
CPU_Timer	/usr/include/itpp/base/timing.h	/^class CPU_Timer : public Timer$/;"	c	namespace:itpp	inherits:Timer
CRC_Code	/usr/include/itpp/comm/crc.h	/^  CRC_Code() { reverse_parity = false; }$/;"	f	class:itpp::CRC_Code	access:public	signature:()
CRC_Code	/usr/include/itpp/comm/crc.h	/^  CRC_Code(const std::string &code) { reverse_parity = false; set_code(code); }$/;"	f	class:itpp::CRC_Code	access:public	signature:(const std::string &code)
CRC_Code	/usr/include/itpp/comm/crc.h	/^class CRC_Code$/;"	c	namespace:itpp
CRC_H	/usr/include/itpp/comm/crc.h	31;"	d
CWnd_index	/usr/include/itpp/protocol/tcp.h	/^  int CWnd_index;$/;"	m	class:itpp::TCP_Sender	access:private
CWnd_time	/usr/include/itpp/protocol/tcp.h	/^  vec CWnd_time;$/;"	m	class:itpp::TCP_Sender	access:private
CWnd_val	/usr/include/itpp/protocol/tcp.h	/^  vec CWnd_val;$/;"	m	class:itpp::TCP_Sender	access:private
CalcRTOValue	/usr/include/itpp/protocol/tcp.h	/^  virtual double CalcRTOValue() const;   \/**< \\brief  value for rtx timer *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:() const
Ccmat2mxArray	/usr/include/itpp/itmex.h	/^void Ccmat2mxArray(double **in_real, double **in_imag, mxArray *out)$/;"	f	namespace:itpp	signature:(double **in_real, double **in_imag, mxArray *out)
Ccmat2mxArray	/usr/include/itpp/itmex.h	/^void Ccmat2mxArray(double **in_real, double **in_imag, mxArray *out);$/;"	p	namespace:itpp	signature:(double **in_real, double **in_imag, mxArray *out)
Ccvec2mxArray	/usr/include/itpp/itmex.h	/^void Ccvec2mxArray(double *in_real, double *in_imag, mxArray *out)$/;"	f	namespace:itpp	signature:(double *in_real, double *in_imag, mxArray *out)
Ccvec2mxArray	/usr/include/itpp/itmex.h	/^void Ccvec2mxArray(double *in_real, double *in_imag, mxArray *out);$/;"	p	namespace:itpp	signature:(double *in_real, double *in_imag, mxArray *out)
Channel_Code	/usr/include/itpp/comm/channel_code.h	/^  Channel_Code() {}$/;"	f	class:itpp::Channel_Code	access:public	signature:()
Channel_Code	/usr/include/itpp/comm/channel_code.h	/^class Channel_Code$/;"	c	namespace:itpp
Channel_Specification	/usr/include/itpp/comm/channel.h	/^  Channel_Specification(const CHANNEL_PROFILE profile);$/;"	p	class:itpp::Channel_Specification	access:public	signature:(const CHANNEL_PROFILE profile)
Channel_Specification	/usr/include/itpp/comm/channel.h	/^  Channel_Specification(const vec &avg_power_dB = "0", const vec &delay_prof = "0");$/;"	p	class:itpp::Channel_Specification	access:public	signature:(const vec &avg_power_dB = Ó, const vec &delay_prof = Ó)
Channel_Specification	/usr/include/itpp/comm/channel.h	/^class Channel_Specification$/;"	c	namespace:itpp
Cimat2mxArray	/usr/include/itpp/itmex.h	/^void Cimat2mxArray(int **in, mxArray *out)$/;"	f	namespace:itpp	signature:(int **in, mxArray *out)
Cimat2mxArray	/usr/include/itpp/itmex.h	/^void Cimat2mxArray(int **in, mxArray *out);$/;"	p	namespace:itpp	signature:(int **in, mxArray *out)
Circular_Buffer	/usr/include/itpp/base/circular_buffer.h	/^  Circular_Buffer();$/;"	p	class:itpp::Circular_Buffer	access:public	signature:()
Circular_Buffer	/usr/include/itpp/base/circular_buffer.h	/^  Circular_Buffer(const Circular_Buffer<T> &s);$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(const Circular_Buffer<T> &s)
Circular_Buffer	/usr/include/itpp/base/circular_buffer.h	/^  Circular_Buffer(int n);$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(int n)
Circular_Buffer	/usr/include/itpp/base/circular_buffer.h	/^Circular_Buffer<T>::Circular_Buffer()$/;"	f	class:itpp::Circular_Buffer	signature:()
Circular_Buffer	/usr/include/itpp/base/circular_buffer.h	/^Circular_Buffer<T>::Circular_Buffer(const Circular_Buffer<T> &cb)$/;"	f	class:itpp::Circular_Buffer	signature:(const Circular_Buffer<T> &cb)
Circular_Buffer	/usr/include/itpp/base/circular_buffer.h	/^Circular_Buffer<T>::Circular_Buffer(int n)$/;"	f	class:itpp::Circular_Buffer	signature:(int n)
Circular_Buffer	/usr/include/itpp/base/circular_buffer.h	/^class Circular_Buffer$/;"	c	namespace:itpp
Civec2mxArray	/usr/include/itpp/itmex.h	/^void Civec2mxArray(int *in, mxArray *out)$/;"	f	namespace:itpp	signature:(int *in, mxArray *out)
Civec2mxArray	/usr/include/itpp/itmex.h	/^void Civec2mxArray(int *in, mxArray *out);$/;"	p	namespace:itpp	signature:(int *in, mxArray *out)
Classic	/usr/include/itpp/comm/channel.h	/^  Jakes = 0, J = 0, Classic = 0, C = 0,$/;"	e	enum:itpp::DOPPLER_SPECTRUM
Cmat2mxArray	/usr/include/itpp/itmex.h	/^void Cmat2mxArray(double **in, mxArray *out)$/;"	f	namespace:itpp	signature:(double **in, mxArray *out)
Cmat2mxArray	/usr/include/itpp/itmex.h	/^void Cmat2mxArray(double **in, mxArray *out);$/;"	p	namespace:itpp	signature:(double **in, mxArray *out)
CodeBook	/usr/include/itpp/srccode/vq.h	/^  vec CodeBook;$/;"	m	class:itpp::Vector_Quantizer	access:protected
Compare_Base_Event_Times	/usr/include/itpp/protocol/events.h	/^struct Compare_Base_Event_Times {$/;"	s	namespace:itpp
Complex_Normal_RNG	/usr/include/itpp/base/random.h	/^  Complex_Normal_RNG(): m(0.0), sigma(1.0), norm_factor(1.0 \/ std::sqrt(2.0)) {}$/;"	f	class:itpp::Complex_Normal_RNG	access:public	signature:()
Complex_Normal_RNG	/usr/include/itpp/base/random.h	/^  Complex_Normal_RNG(std::complex<double> mean, double variance):$/;"	f	class:itpp::Complex_Normal_RNG	access:public	signature:(std::complex<double> mean, double variance)
Complex_Normal_RNG	/usr/include/itpp/base/random.h	/^class Complex_Normal_RNG$/;"	c	namespace:itpp
Connections	/usr/include/itpp/comm/sequence.h	/^  bvec memory, Connections;$/;"	m	class:itpp::LFSR	access:private
Constant_Rate_Packet_Generator	/usr/include/itpp/protocol/packet_generator.h	/^  Constant_Rate_Packet_Generator(const double Avg_bit_rate = 1.0, const int Packet_size = 150, const unsigned long int Max_packets = 0);$/;"	p	class:itpp::Constant_Rate_Packet_Generator	access:public	signature:(const double Avg_bit_rate = 1.0, const int Packet_size = 150, const unsigned long int Max_packets = 0)
Constant_Rate_Packet_Generator	/usr/include/itpp/protocol/packet_generator.h	/^class Constant_Rate_Packet_Generator : public Poisson_Packet_Generator$/;"	c	namespace:itpp	inherits:Poisson_Packet_Generator
Convert	/usr/include/itpp/fixed/fix_functions.h	/^class Convert$/;"	c	namespace:itpp
Convert	/usr/include/itpp/fixed/fix_functions.h	/^class Convert<Array<T> >$/;"	c	namespace:itpp
Convert	/usr/include/itpp/fixed/fix_functions.h	/^class Convert<CFix>$/;"	c	namespace:itpp
Convert	/usr/include/itpp/fixed/fix_functions.h	/^class Convert<Mat<T> >$/;"	c	namespace:itpp
Convert	/usr/include/itpp/fixed/fix_functions.h	/^class Convert<Vec<T> >$/;"	c	namespace:itpp
Convert	/usr/include/itpp/fixed/fix_functions.h	/^class Convert<std::complex<T> >$/;"	c	namespace:itpp
ConvertU2T	/usr/include/itpp/fixed/fix_functions.h	/^class ConvertU2T$/;"	c	namespace:itpp
ConvertU2T	/usr/include/itpp/fixed/fix_functions.h	/^class ConvertU2T<T, Array<U> >$/;"	c	namespace:itpp
ConvertU2T	/usr/include/itpp/fixed/fix_functions.h	/^class ConvertU2T<T, Mat<U> >$/;"	c	namespace:itpp
ConvertU2T	/usr/include/itpp/fixed/fix_functions.h	/^class ConvertU2T<T, Vec<U> >$/;"	c	namespace:itpp
Convolutional_Code	/usr/include/itpp/comm/convcode.h	/^  Convolutional_Code(void): K(0), start_state(0), cc_method(Tail) {$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(void)
Convolutional_Code	/usr/include/itpp/comm/convcode.h	/^class Convolutional_Code : public Channel_Code$/;"	c	namespace:itpp	inherits:Channel_Code
Correlated	/usr/include/itpp/comm/channel.h	/^enum FADING_TYPE { Independent, Static, Correlated };$/;"	e	enum:itpp::FADING_TYPE
Correlated_Fading_Generator	/usr/include/itpp/comm/channel.h	/^  Correlated_Fading_Generator(double norm_doppler);$/;"	p	class:itpp::Correlated_Fading_Generator	access:public	signature:(double norm_doppler)
Correlated_Fading_Generator	/usr/include/itpp/comm/channel.h	/^class Correlated_Fading_Generator : public Fading_Generator$/;"	c	namespace:itpp	inherits:Fading_Generator
Cross_Interleaver	/usr/include/itpp/comm/interleave.h	/^  Cross_Interleaver(int in_order);$/;"	p	class:itpp::Cross_Interleaver	access:public	signature:(int in_order)
Cross_Interleaver	/usr/include/itpp/comm/interleave.h	/^  Cross_Interleaver(void) {order = 0;};$/;"	f	class:itpp::Cross_Interleaver	access:public	signature:(void)
Cross_Interleaver	/usr/include/itpp/comm/interleave.h	/^Cross_Interleaver<T>::Cross_Interleaver(int in_order)$/;"	f	class:itpp::Cross_Interleaver	signature:(int in_order)
Cross_Interleaver	/usr/include/itpp/comm/interleave.h	/^class Cross_Interleaver$/;"	c	namespace:itpp
Csmat2mxArray	/usr/include/itpp/itmex.h	/^void Csmat2mxArray(short **in, mxArray *out)$/;"	f	namespace:itpp	signature:(short **in, mxArray *out)
Csmat2mxArray	/usr/include/itpp/itmex.h	/^void Csmat2mxArray(short **in, mxArray *out);$/;"	p	namespace:itpp	signature:(short **in, mxArray *out)
Csvec2mxArray	/usr/include/itpp/itmex.h	/^void Csvec2mxArray(short *in, mxArray *out)$/;"	f	namespace:itpp	signature:(short *in, mxArray *out)
Csvec2mxArray	/usr/include/itpp/itmex.h	/^void Csvec2mxArray(short *in, mxArray *out);$/;"	p	namespace:itpp	signature:(short *in, mxArray *out)
Cvec2mxArray	/usr/include/itpp/itmex.h	/^void Cvec2mxArray(double *in, mxArray *out)$/;"	f	namespace:itpp	signature:(double *in, mxArray *out)
Cvec2mxArray	/usr/include/itpp/itmex.h	/^void Cvec2mxArray(double *in, mxArray *out);$/;"	p	namespace:itpp	signature:(double *in, mxArray *out)
D	/usr/include/itpp/signal/fastica.h	/^  vec D;$/;"	m	class:itpp::Fast_ICA	access:private
D	/usr/include/itpp/stat/mog_generic.h	/^  int D;$/;"	m	class:itpp::MOG_generic	access:protected
DEFAULT_FACTORY	/usr/include/itpp/base/factory.h	/^const Factory DEFAULT_FACTORY;$/;"	m	namespace:itpp
DEFAULT_MAX_BYTES_IN_QUEUE	/usr/include/itpp/protocol/front_drop_queue.h	44;"	d
DET_H	/usr/include/itpp/base/algebra/det.h	31;"	d
DOPPLER_SPECTRUM	/usr/include/itpp/comm/channel.h	/^enum DOPPLER_SPECTRUM {$/;"	g	namespace:itpp
DOUBLE_POW2	/usr/include/itpp/fixed/fix_base.h	/^const double DOUBLE_POW2[128] = {$/;"	m	namespace:itpp
D_start	/usr/include/itpp/optim/newton_search.h	/^  mat D_start;$/;"	m	class:itpp::Newton_Search	access:private
Data_Event	/usr/include/itpp/protocol/events.h	/^  Data_Event(ObjectType *object_pointer,$/;"	f	class:itpp::Data_Event	access:public	signature:(ObjectType *object_pointer, void (ObjectType::*object_function_pointer)(DataType data), DataType data, const Ttype delta_time)
Data_Event	/usr/include/itpp/protocol/events.h	/^template <class ObjectType, class DataType> class Data_Event : public Base_Event$/;"	c	namespace:itpp	inherits:Base_Event
DelayedACKHandler	/usr/include/itpp/protocol/tcp.h	/^  virtual void DelayedACKHandler(Ttype);    \/**< \\brief  handler for delayed ACK timer *\/$/;"	p	class:itpp::TCP_Receiver	access:private	signature:(Ttype)
Delta_values	/usr/include/itpp/optim/newton_search.h	/^  vec F_values, ng_values, Delta_values;$/;"	m	class:itpp::Newton_Search	access:private
Dim	/usr/include/itpp/srccode/vq.h	/^  int Dim;$/;"	m	class:itpp::Vector_Quantizer	access:protected
Dint1	/usr/include/itpp/comm/llr.h	/^  short int Dint1, Dint2, Dint3;$/;"	m	class:itpp::LLR_calc_unit	access:private
Dint2	/usr/include/itpp/comm/llr.h	/^  short int Dint1, Dint2, Dint3;$/;"	m	class:itpp::LLR_calc_unit	access:private
Dint3	/usr/include/itpp/comm/llr.h	/^  short int Dint1, Dint2, Dint3;$/;"	m	class:itpp::LLR_calc_unit	access:private
Dummy_Code	/usr/include/itpp/comm/channel_code.h	/^  Dummy_Code() {}$/;"	f	class:itpp::Dummy_Code	access:public	signature:()
Dummy_Code	/usr/include/itpp/comm/channel_code.h	/^class Dummy_Code : public Channel_Code$/;"	c	namespace:itpp	inherits:Channel_Code
E	/usr/include/itpp/signal/fastica.h	/^  mat E, VecPr;$/;"	m	class:itpp::Fast_ICA	access:private
EGOLAY_H	/usr/include/itpp/comm/egolay.h	31;"	d
EIGEN_H	/usr/include/itpp/base/algebra/eigen.h	31;"	d
ELEM_MATH_H	/usr/include/itpp/base/math/elem_math.h	31;"	d
ERROR_COUNTERS_H	/usr/include/itpp/comm/error_counters.h	32;"	d
ERROR_H	/usr/include/itpp/base/math/error.h	31;"	d
EVENTS_H	/usr/include/itpp/protocol/events.h	31;"	d
Ec	/usr/include/itpp/comm/turbo.h	/^  double Ec, N0, Lc, R, logmax_scale_factor;$/;"	m	class:itpp::Turbo_Codec	access:private
Event	/usr/include/itpp/protocol/events.h	/^  Event(ObjectType *object_pointer, void (ObjectType::*object_function_pointer)(), const Ttype delta_time) : Base_Event(delta_time) {$/;"	f	class:itpp::Event	access:public	signature:(ObjectType *object_pointer, void (ObjectType::*object_function_pointer)(), const Ttype delta_time)
Event	/usr/include/itpp/protocol/events.h	/^class Event : public Base_Event$/;"	c	namespace:itpp	inherits:Base_Event
Event_Queue	/usr/include/itpp/protocol/events.h	/^  Event_Queue() {}$/;"	f	class:itpp::Event_Queue	access:public	signature:()
Event_Queue	/usr/include/itpp/protocol/events.h	/^class Event_Queue$/;"	c	namespace:itpp
Exact	/usr/include/itpp/optim/newton_search.h	/^enum Line_Search_Method {Soft, Exact};$/;"	e	enum:itpp::Line_Search_Method
ExpirationTime	/usr/include/itpp/protocol/signals_slots.h	/^  Ttype  ExpirationTime() const {$/;"	f	class:itpp::TTimer	access:public	signature:() const
Exponential_RNG	/usr/include/itpp/base/random.h	/^  Exponential_RNG(double lambda = 1.0);$/;"	p	class:itpp::Exponential_RNG	access:public	signature:(double lambda = 1.0)
Exponential_RNG	/usr/include/itpp/base/random.h	/^class Exponential_RNG$/;"	c	namespace:itpp
Extended_Golay	/usr/include/itpp/comm/egolay.h	/^  Extended_Golay();$/;"	p	class:itpp::Extended_Golay	access:public	signature:()
Extended_Golay	/usr/include/itpp/comm/egolay.h	/^class Extended_Golay : public Channel_Code$/;"	c	namespace:itpp	inherits:Channel_Code
F	/usr/include/itpp/optim/newton_search.h	/^  double F, ng, nh; \/\/ function value, stop_1, stop_2 values at solution point$/;"	m	class:itpp::Newton_Search	access:private
FACTORY_H	/usr/include/itpp/base/factory.h	31;"	d
FADING_TYPE	/usr/include/itpp/comm/channel.h	/^enum FADING_TYPE { Independent, Static, Correlated };$/;"	g	namespace:itpp
FASTICA_H	/usr/include/itpp/signal/fastica.h	64;"	d
FASTMATH_H	/usr/include/itpp/base/fastmath.h	32;"	d
FICA_APPROACH_DEFL	/usr/include/itpp/signal/fastica.h	70;"	d
FICA_APPROACH_SYMM	/usr/include/itpp/signal/fastica.h	72;"	d
FICA_INIT_GUESS	/usr/include/itpp/signal/fastica.h	86;"	d
FICA_INIT_RAND	/usr/include/itpp/signal/fastica.h	84;"	d
FICA_NONLIN_GAUSS	/usr/include/itpp/signal/fastica.h	79;"	d
FICA_NONLIN_POW3	/usr/include/itpp/signal/fastica.h	75;"	d
FICA_NONLIN_SKEW	/usr/include/itpp/signal/fastica.h	81;"	d
FICA_NONLIN_TANH	/usr/include/itpp/signal/fastica.h	77;"	d
FICA_TOL	/usr/include/itpp/signal/fastica.h	89;"	d
FILTER_DESIGN_H	/usr/include/itpp/signal/filter_design.h	31;"	d
FILTER_H	/usr/include/itpp/signal/filter.h	31;"	d
FIR	/usr/include/itpp/comm/channel.h	/^enum CORRELATED_METHOD { Rice_MEDS, IFFT, FIR };$/;"	e	enum:itpp::CORRELATED_METHOD
FIR_Fading_Generator	/usr/include/itpp/comm/channel.h	/^  FIR_Fading_Generator(double norm_doppler, int filter_length = 500);$/;"	p	class:itpp::FIR_Fading_Generator	access:public	signature:(double norm_doppler, int filter_length = 500)
FIR_Fading_Generator	/usr/include/itpp/comm/channel.h	/^class FIR_Fading_Generator : public Correlated_Fading_Generator$/;"	c	namespace:itpp	inherits:Correlated_Fading_Generator
FIXED_H	/usr/include/itpp/fixed/fixed.h	31;"	d
FIX_BASE_H	/usr/include/itpp/fixed/fix_base.h	31;"	d
FIX_FACTORY_H	/usr/include/itpp/fixed/fix_factory.h	32;"	d
FIX_FUNCTIONS_H	/usr/include/itpp/fixed/fix_functions.h	32;"	d
FIX_H	/usr/include/itpp/fixed/fix.h	31;"	d
FIX_OPERATORS_H	/usr/include/itpp/fixed/fix_operators.h	32;"	d
FP_NINF	/usr/include/itpp/config.h	243;"	d
FP_PINF	/usr/include/itpp/config.h	244;"	d
FREQ_FILT_H	/usr/include/itpp/signal/freq_filt.h	31;"	d
FRONT_DROP_QUEUE_H	/usr/include/itpp/protocol/front_drop_queue.h	31;"	d
FULL_ENUM_LOGMAP	/usr/include/itpp/comm/modulator_nd.h	/^    FULL_ENUM_LOGMAP,$/;"	e	enum:itpp::Modulator_ND::Soft_Demod_Method
F_end	/usr/include/itpp/optim/newton_search.h	/^  double F_end;$/;"	m	class:itpp::Line_Search	access:private
F_start	/usr/include/itpp/optim/newton_search.h	/^  double F_start;$/;"	m	class:itpp::Line_Search	access:private
F_values	/usr/include/itpp/optim/newton_search.h	/^  vec F_values, ng_values, Delta_values;$/;"	m	class:itpp::Newton_Search	access:private
F_values	/usr/include/itpp/optim/newton_search.h	/^  vec alpha_values, F_values, dF_values;$/;"	m	class:itpp::Line_Search	access:private
Factory	/usr/include/itpp/base/factory.h	/^  Factory() {}$/;"	f	class:itpp::Factory	access:public	signature:()
Factory	/usr/include/itpp/base/factory.h	/^class Factory$/;"	c	namespace:itpp
Fading_Generator	/usr/include/itpp/comm/channel.h	/^  Fading_Generator();$/;"	p	class:itpp::Fading_Generator	access:public	signature:()
Fading_Generator	/usr/include/itpp/comm/channel.h	/^class Fading_Generator$/;"	c	namespace:itpp
Fast_ICA	/usr/include/itpp/signal/fastica.h	/^  Fast_ICA(mat ma_mixed_sig);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(mat ma_mixed_sig)
Fast_ICA	/usr/include/itpp/signal/fastica.h	/^class Fast_ICA$/;"	c	namespace:itpp
Filter	/usr/include/itpp/signal/filter.h	/^  Filter() {}$/;"	f	class:itpp::Filter	access:public	signature:()
Filter	/usr/include/itpp/signal/filter.h	/^class Filter$/;"	c	namespace:itpp
FinishFastRecovery	/usr/include/itpp/protocol/tcp.h	/^  virtual void FinishFastRecovery();       \/**< \\brief  actions at end of fast recovery *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:()
Fix	/usr/include/itpp/fixed/fix.h	/^  Fix(const Fix &x, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)$/;"	f	class:itpp::Fix	access:public	signature:(const Fix &x, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)
Fix	/usr/include/itpp/fixed/fix.h	/^  Fix(double x = 0.0, int s = 0, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)$/;"	f	class:itpp::Fix	access:public	signature:(double x = 0.0, int s = 0, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)
Fix	/usr/include/itpp/fixed/fix.h	/^  Fix(fixrep r, int s, int, int)$/;"	f	class:itpp::Fix	access:public	signature:(fixrep r, int s, int, int)
Fix	/usr/include/itpp/fixed/fix.h	/^  explicit Fix(const Fix_Factory &f)$/;"	f	class:itpp::Fix	access:public	signature:(const Fix_Factory &f)
Fix	/usr/include/itpp/fixed/fix.h	/^class Fix : public Fix_Base$/;"	c	namespace:itpp	inherits:Fix_Base
Fix_Base	/usr/include/itpp/fixed/fix_base.h	/^  Fix_Base(const Fix_Base &x)$/;"	f	class:itpp::Fix_Base	access:public	signature:(const Fix_Base &x)
Fix_Base	/usr/include/itpp/fixed/fix_base.h	/^  explicit Fix_Base(int s = 0, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)$/;"	f	class:itpp::Fix_Base	access:public	signature:(int s = 0, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)
Fix_Base	/usr/include/itpp/fixed/fix_base.h	/^class Fix_Base$/;"	c	namespace:itpp
Fix_Factory	/usr/include/itpp/fixed/fix_factory.h	/^  explicit Fix_Factory(int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)$/;"	f	class:itpp::Fix_Factory	access:public	signature:(int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)
Fix_Factory	/usr/include/itpp/fixed/fix_factory.h	/^class Fix_Factory : public Factory$/;"	c	namespace:itpp	inherits:Factory
Fixed	/usr/include/itpp/fixed/fixed.h	/^  Fixed(const Fix &x, Stat *ptr = 0)$/;"	f	class:itpp::Fixed	access:public	signature:(const Fix &x, Stat *ptr = 0)
Fixed	/usr/include/itpp/fixed/fixed.h	/^  Fixed(double x = 0.0, int s = 0, Stat *ptr = 0)$/;"	f	class:itpp::Fixed	access:public	signature:(double x = 0.0, int s = 0, Stat *ptr = 0)
Fixed	/usr/include/itpp/fixed/fixed.h	/^  explicit Fixed(Stat *ptr)$/;"	f	class:itpp::Fixed	access:public	signature:(Stat *ptr)
Fixed	/usr/include/itpp/fixed/fixed.h	/^class Fixed : public Fix$/;"	c	namespace:itpp	inherits:Fix
Freq_Filt	/usr/include/itpp/signal/freq_filt.h	/^  Freq_Filt() {}$/;"	f	class:itpp::Freq_Filt	access:public	signature:()
Freq_Filt	/usr/include/itpp/signal/freq_filt.h	/^  Freq_Filt(const Vec<Num_T> &b, const int xlength) {init(b, xlength);}$/;"	f	class:itpp::Freq_Filt	access:public	signature:(const Vec<Num_T> &b, const int xlength)
Freq_Filt	/usr/include/itpp/signal/freq_filt.h	/^class Freq_Filt$/;"	c	namespace:itpp
Front_Drop_Queue	/usr/include/itpp/protocol/front_drop_queue.h	/^  Front_Drop_Queue(const int max_bytes = DEFAULT_MAX_BYTES_IN_QUEUE)  {$/;"	f	class:itpp::Front_Drop_Queue	access:public	signature:(const int max_bytes = DEFAULT_MAX_BYTES_IN_QUEUE)
Front_Drop_Queue	/usr/include/itpp/protocol/front_drop_queue.h	/^class Front_Drop_Queue : public virtual std::queue<Packet*>$/;"	c	namespace:itpp	inherits:std::queue
Full	/usr/include/itpp/base/itassert.h	/^enum error_msg_style { Full, Minimum };$/;"	e	enum:itpp::error_msg_style
G	/usr/include/itpp/comm/egolay.h	/^  bmat B, G;$/;"	m	class:itpp::Extended_Golay	access:private
G	/usr/include/itpp/comm/hammcode.h	/^  bmat H, G;$/;"	m	class:itpp::Hamming_Code	access:private
G	/usr/include/itpp/comm/ldpc.h	/^  GF2mat G; \/\/ the matrix is stored in transposed form$/;"	m	class:itpp::LDPC_Generator_Systematic	access:private
G	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Generator *G;  \/\/!< Generator object pointer$/;"	m	class:itpp::LDPC_Code	access:protected
G1	/usr/include/itpp/comm/channel.h	/^  GaussI = 1, Gauss1 = 1, GI = 1, G1 = 1,$/;"	e	enum:itpp::DOPPLER_SPECTRUM
G2	/usr/include/itpp/comm/channel.h	/^  GaussII = 2, Gauss2 = 2, GII = 2, G2 = 2$/;"	e	enum:itpp::DOPPLER_SPECTRUM
GALOIS_H	/usr/include/itpp/comm/galois.h	31;"	d
GCC_VERSION	/usr/include/itpp/config.h	264;"	d
GF	/usr/include/itpp/comm/galois.h	/^  GF() { m = 0; }$/;"	f	class:itpp::GF	access:public	signature:()
GF	/usr/include/itpp/comm/galois.h	/^  GF(const GF &ingf) { m = ingf.m; value = ingf.value; }$/;"	f	class:itpp::GF	access:public	signature:(const GF &ingf)
GF	/usr/include/itpp/comm/galois.h	/^  GF(int qvalue) {$/;"	f	class:itpp::GF	access:public	signature:(int qvalue)
GF	/usr/include/itpp/comm/galois.h	/^  GF(int qvalue, int inexp) { m = 0; set(qvalue, inexp); }$/;"	f	class:itpp::GF	access:public	signature:(int qvalue, int inexp)
GF	/usr/include/itpp/comm/galois.h	/^class GF$/;"	c	namespace:itpp
GF2MAT_H	/usr/include/itpp/base/gf2mat.h	44;"	d
GF2mat	/usr/include/itpp/base/gf2mat.h	/^  GF2mat();$/;"	p	class:itpp::GF2mat	access:public	signature:()
GF2mat	/usr/include/itpp/base/gf2mat.h	/^  GF2mat(const GF2mat_sparse &X);$/;"	p	class:itpp::GF2mat	access:public	signature:(const GF2mat_sparse &X)
GF2mat	/usr/include/itpp/base/gf2mat.h	/^  GF2mat(const GF2mat_sparse &X, const ivec &columns);$/;"	p	class:itpp::GF2mat	access:public	signature:(const GF2mat_sparse &X, const ivec &columns)
GF2mat	/usr/include/itpp/base/gf2mat.h	/^  GF2mat(const GF2mat_sparse &X, int m1, int n1, int m2, int n2);$/;"	p	class:itpp::GF2mat	access:public	signature:(const GF2mat_sparse &X, int m1, int n1, int m2, int n2)
GF2mat	/usr/include/itpp/base/gf2mat.h	/^  GF2mat(const bmat &X);$/;"	p	class:itpp::GF2mat	access:public	signature:(const bmat &X)
GF2mat	/usr/include/itpp/base/gf2mat.h	/^  GF2mat(const bvec &x, bool is_column = true);$/;"	p	class:itpp::GF2mat	access:public	signature:(const bvec &x, bool is_column = true)
GF2mat	/usr/include/itpp/base/gf2mat.h	/^  GF2mat(int m, int n);$/;"	p	class:itpp::GF2mat	access:public	signature:(int m, int n)
GF2mat	/usr/include/itpp/base/gf2mat.h	/^class GF2mat$/;"	c	namespace:itpp
GF2mat_sparse	/usr/include/itpp/base/gf2mat.h	/^typedef Sparse_Mat<bin> GF2mat_sparse;$/;"	t	namespace:itpp
GF2mat_sparse_alist	/usr/include/itpp/base/gf2mat.h	/^  GF2mat_sparse_alist() : data_ok(false) {}$/;"	f	class:itpp::GF2mat_sparse_alist	access:public	signature:()
GF2mat_sparse_alist	/usr/include/itpp/base/gf2mat.h	/^  GF2mat_sparse_alist(const std::string &fname);$/;"	p	class:itpp::GF2mat_sparse_alist	access:public	signature:(const std::string &fname)
GF2mat_sparse_alist	/usr/include/itpp/base/gf2mat.h	/^class GF2mat_sparse_alist$/;"	c	namespace:itpp
GF2vec_sparse	/usr/include/itpp/base/gf2mat.h	/^typedef Sparse_Vec<bin> GF2vec_sparse;$/;"	t	namespace:itpp
GFX	/usr/include/itpp/comm/galois.h	/^  GFX();$/;"	p	class:itpp::GFX	access:public	signature:()
GFX	/usr/include/itpp/comm/galois.h	/^  GFX(const GFX &ingfx);$/;"	p	class:itpp::GFX	access:public	signature:(const GFX &ingfx)
GFX	/usr/include/itpp/comm/galois.h	/^  GFX(int qvalue);$/;"	p	class:itpp::GFX	access:public	signature:(int qvalue)
GFX	/usr/include/itpp/comm/galois.h	/^  GFX(int qvalue, char *invalues);$/;"	p	class:itpp::GFX	access:public	signature:(int qvalue, char *invalues)
GFX	/usr/include/itpp/comm/galois.h	/^  GFX(int qvalue, const ivec &invalues);$/;"	p	class:itpp::GFX	access:public	signature:(int qvalue, const ivec &invalues)
GFX	/usr/include/itpp/comm/galois.h	/^  GFX(int qvalue, int indegree);$/;"	p	class:itpp::GFX	access:public	signature:(int qvalue, int indegree)
GFX	/usr/include/itpp/comm/galois.h	/^  GFX(int qvalue, std::string invalues);$/;"	p	class:itpp::GFX	access:public	signature:(int qvalue, std::string invalues)
GFX	/usr/include/itpp/comm/galois.h	/^class GFX$/;"	c	namespace:itpp
GFX	/usr/include/itpp/comm/galois.h	/^inline GFX::GFX()$/;"	f	class:itpp::GFX	signature:()
GFX	/usr/include/itpp/comm/galois.h	/^inline GFX::GFX(const GFX &ingfx)$/;"	f	class:itpp::GFX	signature:(const GFX &ingfx)
GFX	/usr/include/itpp/comm/galois.h	/^inline GFX::GFX(int qvalue)$/;"	f	class:itpp::GFX	signature:(int qvalue)
GFX	/usr/include/itpp/comm/galois.h	/^inline GFX::GFX(int qvalue, char *invalues)$/;"	f	class:itpp::GFX	signature:(int qvalue, char *invalues)
GFX	/usr/include/itpp/comm/galois.h	/^inline GFX::GFX(int qvalue, const ivec &invalues)$/;"	f	class:itpp::GFX	signature:(int qvalue, const ivec &invalues)
GFX	/usr/include/itpp/comm/galois.h	/^inline GFX::GFX(int qvalue, int indegree)$/;"	f	class:itpp::GFX	signature:(int qvalue, int indegree)
GFX	/usr/include/itpp/comm/galois.h	/^inline GFX::GFX(int qvalue, std::string invalues)$/;"	f	class:itpp::GFX	signature:(int qvalue, std::string invalues)
GI	/usr/include/itpp/comm/channel.h	/^  GaussI = 1, Gauss1 = 1, GI = 1, G1 = 1,$/;"	e	enum:itpp::DOPPLER_SPECTRUM
GII	/usr/include/itpp/comm/channel.h	/^  GaussII = 2, Gauss2 = 2, GII = 2, G2 = 2$/;"	e	enum:itpp::DOPPLER_SPECTRUM
GMM	/usr/include/itpp/srccode/gmm.h	/^  GMM();$/;"	p	class:itpp::GMM	access:public	signature:()
GMM	/usr/include/itpp/srccode/gmm.h	/^  GMM(int nomix, int dim);$/;"	p	class:itpp::GMM	access:public	signature:(int nomix, int dim)
GMM	/usr/include/itpp/srccode/gmm.h	/^  GMM(std::string filename);$/;"	p	class:itpp::GMM	access:public	signature:(std::string filename)
GMM	/usr/include/itpp/srccode/gmm.h	/^class GMM$/;"	c	namespace:itpp
GMM_H	/usr/include/itpp/srccode/gmm.h	31;"	d
G_defined	/usr/include/itpp/comm/ldpc.h	/^  bool G_defined;  \/\/!< true if generator is defined$/;"	m	class:itpp::LDPC_Code	access:protected
Gauss1	/usr/include/itpp/comm/channel.h	/^  GaussI = 1, Gauss1 = 1, GI = 1, G1 = 1,$/;"	e	enum:itpp::DOPPLER_SPECTRUM
Gauss2	/usr/include/itpp/comm/channel.h	/^  GaussII = 2, Gauss2 = 2, GII = 2, G2 = 2$/;"	e	enum:itpp::DOPPLER_SPECTRUM
GaussI	/usr/include/itpp/comm/channel.h	/^  GaussI = 1, Gauss1 = 1, GI = 1, G1 = 1,$/;"	e	enum:itpp::DOPPLER_SPECTRUM
GaussII	/usr/include/itpp/comm/channel.h	/^  GaussII = 2, Gauss2 = 2, GII = 2, G2 = 2$/;"	e	enum:itpp::DOPPLER_SPECTRUM
Gauss_RNG	/usr/include/itpp/base/random.h	/^typedef Normal_RNG Gauss_RNG;$/;"	t	namespace:itpp
GenerateFilename	/usr/include/itpp/protocol/tcp.h	/^  virtual std::string GenerateFilename();$/;"	p	class:itpp::TCP_Receiver	access:private	signature:()
GenerateFilename	/usr/include/itpp/protocol/tcp.h	/^  virtual std::string GenerateFilename();$/;"	p	class:itpp::TCP_Sender	access:private	signature:()
GetNextSegmentSize	/usr/include/itpp/protocol/tcp.h	/^  virtual unsigned GetNextSegmentSize(const Sequence_Number & begin);$/;"	p	class:itpp::TCP_Sender	access:private	signature:(const Sequence_Number & begin)
Gold	/usr/include/itpp/comm/sequence.h	/^  Gold(const bvec &mseq1_connections, const bvec &mseq2_connections);$/;"	p	class:itpp::Gold	access:public	signature:(const bvec &mseq1_connections, const bvec &mseq2_connections)
Gold	/usr/include/itpp/comm/sequence.h	/^  Gold(const ivec &mseq1_connections, const ivec &mseq2_connections);$/;"	p	class:itpp::Gold	access:public	signature:(const ivec &mseq1_connections, const ivec &mseq2_connections)
Gold	/usr/include/itpp/comm/sequence.h	/^  Gold(int degree);$/;"	p	class:itpp::Gold	access:public	signature:(int degree)
Gold	/usr/include/itpp/comm/sequence.h	/^class Gold$/;"	c	namespace:itpp
H	/usr/include/itpp/base/mat.h	/^  Mat<Num_T> H() const { return this->hermitian_transpose(); }$/;"	f	class:itpp::Mat	access:public	signature:() const
H	/usr/include/itpp/base/vec.h	/^  Mat<Num_T> H() const { return this->hermitian_transpose(); }$/;"	f	class:itpp::Vec	access:public	signature:() const
H	/usr/include/itpp/comm/hammcode.h	/^  bmat H, G;$/;"	m	class:itpp::Hamming_Code	access:private
H	/usr/include/itpp/comm/ldpc.h	/^  GF2mat_sparse H;$/;"	m	class:itpp::LDPC_Parity	access:protected
HAMMING_H	/usr/include/itpp/comm/hammcode.h	31;"	d
HAVE_ACOSH	/usr/include/itpp/config.h	17;"	d
HAVE_ASINH	/usr/include/itpp/config.h	20;"	d
HAVE_ATANH	/usr/include/itpp/config.h	23;"	d
HAVE_BLAS	/usr/include/itpp/config.h	26;"	d
HAVE_CBRT	/usr/include/itpp/config.h	38;"	d
HAVE_CMATH	/usr/include/itpp/config.h	41;"	d
HAVE_COMPLEX	/usr/include/itpp/config.h	44;"	d
HAVE_DECL_ISFINITE	/usr/include/itpp/config.h	48;"	d
HAVE_DECL_ISINF	/usr/include/itpp/config.h	52;"	d
HAVE_DECL_ISNAN	/usr/include/itpp/config.h	56;"	d
HAVE_DECL_SIGNGAM	/usr/include/itpp/config.h	60;"	d
HAVE_DLFCN_H	/usr/include/itpp/config.h	63;"	d
HAVE_ERF	/usr/include/itpp/config.h	66;"	d
HAVE_ERFC	/usr/include/itpp/config.h	69;"	d
HAVE_EXTERN_TEMPLATE	/usr/include/itpp/config.h	72;"	d
HAVE_FFT	/usr/include/itpp/config.h	75;"	d
HAVE_FFTW3	/usr/include/itpp/config.h	78;"	d
HAVE_FINITE	/usr/include/itpp/config.h	235;"	d
HAVE_FINITE	/usr/include/itpp/config.h	87;"	d
HAVE_FPCLASS	/usr/include/itpp/config.h	241;"	d
HAVE_INTTYPES_H	/usr/include/itpp/config.h	96;"	d
HAVE_ISFINITE	/usr/include/itpp/config.h	237;"	d
HAVE_ISINF	/usr/include/itpp/config.h	102;"	d
HAVE_ISNAN	/usr/include/itpp/config.h	105;"	d
HAVE_ISNAN	/usr/include/itpp/config.h	239;"	d
HAVE_J0	/usr/include/itpp/config.h	249;"	d
HAVE_J1	/usr/include/itpp/config.h	251;"	d
HAVE_JN	/usr/include/itpp/config.h	245;"	d
HAVE_LAPACK	/usr/include/itpp/config.h	108;"	d
HAVE_LGAMMA	/usr/include/itpp/config.h	111;"	d
HAVE_LOG1P	/usr/include/itpp/config.h	114;"	d
HAVE_LOG2	/usr/include/itpp/config.h	117;"	d
HAVE_MEMORY_H	/usr/include/itpp/config.h	120;"	d
HAVE_RINT	/usr/include/itpp/config.h	123;"	d
HAVE_STDINT_H	/usr/include/itpp/config.h	126;"	d
HAVE_STDLIB_H	/usr/include/itpp/config.h	129;"	d
HAVE_STD_ISFINITE	/usr/include/itpp/base/math/misc.h	89;"	d
HAVE_STD_ISFINITE	/usr/include/itpp/config.h	132;"	d
HAVE_STD_ISINF	/usr/include/itpp/base/math/misc.h	66;"	d
HAVE_STD_ISINF	/usr/include/itpp/config.h	135;"	d
HAVE_STD_ISNAN	/usr/include/itpp/base/math/misc.h	75;"	d
HAVE_STD_ISNAN	/usr/include/itpp/config.h	138;"	d
HAVE_STRINGS_H	/usr/include/itpp/config.h	141;"	d
HAVE_STRING_H	/usr/include/itpp/config.h	144;"	d
HAVE_SYS_STAT_H	/usr/include/itpp/config.h	147;"	d
HAVE_SYS_TYPES_H	/usr/include/itpp/config.h	150;"	d
HAVE_TGAMMA	/usr/include/itpp/config.h	153;"	d
HAVE_UNISTD_H	/usr/include/itpp/config.h	156;"	d
HAVE_YN	/usr/include/itpp/config.h	247;"	d
HAVE_ZDOTUSUB	/usr/include/itpp/config.h	159;"	d
HEAPSORT	/usr/include/itpp/base/sort.h	/^enum SORTING_METHOD { INTROSORT = 0, QUICKSORT = 1, HEAPSORT = 2,$/;"	e	enum:itpp::SORTING_METHOD
HELP_FUNCTIONS_H	/usr/include/itpp/base/help_functions.h	31;"	d
HISTOGRAM_H	/usr/include/itpp/stat/histogram.h	31;"	d
H_b	/usr/include/itpp/comm/ldpc.h	/^  imat H_b;   \/\/!< Base matrix$/;"	m	class:itpp::BLDPC_Parity	access:private
H_b_valid	/usr/include/itpp/comm/ldpc.h	/^  bool H_b_valid;  \/\/!< Indicates that base matrix is valid$/;"	m	class:itpp::BLDPC_Parity	access:private
H_defined	/usr/include/itpp/comm/ldpc.h	/^  bool H_defined;  \/\/!< true if parity check matrix is defined$/;"	m	class:itpp::LDPC_Code	access:protected
H_enc	/usr/include/itpp/comm/ldpc.h	/^  GF2mat H_enc;  \/\/!< Preprocessed parity check matrix$/;"	m	class:itpp::BLDPC_Generator	access:protected
Hamming_Code	/usr/include/itpp/comm/hammcode.h	/^  Hamming_Code(short m);$/;"	p	class:itpp::Hamming_Code	access:public	signature:(short m)
Hamming_Code	/usr/include/itpp/comm/hammcode.h	/^class Hamming_Code : public Channel_Code$/;"	c	namespace:itpp	inherits:Channel_Code
HandleACK	/usr/include/itpp/protocol/tcp.h	/^  virtual void HandleACK(TCP_Packet &);      \/**< \\brief  process incoming ACK *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:(TCP_Packet &)
HandleCancelEvent	/usr/include/itpp/protocol/signals_slots.h	/^  virtual void HandleCancelEvent(Ttype) {$/;"	f	class:itpp::TTimer	access:protected	signature:(Ttype)
HandleEndOfProcessing	/usr/include/itpp/protocol/tcp.h	/^  virtual void HandleEndOfProcessing(Ttype); \/**< \\brief  handler for user msg proc. *\/$/;"	p	class:itpp::TCP_Receiver	access:private	signature:(Ttype)
HandleProcessEvent	/usr/include/itpp/protocol/signals_slots.h	/^  virtual void HandleProcessEvent(Ttype currentTime) {$/;"	f	class:itpp::TTimer	access:protected	signature:(Ttype currentTime)
HandleRtxTimeout	/usr/include/itpp/protocol/tcp.h	/^  virtual void HandleRtxTimeout(Ttype);       \/**< \\brief  what to do after Timeout *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:(Ttype)
HandleSWSATimeout	/usr/include/itpp/protocol/tcp.h	/^  virtual void HandleSWSATimeout(Ttype);      \/**< \\brief  handler for SWSA\/Nagle timer *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:(Ttype)
HandleUserMessageIndication	/usr/include/itpp/protocol/tcp.h	/^  virtual void HandleUserMessageIndication(itpp::Packet *user_data);$/;"	p	class:itpp::TCP_Sender	access:private	signature:(itpp::Packet *user_data)
HeapSort	/usr/include/itpp/base/sort.h	/^  void HeapSort(int low, int high, T data[]);$/;"	p	class:itpp::Sort	access:private	signature:(int low, int high, T data[])
HeapSort	/usr/include/itpp/base/sort.h	/^void Sort<T>::HeapSort(int low, int high, T data[])$/;"	f	class:itpp::Sort	signature:(int low, int high, T data[])
HeapSort_Index	/usr/include/itpp/base/sort.h	/^  void HeapSort_Index(int low, int high, int indexlist[], const T data[]);$/;"	p	class:itpp::Sort	access:private	signature:(int low, int high, int indexlist[], const T data[])
HeapSort_Index	/usr/include/itpp/base/sort.h	/^void Sort<T>::HeapSort_Index(int low, int high, int indexlist[],$/;"	f	class:itpp::Sort	signature:(int low, int high, int indexlist[], const T data[])
Histogram	/usr/include/itpp/stat/histogram.h	/^  Histogram(Num_T from = Num_T(0), Num_T to = Num_T(99), int n_bins = 100);$/;"	p	class:itpp::Histogram	access:public	signature:(Num_T from = Num_T(0), Num_T to = Num_T(99), int n_bins = 100)
Histogram	/usr/include/itpp/stat/histogram.h	/^class Histogram$/;"	c	namespace:itpp
Histogram	/usr/include/itpp/stat/histogram.h	/^inline Histogram<Num_T>::Histogram(Num_T from, Num_T to, int n_bins)$/;"	f	class:itpp::Histogram	signature:(Num_T from, Num_T to, int n_bins)
Ht	/usr/include/itpp/comm/ldpc.h	/^  GF2mat_sparse Ht;$/;"	m	class:itpp::LDPC_Parity	access:protected
IFFT	/usr/include/itpp/comm/channel.h	/^enum CORRELATED_METHOD { Rice_MEDS, IFFT, FIR };$/;"	e	enum:itpp::CORRELATED_METHOD
IFFT_Fading_Generator	/usr/include/itpp/comm/channel.h	/^  IFFT_Fading_Generator(double norm_doppler) :$/;"	f	class:itpp::IFFT_Fading_Generator	access:public	signature:(double norm_doppler)
IFFT_Fading_Generator	/usr/include/itpp/comm/channel.h	/^class IFFT_Fading_Generator : public Correlated_Fading_Generator$/;"	c	namespace:itpp	inherits:Correlated_Fading_Generator
INSERTSORT	/usr/include/itpp/base/sort.h	/^                      INSERTSORT = 3$/;"	e	enum:itpp::SORTING_METHOD
INTEGRATION_H	/usr/include/itpp/base/math/integration.h	31;"	d
INTERLEAVE_H	/usr/include/itpp/comm/interleave.h	31;"	d
INTROSORT	/usr/include/itpp/base/sort.h	/^enum SORTING_METHOD { INTROSORT = 0, QUICKSORT = 1, HEAPSORT = 2,$/;"	e	enum:itpp::SORTING_METHOD
INV_H	/usr/include/itpp/base/algebra/inv.h	31;"	d
ITASSERT_H	/usr/include/itpp/base/itassert.h	31;"	d
ITBASE_H	/usr/include/itpp/itbase.h	31;"	d
ITCOMM_H	/usr/include/itpp/itcomm.h	31;"	d
ITFILE_H	/usr/include/itpp/base/itfile.h	31;"	d
ITFIXED_H	/usr/include/itpp/itfixed.h	31;"	d
ITMEX_H	/usr/include/itpp/itmex.h	31;"	d
ITOPTIM_H	/usr/include/itpp/itoptim.h	31;"	d
ITPROTOCOL_H	/usr/include/itpp/itprotocol.h	31;"	d
ITSIGNAL_H	/usr/include/itpp/itsignal.h	31;"	d
ITSRCCODE_H	/usr/include/itpp/itsrccode.h	31;"	d
ITSTAT_H	/usr/include/itpp/itstat.h	31;"	d
ITTYPES_H	/usr/include/itpp/base/ittypes.h	31;"	d
ITU_Pedestrian_A	/usr/include/itpp/comm/channel.h	/^  ITU_Vehicular_A, ITU_Vehicular_B, ITU_Pedestrian_A, ITU_Pedestrian_B,$/;"	e	enum:itpp::CHANNEL_PROFILE
ITU_Pedestrian_B	/usr/include/itpp/comm/channel.h	/^  ITU_Vehicular_A, ITU_Vehicular_B, ITU_Pedestrian_A, ITU_Pedestrian_B,$/;"	e	enum:itpp::CHANNEL_PROFILE
ITU_Vehicular_A	/usr/include/itpp/comm/channel.h	/^  ITU_Vehicular_A, ITU_Vehicular_B, ITU_Pedestrian_A, ITU_Pedestrian_B,$/;"	e	enum:itpp::CHANNEL_PROFILE
ITU_Vehicular_B	/usr/include/itpp/comm/channel.h	/^  ITU_Vehicular_A, ITU_Vehicular_B, ITU_Pedestrian_A, ITU_Pedestrian_B,$/;"	e	enum:itpp::CHANNEL_PROFILE
I_Uniform_RNG	/usr/include/itpp/base/random.h	/^  I_Uniform_RNG(int min = 0, int max = 1);$/;"	p	class:itpp::I_Uniform_RNG	access:public	signature:(int min = 0, int max = 1)
I_Uniform_RNG	/usr/include/itpp/base/random.h	/^class I_Uniform_RNG$/;"	c	namespace:itpp
IdleCheck	/usr/include/itpp/protocol/tcp.h	/^  virtual void IdleCheck();       \/**< \\brief  check whether SSR after idle is done *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:()
Impulse_Source	/usr/include/itpp/signal/source.h	/^  Impulse_Source(double freq, double ampl = 1.0, double inphase = 0.0);$/;"	p	class:itpp::Impulse_Source	access:public	signature:(double freq, double ampl = 1.0, double inphase = 0.0)
Impulse_Source	/usr/include/itpp/signal/source.h	/^class Impulse_Source$/;"	c	namespace:itpp
Independent	/usr/include/itpp/comm/channel.h	/^enum FADING_TYPE { Independent, Static, Correlated };$/;"	e	enum:itpp::FADING_TYPE
Independent_Fading_Generator	/usr/include/itpp/comm/channel.h	/^  Independent_Fading_Generator() : Fading_Generator() {}$/;"	f	class:itpp::Independent_Fading_Generator	access:public	signature:()
Independent_Fading_Generator	/usr/include/itpp/comm/channel.h	/^class Independent_Fading_Generator : public Fading_Generator$/;"	c	namespace:itpp	inherits:Fading_Generator
IndicateUserMessage	/usr/include/itpp/protocol/tcp.h	/^  void IndicateUserMessage(); \/**< \\brief indicate new data to higher layer *\/$/;"	p	class:itpp::TCP_Receiver	access:private	signature:()
InitStatistics	/usr/include/itpp/protocol/tcp.h	/^  virtual void InitStatistics();       \/**< \\brief  reset statistic counters *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:()
InsertSort	/usr/include/itpp/base/sort.h	/^  void InsertSort(int low, int high, T data[]);$/;"	p	class:itpp::Sort	access:private	signature:(int low, int high, T data[])
InsertSort	/usr/include/itpp/base/sort.h	/^void Sort<T>::InsertSort(int low, int high, T data[])$/;"	f	class:itpp::Sort	signature:(int low, int high, T data[])
InsertSort_Index	/usr/include/itpp/base/sort.h	/^  void InsertSort_Index(int low, int high, int indexlist[], const T data[]);$/;"	p	class:itpp::Sort	access:private	signature:(int low, int high, int indexlist[], const T data[])
InsertSort_Index	/usr/include/itpp/base/sort.h	/^void Sort<T>::InsertSort_Index(int low, int high, int indexlist[],$/;"	f	class:itpp::Sort	signature:(int low, int high, int indexlist[], const T data[])
IntroSort	/usr/include/itpp/base/sort.h	/^  void IntroSort(int low, int high, int max_depth, T data[]);$/;"	p	class:itpp::Sort	access:private	signature:(int low, int high, int max_depth, T data[])
IntroSort	/usr/include/itpp/base/sort.h	/^void Sort<T>::IntroSort(int low, int high, int max_depth, T data[])$/;"	f	class:itpp::Sort	signature:(int low, int high, int max_depth, T data[])
IntroSort_Index	/usr/include/itpp/base/sort.h	/^  void IntroSort_Index(int low, int high, int max_depth, int indexlist[],$/;"	p	class:itpp::Sort	access:private	signature:(int low, int high, int max_depth, int indexlist[], const T data[])
IntroSort_Index	/usr/include/itpp/base/sort.h	/^void Sort<T>::IntroSort_Index(int low, int high, int max_depth,$/;"	f	class:itpp::Sort	signature:(int low, int high, int max_depth, int indexlist[], const T data[])
IsPending	/usr/include/itpp/protocol/signals_slots.h	/^  bool  IsPending() const { return fPending; }$/;"	f	class:itpp::TTimer	access:public	signature:() const
J	/usr/include/itpp/comm/channel.h	/^  Jakes = 0, J = 0, Classic = 0, C = 0,$/;"	e	enum:itpp::DOPPLER_SPECTRUM
Jakes	/usr/include/itpp/comm/channel.h	/^  Jakes = 0, J = 0, Classic = 0, C = 0,$/;"	e	enum:itpp::DOPPLER_SPECTRUM
Jakes_filter	/usr/include/itpp/comm/channel.h	/^  vec Jakes_filter(double norm_dopp, int order = 100);$/;"	p	class:itpp::FIR_Fading_Generator	access:protected	signature:(double norm_dopp, int order = 100)
K	/usr/include/itpp/comm/convcode.h	/^  int K;$/;"	m	class:itpp::Convolutional_Code	access:protected
K	/usr/include/itpp/comm/ldpc.h	/^  int K;   \/\/!< Number of information bits = N-M$/;"	m	class:itpp::BLDPC_Generator	access:protected
K	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  int n, K, m;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
K	/usr/include/itpp/protocol/packet_channel.h	/^  int k, K, L;$/;"	m	class:itpp::ACK_Channel	access:private
K	/usr/include/itpp/protocol/packet_channel.h	/^  int k, K, L;$/;"	m	class:itpp::Packet_Channel	access:private
K	/usr/include/itpp/stat/mog_generic.h	/^  int K;$/;"	m	class:itpp::MOG_generic	access:protected
L	/usr/include/itpp/comm/modulator.h	/^  int L;$/;"	m	class:itpp::QAM	access:protected
L	/usr/include/itpp/comm/modulator_nd.h	/^  ivec L;  \/\/!< the square root of M$/;"	m	class:itpp::ND_UQAM	access:protected
L	/usr/include/itpp/comm/spread.h	/^  short L;$/;"	m	class:itpp::Multicode_Spread_1d	access:protected
L	/usr/include/itpp/protocol/packet_channel.h	/^  int k, K, L;$/;"	m	class:itpp::ACK_Channel	access:private
L	/usr/include/itpp/protocol/packet_channel.h	/^  int k, K, L;$/;"	m	class:itpp::Packet_Channel	access:private
L3_Packet_Info	/usr/include/itpp/protocol/packet.h	/^  L3_Packet_Info(Packet *packet) { timestamp = 0; pkt_pointer = packet; }$/;"	f	class:itpp::L3_Packet_Info	access:public	signature:(Packet *packet)
L3_Packet_Info	/usr/include/itpp/protocol/packet.h	/^class L3_Packet_Info$/;"	c	namespace:itpp
LDPC_Code	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Code();$/;"	p	class:itpp::LDPC_Code	access:public	signature:()
LDPC_Code	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Code(const LDPC_Parity* const H, LDPC_Generator* const G = 0);$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const LDPC_Parity* const H, LDPC_Generator* const G = 0)
LDPC_Code	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Code(const std::string& filename, LDPC_Generator* const G = 0);$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const std::string& filename, LDPC_Generator* const G = 0)
LDPC_Code	/usr/include/itpp/comm/ldpc.h	/^class LDPC_Code : public Channel_Code$/;"	c	namespace:itpp	inherits:Channel_Code
LDPC_Generator	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Generator(const std::string& type_in = ""): init_flag(false),$/;"	f	class:itpp::LDPC_Generator	access:public	signature:(const std::string& type_in = Ó)
LDPC_Generator	/usr/include/itpp/comm/ldpc.h	/^class LDPC_Generator$/;"	c	namespace:itpp
LDPC_Generator_Systematic	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Generator_Systematic(): LDPC_Generator("systematic"), G() {}$/;"	f	class:itpp::LDPC_Generator_Systematic	access:public	signature:()
LDPC_Generator_Systematic	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Generator_Systematic(LDPC_Parity* const H,$/;"	p	class:itpp::LDPC_Generator_Systematic	access:public	signature:(LDPC_Parity* const H, bool natural_ordering = false, const ivec& ind = Ó)
LDPC_Generator_Systematic	/usr/include/itpp/comm/ldpc.h	/^class LDPC_Generator_Systematic : public LDPC_Generator$/;"	c	namespace:itpp	inherits:LDPC_Generator
LDPC_H	/usr/include/itpp/comm/ldpc.h	31;"	d
LDPC_Parity	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Parity(): init_flag(false) {}$/;"	f	class:itpp::LDPC_Parity	access:public	signature:()
LDPC_Parity	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Parity(const GF2mat_sparse_alist& alist);$/;"	p	class:itpp::LDPC_Parity	access:public	signature:(const GF2mat_sparse_alist& alist)
LDPC_Parity	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Parity(const std::string& filename, const std::string& format);$/;"	p	class:itpp::LDPC_Parity	access:public	signature:(const std::string& filename, const std::string& format)
LDPC_Parity	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Parity(int ncheck, int nvar);$/;"	p	class:itpp::LDPC_Parity	access:public	signature:(int ncheck, int nvar)
LDPC_Parity	/usr/include/itpp/comm/ldpc.h	/^class LDPC_Parity$/;"	c	namespace:itpp
LDPC_Parity_Irregular	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Parity_Irregular() {}$/;"	f	class:itpp::LDPC_Parity_Irregular	access:public	signature:()
LDPC_Parity_Irregular	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Parity_Irregular(int Nvar, const vec& var_deg, const vec& chk_deg,$/;"	p	class:itpp::LDPC_Parity_Irregular	access:public	signature:(int Nvar, const vec& var_deg, const vec& chk_deg, const std::string& method = Ó, const ivec& options = Ó)
LDPC_Parity_Irregular	/usr/include/itpp/comm/ldpc.h	/^class LDPC_Parity_Irregular : public LDPC_Parity_Unstructured$/;"	c	namespace:itpp	inherits:LDPC_Parity_Unstructured
LDPC_Parity_Regular	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Parity_Regular() {}$/;"	f	class:itpp::LDPC_Parity_Regular	access:public	signature:()
LDPC_Parity_Regular	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Parity_Regular(int Nvar, int k, int l,$/;"	p	class:itpp::LDPC_Parity_Regular	access:public	signature:(int Nvar, int k, int l, const std::string& method = Ó, const ivec& options = Ó)
LDPC_Parity_Regular	/usr/include/itpp/comm/ldpc.h	/^class LDPC_Parity_Regular : public LDPC_Parity_Unstructured$/;"	c	namespace:itpp	inherits:LDPC_Parity_Unstructured
LDPC_Parity_Unstructured	/usr/include/itpp/comm/ldpc.h	/^class LDPC_Parity_Unstructured : public LDPC_Parity$/;"	c	namespace:itpp	inherits:LDPC_Parity
LFSR	/usr/include/itpp/comm/sequence.h	/^  LFSR(const bvec &connections);$/;"	p	class:itpp::LFSR	access:public	signature:(const bvec &connections)
LFSR	/usr/include/itpp/comm/sequence.h	/^  LFSR(const ivec &connections);$/;"	p	class:itpp::LFSR	access:public	signature:(const ivec &connections)
LFSR	/usr/include/itpp/comm/sequence.h	/^  LFSR(void) {};$/;"	f	class:itpp::LFSR	access:public	signature:(void)
LFSR	/usr/include/itpp/comm/sequence.h	/^class LFSR$/;"	c	namespace:itpp
LLR_H	/usr/include/itpp/comm/llr.h	31;"	d
LLR_calc_unit	/usr/include/itpp/comm/llr.h	/^  LLR_calc_unit();$/;"	p	class:itpp::LLR_calc_unit	access:public	signature:()
LLR_calc_unit	/usr/include/itpp/comm/llr.h	/^  LLR_calc_unit(short int Dint1, short int Dint2, short int Dint3);$/;"	p	class:itpp::LLR_calc_unit	access:public	signature:(short int Dint1, short int Dint2, short int Dint3)
LLR_calc_unit	/usr/include/itpp/comm/llr.h	/^class LLR_calc_unit$/;"	c	namespace:itpp
LOGMAP	/usr/include/itpp/comm/modulator.h	/^  LOGMAP,   \/\/!< Log-MAP full calculation$/;"	e	enum:itpp::Soft_Method
LOG_EXP_H	/usr/include/itpp/base/math/log_exp.h	31;"	d
LPCFUNC_H	/usr/include/itpp/srccode/lpcfunc.h	46;"	d
LS_SOLVE_H	/usr/include/itpp/base/algebra/ls_solve.h	31;"	d
LT_OBJDIR	/usr/include/itpp/config.h	169;"	d
LU_H	/usr/include/itpp/base/algebra/lu.h	31;"	d
Laplace_RNG	/usr/include/itpp/base/random.h	/^  Laplace_RNG(double meanval = 0.0, double variance = 1.0);$/;"	p	class:itpp::Laplace_RNG	access:public	signature:(double meanval = 0.0, double variance = 1.0)
Laplace_RNG	/usr/include/itpp/base/random.h	/^class Laplace_RNG$/;"	c	namespace:itpp
LatestDist	/usr/include/itpp/srccode/vq.h	/^  double LatestDist;$/;"	m	class:itpp::Scalar_Quantizer	access:protected
LatestDist	/usr/include/itpp/srccode/vq.h	/^  double LatestDist;$/;"	m	class:itpp::Vector_Quantizer	access:protected
Lc	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  double rate, Lc;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
Lc	/usr/include/itpp/comm/turbo.h	/^  double Ec, N0, Lc, R, logmax_scale_factor;$/;"	m	class:itpp::Turbo_Codec	access:private
Levels	/usr/include/itpp/srccode/vq.h	/^  vec Levels;$/;"	m	class:itpp::Scalar_Quantizer	access:protected
Line_Search	/usr/include/itpp/optim/newton_search.h	/^  Line_Search();$/;"	p	class:itpp::Line_Search	access:public	signature:()
Line_Search	/usr/include/itpp/optim/newton_search.h	/^class Line_Search$/;"	c	namespace:itpp
Line_Search_Method	/usr/include/itpp/optim/newton_search.h	/^enum Line_Search_Method {Soft, Exact};$/;"	g	namespace:itpp
Link_Packet	/usr/include/itpp/protocol/packet.h	/^  Link_Packet(const int Seq_no, const unsigned long int Link_packet_id, L3_Packet_Info *Cp) { seq_no = Seq_no; link_packet_id = Link_packet_id; l3_pkt_info_p = Cp; }$/;"	f	class:itpp::Link_Packet	access:public	signature:(const int Seq_no, const unsigned long int Link_packet_id, L3_Packet_Info *Cp)
Link_Packet	/usr/include/itpp/protocol/packet.h	/^class Link_Packet : public Packet$/;"	c	namespace:itpp	inherits:Packet
M	/usr/include/itpp/base/gf2mat.h	/^  int M;$/;"	m	class:itpp::GF2mat_sparse_alist	access:protected
M	/usr/include/itpp/comm/ldpc.h	/^  int M;       \/\/!< Number of parity check bits = H_enc.rows()$/;"	m	class:itpp::BLDPC_Generator	access:protected
M	/usr/include/itpp/comm/modulator.h	/^  int M;$/;"	m	class:itpp::Modulator	access:protected
M	/usr/include/itpp/comm/modulator_nd.h	/^  ivec M;$/;"	m	class:itpp::Modulator_ND	access:protected
M	/usr/include/itpp/srccode/gmm.h	/^  int   M, d;$/;"	m	class:itpp::GMM	access:protected
MATFUNC_H	/usr/include/itpp/base/matfunc.h	32;"	d
MAT_H	/usr/include/itpp/base/mat.h	31;"	d
MAX_WORDLEN	/usr/include/itpp/fixed/fix_base.h	/^const int MAX_WORDLEN = 64;$/;"	m	namespace:itpp
MA_Filter	/usr/include/itpp/signal/filter.h	/^  explicit MA_Filter();$/;"	p	class:itpp::MA_Filter	access:public	signature:()
MA_Filter	/usr/include/itpp/signal/filter.h	/^  explicit MA_Filter(const Vec<T2> &b);$/;"	p	class:itpp::MA_Filter	access:public	signature:(const Vec<T2> &b)
MA_Filter	/usr/include/itpp/signal/filter.h	/^MA_Filter<T1, T2, T3>::MA_Filter() : Filter<T1, T2, T3>()$/;"	f	class:itpp::MA_Filter	signature:()
MA_Filter	/usr/include/itpp/signal/filter.h	/^MA_Filter<T1, T2, T3>::MA_Filter(const Vec<T2> &b) : Filter<T1, T2, T3>()$/;"	f	class:itpp::MA_Filter	signature:(const Vec<T2> &b)
MA_Filter	/usr/include/itpp/signal/filter.h	/^class MA_Filter : public Filter<T1, T2, T3>$/;"	c	namespace:itpp	inherits:Filter
MEDS	/usr/include/itpp/comm/channel.h	/^enum RICE_METHOD { MEDS };$/;"	e	enum:itpp::RICE_METHOD
MFD	/usr/include/itpp/comm/convcode.h	/^enum CONVOLUTIONAL_CODE_TYPE {MFD, ODS};$/;"	e	enum:itpp::CONVOLUTIONAL_CODE_TYPE
MIN_MAX_H	/usr/include/itpp/base/math/min_max.h	31;"	d
MISC_H	/usr/include/itpp/base/math/misc.h	31;"	d
MISC_STAT_H	/usr/include/itpp/stat/misc_stat.h	31;"	d
MODULATOR_H	/usr/include/itpp/comm/modulator.h	31;"	d
MODULATOR_ND_H	/usr/include/itpp/comm/modulator_nd.h	31;"	d
MOG_DIAG_EM_H	/usr/include/itpp/stat/mog_diag_em.h	31;"	d
MOG_DIAG_H	/usr/include/itpp/stat/mog_diag.h	31;"	d
MOG_DIAG_KMEANS_H	/usr/include/itpp/stat/mog_diag_kmeans.h	32;"	d
MOG_GENERIC_H	/usr/include/itpp/stat/mog_generic.h	31;"	d
MOG_diag	/usr/include/itpp/stat/mog_diag.h	/^  MOG_diag() { zero_all_ptrs(); init(); }$/;"	f	class:itpp::MOG_diag	access:public	signature:()
MOG_diag	/usr/include/itpp/stat/mog_diag.h	/^  MOG_diag(Array<vec> &means_in, Array<mat> &full_covs_in, vec &weights_in) { zero_all_ptrs(); init(means_in, full_covs_in, weights_in); convert_to_diag(); }$/;"	f	class:itpp::MOG_diag	access:public	signature:(Array<vec> &means_in, Array<mat> &full_covs_in, vec &weights_in)
MOG_diag	/usr/include/itpp/stat/mog_diag.h	/^  MOG_diag(Array<vec> &means_in, Array<vec> &diag_covs_in, vec &weights_in) { zero_all_ptrs(); init(means_in, diag_covs_in, weights_in); }$/;"	f	class:itpp::MOG_diag	access:public	signature:(Array<vec> &means_in, Array<vec> &diag_covs_in, vec &weights_in)
MOG_diag	/usr/include/itpp/stat/mog_diag.h	/^  MOG_diag(Array<vec> &means_in, bool) { zero_all_ptrs(); init(means_in, false);  }$/;"	f	class:itpp::MOG_diag	access:public	signature:(Array<vec> &means_in, bool)
MOG_diag	/usr/include/itpp/stat/mog_diag.h	/^  MOG_diag(const int &K_in, const int &D_in, bool full_in = false) { zero_all_ptrs(); init(K_in, D_in, full_in); }$/;"	f	class:itpp::MOG_diag	access:public	signature:(const int &K_in, const int &D_in, bool full_in = false)
MOG_diag	/usr/include/itpp/stat/mog_diag.h	/^  MOG_diag(const std::string &name) { zero_all_ptrs(); load(name); }$/;"	f	class:itpp::MOG_diag	access:public	signature:(const std::string &name)
MOG_diag	/usr/include/itpp/stat/mog_diag.h	/^class MOG_diag : public MOG_generic$/;"	c	namespace:itpp	inherits:MOG_generic
MOG_diag_EM_sup	/usr/include/itpp/stat/mog_diag_em.h	/^  MOG_diag_EM_sup() { verbose = false; }$/;"	f	class:itpp::MOG_diag_EM_sup	access:public	signature:()
MOG_diag_EM_sup	/usr/include/itpp/stat/mog_diag_em.h	/^class MOG_diag_EM_sup : public MOG_diag$/;"	c	namespace:itpp	inherits:MOG_diag
MOG_diag_MAP	/usr/include/itpp/stat/mog_diag_em.h	/^void MOG_diag_MAP(MOG_diag &model_in, MOG_diag &prior_model_in, Array<vec> &X_in, int max_iter_in = 10, double alpha_in = 0.5, double var_floor_in = 0.0, double weight_floor_in = 0.0, bool verbose_in = false);$/;"	p	namespace:itpp	signature:(MOG_diag &model_in, MOG_diag &prior_model_in, Array<vec> &X_in, int max_iter_in = 10, double alpha_in = 0.5, double var_floor_in = 0.0, double weight_floor_in = 0.0, bool verbose_in = false)
MOG_diag_ML	/usr/include/itpp/stat/mog_diag_em.h	/^void MOG_diag_ML(MOG_diag &model_in, Array<vec> &X_in, int max_iter_in = 10, double var_floor_in = 0.0, double weight_floor_in = 0.0, bool verbose_in = false);$/;"	p	namespace:itpp	signature:(MOG_diag &model_in, Array<vec> &X_in, int max_iter_in = 10, double var_floor_in = 0.0, double weight_floor_in = 0.0, bool verbose_in = false)
MOG_diag_kmeans	/usr/include/itpp/stat/mog_diag_kmeans.h	/^void MOG_diag_kmeans(MOG_diag &model_in, Array<vec> &X_in, int max_iter_in = 10, double trust_in = 0.5, bool normalise_in = true, bool verbose_in = false);$/;"	p	namespace:itpp	signature:(MOG_diag &model_in, Array<vec> &X_in, int max_iter_in = 10, double trust_in = 0.5, bool normalise_in = true, bool verbose_in = false)
MOG_diag_kmeans_sup	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  MOG_diag_kmeans_sup() { verbose = false; }$/;"	f	class:itpp::MOG_diag_kmeans_sup	access:public	signature:()
MOG_diag_kmeans_sup	/usr/include/itpp/stat/mog_diag_kmeans.h	/^class MOG_diag_kmeans_sup : public MOG_diag$/;"	c	namespace:itpp	inherits:MOG_diag
MOG_generic	/usr/include/itpp/stat/mog_generic.h	/^  MOG_generic() { init(); }$/;"	f	class:itpp::MOG_generic	access:public	signature:()
MOG_generic	/usr/include/itpp/stat/mog_generic.h	/^  MOG_generic(Array<vec> &means_in, Array<mat> &full_covs_in, vec &weights_in) { init(means_in, full_covs_in, weights_in); }$/;"	f	class:itpp::MOG_generic	access:public	signature:(Array<vec> &means_in, Array<mat> &full_covs_in, vec &weights_in)
MOG_generic	/usr/include/itpp/stat/mog_generic.h	/^  MOG_generic(Array<vec> &means_in, Array<vec> &diag_covs_in, vec &weights_in) { init(means_in, diag_covs_in, weights_in); }$/;"	f	class:itpp::MOG_generic	access:public	signature:(Array<vec> &means_in, Array<vec> &diag_covs_in, vec &weights_in)
MOG_generic	/usr/include/itpp/stat/mog_generic.h	/^  MOG_generic(Array<vec> &means_in, bool full_in = false) { init(means_in, full_in); }$/;"	f	class:itpp::MOG_generic	access:public	signature:(Array<vec> &means_in, bool full_in = false)
MOG_generic	/usr/include/itpp/stat/mog_generic.h	/^  MOG_generic(const int &K_in, const int &D_in, bool full_in = false) { init(K_in, D_in, full_in); }$/;"	f	class:itpp::MOG_generic	access:public	signature:(const int &K_in, const int &D_in, bool full_in = false)
MOG_generic	/usr/include/itpp/stat/mog_generic.h	/^  MOG_generic(const std::string &name_in) { load(name_in); }$/;"	f	class:itpp::MOG_generic	access:public	signature:(const std::string &name_in)
MOG_generic	/usr/include/itpp/stat/mog_generic.h	/^class MOG_generic$/;"	c	namespace:itpp
Mat	/usr/include/itpp/base/mat.h	/^  Mat(const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:public	signature:(const Mat<Num_T> &m)
Mat	/usr/include/itpp/base/mat.h	/^  Mat(const Mat<Num_T> &m, const Factory &f);$/;"	p	class:itpp::Mat	access:public	signature:(const Mat<Num_T> &m, const Factory &f)
Mat	/usr/include/itpp/base/mat.h	/^  Mat(const Num_T *c_array, int rows, int cols, bool row_major = true,$/;"	p	class:itpp::Mat	access:public	signature:(const Num_T *c_array, int rows, int cols, bool row_major = true, const Factory &f = DEFAULT_FACTORY)
Mat	/usr/include/itpp/base/mat.h	/^  Mat(const Vec<Num_T> &v, const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Mat	access:public	signature:(const Vec<Num_T> &v, const Factory &f = DEFAULT_FACTORY)
Mat	/usr/include/itpp/base/mat.h	/^  Mat(const char *str, const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Mat	access:public	signature:(const char *str, const Factory &f = DEFAULT_FACTORY)
Mat	/usr/include/itpp/base/mat.h	/^  Mat(const std::string &str, const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Mat	access:public	signature:(const std::string &str, const Factory &f = DEFAULT_FACTORY)
Mat	/usr/include/itpp/base/mat.h	/^  Mat(int rows, int cols, const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Mat	access:public	signature:(int rows, int cols, const Factory &f = DEFAULT_FACTORY)
Mat	/usr/include/itpp/base/mat.h	/^  explicit Mat(const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Mat	access:public	signature:(const Factory &f = DEFAULT_FACTORY)
Mat	/usr/include/itpp/base/mat.h	/^Mat<Num_T>::Mat(const Factory &f) :$/;"	f	class:itpp::Mat	signature:(const Factory &f)
Mat	/usr/include/itpp/base/mat.h	/^Mat<Num_T>::Mat(const Mat<Num_T> &m) :$/;"	f	class:itpp::Mat	signature:(const Mat<Num_T> &m)
Mat	/usr/include/itpp/base/mat.h	/^Mat<Num_T>::Mat(const Mat<Num_T> &m, const Factory &f) :$/;"	f	class:itpp::Mat	signature:(const Mat<Num_T> &m, const Factory &f)
Mat	/usr/include/itpp/base/mat.h	/^Mat<Num_T>::Mat(const Num_T *c_array, int rows, int cols, bool row_major,$/;"	f	class:itpp::Mat	signature:(const Num_T *c_array, int rows, int cols, bool row_major, const Factory &f)
Mat	/usr/include/itpp/base/mat.h	/^Mat<Num_T>::Mat(const Vec<Num_T> &v, const Factory &f) :$/;"	f	class:itpp::Mat	signature:(const Vec<Num_T> &v, const Factory &f)
Mat	/usr/include/itpp/base/mat.h	/^Mat<Num_T>::Mat(const char *str, const Factory &f) :$/;"	f	class:itpp::Mat	signature:(const char *str, const Factory &f)
Mat	/usr/include/itpp/base/mat.h	/^Mat<Num_T>::Mat(const std::string &str, const Factory &f) :$/;"	f	class:itpp::Mat	signature:(const std::string &str, const Factory &f)
Mat	/usr/include/itpp/base/mat.h	/^Mat<Num_T>::Mat(int rows, int cols, const Factory &f) :$/;"	f	class:itpp::Mat	signature:(int rows, int cols, const Factory &f)
Mat	/usr/include/itpp/base/mat.h	/^class Mat$/;"	c	namespace:itpp
Minimum	/usr/include/itpp/base/itassert.h	/^enum error_msg_style { Full, Minimum };$/;"	e	enum:itpp::error_msg_style
Modulator	/usr/include/itpp/comm/modulator.h	/^  Modulator();$/;"	p	class:itpp::Modulator	access:public	signature:()
Modulator	/usr/include/itpp/comm/modulator.h	/^  Modulator(const Vec<T>& symbols, const ivec& bits2symbols);$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& symbols, const ivec& bits2symbols)
Modulator	/usr/include/itpp/comm/modulator.h	/^Modulator<T>::Modulator() :$/;"	f	class:itpp::Modulator	signature:()
Modulator	/usr/include/itpp/comm/modulator.h	/^Modulator<T>::Modulator(const Vec<T> &symbols, const ivec &bits2symbols)$/;"	f	class:itpp::Modulator	signature:(const Vec<T> &symbols, const ivec &bits2symbols)
Modulator	/usr/include/itpp/comm/modulator.h	/^class Modulator$/;"	c	namespace:itpp
Modulator_1D	/usr/include/itpp/comm/modulator.h	/^typedef Modulator<double> Modulator_1D;$/;"	t	namespace:itpp
Modulator_2D	/usr/include/itpp/comm/modulator.h	/^typedef Modulator<std::complex<double> > Modulator_2D;$/;"	t	namespace:itpp
Modulator_NCD	/usr/include/itpp/comm/modulator_nd.h	/^  Modulator_NCD() {}$/;"	f	class:itpp::Modulator_NCD	access:public	signature:()
Modulator_NCD	/usr/include/itpp/comm/modulator_nd.h	/^class Modulator_NCD : public Modulator_ND$/;"	c	namespace:itpp	inherits:Modulator_ND
Modulator_ND	/usr/include/itpp/comm/modulator_nd.h	/^  Modulator_ND(LLR_calc_unit llrcalc_in = LLR_calc_unit()):$/;"	f	class:itpp::Modulator_ND	access:public	signature:(LLR_calc_unit llrcalc_in = LLR_calc_unit())
Modulator_ND	/usr/include/itpp/comm/modulator_nd.h	/^class Modulator_ND$/;"	c	namespace:itpp
Modulator_NRD	/usr/include/itpp/comm/modulator_nd.h	/^  Modulator_NRD() {}$/;"	f	class:itpp::Modulator_NRD	access:public	signature:()
Modulator_NRD	/usr/include/itpp/comm/modulator_nd.h	/^class Modulator_NRD : public Modulator_ND$/;"	c	namespace:itpp	inherits:Modulator_ND
Multicode_Spread_1d	/usr/include/itpp/comm/spread.h	/^  Multicode_Spread_1d() { }$/;"	f	class:itpp::Multicode_Spread_1d	access:public	signature:()
Multicode_Spread_1d	/usr/include/itpp/comm/spread.h	/^  Multicode_Spread_1d(const mat &incodes);$/;"	p	class:itpp::Multicode_Spread_1d	access:public	signature:(const mat &incodes)
Multicode_Spread_1d	/usr/include/itpp/comm/spread.h	/^class Multicode_Spread_1d$/;"	c	namespace:itpp
Multicode_Spread_2d	/usr/include/itpp/comm/spread.h	/^  Multicode_Spread_2d() { }$/;"	f	class:itpp::Multicode_Spread_2d	access:public	signature:()
Multicode_Spread_2d	/usr/include/itpp/comm/spread.h	/^  Multicode_Spread_2d(const mat &incodesI, const mat &incodesQ);$/;"	p	class:itpp::Multicode_Spread_2d	access:public	signature:(const mat &incodesI, const mat &incodesQ)
Multicode_Spread_2d	/usr/include/itpp/comm/spread.h	/^class Multicode_Spread_2d$/;"	c	namespace:itpp
N	/usr/include/itpp/base/gf2mat.h	/^  int N;$/;"	m	class:itpp::GF2mat_sparse_alist	access:protected
N	/usr/include/itpp/comm/ldpc.h	/^  int N;   \/\/!< Codeword length = H_enc.cols()$/;"	m	class:itpp::BLDPC_Generator	access:protected
N	/usr/include/itpp/comm/sequence.h	/^  int N;$/;"	m	class:itpp::Gold	access:private
N	/usr/include/itpp/comm/spread.h	/^  short N;$/;"	m	class:itpp::Multicode_Spread_1d	access:protected
N	/usr/include/itpp/comm/spread.h	/^  short N;$/;"	m	class:itpp::Spread_1d	access:protected
N	/usr/include/itpp/protocol/packet_generator.h	/^  int N;$/;"	m	class:itpp::Burst_WWW_Packet_Generator	access:protected
N	/usr/include/itpp/stat/mog_diag_em.h	/^  int N;$/;"	m	class:itpp::MOG_diag_EM_sup	access:protected
N	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  int N;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:protected
N0	/usr/include/itpp/comm/turbo.h	/^  double Ec, N0, Lc, R, logmax_scale_factor;$/;"	m	class:itpp::Turbo_Codec	access:private
ND_UPAM	/usr/include/itpp/comm/modulator_nd.h	/^  ND_UPAM(int nt = 1, int Mary = 2);$/;"	p	class:itpp::ND_UPAM	access:public	signature:(int nt = 1, int Mary = 2)
ND_UPAM	/usr/include/itpp/comm/modulator_nd.h	/^class ND_UPAM : public Modulator_NRD$/;"	c	namespace:itpp	inherits:Modulator_NRD
ND_UPSK	/usr/include/itpp/comm/modulator_nd.h	/^  ND_UPSK(int nt = 1, int Mary = 4);$/;"	p	class:itpp::ND_UPSK	access:public	signature:(int nt = 1, int Mary = 4)
ND_UPSK	/usr/include/itpp/comm/modulator_nd.h	/^class ND_UPSK : public Modulator_NCD$/;"	c	namespace:itpp	inherits:Modulator_NCD
ND_UQAM	/usr/include/itpp/comm/modulator_nd.h	/^  ND_UQAM(int nt = 1, int Mary = 4);$/;"	p	class:itpp::ND_UQAM	access:public	signature:(int nt = 1, int Mary = 4)
ND_UQAM	/usr/include/itpp/comm/modulator_nd.h	/^class ND_UQAM : public Modulator_NCD$/;"	c	namespace:itpp	inherits:Modulator_NCD
NEWTON_SEARCH_H	/usr/include/itpp/optim/newton_search.h	31;"	d
N_taps	/usr/include/itpp/comm/channel.h	/^  int N_taps; \/\/!< Number of taps$/;"	m	class:itpp::Channel_Specification	access:protected
N_taps	/usr/include/itpp/comm/channel.h	/^  int N_taps; \/\/!< Number of taps$/;"	m	class:itpp::TDL_Channel	access:protected
Name	/usr/include/itpp/base/itfile.h	/^  Name(const std::string& n, const std::string& d = ""): name(n), desc(d) {}$/;"	f	class:itpp::Name	access:public	signature:(const std::string& n, const std::string& d = Ó)
Name	/usr/include/itpp/base/itfile.h	/^class Name$/;"	c	namespace:itpp
Navg	/usr/include/itpp/protocol/packet_generator.h	/^  int Navg;$/;"	m	class:itpp::Burst_WWW_Packet_Generator	access:protected
Nbytes	/usr/include/itpp/protocol/packet_generator.h	/^  unsigned long int Nbytes;$/;"	m	class:itpp::Sink	access:private
Ncoded	/usr/include/itpp/comm/turbo.h	/^  int Ncoded, Nuncoded;$/;"	m	class:itpp::Turbo_Codec	access:private
Ncp	/usr/include/itpp/comm/ofdm.h	/^  int Nfft, Ncp, Nupsample;$/;"	m	class:itpp::OFDM	access:private
Ncp	/usr/include/itpp/protocol/packet_generator.h	/^  unsigned long int Ncp;$/;"	m	class:itpp::Sink	access:private
Newton_Search	/usr/include/itpp/optim/newton_search.h	/^  Newton_Search();$/;"	p	class:itpp::Newton_Search	access:public	signature:()
Newton_Search	/usr/include/itpp/optim/newton_search.h	/^class Newton_Search$/;"	c	namespace:itpp
Newton_Search_Method	/usr/include/itpp/optim/newton_search.h	/^enum Newton_Search_Method {BFGS};$/;"	g	namespace:itpp
Nfft	/usr/include/itpp/comm/ofdm.h	/^  int Nfft, Ncp, Nupsample;$/;"	m	class:itpp::OFDM	access:private
Ni	/usr/include/itpp/comm/channel.h	/^  int Ni;$/;"	m	class:itpp::Rice_Fading_Generator	access:protected
Nmax	/usr/include/itpp/comm/ldpc.h	/^  static const int Nmax = 200;$/;"	m	class:itpp::LDPC_Parity	access:protected
Normal_RNG	/usr/include/itpp/base/random.h	/^  Normal_RNG(): mean(0.0), sigma(1.0) {}$/;"	f	class:itpp::Normal_RNG	access:public	signature:()
Normal_RNG	/usr/include/itpp/base/random.h	/^  Normal_RNG(double meanval, double variance):$/;"	f	class:itpp::Normal_RNG	access:public	signature:(double meanval, double variance)
Normal_RNG	/usr/include/itpp/base/random.h	/^class Normal_RNG$/;"	c	namespace:itpp
Nstates	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  int encoder_state, Nstates;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
Nuncoded	/usr/include/itpp/comm/turbo.h	/^  int Ncoded, Nuncoded;$/;"	m	class:itpp::Turbo_Codec	access:private
Nupsample	/usr/include/itpp/comm/ofdm.h	/^  int Nfft, Ncp, Nupsample;$/;"	m	class:itpp::OFDM	access:private
ODS	/usr/include/itpp/comm/convcode.h	/^enum CONVOLUTIONAL_CODE_TYPE {MFD, ODS};$/;"	e	enum:itpp::CONVOLUTIONAL_CODE_TYPE
OFDM	/usr/include/itpp/comm/ofdm.h	/^  OFDM(int inNfft, int inNcp, int inNupsample = 1);$/;"	p	class:itpp::OFDM	access:public	signature:(int inNfft, int inNcp, int inNupsample = 1)
OFDM	/usr/include/itpp/comm/ofdm.h	/^  OFDM(void) { setup_done = false; }$/;"	f	class:itpp::OFDM	access:public	signature:(void)
OFDM	/usr/include/itpp/comm/ofdm.h	/^class OFDM$/;"	c	namespace:itpp
OFDM_H	/usr/include/itpp/comm/ofdm.h	32;"	d
OPERATORS_H	/usr/include/itpp/base/operators.h	32;"	d
OUTPUT_FIX	/usr/include/itpp/fixed/fix_base.h	/^  OUTPUT_FIX,         \/\/!< Output fixed-point representation only$/;"	e	enum:itpp::output_mode
OUTPUT_FIX_SHIFT	/usr/include/itpp/fixed/fix_base.h	/^  OUTPUT_FIX_SHIFT,   \/\/!< Output fixed-point representation followed by \\<shift\\> (default)$/;"	e	enum:itpp::output_mode
OUTPUT_FLOAT	/usr/include/itpp/fixed/fix_base.h	/^  OUTPUT_FLOAT,       \/\/!< Output floating-point value$/;"	e	enum:itpp::output_mode
OUTPUT_FLOAT_SHIFT	/usr/include/itpp/fixed/fix_base.h	/^  OUTPUT_FLOAT_SHIFT  \/\/!< Output floating-point value followed by \\<\\<shift$/;"	e	enum:itpp::output_mode
PACKAGE	/usr/include/itpp/config.h	172;"	d
PACKAGE_BUGREPORT	/usr/include/itpp/config.h	175;"	d
PACKAGE_NAME	/usr/include/itpp/config.h	178;"	d
PACKAGE_STRING	/usr/include/itpp/config.h	181;"	d
PACKAGE_TARNAME	/usr/include/itpp/config.h	184;"	d
PACKAGE_VERSION	/usr/include/itpp/config.h	187;"	d
PACKET_CHANNEL_H	/usr/include/itpp/protocol/packet_channel.h	31;"	d
PACKET_GENERATOR_H	/usr/include/itpp/protocol/packet_generator.h	31;"	d
PACKET_H	/usr/include/itpp/protocol/packet.h	31;"	d
PAM	/usr/include/itpp/comm/modulator.h	/^  PAM() {}$/;"	f	class:itpp::PAM	access:public	signature:()
PAM	/usr/include/itpp/comm/modulator.h	/^  PAM(int M) { set_M(M); }$/;"	f	class:itpp::PAM	access:public	signature:(int M)
PAM	/usr/include/itpp/comm/modulator.h	/^class PAM : public Modulator<double>$/;"	c	namespace:itpp	inherits:Modulator
PAM_c	/usr/include/itpp/comm/modulator.h	/^  PAM_c() {}$/;"	f	class:itpp::PAM_c	access:public	signature:()
PAM_c	/usr/include/itpp/comm/modulator.h	/^  PAM_c(int M) { set_M(M); }$/;"	f	class:itpp::PAM_c	access:public	signature:(int M)
PAM_c	/usr/include/itpp/comm/modulator.h	/^class PAM_c : public Modulator<std::complex<double> >$/;"	c	namespace:itpp	inherits:Modulator
PARAM_R	/usr/include/itpp/base/random.h	/^  static const double PARAM_R;$/;"	m	class:itpp::Normal_RNG	access:private
PARSER_H	/usr/include/itpp/base/parser.h	33;"	d
PCAonly	/usr/include/itpp/signal/fastica.h	/^  bool finetune, stabilization, PCAonly;$/;"	m	class:itpp::Fast_ICA	access:private
PNM_H	/usr/include/itpp/srccode/pnm.h	31;"	d
POLY_H	/usr/include/itpp/signal/poly.h	31;"	d
PSK	/usr/include/itpp/comm/modulator.h	/^  PSK() {}$/;"	f	class:itpp::PSK	access:public	signature:()
PSK	/usr/include/itpp/comm/modulator.h	/^  PSK(int M) { set_M(M); }$/;"	f	class:itpp::PSK	access:public	signature:(int M)
PSK	/usr/include/itpp/comm/modulator.h	/^class PSK : public Modulator<std::complex<double> >$/;"	c	namespace:itpp	inherits:Modulator
PULSE_SHAPE_H	/usr/include/itpp/comm/pulse_shape.h	31;"	d
PUNCT_CONVCODE_H	/usr/include/itpp/comm/punct_convcode.h	31;"	d
Packet	/usr/include/itpp/protocol/packet.h	/^  Packet(const int packet_size = 0) { set_bit_size(packet_size); }$/;"	f	class:itpp::Packet	access:public	signature:(const int packet_size = 0)
Packet	/usr/include/itpp/protocol/packet.h	/^class Packet$/;"	c	namespace:itpp
Packet_Channel	/usr/include/itpp/protocol/packet_channel.h	/^  Packet_Channel();$/;"	p	class:itpp::Packet_Channel	access:public	signature:()
Packet_Channel	/usr/include/itpp/protocol/packet_channel.h	/^  Packet_Channel(const double Pr, const Ttype Delay, const double Block_rate, const int Max_slots = 0);$/;"	p	class:itpp::Packet_Channel	access:public	signature:(const double Pr, const Ttype Delay, const double Block_rate, const int Max_slots = 0)
Packet_Channel	/usr/include/itpp/protocol/packet_channel.h	/^class Packet_Channel$/;"	c	namespace:itpp
Packet_Generator	/usr/include/itpp/protocol/packet_generator.h	/^  Packet_Generator(const int Packet_size = 150, const unsigned long int Max_packets = 0);$/;"	p	class:itpp::Packet_Generator	access:public	signature:(const int Packet_size = 150, const unsigned long int Max_packets = 0)
Packet_Generator	/usr/include/itpp/protocol/packet_generator.h	/^class Packet_Generator$/;"	c	namespace:itpp
Parser	/usr/include/itpp/base/parser.h	/^  Parser();$/;"	p	class:itpp::Parser	access:public	signature:()
Parser	/usr/include/itpp/base/parser.h	/^  Parser(const Array<std::string> &setup);$/;"	p	class:itpp::Parser	access:public	signature:(const Array<std::string> &setup)
Parser	/usr/include/itpp/base/parser.h	/^  Parser(const std::string &filename);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &filename)
Parser	/usr/include/itpp/base/parser.h	/^  Parser(const std::string &filename, int argc, char *argv[]);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &filename, int argc, char *argv[])
Parser	/usr/include/itpp/base/parser.h	/^  Parser(int argc, char *argv[]);$/;"	p	class:itpp::Parser	access:public	signature:(int argc, char *argv[])
Parser	/usr/include/itpp/base/parser.h	/^class Parser$/;"	c	namespace:itpp
Pattern_Source	/usr/include/itpp/signal/source.h	/^  Pattern_Source(const vec &pattern, int start_pos = 0);$/;"	p	class:itpp::Pattern_Source	access:public	signature:(const vec &pattern, int start_pos = 0)
Pattern_Source	/usr/include/itpp/signal/source.h	/^class Pattern_Source$/;"	c	namespace:itpp
Period	/usr/include/itpp/comm/punct_convcode.h	/^  int Period;$/;"	m	class:itpp::Punctured_Convolutional_Code	access:protected
PeriodicACKHandler	/usr/include/itpp/protocol/tcp.h	/^  virtual void PeriodicACKHandler(Ttype);   \/**< \\brief  handler for periodic ACK timer *\/$/;"	p	class:itpp::TCP_Receiver	access:private	signature:(Ttype)
Poisson_Packet_Generator	/usr/include/itpp/protocol/packet_generator.h	/^  Poisson_Packet_Generator(const double Avg_bit_rate = 1.0, const int Packet_size = 150, const unsigned long int Max_packets = 0);$/;"	p	class:itpp::Poisson_Packet_Generator	access:public	signature:(const double Avg_bit_rate = 1.0, const int Packet_size = 150, const unsigned long int Max_packets = 0)
Poisson_Packet_Generator	/usr/include/itpp/protocol/packet_generator.h	/^class Poisson_Packet_Generator : public Packet_Generator$/;"	c	namespace:itpp	inherits:Packet_Generator
Pulse_Shape	/usr/include/itpp/comm/pulse_shape.h	/^  Pulse_Shape();$/;"	p	class:itpp::Pulse_Shape	access:public	signature:()
Pulse_Shape	/usr/include/itpp/comm/pulse_shape.h	/^  Pulse_Shape(const Vec<T2> &impulse_response, int upsampling_factor);$/;"	p	class:itpp::Pulse_Shape	access:public	signature:(const Vec<T2> &impulse_response, int upsampling_factor)
Pulse_Shape	/usr/include/itpp/comm/pulse_shape.h	/^Pulse_Shape<T1, T2, T3>::Pulse_Shape()$/;"	f	class:itpp::Pulse_Shape	signature:()
Pulse_Shape	/usr/include/itpp/comm/pulse_shape.h	/^Pulse_Shape<T1, T2, T3>::Pulse_Shape(const Vec<T2> &impulse_response, int upsampling_factor)$/;"	f	class:itpp::Pulse_Shape	signature:(const Vec<T2> &impulse_response, int upsampling_factor)
Pulse_Shape	/usr/include/itpp/comm/pulse_shape.h	/^class Pulse_Shape$/;"	c	namespace:itpp
Punctured_Convolutional_Code	/usr/include/itpp/comm/punct_convcode.h	/^  Punctured_Convolutional_Code(void) : Convolutional_Code() {}$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:(void)
Punctured_Convolutional_Code	/usr/include/itpp/comm/punct_convcode.h	/^class Punctured_Convolutional_Code : public Convolutional_Code$/;"	c	namespace:itpp	inherits:Convolutional_Code
Q	/usr/include/itpp/srccode/vq.h	/^  double Q(double x) const;$/;"	p	class:itpp::Scalar_Quantizer	access:public	signature:(double x) const
Q	/usr/include/itpp/srccode/vq.h	/^  vec Q(const vec &x) const;$/;"	p	class:itpp::Scalar_Quantizer	access:public	signature:(const vec &x) const
Q	/usr/include/itpp/srccode/vq.h	/^  vec Q(const vec &x);$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:(const vec &x)
Q	/usr/include/itpp/srccode/vq.h	/^inline double Scalar_Quantizer::Q(double x) const { return decode(encode(x)); }$/;"	f	class:itpp::Scalar_Quantizer	signature:(double x) const
Q	/usr/include/itpp/srccode/vq.h	/^inline vec Vector_Quantizer::Q(const vec &x) { return decode(encode(x)); }$/;"	f	class:itpp::Vector_Quantizer	signature:(const vec &x)
QAM	/usr/include/itpp/comm/modulator.h	/^  QAM() {}$/;"	f	class:itpp::QAM	access:public	signature:()
QAM	/usr/include/itpp/comm/modulator.h	/^  QAM(int M) { set_M(M); }$/;"	f	class:itpp::QAM	access:public	signature:(int M)
QAM	/usr/include/itpp/comm/modulator.h	/^class QAM : public Modulator<std::complex<double> >$/;"	c	namespace:itpp	inherits:Modulator
QLLR	/usr/include/itpp/comm/llr.h	/^typedef signed int QLLR;$/;"	t	namespace:itpp
QLLR_MAX	/usr/include/itpp/comm/llr.h	/^const QLLR QLLR_MAX = (std::numeric_limits<QLLR>::max() >> 4);$/;"	m	namespace:itpp
QLLRmat	/usr/include/itpp/comm/llr.h	/^typedef Mat<QLLR> QLLRmat;$/;"	t	namespace:itpp
QLLRvec	/usr/include/itpp/comm/llr.h	/^typedef Vec<QLLR> QLLRvec;$/;"	t	namespace:itpp
QPSK	/usr/include/itpp/comm/modulator.h	/^  QPSK(): PSK(4) {}$/;"	f	class:itpp::QPSK	access:public	signature:()
QPSK	/usr/include/itpp/comm/modulator.h	/^class QPSK : public PSK$/;"	c	namespace:itpp	inherits:PSK
QR_H	/usr/include/itpp/base/algebra/qr.h	31;"	d
QUICKSORT	/usr/include/itpp/base/sort.h	/^enum SORTING_METHOD { INTROSORT = 0, QUICKSORT = 1, HEAPSORT = 2,$/;"	e	enum:itpp::SORTING_METHOD
Qfunc	/usr/include/itpp/base/math/error.h	/^double Qfunc(double x);$/;"	p	namespace:itpp	signature:(double x)
Qfunc	/usr/include/itpp/base/math/error.h	/^inline mat Qfunc(const mat &x)$/;"	f	namespace:itpp	signature:(const mat &x)
Qfunc	/usr/include/itpp/base/math/error.h	/^inline vec Qfunc(const vec &x)$/;"	f	namespace:itpp	signature:(const vec &x)
QuickSort	/usr/include/itpp/base/sort.h	/^  void QuickSort(int low, int high, T data[]);$/;"	p	class:itpp::Sort	access:private	signature:(int low, int high, T data[])
QuickSort	/usr/include/itpp/base/sort.h	/^void Sort<T>::QuickSort(int low, int high, T data[])$/;"	f	class:itpp::Sort	signature:(int low, int high, T data[])
QuickSort_Index	/usr/include/itpp/base/sort.h	/^  void QuickSort_Index(int low, int high, int indexlist[], const T data[]);$/;"	p	class:itpp::Sort	access:private	signature:(int low, int high, int indexlist[], const T data[])
QuickSort_Index	/usr/include/itpp/base/sort.h	/^void Sort<T>::QuickSort_Index(int low, int high, int indexlist[],$/;"	f	class:itpp::Sort	signature:(int low, int high, int indexlist[], const T data[])
R	/usr/include/itpp/comm/turbo.h	/^  double Ec, N0, Lc, R, logmax_scale_factor;$/;"	m	class:itpp::Turbo_Codec	access:private
RANDOM_H	/usr/include/itpp/base/random.h	31;"	d
REC_SYST_CONV_CODE_H	/usr/include/itpp/comm/rec_syst_conv_code.h	31;"	d
REEDSOLOMON_H	/usr/include/itpp/comm/reedsolomon.h	31;"	d
RESAMPLING_H	/usr/include/itpp/signal/resampling.h	31;"	d
RICE_METHOD	/usr/include/itpp/comm/channel.h	/^enum RICE_METHOD { MEDS };$/;"	g	namespace:itpp
RND	/usr/include/itpp/fixed/fix_base.h	/^  RND,                \/\/!< Rounding to plus infinity$/;"	e	enum:itpp::q_mode
RND_CONV	/usr/include/itpp/fixed/fix_base.h	/^  RND_CONV,           \/\/!< Convergent rounding with half-way value rounded to even value$/;"	e	enum:itpp::q_mode
RND_CONV_ODD	/usr/include/itpp/fixed/fix_base.h	/^  RND_CONV_ODD,       \/\/!< Convergent rounding with half-way value rounded to odd value (not defined in SystemC)$/;"	e	enum:itpp::q_mode
RND_INF	/usr/include/itpp/fixed/fix_base.h	/^  RND_INF,            \/\/!< Rounding to infinity$/;"	e	enum:itpp::q_mode
RND_MIN_INF	/usr/include/itpp/fixed/fix_base.h	/^  RND_MIN_INF,        \/\/!< Rounding to minus infinity$/;"	e	enum:itpp::q_mode
RND_ZERO	/usr/include/itpp/fixed/fix_base.h	/^  RND_ZERO,           \/\/!< Rounding to zero$/;"	e	enum:itpp::q_mode
RNG	/usr/include/itpp/base/random.h	/^  Random_Generator RNG;$/;"	m	class:itpp::AR1_Normal_RNG	access:private
RNG	/usr/include/itpp/base/random.h	/^  Random_Generator RNG;$/;"	m	class:itpp::Bernoulli_RNG	access:private
RNG	/usr/include/itpp/base/random.h	/^  Random_Generator RNG;$/;"	m	class:itpp::Exponential_RNG	access:private
RNG	/usr/include/itpp/base/random.h	/^  Random_Generator RNG;$/;"	m	class:itpp::I_Uniform_RNG	access:private
RNG	/usr/include/itpp/base/random.h	/^  Random_Generator RNG;$/;"	m	class:itpp::Laplace_RNG	access:private
RNG	/usr/include/itpp/base/random.h	/^  Random_Generator RNG;$/;"	m	class:itpp::Normal_RNG	access:private
RNG	/usr/include/itpp/base/random.h	/^  Random_Generator RNG;$/;"	m	class:itpp::Uniform_RNG	access:private
RNG	/usr/include/itpp/base/random.h	/^  Random_Generator RNG;$/;"	m	class:itpp::Weibull_RNG	access:private
RNG_get_state	/usr/include/itpp/base/random.h	/^void RNG_get_state(ivec &state);$/;"	p	namespace:itpp	signature:(ivec &state)
RNG_randomize	/usr/include/itpp/base/random.h	/^void RNG_randomize();$/;"	p	namespace:itpp	signature:()
RNG_reset	/usr/include/itpp/base/random.h	/^void RNG_reset();$/;"	p	namespace:itpp	signature:()
RNG_reset	/usr/include/itpp/base/random.h	/^void RNG_reset(unsigned int seed);$/;"	p	namespace:itpp	signature:(unsigned int seed)
RNG_set_state	/usr/include/itpp/base/random.h	/^void RNG_set_state(ivec &state);$/;"	p	namespace:itpp	signature:(ivec &state)
RTTEstimate_index	/usr/include/itpp/protocol/tcp.h	/^  int RTTEstimate_index;$/;"	m	class:itpp::TCP_Sender	access:private
RTTEstimate_time	/usr/include/itpp/protocol/tcp.h	/^  vec RTTEstimate_time;$/;"	m	class:itpp::TCP_Sender	access:private
RTTEstimate_val	/usr/include/itpp/protocol/tcp.h	/^  vec RTTEstimate_val;$/;"	m	class:itpp::TCP_Sender	access:private
RTTsample_index	/usr/include/itpp/protocol/tcp.h	/^  int RTTsample_index;$/;"	m	class:itpp::TCP_Sender	access:private
RTTsample_time	/usr/include/itpp/protocol/tcp.h	/^  vec RTTsample_time;$/;"	m	class:itpp::TCP_Sender	access:private
RTTsample_val	/usr/include/itpp/protocol/tcp.h	/^  vec RTTsample_val;$/;"	m	class:itpp::TCP_Sender	access:private
Raised_Cosine	/usr/include/itpp/comm/pulse_shape.h	/^  Raised_Cosine() {}$/;"	f	class:itpp::Raised_Cosine	access:public	signature:()
Raised_Cosine	/usr/include/itpp/comm/pulse_shape.h	/^  Raised_Cosine(double roll_off, int filter_length = 6, int upsampling_factor = 8);$/;"	p	class:itpp::Raised_Cosine	access:public	signature:(double roll_off, int filter_length = 6, int upsampling_factor = 8)
Raised_Cosine	/usr/include/itpp/comm/pulse_shape.h	/^Raised_Cosine<T1>::Raised_Cosine(double roll_off_factor, int filter_length, int upsampling_factor)$/;"	f	class:itpp::Raised_Cosine	signature:(double roll_off_factor, int filter_length, int upsampling_factor)
Raised_Cosine	/usr/include/itpp/comm/pulse_shape.h	/^class Raised_Cosine : public Pulse_Shape<T1, double, T1>$/;"	c	namespace:itpp	inherits:Pulse_Shape
Random_Generator	/usr/include/itpp/base/random.h	/^  Random_Generator() { if (!initialized) reset(4357U); }$/;"	f	class:itpp::Random_Generator	access:public	signature:()
Random_Generator	/usr/include/itpp/base/random.h	/^  Random_Generator(unsigned int seed) { reset(seed); }$/;"	f	class:itpp::Random_Generator	access:public	signature:(unsigned int seed)
Random_Generator	/usr/include/itpp/base/random.h	/^class Random_Generator$/;"	c	namespace:itpp
Rayleigh_RNG	/usr/include/itpp/base/random.h	/^  Rayleigh_RNG(double sigma = 1.0);$/;"	p	class:itpp::Rayleigh_RNG	access:public	signature:(double sigma = 1.0)
Rayleigh_RNG	/usr/include/itpp/base/random.h	/^class Rayleigh_RNG$/;"	c	namespace:itpp
Real_Timer	/usr/include/itpp/base/timing.h	/^  Real_Timer() { }$/;"	f	class:itpp::Real_Timer	access:public	signature:()
Real_Timer	/usr/include/itpp/base/timing.h	/^class Real_Timer : public Timer$/;"	c	namespace:itpp	inherits:Timer
Rec_Syst_Conv_Code	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  Rec_Syst_Conv_Code(): infinity(1e30) {}$/;"	f	class:itpp::Rec_Syst_Conv_Code	access:public	signature:()
Rec_Syst_Conv_Code	/usr/include/itpp/comm/rec_syst_conv_code.h	/^class Rec_Syst_Conv_Code$/;"	c	namespace:itpp
ReceiveDataPacket	/usr/include/itpp/protocol/tcp.h	/^  virtual void ReceiveDataPacket(TCP_Packet & packet); \/**< \\brief  receive TCP packet *\/$/;"	p	class:itpp::TCP_Receiver	access:private	signature:(TCP_Packet & packet)
ReceiveMessageFromNet	/usr/include/itpp/protocol/tcp.h	/^  virtual void ReceiveMessageFromNet(itpp::Packet *msg);$/;"	p	class:itpp::TCP_Sender	access:private	signature:(itpp::Packet *msg)
ReceiveMessageFromNet	/usr/include/itpp/protocol/tcp.h	/^  virtual void ReceiveMessageFromNet(itpp::Packet* msg); \/**< \\brief  receive from network *\/$/;"	p	class:itpp::TCP_Receiver	access:private	signature:(itpp::Packet* msg)
ReduceSSThresh	/usr/include/itpp/protocol/tcp.h	/^  virtual void ReduceSSThresh();       \/**< \\brief  halving on dup ACK or TO *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:()
Reed_Solomon	/usr/include/itpp/comm/reedsolomon.h	/^  Reed_Solomon(int in_m, int in_t, bool sys = false);$/;"	p	class:itpp::Reed_Solomon	access:public	signature:(int in_m, int in_t, bool sys = false)
Reed_Solomon	/usr/include/itpp/comm/reedsolomon.h	/^class Reed_Solomon : public Channel_Code$/;"	c	namespace:itpp	inherits:Channel_Code
Reset	/usr/include/itpp/protocol/signals_slots.h	/^  void  Reset() {$/;"	f	class:itpp::TTimer	access:public	signature:()
Rice_Fading_Generator	/usr/include/itpp/comm/channel.h	/^  Rice_Fading_Generator(double norm_doppler, DOPPLER_SPECTRUM spectrum = Jakes,$/;"	p	class:itpp::Rice_Fading_Generator	access:public	signature:(double norm_doppler, DOPPLER_SPECTRUM spectrum = Jakes, int no_freq = 16, RICE_METHOD method = MEDS)
Rice_Fading_Generator	/usr/include/itpp/comm/channel.h	/^class Rice_Fading_Generator : public Correlated_Fading_Generator$/;"	c	namespace:itpp	inherits:Correlated_Fading_Generator
Rice_MEDS	/usr/include/itpp/comm/channel.h	/^enum CORRELATED_METHOD { Rice_MEDS, IFFT, FIR };$/;"	e	enum:itpp::CORRELATED_METHOD
Rice_RNG	/usr/include/itpp/base/random.h	/^  Rice_RNG(double sigma = 1.0, double v = 1.0);$/;"	p	class:itpp::Rice_RNG	access:public	signature:(double sigma = 1.0, double v = 1.0)
Rice_RNG	/usr/include/itpp/base/random.h	/^class Rice_RNG$/;"	c	namespace:itpp
Rnext	/usr/include/itpp/protocol/selective_repeat.h	/^  int Rnext;$/;"	m	class:itpp::Selective_Repeat_ARQ_Receiver	access:private
Root_Raised_Cosine	/usr/include/itpp/comm/pulse_shape.h	/^  Root_Raised_Cosine() {}$/;"	f	class:itpp::Root_Raised_Cosine	access:public	signature:()
Root_Raised_Cosine	/usr/include/itpp/comm/pulse_shape.h	/^  Root_Raised_Cosine(double roll_off_factor, int filter_length = 6, int upsampling_factor = 8);$/;"	p	class:itpp::Root_Raised_Cosine	access:public	signature:(double roll_off_factor, int filter_length = 6, int upsampling_factor = 8)
Root_Raised_Cosine	/usr/include/itpp/comm/pulse_shape.h	/^Root_Raised_Cosine<T1>::Root_Raised_Cosine(double roll_off_factor, int filter_length, int upsampling_factor)$/;"	f	class:itpp::Root_Raised_Cosine	signature:(double roll_off_factor, int filter_length, int upsampling_factor)
Root_Raised_Cosine	/usr/include/itpp/comm/pulse_shape.h	/^class Root_Raised_Cosine : public Pulse_Shape<T1, double, T1>$/;"	c	namespace:itpp	inherits:Pulse_Shape
S0	/usr/include/itpp/comm/modulator.h	/^  imat S0;$/;"	m	class:itpp::Modulator	access:protected
S1	/usr/include/itpp/comm/modulator.h	/^  imat S1;$/;"	m	class:itpp::Modulator	access:protected
SAT	/usr/include/itpp/fixed/fix_base.h	/^  SAT,                \/\/!< Saturation$/;"	e	enum:itpp::o_mode
SAT_SYM	/usr/include/itpp/fixed/fix_base.h	/^  SAT_SYM,            \/\/!< Symmetrical saturation (Not implemented)$/;"	e	enum:itpp::o_mode
SAT_ZERO	/usr/include/itpp/fixed/fix_base.h	/^  SAT_ZERO,           \/\/!< Saturation to zero (Not implemented)$/;"	e	enum:itpp::o_mode
SCHUR_H	/usr/include/itpp/base/algebra/schur.h	31;"	d
SELECTIVE_REPEAT_H	/usr/include/itpp/protocol/selective_repeat.h	31;"	d
SEQUENCE_H	/usr/include/itpp/comm/sequence.h	31;"	d
SIGFUN_H	/usr/include/itpp/signal/sigfun.h	31;"	d
SIGNAL_SLOT_H	/usr/include/itpp/protocol/signals_slots.h	31;"	d
SIZEOF_INT	/usr/include/itpp/config.h	190;"	d
SIZEOF_LONG	/usr/include/itpp/config.h	193;"	d
SIZEOF_LONG_LONG	/usr/include/itpp/config.h	196;"	d
SIZEOF_SHORT	/usr/include/itpp/config.h	199;"	d
SIZEOF_UNSIGNED_INT	/usr/include/itpp/config.h	202;"	d
SIZEOF_UNSIGNED_LONG	/usr/include/itpp/config.h	205;"	d
SIZEOF_UNSIGNED_LONG_LONG	/usr/include/itpp/config.h	208;"	d
SIZEOF_UNSIGNED_SHORT	/usr/include/itpp/config.h	211;"	d
SMAT_H	/usr/include/itpp/base/smat.h	31;"	d
SND_Format	/usr/include/itpp/srccode/audiofile.h	/^class SND_Format$/;"	c	namespace:itpp
SND_INFO_LEN	/usr/include/itpp/srccode/audiofile.h	42;"	d
SND_IO_File	/usr/include/itpp/srccode/audiofile.h	/^  SND_IO_File() { }$/;"	f	class:itpp::SND_IO_File	access:public	signature:()
SND_IO_File	/usr/include/itpp/srccode/audiofile.h	/^  SND_IO_File(const char *fname) { open(fname); }$/;"	f	class:itpp::SND_IO_File	access:public	signature:(const char *fname)
SND_IO_File	/usr/include/itpp/srccode/audiofile.h	/^class SND_IO_File : public SND_In_File, public SND_Out_File$/;"	c	namespace:itpp	inherits:SND_In_File,SND_Out_File
SND_In_File	/usr/include/itpp/srccode/audiofile.h	/^  SND_In_File();$/;"	p	class:itpp::SND_In_File	access:public	signature:()
SND_In_File	/usr/include/itpp/srccode/audiofile.h	/^  SND_In_File(const char *fname);$/;"	p	class:itpp::SND_In_File	access:public	signature:(const char *fname)
SND_In_File	/usr/include/itpp/srccode/audiofile.h	/^class SND_In_File : virtual public Audio_File, virtual public SND_Format$/;"	c	namespace:itpp	inherits:Audio_File,SND_Format
SND_Out_File	/usr/include/itpp/srccode/audiofile.h	/^  SND_Out_File();$/;"	p	class:itpp::SND_Out_File	access:public	signature:()
SND_Out_File	/usr/include/itpp/srccode/audiofile.h	/^  SND_Out_File(const char *fname, int rate = 8000, data_encoding e = enc_linear16);$/;"	p	class:itpp::SND_Out_File	access:public	signature:(const char *fname, int rate = 8000, data_encoding e = enc_linear16)
SND_Out_File	/usr/include/itpp/srccode/audiofile.h	/^class SND_Out_File : virtual public Audio_File, virtual public SND_Format$/;"	c	namespace:itpp	inherits:Audio_File,SND_Format
SORTING_METHOD	/usr/include/itpp/base/sort.h	/^enum SORTING_METHOD { INTROSORT = 0, QUICKSORT = 1, HEAPSORT = 2,$/;"	g	namespace:itpp
SORT_H	/usr/include/itpp/base/sort.h	31;"	d
SOURCE_H	/usr/include/itpp/signal/source.h	31;"	d
SPECMAT_H	/usr/include/itpp/base/specmat.h	32;"	d
SPREAD_H	/usr/include/itpp/comm/spread.h	31;"	d
SSThresh_index	/usr/include/itpp/protocol/tcp.h	/^  int SSThresh_index;$/;"	m	class:itpp::TCP_Sender	access:private
SSThresh_time	/usr/include/itpp/protocol/tcp.h	/^  vec SSThresh_time;$/;"	m	class:itpp::TCP_Sender	access:private
SSThresh_val	/usr/include/itpp/protocol/tcp.h	/^  vec SSThresh_val;$/;"	m	class:itpp::TCP_Sender	access:private
STACK_H	/usr/include/itpp/base/stack.h	37;"	d
STDC_HEADERS	/usr/include/itpp/config.h	214;"	d
SVD_H	/usr/include/itpp/base/algebra/svd.h	31;"	d
SVEC_H	/usr/include/itpp/base/svec.h	31;"	d
Sawtooth_Source	/usr/include/itpp/signal/source.h	/^  Sawtooth_Source(double freq, double mean = 0.0, double ampl = 1.0, double inphase = 0.0);$/;"	p	class:itpp::Sawtooth_Source	access:public	signature:(double freq, double mean = 0.0, double ampl = 1.0, double inphase = 0.0)
Sawtooth_Source	/usr/include/itpp/signal/source.h	/^class Sawtooth_Source$/;"	c	namespace:itpp
Scalar_Quantizer	/usr/include/itpp/srccode/vq.h	/^  Scalar_Quantizer();$/;"	p	class:itpp::Scalar_Quantizer	access:public	signature:()
Scalar_Quantizer	/usr/include/itpp/srccode/vq.h	/^  Scalar_Quantizer(const char *Name);$/;"	p	class:itpp::Scalar_Quantizer	access:public	signature:(const char *Name)
Scalar_Quantizer	/usr/include/itpp/srccode/vq.h	/^class Scalar_Quantizer$/;"	c	namespace:itpp
ScheduleACKMessage	/usr/include/itpp/protocol/tcp.h	/^  virtual void ScheduleACKMessage(); \/**< \\brief  prepare ACK message for sending *\/$/;"	p	class:itpp::TCP_Receiver	access:private	signature:()
Selective_Repeat_ARQ_Receiver	/usr/include/itpp/protocol/selective_repeat.h	/^  Selective_Repeat_ARQ_Receiver();$/;"	p	class:itpp::Selective_Repeat_ARQ_Receiver	access:public	signature:()
Selective_Repeat_ARQ_Receiver	/usr/include/itpp/protocol/selective_repeat.h	/^  Selective_Repeat_ARQ_Receiver(const int Seq_no_size);$/;"	p	class:itpp::Selective_Repeat_ARQ_Receiver	access:public	signature:(const int Seq_no_size)
Selective_Repeat_ARQ_Receiver	/usr/include/itpp/protocol/selective_repeat.h	/^class Selective_Repeat_ARQ_Receiver$/;"	c	namespace:itpp
Selective_Repeat_ARQ_Sender	/usr/include/itpp/protocol/selective_repeat.h	/^  Selective_Repeat_ARQ_Sender();$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:public	signature:()
Selective_Repeat_ARQ_Sender	/usr/include/itpp/protocol/selective_repeat.h	/^  Selective_Repeat_ARQ_Sender(const int Seq_no_size, const int Buffer_size_factor, const int Link_packet_size, const Ttype Time_out);$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:public	signature:(const int Seq_no_size, const int Buffer_size_factor, const int Link_packet_size, const Ttype Time_out)
Selective_Repeat_ARQ_Sender	/usr/include/itpp/protocol/selective_repeat.h	/^class Selective_Repeat_ARQ_Sender$/;"	c	namespace:itpp
SendACK	/usr/include/itpp/protocol/tcp.h	/^  virtual void SendACK(bool);        \/**< \\brief  send an ACK if necessary or enforced *\/$/;"	p	class:itpp::TCP_Receiver	access:private	signature:(bool)
SendACKMessage	/usr/include/itpp/protocol/tcp.h	/^  virtual void SendACKMessage(Ttype); \/**< \\brief  called by ACK scheduling timer *\/$/;"	p	class:itpp::TCP_Receiver	access:private	signature:(Ttype)
SendMsg	/usr/include/itpp/protocol/tcp.h	/^  virtual void SendMsg(TCP_Packet & msg);    \/**< \\brief  access to network *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:(TCP_Packet & msg)
SendNewData	/usr/include/itpp/protocol/tcp.h	/^  virtual void SendNewData(bool skipSWSA = false); \/**< \\brief  send new data *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:(bool skipSWSA = false)
SendWindow	/usr/include/itpp/protocol/tcp.h	/^  virtual unsigned SendWindow() const;   \/**< \\brief  min of CWnd, MaxCWnd and RecWnd *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:() const
Sequence_Interleaver	/usr/include/itpp/comm/interleave.h	/^  Sequence_Interleaver(int in_interleaver_depth);$/;"	p	class:itpp::Sequence_Interleaver	access:public	signature:(int in_interleaver_depth)
Sequence_Interleaver	/usr/include/itpp/comm/interleave.h	/^  Sequence_Interleaver(ivec in_interleaver_sequence);$/;"	p	class:itpp::Sequence_Interleaver	access:public	signature:(ivec in_interleaver_sequence)
Sequence_Interleaver	/usr/include/itpp/comm/interleave.h	/^  Sequence_Interleaver(void) {interleaver_depth = 0;};$/;"	f	class:itpp::Sequence_Interleaver	access:public	signature:(void)
Sequence_Interleaver	/usr/include/itpp/comm/interleave.h	/^Sequence_Interleaver<T>::Sequence_Interleaver(int in_interleaver_depth)$/;"	f	class:itpp::Sequence_Interleaver	signature:(int in_interleaver_depth)
Sequence_Interleaver	/usr/include/itpp/comm/interleave.h	/^Sequence_Interleaver<T>::Sequence_Interleaver(ivec in_interleaver_sequence)$/;"	f	class:itpp::Sequence_Interleaver	signature:(ivec in_interleaver_sequence)
Sequence_Interleaver	/usr/include/itpp/comm/interleave.h	/^class Sequence_Interleaver$/;"	c	namespace:itpp
Sequence_Number	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number() : seq(0) { }$/;"	f	class:itpp::Sequence_Number	access:public	signature:()
Sequence_Number	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number(const Sequence_Number &n) : seq(n.seq) { }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const Sequence_Number &n)
Sequence_Number	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number(int n) : seq(n) {}$/;"	f	class:itpp::Sequence_Number	access:protected	signature:(int n)
Sequence_Number	/usr/include/itpp/protocol/tcp.h	/^class Sequence_Number$/;"	c	namespace:itpp
Set	/usr/include/itpp/protocol/signals_slots.h	/^  void  Set(Ttype time, bool relative = true) {$/;"	f	class:itpp::TTimer	access:public	signature:(Ttype time, bool relative = true)
SetRtxTimer	/usr/include/itpp/protocol/tcp.h	/^  virtual void SetRtxTimer();$/;"	p	class:itpp::TCP_Sender	access:private	signature:()
SetupStrings	/usr/include/itpp/base/parser.h	/^  Array<std::string> SetupStrings;$/;"	m	class:itpp::Parser	access:private
Signal	/usr/include/itpp/protocol/signals_slots.h	/^  Signal(const std::string signal_name = "Unamed Signal", const bool single_shot = false, const bool enable_debug = false);$/;"	p	class:itpp::Signal	access:public	signature:(const std::string signal_name = Ó, const bool single_shot = false, const bool enable_debug = false)
Signal	/usr/include/itpp/protocol/signals_slots.h	/^Signal<DataType>::Signal(const std::string signal_name, const bool single_shot, const bool enable_debug)$/;"	f	class:itpp::Signal	signature:(const std::string signal_name, const bool single_shot, const bool enable_debug)
Signal	/usr/include/itpp/protocol/signals_slots.h	/^class Signal$/;"	c	namespace:itpp
Signal_Iterator	/usr/include/itpp/protocol/signals_slots.h	/^  typedef typename std::list<Signal<DataType>*, std::allocator< Signal<DataType>* > >::iterator Signal_Iterator;$/;"	t	class:itpp::Base_Slot	access:protected
Sine_Source	/usr/include/itpp/signal/source.h	/^  Sine_Source(double freq, double mean = 0.0, double ampl = 1.0, double inphase = 0.0);$/;"	p	class:itpp::Sine_Source	access:public	signature:(double freq, double mean = 0.0, double ampl = 1.0, double inphase = 0.0)
Sine_Source	/usr/include/itpp/signal/source.h	/^class Sine_Source$/;"	c	namespace:itpp
Sink	/usr/include/itpp/protocol/packet_generator.h	/^  Sink(const unsigned long int Max_packets = 1000);$/;"	p	class:itpp::Sink	access:public	signature:(const unsigned long int Max_packets = 1000)
Sink	/usr/include/itpp/protocol/packet_generator.h	/^class Sink$/;"	c	namespace:itpp
Size	/usr/include/itpp/srccode/vq.h	/^  int Size;$/;"	m	class:itpp::Vector_Quantizer	access:protected
Slot	/usr/include/itpp/protocol/signals_slots.h	/^  Slot(const std::string _name = "Unamed Slot");$/;"	p	class:itpp::Slot	access:public	signature:(const std::string _name = Ó)
Slot	/usr/include/itpp/protocol/signals_slots.h	/^Slot<ObjectType, DataType>::Slot(const std::string slot_name) : Base_Slot<DataType>(slot_name)$/;"	f	class:itpp::Slot	signature:(const std::string slot_name)
Slot	/usr/include/itpp/protocol/signals_slots.h	/^class Slot : public Base_Slot<DataType>$/;"	c	namespace:itpp	inherits:Base_Slot
SocketWriteQueue	/usr/include/itpp/protocol/tcp.h	/^  std::queue<itpp::Packet*> SocketWriteQueue;$/;"	m	class:itpp::TCP_Sender	access:private
Soft	/usr/include/itpp/optim/newton_search.h	/^enum Line_Search_Method {Soft, Exact};$/;"	e	enum:itpp::Line_Search_Method
Soft_Demod_Method	/usr/include/itpp/comm/modulator_nd.h	/^  enum Soft_Demod_Method {$/;"	g	class:itpp::Modulator_ND	access:public
Soft_Method	/usr/include/itpp/comm/modulator.h	/^enum Soft_Method {$/;"	g	namespace:itpp
Sort	/usr/include/itpp/base/sort.h	/^  Sort(SORTING_METHOD method = INTROSORT): sort_method(method) {}$/;"	f	class:itpp::Sort	access:public	signature:(SORTING_METHOD method = INTROSORT)
Sort	/usr/include/itpp/base/sort.h	/^class Sort$/;"	c	namespace:itpp
Sparse_Mat	/usr/include/itpp/base/smat.h	/^  Sparse_Mat();$/;"	p	class:itpp::Sparse_Mat	access:public	signature:()
Sparse_Mat	/usr/include/itpp/base/smat.h	/^  Sparse_Mat(const Mat<T> &m);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const Mat<T> &m)
Sparse_Mat	/usr/include/itpp/base/smat.h	/^  Sparse_Mat(const Mat<T> &m, T epsilon);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const Mat<T> &m, T epsilon)
Sparse_Mat	/usr/include/itpp/base/smat.h	/^  Sparse_Mat(const Sparse_Mat<T> &m);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const Sparse_Mat<T> &m)
Sparse_Mat	/usr/include/itpp/base/smat.h	/^  Sparse_Mat(int rows, int cols, int row_data_init = 200);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(int rows, int cols, int row_data_init = 200)
Sparse_Mat	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T>::Sparse_Mat()$/;"	f	class:itpp::Sparse_Mat	signature:()
Sparse_Mat	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T>::Sparse_Mat(const Mat<T> &m)$/;"	f	class:itpp::Sparse_Mat	signature:(const Mat<T> &m)
Sparse_Mat	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T>::Sparse_Mat(const Mat<T> &m, T epsilon)$/;"	f	class:itpp::Sparse_Mat	signature:(const Mat<T> &m, T epsilon)
Sparse_Mat	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T>::Sparse_Mat(const Sparse_Mat<T> &m)$/;"	f	class:itpp::Sparse_Mat	signature:(const Sparse_Mat<T> &m)
Sparse_Mat	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T>::Sparse_Mat(int rows, int cols, int row_data_init)$/;"	f	class:itpp::Sparse_Mat	signature:(int rows, int cols, int row_data_init)
Sparse_Mat	/usr/include/itpp/base/smat.h	/^class Sparse_Mat$/;"	c	namespace:itpp
Sparse_Vec	/usr/include/itpp/base/svec.h	/^  Sparse_Vec();$/;"	p	class:itpp::Sparse_Vec	access:public	signature:()
Sparse_Vec	/usr/include/itpp/base/svec.h	/^  Sparse_Vec(const Sparse_Vec<T> &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const Sparse_Vec<T> &v)
Sparse_Vec	/usr/include/itpp/base/svec.h	/^  Sparse_Vec(const Vec<T> &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const Vec<T> &v)
Sparse_Vec	/usr/include/itpp/base/svec.h	/^  Sparse_Vec(const Vec<T> &v, T epsilon);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const Vec<T> &v, T epsilon)
Sparse_Vec	/usr/include/itpp/base/svec.h	/^  Sparse_Vec(int sz, int data_init = 200);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(int sz, int data_init = 200)
Sparse_Vec	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T>::Sparse_Vec()$/;"	f	class:itpp::Sparse_Vec	signature:()
Sparse_Vec	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T>::Sparse_Vec(const Sparse_Vec<T> &v)$/;"	f	class:itpp::Sparse_Vec	signature:(const Sparse_Vec<T> &v)
Sparse_Vec	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T>::Sparse_Vec(const Vec<T> &v)$/;"	f	class:itpp::Sparse_Vec	signature:(const Vec<T> &v)
Sparse_Vec	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T>::Sparse_Vec(const Vec<T> &v, T epsilon)$/;"	f	class:itpp::Sparse_Vec	signature:(const Vec<T> &v, T epsilon)
Sparse_Vec	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T>::Sparse_Vec(int sz, int data_init)$/;"	f	class:itpp::Sparse_Vec	signature:(int sz, int data_init)
Sparse_Vec	/usr/include/itpp/base/svec.h	/^class Sparse_Vec$/;"	c	namespace:itpp
Spread_1d	/usr/include/itpp/comm/spread.h	/^  Spread_1d() { }$/;"	f	class:itpp::Spread_1d	access:public	signature:()
Spread_1d	/usr/include/itpp/comm/spread.h	/^  Spread_1d(const vec &incode);$/;"	p	class:itpp::Spread_1d	access:public	signature:(const vec &incode)
Spread_1d	/usr/include/itpp/comm/spread.h	/^class Spread_1d$/;"	c	namespace:itpp
Spread_2d	/usr/include/itpp/comm/spread.h	/^  Spread_2d() { }$/;"	f	class:itpp::Spread_2d	access:public	signature:()
Spread_2d	/usr/include/itpp/comm/spread.h	/^  Spread_2d(const vec &incodeI, const vec &incodeQ);$/;"	p	class:itpp::Spread_2d	access:public	signature:(const vec &incodeI, const vec &incodeQ)
Spread_2d	/usr/include/itpp/comm/spread.h	/^class Spread_2d$/;"	c	namespace:itpp
Square_Source	/usr/include/itpp/signal/source.h	/^  Square_Source(double freq, double mean = 0.0, double ampl = 1.0, double inphase = 0.0);$/;"	p	class:itpp::Square_Source	access:public	signature:(double freq, double mean = 0.0, double ampl = 1.0, double inphase = 0.0)
Square_Source	/usr/include/itpp/signal/source.h	/^class Square_Source$/;"	c	namespace:itpp
Stack	/usr/include/itpp/base/stack.h	/^  Stack();$/;"	p	class:itpp::Stack	access:public	signature:()
Stack	/usr/include/itpp/base/stack.h	/^  Stack(const Stack<T> &s);$/;"	p	class:itpp::Stack	access:public	signature:(const Stack<T> &s)
Stack	/usr/include/itpp/base/stack.h	/^  Stack(int n);$/;"	p	class:itpp::Stack	access:public	signature:(int n)
Stack	/usr/include/itpp/base/stack.h	/^Stack<T>::Stack()$/;"	f	class:itpp::Stack	signature:()
Stack	/usr/include/itpp/base/stack.h	/^Stack<T>::Stack(const Stack<T> &s)$/;"	f	class:itpp::Stack	signature:(const Stack<T> &s)
Stack	/usr/include/itpp/base/stack.h	/^Stack<T>::Stack(int n)$/;"	f	class:itpp::Stack	signature:(int n)
Stack	/usr/include/itpp/base/stack.h	/^class Stack$/;"	c	namespace:itpp
Stat	/usr/include/itpp/stat/misc_stat.h	/^  Stat() {clear();}$/;"	f	class:itpp::Stat	access:public	signature:()
Stat	/usr/include/itpp/stat/misc_stat.h	/^class Stat$/;"	c	namespace:itpp
Static	/usr/include/itpp/comm/channel.h	/^enum FADING_TYPE { Independent, Static, Correlated };$/;"	e	enum:itpp::FADING_TYPE
Static_Fading_Generator	/usr/include/itpp/comm/channel.h	/^  Static_Fading_Generator() : Fading_Generator() {}$/;"	f	class:itpp::Static_Fading_Generator	access:public	signature:()
Static_Fading_Generator	/usr/include/itpp/comm/channel.h	/^class Static_Fading_Generator : public Fading_Generator$/;"	c	namespace:itpp	inherits:Fading_Generator
StopTransientPhase	/usr/include/itpp/protocol/tcp.h	/^  void StopTransientPhase(); \/**< \\brief reset statistic counters *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:()
T	/usr/include/itpp/base/mat.h	/^  Mat<Num_T> T() const { return this->transpose(); }$/;"	f	class:itpp::Mat	access:public	signature:() const
T	/usr/include/itpp/base/vec.h	/^  Mat<Num_T> T() const { return this->transpose(); }$/;"	f	class:itpp::Vec	access:public	signature:() const
TC	/usr/include/itpp/fixed/fix_base.h	/^  TC,                 \/\/!< Two's complement$/;"	e	enum:itpp::e_mode
TCP_Client_Application	/usr/include/itpp/protocol/tcp_client_server.h	/^  TCP_Client_Application(TCP_Sender *tcp_snd_p, TCP_Receiver *tcp_recv_p) {$/;"	f	class:itpp::TCP_Client_Application	access:public	signature:(TCP_Sender *tcp_snd_p, TCP_Receiver *tcp_recv_p)
TCP_Client_Application	/usr/include/itpp/protocol/tcp_client_server.h	/^class TCP_Client_Application$/;"	c	namespace:itpp
TCP_H	/usr/include/itpp/protocol/tcp.h	34;"	d
TCP_Packet	/usr/include/itpp/protocol/tcp.h	/^  TCP_Packet();$/;"	p	class:itpp::TCP_Packet	access:public	signature:()
TCP_Packet	/usr/include/itpp/protocol/tcp.h	/^  TCP_Packet(const TCP_Packet &packet);$/;"	p	class:itpp::TCP_Packet	access:public	signature:(const TCP_Packet &packet)
TCP_Packet	/usr/include/itpp/protocol/tcp.h	/^class TCP_Packet : public itpp::Packet$/;"	c	namespace:itpp	inherits:itpp::Packet
TCP_Receiver	/usr/include/itpp/protocol/tcp.h	/^  TCP_Receiver(int label);$/;"	p	class:itpp::TCP_Receiver	access:public	signature:(int label)
TCP_Receiver	/usr/include/itpp/protocol/tcp.h	/^class TCP_Receiver$/;"	c	namespace:itpp
TCP_Receiver_Buffer	/usr/include/itpp/protocol/tcp.h	/^  TCP_Receiver_Buffer();$/;"	p	class:itpp::TCP_Receiver_Buffer	access:public	signature:()
TCP_Receiver_Buffer	/usr/include/itpp/protocol/tcp.h	/^  TCP_Receiver_Buffer(const TCP_Receiver_Buffer &);$/;"	p	class:itpp::TCP_Receiver_Buffer	access:public	signature:(const TCP_Receiver_Buffer &)
TCP_Receiver_Buffer	/usr/include/itpp/protocol/tcp.h	/^class TCP_Receiver_Buffer$/;"	c	namespace:itpp
TCP_Segment	/usr/include/itpp/protocol/tcp.h	/^  TCP_Segment();$/;"	p	class:itpp::TCP_Segment	access:public	signature:()
TCP_Segment	/usr/include/itpp/protocol/tcp.h	/^  TCP_Segment(const Sequence_Number &sn_begin, const Sequence_Number &sn_end);$/;"	p	class:itpp::TCP_Segment	access:public	signature:(const Sequence_Number &sn_begin, const Sequence_Number &sn_end)
TCP_Segment	/usr/include/itpp/protocol/tcp.h	/^  TCP_Segment(const TCP_Segment &segment);$/;"	p	class:itpp::TCP_Segment	access:public	signature:(const TCP_Segment &segment)
TCP_Segment	/usr/include/itpp/protocol/tcp.h	/^class TCP_Segment$/;"	c	namespace:itpp
TCP_Sender	/usr/include/itpp/protocol/tcp.h	/^  TCP_Sender(int label);$/;"	p	class:itpp::TCP_Sender	access:public	signature:(int label)
TCP_Sender	/usr/include/itpp/protocol/tcp.h	/^class TCP_Sender$/;"	c	namespace:itpp
TCP_Server_Application	/usr/include/itpp/protocol/tcp_client_server.h	/^  TCP_Server_Application() {$/;"	f	class:itpp::TCP_Server_Application	access:public	signature:()
TCP_Server_Application	/usr/include/itpp/protocol/tcp_client_server.h	/^class TCP_Server_Application$/;"	c	namespace:itpp
TDL_Channel	/usr/include/itpp/comm/channel.h	/^  TDL_Channel(const Channel_Specification &channel_spec, double sampling_time);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const Channel_Specification &channel_spec, double sampling_time)
TDL_Channel	/usr/include/itpp/comm/channel.h	/^  TDL_Channel(const vec &avg_power_dB = "0", const ivec &delay_prof = "0");$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const vec &avg_power_dB = Ó, const ivec &delay_prof = Ó)
TDL_Channel	/usr/include/itpp/comm/channel.h	/^class TDL_Channel$/;"	c	namespace:itpp
TDebugInfo	/usr/include/itpp/protocol/tcp.h	/^  struct TDebugInfo {$/;"	s	class:itpp::TCP_Packet	access:protected
TIME_WITH_SYS_TIME	/usr/include/itpp/config.h	217;"	d
TIMING_H	/usr/include/itpp/base/timing.h	31;"	d
TRANSFORMS_H	/usr/include/itpp/signal/transforms.h	32;"	d
TRIG_HYP_H	/usr/include/itpp/base/math/trig_hyp.h	31;"	d
TRN	/usr/include/itpp/fixed/fix_base.h	/^  TRN,                \/\/!< Truncation$/;"	e	enum:itpp::q_mode
TRN_ZERO	/usr/include/itpp/fixed/fix_base.h	/^  TRN_ZERO            \/\/!< Truncation to zero$/;"	e	enum:itpp::q_mode
TTimer	/usr/include/itpp/protocol/signals_slots.h	/^  TTimer(THandler & handler, void (THandler::*handlerFunction)(Ttype time)) :$/;"	f	class:itpp::TTimer	access:public	signature:(THandler & handler, void (THandler::*handlerFunction)(Ttype time))
TTimer	/usr/include/itpp/protocol/signals_slots.h	/^class TTimer$/;"	c	namespace:itpp
TURBO_H	/usr/include/itpp/comm/turbo.h	31;"	d
T_fact	/usr/include/itpp/base/gf2mat.h	/^  int T_fact(GF2mat &T, GF2mat &U, ivec &P) const;$/;"	p	class:itpp::GF2mat	access:public	signature:(GF2mat &T, GF2mat &U, ivec &P) const
T_fact_update_addcol	/usr/include/itpp/base/gf2mat.h	/^  bool T_fact_update_addcol(GF2mat &T, GF2mat &U,$/;"	p	class:itpp::GF2mat	access:public	signature:(GF2mat &T, GF2mat &U, ivec &P, bvec newcol) const
T_fact_update_bitflip	/usr/include/itpp/base/gf2mat.h	/^  int T_fact_update_bitflip(GF2mat &T, GF2mat &U,$/;"	p	class:itpp::GF2mat	access:public	signature:(GF2mat &T, GF2mat &U, ivec &P, int rank, int r, int c) const
Tail	/usr/include/itpp/comm/convcode.h	/^enum CONVOLUTIONAL_CODE_METHOD {Trunc, Tail, Tailbite};$/;"	e	enum:itpp::CONVOLUTIONAL_CODE_METHOD
Tailbite	/usr/include/itpp/comm/convcode.h	/^enum CONVOLUTIONAL_CODE_METHOD {Trunc, Tail, Tailbite};$/;"	e	enum:itpp::CONVOLUTIONAL_CODE_METHOD
Ti	/usr/include/itpp/protocol/packet_generator.h	/^  double Ti;$/;"	m	class:itpp::Burst_WWW_Packet_Generator	access:protected
Timer	/usr/include/itpp/base/timing.h	/^  Timer();$/;"	p	class:itpp::Timer	access:public	signature:()
Timer	/usr/include/itpp/base/timing.h	/^class Timer$/;"	c	namespace:itpp
Tr	/usr/include/itpp/protocol/packet_generator.h	/^  double Tr;$/;"	m	class:itpp::Burst_WWW_Packet_Generator	access:protected
TraceACKedSeqNo	/usr/include/itpp/protocol/tcp.h	/^  virtual void TraceACKedSeqNo(const Sequence_Number sn);$/;"	p	class:itpp::TCP_Sender	access:private	signature:(const Sequence_Number sn)
TraceCWnd	/usr/include/itpp/protocol/tcp.h	/^  virtual void TraceCWnd();$/;"	p	class:itpp::TCP_Sender	access:private	signature:()
TraceRTTVariables	/usr/include/itpp/protocol/tcp.h	/^  virtual void TraceRTTVariables(double sampleRTT);$/;"	p	class:itpp::TCP_Sender	access:private	signature:(double sampleRTT)
TraceReceivedSeqNo	/usr/include/itpp/protocol/tcp.h	/^  virtual void TraceReceivedSeqNo(const Sequence_Number &sn);$/;"	p	class:itpp::TCP_Receiver	access:private	signature:(const Sequence_Number &sn)
TraceSSThresh	/usr/include/itpp/protocol/tcp.h	/^  virtual void TraceSSThresh();$/;"	p	class:itpp::TCP_Sender	access:private	signature:()
TraceSentSeqNo	/usr/include/itpp/protocol/tcp.h	/^  virtual void TraceSentSeqNo(const Sequence_Number sn);$/;"	p	class:itpp::TCP_Sender	access:private	signature:(const Sequence_Number sn)
Triangle_Source	/usr/include/itpp/signal/source.h	/^  Triangle_Source(double freq, double mean = 0.0, double ampl = 1.0, double inphase = 0.0);$/;"	p	class:itpp::Triangle_Source	access:public	signature:(double freq, double mean = 0.0, double ampl = 1.0, double inphase = 0.0)
Triangle_Source	/usr/include/itpp/signal/source.h	/^class Triangle_Source$/;"	c	namespace:itpp
Trunc	/usr/include/itpp/comm/convcode.h	/^enum CONVOLUTIONAL_CODE_METHOD {Trunc, Tail, Tailbite};$/;"	e	enum:itpp::CONVOLUTIONAL_CODE_METHOD
Ttype	/usr/include/itpp/protocol/events.h	/^typedef double Ttype; \/\/!< 64-bit floating point time$/;"	t	namespace:itpp
Turbo_Codec	/usr/include/itpp/comm/turbo.h	/^  Turbo_Codec(void) {}$/;"	f	class:itpp::Turbo_Codec	access:public	signature:(void)
Turbo_Codec	/usr/include/itpp/comm/turbo.h	/^class Turbo_Codec$/;"	c	namespace:itpp
UINT64_POW2	/usr/include/itpp/fixed/fix_base.h	/^const uint64_t UINT64_POW2[64] = {$/;"	m	namespace:itpp
US	/usr/include/itpp/fixed/fix_base.h	/^  US                  \/\/!< Unsigned$/;"	e	enum:itpp::e_mode
UnaRetransmit	/usr/include/itpp/protocol/tcp.h	/^  virtual void UnaRetransmit();       \/**< \\brief  TO or fast retransmit *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:()
Uniform_RNG	/usr/include/itpp/base/random.h	/^  Uniform_RNG(double min = 0, double max = 1.0);$/;"	p	class:itpp::Uniform_RNG	access:public	signature:(double min = 0, double max = 1.0)
Uniform_RNG	/usr/include/itpp/base/random.h	/^class Uniform_RNG$/;"	c	namespace:itpp
UpdateRTTVariables	/usr/include/itpp/protocol/tcp.h	/^  virtual void UpdateRTTVariables(double sampleRTT); \/**< \\brief  evaluate RTT measuremnt *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:(double sampleRTT)
V	/usr/include/itpp/comm/ldpc.h	/^  ivec C, V, sumX1, sumX2, iind, jind;$/;"	m	class:itpp::LDPC_Code	access:private
VEC_H	/usr/include/itpp/base/vec.h	31;"	d
VERBOSE	/usr/include/itpp/base/parser.h	/^  bool VERBOSE;$/;"	m	class:itpp::Parser	access:private
VERSION	/usr/include/itpp/config.h	220;"	d
VQTRAIN_H	/usr/include/itpp/srccode/vqtrain.h	31;"	d
VQ_H	/usr/include/itpp/srccode/vq.h	31;"	d
Vec	/usr/include/itpp/base/vec.h	/^  Vec(const Num_T *c_array, int size, const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Vec	access:public	signature:(const Num_T *c_array, int size, const Factory &f = DEFAULT_FACTORY)
Vec	/usr/include/itpp/base/vec.h	/^  Vec(const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:public	signature:(const Vec<Num_T> &v)
Vec	/usr/include/itpp/base/vec.h	/^  Vec(const Vec<Num_T> &v, const Factory &f);$/;"	p	class:itpp::Vec	access:public	signature:(const Vec<Num_T> &v, const Factory &f)
Vec	/usr/include/itpp/base/vec.h	/^  Vec(const char *values, const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Vec	access:public	signature:(const char *values, const Factory &f = DEFAULT_FACTORY)
Vec	/usr/include/itpp/base/vec.h	/^  Vec(const std::string &values, const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Vec	access:public	signature:(const std::string &values, const Factory &f = DEFAULT_FACTORY)
Vec	/usr/include/itpp/base/vec.h	/^  explicit Vec(const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Vec	access:public	signature:(const Factory &f = DEFAULT_FACTORY)
Vec	/usr/include/itpp/base/vec.h	/^  explicit Vec(int size, const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Vec	access:public	signature:(int size, const Factory &f = DEFAULT_FACTORY)
Vec	/usr/include/itpp/base/vec.h	/^Vec<Num_T>::Vec(const Factory &f) : datasize(0), data(0), factory(f) {}$/;"	f	class:itpp::Vec	signature:(const Factory &f)
Vec	/usr/include/itpp/base/vec.h	/^Vec<Num_T>::Vec(const Num_T *c_array, int size, const Factory &f) : datasize(0), data(0), factory(f)$/;"	f	class:itpp::Vec	signature:(const Num_T *c_array, int size, const Factory &f)
Vec	/usr/include/itpp/base/vec.h	/^Vec<Num_T>::Vec(const Vec<Num_T> &v) : datasize(0), data(0), factory(v.factory)$/;"	f	class:itpp::Vec	signature:(const Vec<Num_T> &v)
Vec	/usr/include/itpp/base/vec.h	/^Vec<Num_T>::Vec(const Vec<Num_T> &v, const Factory &f) : datasize(0), data(0), factory(f)$/;"	f	class:itpp::Vec	signature:(const Vec<Num_T> &v, const Factory &f)
Vec	/usr/include/itpp/base/vec.h	/^Vec<Num_T>::Vec(const char *values, const Factory &f) : datasize(0), data(0), factory(f)$/;"	f	class:itpp::Vec	signature:(const char *values, const Factory &f)
Vec	/usr/include/itpp/base/vec.h	/^Vec<Num_T>::Vec(const std::string &values, const Factory &f) : datasize(0), data(0), factory(f)$/;"	f	class:itpp::Vec	signature:(const std::string &values, const Factory &f)
Vec	/usr/include/itpp/base/vec.h	/^Vec<Num_T>::Vec(int size, const Factory &f) : datasize(0), data(0), factory(f)$/;"	f	class:itpp::Vec	signature:(int size, const Factory &f)
Vec	/usr/include/itpp/base/vec.h	/^class Vec$/;"	c	namespace:itpp
VecPr	/usr/include/itpp/signal/fastica.h	/^  mat E, VecPr;$/;"	m	class:itpp::Fast_ICA	access:private
Vector_Quantizer	/usr/include/itpp/srccode/vq.h	/^  Vector_Quantizer();$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:()
Vector_Quantizer	/usr/include/itpp/srccode/vq.h	/^  Vector_Quantizer(const char *Name);$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:(const char *Name)
Vector_Quantizer	/usr/include/itpp/srccode/vq.h	/^class Vector_Quantizer$/;"	c	namespace:itpp
W	/usr/include/itpp/signal/fastica.h	/^  mat mixedSig, A, W, icasig;$/;"	m	class:itpp::Fast_ICA	access:private
WINDOW_H	/usr/include/itpp/signal/window.h	31;"	d
WRAP	/usr/include/itpp/fixed/fix_base.h	/^  WRAP,               \/\/!< Wrap-around$/;"	e	enum:itpp::o_mode
WRAP_SM	/usr/include/itpp/fixed/fix_base.h	/^  WRAP_SM             \/\/!< Sign magnitued wrap-around (Not implemented)$/;"	e	enum:itpp::o_mode
Weibull_RNG	/usr/include/itpp/base/random.h	/^  Weibull_RNG(double lambda = 1.0, double beta = 1.0);$/;"	p	class:itpp::Weibull_RNG	access:public	signature:(double lambda = 1.0, double beta = 1.0)
Weibull_RNG	/usr/include/itpp/base/random.h	/^class Weibull_RNG$/;"	c	namespace:itpp
Z	/usr/include/itpp/comm/ldpc.h	/^  int Z;   \/\/!< Expansion factor$/;"	m	class:itpp::BLDPC_Generator	access:protected
Z	/usr/include/itpp/comm/ldpc.h	/^  int Z;   \/\/!< Expansion factor$/;"	m	class:itpp::BLDPC_Parity	access:private
ZF_LOGMAP	/usr/include/itpp/comm/modulator_nd.h	/^    ZF_LOGMAP$/;"	e	enum:itpp::Modulator_ND::Soft_Demod_Method
_connect	/usr/include/itpp/protocol/signals_slots.h	/^  void _connect(Signal<DataType>* signal);$/;"	p	class:itpp::Base_Slot	access:protected	signature:(Signal<DataType>* signal)
_connect	/usr/include/itpp/protocol/signals_slots.h	/^void Base_Slot<DataType>::_connect(Signal<DataType>* signal)$/;"	f	class:itpp::Base_Slot	signature:(Signal<DataType>* signal)
_data	/usr/include/itpp/base/circular_buffer.h	/^  T *_data;$/;"	m	class:itpp::Circular_Buffer	access:private
_data	/usr/include/itpp/base/mat.h	/^  Num_T *_data() { return data; }$/;"	f	class:itpp::Mat	access:public	signature:()
_data	/usr/include/itpp/base/mat.h	/^  const Num_T *_data() const { return data; }$/;"	f	class:itpp::Mat	access:public	signature:() const
_data	/usr/include/itpp/base/vec.h	/^  Num_T *_data() { return data; }$/;"	f	class:itpp::Vec	access:public	signature:()
_data	/usr/include/itpp/base/vec.h	/^  const Num_T *_data() const { return data; }$/;"	f	class:itpp::Vec	access:public	signature:() const
_datasize	/usr/include/itpp/base/mat.h	/^  int _datasize() const { return datasize; }$/;"	f	class:itpp::Mat	access:public	signature:() const
_disconnect	/usr/include/itpp/protocol/signals_slots.h	/^  void _disconnect(Base_Slot<DataType>* slot);$/;"	p	class:itpp::Signal	access:protected	signature:(Base_Slot<DataType>* slot)
_disconnect	/usr/include/itpp/protocol/signals_slots.h	/^  void _disconnect(Signal<DataType>* signal);$/;"	p	class:itpp::Base_Slot	access:protected	signature:(Signal<DataType>* signal)
_disconnect	/usr/include/itpp/protocol/signals_slots.h	/^void Base_Slot<DataType>::_disconnect(Signal<DataType>* signal)$/;"	f	class:itpp::Base_Slot	signature:(Signal<DataType>* signal)
_disconnect	/usr/include/itpp/protocol/signals_slots.h	/^void Signal<DataType>::_disconnect(Base_Slot<DataType>* slot)$/;"	f	class:itpp::Signal	signature:(Base_Slot<DataType>* slot)
_elem	/usr/include/itpp/base/mat.h	/^  Num_T &_elem(int i) { return data[i]; }$/;"	f	class:itpp::Mat	access:public	signature:(int i)
_elem	/usr/include/itpp/base/mat.h	/^  Num_T &_elem(int r, int c) { return data[r+c*no_rows]; }$/;"	f	class:itpp::Mat	access:public	signature:(int r, int c)
_elem	/usr/include/itpp/base/mat.h	/^  const Num_T &_elem(int i) const { return data[i]; }$/;"	f	class:itpp::Mat	access:public	signature:(int i) const
_elem	/usr/include/itpp/base/mat.h	/^  const Num_T &_elem(int r, int c) const { return data[r+c*no_rows]; }$/;"	f	class:itpp::Mat	access:public	signature:(int r, int c) const
_elem	/usr/include/itpp/base/vec.h	/^  Num_T &_elem(int i) { return data[i]; }$/;"	f	class:itpp::Vec	access:public	signature:(int i)
_elem	/usr/include/itpp/base/vec.h	/^  const Num_T &_elem(int i) const { return data[i]; }$/;"	f	class:itpp::Vec	access:public	signature:(int i) const
_max	/usr/include/itpp/stat/misc_stat.h	/^  double _max;$/;"	m	class:itpp::Stat	access:protected
_min	/usr/include/itpp/stat/misc_stat.h	/^  double _min;$/;"	m	class:itpp::Stat	access:protected
_n_overflows	/usr/include/itpp/stat/misc_stat.h	/^  int _n_overflows;$/;"	m	class:itpp::Stat	access:protected
_n_samples	/usr/include/itpp/stat/misc_stat.h	/^  int _n_samples;$/;"	m	class:itpp::Stat	access:protected
_n_zeros	/usr/include/itpp/stat/misc_stat.h	/^  int _n_zeros;$/;"	m	class:itpp::Stat	access:protected
_ndata	/usr/include/itpp/base/circular_buffer.h	/^  int _ndata;$/;"	m	class:itpp::Circular_Buffer	access:private
_read	/usr/include/itpp/base/circular_buffer.h	/^  int _read;$/;"	m	class:itpp::Circular_Buffer	access:private
_run	/usr/include/itpp/protocol/events.h	/^  static void _run();$/;"	p	class:itpp::Event_Queue	access:private	signature:()
_rw_dist	/usr/include/itpp/base/circular_buffer.h	/^  int _rw_dist;$/;"	m	class:itpp::Circular_Buffer	access:private
_sqr_sum	/usr/include/itpp/stat/misc_stat.h	/^  double _sqr_sum;$/;"	m	class:itpp::Stat	access:protected
_sum	/usr/include/itpp/stat/misc_stat.h	/^  double _sum;$/;"	m	class:itpp::Stat	access:protected
_write	/usr/include/itpp/base/circular_buffer.h	/^  int _write;$/;"	m	class:itpp::Circular_Buffer	access:private
a0	/usr/include/itpp/signal/filter.h	/^  T2 a0;$/;"	m	class:itpp::AR_Filter	access:private
a1	/usr/include/itpp/signal/fastica.h	/^  double a1, a2, mu, epsilon, sampleSize;$/;"	m	class:itpp::Fast_ICA	access:private
a2	/usr/include/itpp/signal/fastica.h	/^  double a1, a2, mu, epsilon, sampleSize;$/;"	m	class:itpp::Fast_ICA	access:private
a_prof	/usr/include/itpp/comm/channel.h	/^  vec a_prof; \/\/!< Average amplitude of each tap$/;"	m	class:itpp::TDL_Channel	access:protected
a_prof_dB	/usr/include/itpp/comm/channel.h	/^  vec a_prof_dB; \/\/!< Power profile in dB$/;"	m	class:itpp::Channel_Specification	access:protected
abs	/usr/include/itpp/base/binary.h	/^inline bin abs(const bin &inbin) { return inbin; }$/;"	f	namespace:itpp	signature:(const bin &inbin)
abs	/usr/include/itpp/base/binary.h	/^inline int abs(const itpp::bin &inbin) { return inbin; }$/;"	f	namespace:std	signature:(const itpp::bin &inbin)
abs	/usr/include/itpp/base/math/elem_math.h	/^inline imat abs(const imat &x) { return apply_function<int>(std::abs, x); }$/;"	f	namespace:itpp	signature:(const imat &x)
abs	/usr/include/itpp/base/math/elem_math.h	/^inline ivec abs(const ivec &x) { return apply_function<int>(std::abs, x); }$/;"	f	namespace:itpp	signature:(const ivec &x)
abs	/usr/include/itpp/base/math/elem_math.h	/^inline mat abs(const mat &x) { return apply_function<double>(std::fabs, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
abs	/usr/include/itpp/base/math/elem_math.h	/^inline vec abs(const vec &x) { return apply_function<double>(std::fabs, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
abs	/usr/include/itpp/base/math/elem_math.h	/^mat abs(const cmat &x);$/;"	p	namespace:itpp	signature:(const cmat &x)
abs	/usr/include/itpp/base/math/elem_math.h	/^vec abs(const cvec &x);$/;"	p	namespace:itpp	signature:(const cvec &x)
abs	/usr/include/itpp/fixed/fix_functions.h	/^Fix abs(const Fix &x);$/;"	p	namespace:itpp	signature:(const Fix &x)
ac2poly	/usr/include/itpp/srccode/lpcfunc.h	/^vec ac2poly(const vec &ac);$/;"	p	namespace:itpp	signature:(const vec &ac)
ac2rc	/usr/include/itpp/srccode/lpcfunc.h	/^vec ac2rc(const vec &ac);$/;"	p	namespace:itpp	signature:(const vec &ac)
acc_covs	/usr/include/itpp/stat/mog_diag_em.h	/^  Array<vec> acc_covs;$/;"	m	class:itpp::MOG_diag_EM_sup	access:private
acc_loglhood_K	/usr/include/itpp/stat/mog_diag_em.h	/^  vec acc_loglhood_K;$/;"	m	class:itpp::MOG_diag_EM_sup	access:private
acc_means	/usr/include/itpp/stat/mog_diag_em.h	/^  Array<vec> acc_means;$/;"	m	class:itpp::MOG_diag_EM_sup	access:private
ack_input	/usr/include/itpp/protocol/selective_repeat.h	/^  Slot<Selective_Repeat_ARQ_Sender, Array<Packet*> > ack_input; \/\/!< Receives incoming ack\/nacks.$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:public
ack_output	/usr/include/itpp/protocol/selective_repeat.h	/^  Signal<Array<Packet*> > ack_output; \/\/!< Delivers ack.$/;"	m	class:itpp::Selective_Repeat_ARQ_Receiver	access:public
acoeffs	/usr/include/itpp/signal/filter.h	/^  Vec<T2> acoeffs, bcoeffs;$/;"	m	class:itpp::ARMA_Filter	access:private
acos	/usr/include/itpp/base/math/trig_hyp.h	/^inline mat acos(const mat &x) { return apply_function<double>(std::acos, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
acos	/usr/include/itpp/base/math/trig_hyp.h	/^inline vec acos(const vec &x) { return apply_function<double>(std::acos, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
acosh	/usr/include/itpp/base/math/trig_hyp.h	/^inline double acosh(double x)$/;"	f	signature:(double x)
acosh	/usr/include/itpp/base/math/trig_hyp.h	/^inline mat acosh(const mat &x) { return apply_function<double>(::acosh, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
acosh	/usr/include/itpp/base/math/trig_hyp.h	/^inline vec acosh(const vec &x) { return apply_function<double>(::acosh, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
active	/usr/include/itpp/protocol/events.h	/^  bool active;$/;"	m	class:itpp::Base_Event	access:protected
adaptive_stop	/usr/include/itpp/comm/turbo.h	/^  bool adaptive_stop;$/;"	m	class:itpp::Turbo_Codec	access:private
add	/usr/include/itpp/base/svec.h	/^  void add(const ivec &index_vec, const Vec<T> &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const ivec &index_vec, const Vec<T> &v)
add	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::add(const ivec& index_vec, const Vec<T>& v)$/;"	f	class:itpp::Sparse_Vec	signature:(const ivec& index_vec, const Vec<T>& v)
add	/usr/include/itpp/protocol/events.h	/^  static void add(Base_Event *e);$/;"	p	class:itpp::Event_Queue	access:public	signature:(Base_Event *e)
add_LOS	/usr/include/itpp/comm/channel.h	/^  void add_LOS(int idx, std::complex<double>& sample);$/;"	p	class:itpp::Correlated_Fading_Generator	access:protected	signature:(int idx, std::complex<double>& sample)
add_elem	/usr/include/itpp/base/smat.h	/^  void add_elem(const int r, const int c, const T v);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const int r, const int c, const T v)
add_elem	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::add_elem(int r, int c, T v)$/;"	f	class:itpp::Sparse_Mat	signature:(int r, int c, T v)
add_elem	/usr/include/itpp/base/svec.h	/^  void add_elem(const int i, const T v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const int i, const T v)
add_elem	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::add_elem(const int i, const T v)$/;"	f	class:itpp::Sparse_Vec	signature:(const int i, const T v)
add_rows	/usr/include/itpp/base/gf2mat.h	/^  void add_rows(int i, int j);$/;"	p	class:itpp::GF2mat	access:public	signature:(int i, int j)
addto_element	/usr/include/itpp/base/gf2mat.h	/^  inline void addto_element(int i, int j, bin s);$/;"	p	class:itpp::GF2mat	access:public	signature:(int i, int j, bin s)
addto_element	/usr/include/itpp/base/gf2mat.h	/^inline void GF2mat::addto_element(int i, int j, bin s)$/;"	f	class:itpp::GF2mat	signature:(int i, int j, bin s)
all	/usr/include/itpp/base/matfunc.h	/^bool all(const bvec &testvec);$/;"	p	namespace:itpp	signature:(const bvec &testvec)
alloc	/usr/include/itpp/base/array.h	/^  void alloc(int n);$/;"	p	class:itpp::Array	access:protected	signature:(int n)
alloc	/usr/include/itpp/base/array.h	/^void Array<T>::alloc(int n)$/;"	f	class:itpp::Array	signature:(int n)
alloc	/usr/include/itpp/base/circular_buffer.h	/^  void alloc(int n);$/;"	p	class:itpp::Circular_Buffer	access:private	signature:(int n)
alloc	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::alloc(int n)$/;"	f	class:itpp::Circular_Buffer	signature:(int n)
alloc	/usr/include/itpp/base/mat.h	/^  void alloc(int rows, int cols);$/;"	p	class:itpp::Mat	access:protected	signature:(int rows, int cols)
alloc	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::alloc(int rows, int cols)$/;"	f	class:itpp::Mat	signature:(int rows, int cols)
alloc	/usr/include/itpp/base/smat.h	/^  void alloc(int row_data_size = 200);$/;"	p	class:itpp::Sparse_Mat	access:private	signature:(int row_data_size = 200)
alloc	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::alloc(int row_data_init)$/;"	f	class:itpp::Sparse_Mat	signature:(int row_data_init)
alloc	/usr/include/itpp/base/stack.h	/^  void alloc(int n);$/;"	p	class:itpp::Stack	access:private	signature:(int n)
alloc	/usr/include/itpp/base/stack.h	/^void Stack<T>::alloc(int n)$/;"	f	class:itpp::Stack	signature:(int n)
alloc	/usr/include/itpp/base/svec.h	/^  void alloc();$/;"	p	class:itpp::Sparse_Vec	access:private	signature:()
alloc	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::alloc()$/;"	f	class:itpp::Sparse_Vec	signature:()
alloc	/usr/include/itpp/base/vec.h	/^  void alloc(int size);$/;"	p	class:itpp::Vec	access:protected	signature:(int size)
alloc	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::alloc(int size)$/;"	f	class:itpp::Vec	signature:(int size)
alloc_empty	/usr/include/itpp/base/smat.h	/^  void alloc_empty();$/;"	p	class:itpp::Sparse_Mat	access:private	signature:()
alloc_empty	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::alloc_empty()$/;"	f	class:itpp::Sparse_Mat	signature:()
alpha	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  mat gamma, alpha, beta;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
alpha	/usr/include/itpp/optim/newton_search.h	/^  double alpha; \/\/ end value of alpha, info(1)$/;"	m	class:itpp::Line_Search	access:private
alpha_q	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  QLLRmat gamma_q, alpha_q, beta_q;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
alpha_values	/usr/include/itpp/optim/newton_search.h	/^  vec alpha_values, F_values, dF_values;$/;"	m	class:itpp::Line_Search	access:private
alphapow	/usr/include/itpp/comm/galois.h	/^  static Array<Array<int> > alphapow, logalpha;$/;"	m	class:itpp::GF	access:private
angle	/usr/include/itpp/base/math/elem_math.h	/^inline mat angle(const cmat &x) { return arg(x); }$/;"	f	namespace:itpp	signature:(const cmat &x)
angle	/usr/include/itpp/base/math/elem_math.h	/^inline vec angle(const cvec &x) { return arg(x); }$/;"	f	namespace:itpp	signature:(const cvec &x)
any	/usr/include/itpp/base/matfunc.h	/^bool any(const bvec &testvec);$/;"	p	namespace:itpp	signature:(const bvec &testvec)
append_col	/usr/include/itpp/base/mat.h	/^  void append_col(const Vec<Num_T> &v);$/;"	p	class:itpp::Mat	access:public	signature:(const Vec<Num_T> &v)
append_col	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::append_col(const Vec<Num_T> &v)$/;"	f	class:itpp::Mat	signature:(const Vec<Num_T> &v)
append_row	/usr/include/itpp/base/mat.h	/^  void append_row(const Vec<Num_T> &v);$/;"	p	class:itpp::Mat	access:public	signature:(const Vec<Num_T> &v)
append_row	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::append_row(const Vec<Num_T> &v)$/;"	f	class:itpp::Mat	signature:(const Vec<Num_T> &v)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template bmat apply_function(bin(*f)(bin), const bmat &m);$/;"	p	namespace:itpp	signature:(bin(f)bin), const bmat &m)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template bmat apply_function(bin(*f)(bin, bin), const bin& x, const bmat &m);$/;"	p	namespace:itpp	signature:(bin(f)bin, bin), const bin& x, const bmat &m)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template bmat apply_function(bin(*f)(bin, bin), const bmat &m, const bin& x);$/;"	p	namespace:itpp	signature:(bin(f)bin, bin), const bmat &m, const bin& x)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template bvec apply_function(bin(*f)(bin), const bvec &v);$/;"	p	namespace:itpp	signature:(bin(f)bin), const bvec &v)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template bvec apply_function(bin(*f)(bin, bin), const bin& x, const bvec &v);$/;"	p	namespace:itpp	signature:(bin(f)bin, bin), const bin& x, const bvec &v)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template bvec apply_function(bin(*f)(bin, bin), const bvec &v, const bin& x);$/;"	p	namespace:itpp	signature:(bin(f)bin, bin), const bvec &v, const bin& x)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template cmat apply_function(std::complex<double> (*f)(const std::complex<double> &),$/;"	p	namespace:itpp	signature:(std::complex<double> (f)const std::complex<double> &), const cmat &m)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template cmat apply_function(std::complex<double> (*f)(const std::complex<double> &,$/;"	p	namespace:itpp	signature:(std::complex<double> (f)const std::complex<double> &, const std::complex<double> &), const cmat &m, const std::complex<double>& x)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template cmat apply_function(std::complex<double> (*f)(const std::complex<double> &,$/;"	p	namespace:itpp	signature:(std::complex<double> (f)const std::complex<double> &, const std::complex<double> &), const std::complex<double>& x, const cmat &m)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template cvec apply_function(std::complex<double> (*f)(const std::complex<double> &),$/;"	p	namespace:itpp	signature:(std::complex<double> (f)const std::complex<double> &), const cvec &v)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template cvec apply_function(std::complex<double> (*f)(const std::complex<double> &,$/;"	p	namespace:itpp	signature:(std::complex<double> (f)const std::complex<double> &, const std::complex<double> &), const cvec &v, const std::complex<double>& x)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template cvec apply_function(std::complex<double> (*f)(const std::complex<double> &,$/;"	p	namespace:itpp	signature:(std::complex<double> (f)const std::complex<double> &, const std::complex<double> &), const std::complex<double>& x, const cvec &v)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template imat apply_function(int (*f)(int), const imat &m);$/;"	p	namespace:itpp	signature:(int (*f)(int), const imat &m)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template imat apply_function(int (*f)(int, int), const imat &m, const int& x);$/;"	p	namespace:itpp	signature:(int (*f)(int, int), const imat &m, const int& x)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template imat apply_function(int (*f)(int, int), const int& x, const imat &m);$/;"	p	namespace:itpp	signature:(int (*f)(int, int), const int& x, const imat &m)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template ivec apply_function(int (*f)(int), const ivec &v);$/;"	p	namespace:itpp	signature:(int (*f)(int), const ivec &v)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template ivec apply_function(int (*f)(int, int), const int& x, const ivec &v);$/;"	p	namespace:itpp	signature:(int (*f)(int, int), const int& x, const ivec &v)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template ivec apply_function(int (*f)(int, int), const ivec &v, const int& x);$/;"	p	namespace:itpp	signature:(int (*f)(int, int), const ivec &v, const int& x)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template mat apply_function(double(*f)(double), const mat &m);$/;"	p	namespace:itpp	signature:(double(*f)(double), const mat &m)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template mat apply_function(double(*f)(double, double), const double& x, const mat &m);$/;"	p	namespace:itpp	signature:(double(*f)(double, double), const double& x, const mat &m)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template mat apply_function(double(*f)(double, double), const mat &m, const double& x);$/;"	p	namespace:itpp	signature:(double(*f)(double, double), const mat &m, const double& x)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template smat apply_function(short(*f)(short), const smat &m);$/;"	p	namespace:itpp	signature:(short(*f)(short), const smat &m)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template smat apply_function(short(*f)(short, short), const short& x, const smat &m);$/;"	p	namespace:itpp	signature:(short(*f)(short, short), const short& x, const smat &m)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template smat apply_function(short(*f)(short, short), const smat &m, const short& x);$/;"	p	namespace:itpp	signature:(short(*f)(short, short), const smat &m, const short& x)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template svec apply_function(short(*f)(short), const svec &v);$/;"	p	namespace:itpp	signature:(short(*f)(short), const svec &v)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template svec apply_function(short(*f)(short, short), const short& x, const svec &v);$/;"	p	namespace:itpp	signature:(short(*f)(short, short), const short& x, const svec &v)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template svec apply_function(short(*f)(short, short), const svec &v, const short& x);$/;"	p	namespace:itpp	signature:(short(*f)(short, short), const svec &v, const short& x)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template vec apply_function(double(*f)(double), const vec &v);$/;"	p	namespace:itpp	signature:(double(*f)(double), const vec &v)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template vec apply_function(double(*f)(double, double), const double& x, const vec &v);$/;"	p	namespace:itpp	signature:(double(*f)(double, double), const double& x, const vec &v)
apply_function	/usr/include/itpp/base/help_functions.h	/^extern template vec apply_function(double(*f)(double, double), const vec &v, const double& x);$/;"	p	namespace:itpp	signature:(double(*f)(double, double), const vec &v, const double& x)
apply_function	/usr/include/itpp/base/help_functions.h	/^inline Mat<T> apply_function(T(*f)(T), const Mat<T>& m)$/;"	f	namespace:itpp	signature:(T(f)T), const Mat<T>& m)
apply_function	/usr/include/itpp/base/help_functions.h	/^inline Mat<T> apply_function(T(*f)(T, T), const Mat<T>& m, const T& x)$/;"	f	namespace:itpp	signature:(T(f)T, T), const Mat<T>& m, const T& x)
apply_function	/usr/include/itpp/base/help_functions.h	/^inline Mat<T> apply_function(T(*f)(T, T), const T& x, const Mat<T>& m)$/;"	f	namespace:itpp	signature:(T(f)T, T), const T& x, const Mat<T>& m)
apply_function	/usr/include/itpp/base/help_functions.h	/^inline Mat<T> apply_function(T(*f)(const T&), const Mat<T>& m)$/;"	f	namespace:itpp	signature:(T(f)const T&), const Mat<T>& m)
apply_function	/usr/include/itpp/base/help_functions.h	/^inline Mat<T> apply_function(T(*f)(const T&, const T&), const Mat<T>& m,$/;"	f	namespace:itpp	signature:(T(f)const T&, const T&), const Mat<T>& m, const T& x)
apply_function	/usr/include/itpp/base/help_functions.h	/^inline Mat<T> apply_function(T(*f)(const T&, const T&), const T& x,$/;"	f	namespace:itpp	signature:(T(f)const T&, const T&), const T& x, const Mat<T>& m)
apply_function	/usr/include/itpp/base/help_functions.h	/^inline Vec<T> apply_function(T(*f)(T), const Vec<T>& v)$/;"	f	namespace:itpp	signature:(T(f)T), const Vec<T>& v)
apply_function	/usr/include/itpp/base/help_functions.h	/^inline Vec<T> apply_function(T(*f)(T, T), const T& x, const Vec<T>& v)$/;"	f	namespace:itpp	signature:(T(f)T, T), const T& x, const Vec<T>& v)
apply_function	/usr/include/itpp/base/help_functions.h	/^inline Vec<T> apply_function(T(*f)(T, T), const Vec<T>& v, const T& x)$/;"	f	namespace:itpp	signature:(T(f)T, T), const Vec<T>& v, const T& x)
apply_function	/usr/include/itpp/base/help_functions.h	/^inline Vec<T> apply_function(T(*f)(const T&), const Vec<T>& v)$/;"	f	namespace:itpp	signature:(T(f)const T&), const Vec<T>& v)
apply_function	/usr/include/itpp/base/help_functions.h	/^inline Vec<T> apply_function(T(*f)(const T&, const T&), const T& x,$/;"	f	namespace:itpp	signature:(T(f)const T&, const T&), const T& x, const Vec<T>& v)
apply_function	/usr/include/itpp/base/help_functions.h	/^inline Vec<T> apply_function(T(*f)(const T&, const T&), const Vec<T>& v,$/;"	f	namespace:itpp	signature:(T(f)const T&, const T&), const Vec<T>& v, const T& x)
apply_o_mode	/usr/include/itpp/fixed/fix_base.h	/^  fixrep apply_o_mode(fixrep x) const;$/;"	p	class:itpp::Fix_Base	access:protected	signature:(fixrep x) const
approach	/usr/include/itpp/signal/fastica.h	/^  int approach, numOfIC, g, initState;$/;"	m	class:itpp::Fast_ICA	access:private
arg	/usr/include/itpp/base/math/elem_math.h	/^mat arg(const cmat &x);$/;"	p	namespace:itpp	signature:(const cmat &x)
arg	/usr/include/itpp/base/math/elem_math.h	/^vec arg(const cvec &x);$/;"	p	namespace:itpp	signature:(const cvec &x)
arma_estimator	/usr/include/itpp/signal/filter_design.h	/^void arma_estimator(const int m, const int n, const vec &R, vec &b, vec &a);$/;"	p	namespace:itpp	signature:(const int m, const int n, const vec &R, vec &b, vec &a)
armed	/usr/include/itpp/protocol/signals_slots.h	/^  bool armed;$/;"	m	class:itpp::Signal	access:private
asin	/usr/include/itpp/base/math/trig_hyp.h	/^inline mat asin(const mat &x) { return apply_function<double>(std::asin, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
asin	/usr/include/itpp/base/math/trig_hyp.h	/^inline vec asin(const vec &x) { return apply_function<double>(std::asin, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
asinh	/usr/include/itpp/base/math/trig_hyp.h	/^inline double asinh(double x)$/;"	f	signature:(double x)
asinh	/usr/include/itpp/base/math/trig_hyp.h	/^inline mat asinh(const mat &x) { return apply_function<double>(::asinh, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
asinh	/usr/include/itpp/base/math/trig_hyp.h	/^inline vec asinh(const vec &x) { return apply_function<double>(::asinh, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
assert_fixshift	/usr/include/itpp/fixed/fix_functions.h	/^inline void assert_fixshift(const CFix &x, int shift)$/;"	f	namespace:itpp	signature:(const CFix &x, int shift)
assert_fixshift	/usr/include/itpp/fixed/fix_functions.h	/^inline void assert_fixshift(const Fix &x, int shift)$/;"	f	namespace:itpp	signature:(const Fix &x, int shift)
assert_fixshift	/usr/include/itpp/fixed/fix_functions.h	/^inline void assert_fixshift(const std::complex<double> &, int) {}$/;"	f	namespace:itpp	signature:(const std::complex<double> &, int)
assert_fixshift	/usr/include/itpp/fixed/fix_functions.h	/^inline void assert_fixshift(double, int) {}$/;"	f	namespace:itpp	signature:(double, int)
assert_shifts	/usr/include/itpp/fixed/cfix.h	/^  friend int assert_shifts(const CFix &x, const CFix &y);$/;"	p	class:itpp::CFix	access:friend	signature:(const CFix &x, const CFix &y)
assert_shifts	/usr/include/itpp/fixed/cfix.h	/^  friend int assert_shifts(const CFix &x, const Fix &y);$/;"	p	class:itpp::CFix	access:friend	signature:(const CFix &x, const Fix &y)
assert_shifts	/usr/include/itpp/fixed/cfix.h	/^  friend int assert_shifts(const CFix &x, int y);$/;"	p	class:itpp::CFix	access:friend	signature:(const CFix &x, int y)
assert_shifts	/usr/include/itpp/fixed/cfix.h	/^int assert_shifts(const CFix &x, const CFix &y);$/;"	p	namespace:itpp	signature:(const CFix &x, const CFix &y)
assert_shifts	/usr/include/itpp/fixed/cfix.h	/^int assert_shifts(const CFix &x, const Fix &y);$/;"	p	namespace:itpp	signature:(const CFix &x, const Fix &y)
assert_shifts	/usr/include/itpp/fixed/cfix.h	/^int assert_shifts(const CFix &x, int y);$/;"	p	namespace:itpp	signature:(const CFix &x, int y)
assert_shifts	/usr/include/itpp/fixed/fix.h	/^  friend int assert_shifts(const CFix &x, const Fix &y);$/;"	p	class:itpp::Fix	access:friend	signature:(const CFix &x, const Fix &y)
assert_shifts	/usr/include/itpp/fixed/fix.h	/^  friend int assert_shifts(const Fix &x, const Fix &y);$/;"	p	class:itpp::Fix	access:friend	signature:(const Fix &x, const Fix &y)
assert_shifts	/usr/include/itpp/fixed/fix.h	/^  friend int assert_shifts(const Fix &x, int y);$/;"	p	class:itpp::Fix	access:friend	signature:(const Fix &x, int y)
assert_shifts	/usr/include/itpp/fixed/fix.h	/^int assert_shifts(const Fix &x, const Fix &y);$/;"	p	namespace:itpp	signature:(const Fix &x, const Fix &y)
assert_shifts	/usr/include/itpp/fixed/fix.h	/^int assert_shifts(const Fix &x, int y);$/;"	p	namespace:itpp	signature:(const Fix &x, int y)
assign_to_means	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  void assign_to_means();$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:protected	signature:()
atan	/usr/include/itpp/base/math/trig_hyp.h	/^inline mat atan(const mat &x) { return apply_function<double>(std::atan, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
atan	/usr/include/itpp/base/math/trig_hyp.h	/^inline vec atan(const vec &x) { return apply_function<double>(std::atan, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
atanh	/usr/include/itpp/base/math/trig_hyp.h	/^inline double atanh(double x)$/;"	f	signature:(double x)
atanh	/usr/include/itpp/base/math/trig_hyp.h	/^inline mat atanh(const mat &x) { return apply_function<double>(::atanh, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
atanh	/usr/include/itpp/base/math/trig_hyp.h	/^inline vec atanh(const vec &x) { return apply_function<double>(::atanh, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
autocorr	/usr/include/itpp/srccode/lpcfunc.h	/^vec autocorr(const vec &x, int order);$/;"	p	namespace:itpp	signature:(const vec &x, int order)
avg	/usr/include/itpp/stat/misc_stat.h	/^  double avg() const {return _sum \/ _n_samples;}$/;"	f	class:itpp::Stat	access:public	signature:() const
avg_bit_rate	/usr/include/itpp/protocol/packet_generator.h	/^  double avg_bit_rate;$/;"	m	class:itpp::Poisson_Packet_Generator	access:protected
avg_delta_t	/usr/include/itpp/protocol/packet_generator.h	/^  double avg_delta_t;$/;"	m	class:itpp::Poisson_Packet_Generator	access:protected
avg_log_lhood	/usr/include/itpp/stat/mog_diag.h	/^  double avg_log_lhood(const Array<vec> & X_in);$/;"	p	class:itpp::MOG_diag	access:public	signature:(const Array<vec> & X_in)
avg_log_lhood	/usr/include/itpp/stat/mog_diag.h	/^  double avg_log_lhood(const double ** c_x_in, int N);$/;"	p	class:itpp::MOG_diag	access:public	signature:(const double ** c_x_in, int N)
avg_log_lhood	/usr/include/itpp/stat/mog_generic.h	/^  virtual double avg_log_lhood(const Array<vec> &X_in);$/;"	p	class:itpp::MOG_generic	access:public	signature:(const Array<vec> &X_in)
axpy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void axpy_vector(int n, double alpha, const double *x, double *y)$/;"	f	namespace:itpp	signature:(int n, double alpha, const double *x, double *y)
axpy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void axpy_vector(int n, double alpha, const double *x, int incx,$/;"	f	namespace:itpp	signature:(int n, double alpha, const double *x, int incx, double *y, int incy)
axpy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void axpy_vector(int n, std::complex<double> alpha,$/;"	f	namespace:itpp	signature:(int n, std::complex<double> alpha, const std::complex<double> *x, int incx, std::complex<double> *y, int incy)
axpy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void axpy_vector(int n, std::complex<double> alpha,$/;"	f	namespace:itpp	signature:(int n, std::complex<double> alpha, const std::complex<double> *x, std::complex<double> *y)
axpy_vector	/usr/include/itpp/base/copy_vector.h	/^void axpy_vector(int n, T alpha, const T *x, T *y)$/;"	f	namespace:itpp	signature:(int n, T alpha, const T *x, T *y)
axpy_vector	/usr/include/itpp/base/copy_vector.h	/^void axpy_vector(int n, T alpha, const T *x, int incx, T *y, int incy)$/;"	f	namespace:itpp	signature:(int n, T alpha, const T *x, int incx, T *y, int incy)
b	/usr/include/itpp/base/binary.h	/^  char b;$/;"	m	class:itpp::bin	access:private
b	/usr/include/itpp/base/random.h	/^  double l, b;$/;"	m	class:itpp::Weibull_RNG	access:private
b_endian	/usr/include/itpp/base/binfile.h	/^  enum endian { l_endian, b_endian };$/;"	e	enum:itpp::bfstream_base::endian
backslash	/usr/include/itpp/base/algebra/ls_solve.h	/^bool backslash(const cmat &A, const cmat &B, cmat &X);$/;"	p	namespace:itpp	signature:(const cmat &A, const cmat &B, cmat &X)
backslash	/usr/include/itpp/base/algebra/ls_solve.h	/^bool backslash(const cmat &A, const cvec &b, cvec &x);$/;"	p	namespace:itpp	signature:(const cmat &A, const cvec &b, cvec &x)
backslash	/usr/include/itpp/base/algebra/ls_solve.h	/^bool backslash(const mat &A, const mat &B, mat &X);$/;"	p	namespace:itpp	signature:(const mat &A, const mat &B, mat &X)
backslash	/usr/include/itpp/base/algebra/ls_solve.h	/^bool backslash(const mat &A, const vec &b, vec &x);$/;"	p	namespace:itpp	signature:(const mat &A, const vec &b, vec &x)
backslash	/usr/include/itpp/base/algebra/ls_solve.h	/^cmat backslash(const cmat &A, const cmat &B);$/;"	p	namespace:itpp	signature:(const cmat &A, const cmat &B)
backslash	/usr/include/itpp/base/algebra/ls_solve.h	/^cvec backslash(const cmat &A, const cvec &b);$/;"	p	namespace:itpp	signature:(const cmat &A, const cvec &b)
backslash	/usr/include/itpp/base/algebra/ls_solve.h	/^mat backslash(const mat &A, const mat &B);$/;"	p	namespace:itpp	signature:(const mat &A, const mat &B)
backslash	/usr/include/itpp/base/algebra/ls_solve.h	/^vec backslash(const mat &A, const vec &b);$/;"	p	namespace:itpp	signature:(const mat &A, const vec &b)
backward_substitution	/usr/include/itpp/base/algebra/ls_solve.h	/^vec backward_substitution(const mat &U, const vec &b);$/;"	p	namespace:itpp	signature:(const mat &U, const vec &b)
backward_substitution	/usr/include/itpp/base/algebra/ls_solve.h	/^vec backward_substitution(const mat &U, int q, const vec &b);$/;"	p	namespace:itpp	signature:(const mat &U, int q, const vec &b)
backward_substitution	/usr/include/itpp/base/algebra/ls_solve.h	/^void backward_substitution(const mat &U, const vec &b, vec &x);$/;"	p	namespace:itpp	signature:(const mat &U, const vec &b, vec &x)
backward_substitution	/usr/include/itpp/base/algebra/ls_solve.h	/^void backward_substitution(const mat &U, int q, const vec &b, vec &x);$/;"	p	namespace:itpp	signature:(const mat &U, int q, const vec &b, vec &x)
bcoeffs	/usr/include/itpp/signal/filter.h	/^  Vec<T2> acoeffs, bcoeffs;$/;"	m	class:itpp::ARMA_Filter	access:private
begin	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number begin() const { return seq_begin; }$/;"	f	class:itpp::TCP_Segment	access:public	signature:() const
besseli	/usr/include/itpp/base/bessel.h	/^double besseli(double nu, double x);$/;"	p	namespace:itpp	signature:(double nu, double x)
besseli	/usr/include/itpp/base/bessel.h	/^vec besseli(double nu, const vec &x);$/;"	p	namespace:itpp	signature:(double nu, const vec &x)
besselj	/usr/include/itpp/base/bessel.h	/^double besselj(double nu, double x);$/;"	p	namespace:itpp	signature:(double nu, double x)
besselj	/usr/include/itpp/base/bessel.h	/^double besselj(int nu, double x);$/;"	p	namespace:itpp	signature:(int nu, double x)
besselj	/usr/include/itpp/base/bessel.h	/^vec besselj(double nu, const vec &x);$/;"	p	namespace:itpp	signature:(double nu, const vec &x)
besselj	/usr/include/itpp/base/bessel.h	/^vec besselj(int nu, const vec &x);$/;"	p	namespace:itpp	signature:(int nu, const vec &x)
besselk	/usr/include/itpp/base/bessel.h	/^double besselk(int nu, double x);$/;"	p	namespace:itpp	signature:(int nu, double x)
besselk	/usr/include/itpp/base/bessel.h	/^vec besselk(int nu, const vec &x);$/;"	p	namespace:itpp	signature:(int nu, const vec &x)
bessely	/usr/include/itpp/base/bessel.h	/^double bessely(double nu, double x);$/;"	p	namespace:itpp	signature:(double nu, double x)
bessely	/usr/include/itpp/base/bessel.h	/^double bessely(int nu, double x);$/;"	p	namespace:itpp	signature:(int nu, double x)
bessely	/usr/include/itpp/base/bessel.h	/^vec bessely(double nu, const vec &x);$/;"	p	namespace:itpp	signature:(double nu, const vec &x)
bessely	/usr/include/itpp/base/bessel.h	/^vec bessely(int nu, const vec &x);$/;"	p	namespace:itpp	signature:(int nu, const vec &x)
beta	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  mat gamma, alpha, beta;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
beta_q	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  QLLRmat gamma_q, alpha_q, beta_q;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
bfstream	/usr/include/itpp/base/binfile.h	/^  bfstream();$/;"	p	class:itpp::bfstream	access:public	signature:()
bfstream	/usr/include/itpp/base/binfile.h	/^  bfstream(const std::string& name, endian e = b_endian);$/;"	p	class:itpp::bfstream	access:public	signature:(const std::string& name, endian e = b_endian)
bfstream	/usr/include/itpp/base/binfile.h	/^class bfstream : public bfstream_base, public std::fstream$/;"	c	namespace:itpp	inherits:bfstream_base,std::fstream
bfstream_base	/usr/include/itpp/base/binfile.h	/^  bfstream_base(endian e = b_endian);$/;"	p	class:itpp::bfstream_base	access:public	signature:(endian e = b_endian)
bfstream_base	/usr/include/itpp/base/binfile.h	/^class bfstream_base$/;"	c	namespace:itpp
bidiag	/usr/include/itpp/base/matfunc.h	/^Mat<T> bidiag(const Vec<T> &main, const Vec<T> &sup)$/;"	f	namespace:itpp	signature:(const Vec<T> &main, const Vec<T> &sup)
bidiag	/usr/include/itpp/base/matfunc.h	/^extern template cmat bidiag(const cvec &, const cvec &);$/;"	p	namespace:itpp	signature:(const cvec &, const cvec &)
bidiag	/usr/include/itpp/base/matfunc.h	/^extern template mat bidiag(const vec &, const vec &);$/;"	p	namespace:itpp	signature:(const vec &, const vec &)
bidiag	/usr/include/itpp/base/matfunc.h	/^extern template void bidiag(const cmat &, cvec &, cvec &);$/;"	p	namespace:itpp	signature:(const cmat &, cvec &, cvec &)
bidiag	/usr/include/itpp/base/matfunc.h	/^extern template void bidiag(const cvec &, const cvec &, cmat &);$/;"	p	namespace:itpp	signature:(const cvec &, const cvec &, cmat &)
bidiag	/usr/include/itpp/base/matfunc.h	/^extern template void bidiag(const mat &, vec &, vec &);$/;"	p	namespace:itpp	signature:(const mat &, vec &, vec &)
bidiag	/usr/include/itpp/base/matfunc.h	/^extern template void bidiag(const vec &, const vec &, mat &);$/;"	p	namespace:itpp	signature:(const vec &, const vec &, mat &)
bidiag	/usr/include/itpp/base/matfunc.h	/^void bidiag(const Mat<T> &m, Vec<T> &main, Vec<T> &sup)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, Vec<T> &main, Vec<T> &sup)
bidiag	/usr/include/itpp/base/matfunc.h	/^void bidiag(const Vec<T> &main, const Vec<T> &sup, Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Vec<T> &main, const Vec<T> &sup, Mat<T> &m)
bifstream	/usr/include/itpp/base/binfile.h	/^  bifstream();$/;"	p	class:itpp::bifstream	access:public	signature:()
bifstream	/usr/include/itpp/base/binfile.h	/^  bifstream(const std::string& name, endian e = b_endian);$/;"	p	class:itpp::bifstream	access:public	signature:(const std::string& name, endian e = b_endian)
bifstream	/usr/include/itpp/base/binfile.h	/^class bifstream : public bfstream_base, public std::ifstream$/;"	c	namespace:itpp	inherits:bfstream_base,std::ifstream
bin	/usr/include/itpp/base/binary.h	/^  bin(): b(0) {}$/;"	f	class:itpp::bin	access:public	signature:()
bin	/usr/include/itpp/base/binary.h	/^  bin(const bin &inbin): b(inbin.b) {}$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin)
bin	/usr/include/itpp/base/binary.h	/^  bin(const int &value): b(static_cast<char>(value)) {$/;"	f	class:itpp::bin	access:public	signature:(const int &value)
bin	/usr/include/itpp/base/binary.h	/^class bin$/;"	c	namespace:itpp
bin2dec	/usr/include/itpp/base/converters.h	/^int bin2dec(const bvec &inbvec, bool msb_first = true);$/;"	p	namespace:itpp	signature:(const bvec &inbvec, bool msb_first = true)
bin2mxArray	/usr/include/itpp/itmex.h	/^void bin2mxArray(const bin &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const bin &in, mxArray *out)
bin2oct	/usr/include/itpp/base/converters.h	/^ivec bin2oct(const bvec &inbits);$/;"	p	namespace:itpp	signature:(const bvec &inbits)
bin2pol	/usr/include/itpp/base/converters.h	/^ivec bin2pol(const bvec &inbvec);$/;"	p	namespace:itpp	signature:(const bvec &inbvec)
binom	/usr/include/itpp/base/math/elem_math.h	/^double binom(int n, int k);$/;"	p	namespace:itpp	signature:(int n, int k)
binom_i	/usr/include/itpp/base/math/elem_math.h	/^int binom_i(int n, int k);$/;"	p	namespace:itpp	signature:(int n, int k)
bins	/usr/include/itpp/stat/histogram.h	/^  ivec bins;$/;"	m	class:itpp::Histogram	access:private
bins_num	/usr/include/itpp/stat/histogram.h	/^  int bins_num() const { return num_bins; };$/;"	f	class:itpp::Histogram	access:public	signature:() const
bit_interleaver	/usr/include/itpp/comm/turbo.h	/^  Sequence_Interleaver<bin> bit_interleaver;$/;"	m	class:itpp::Turbo_Codec	access:private
bit_size	/usr/include/itpp/protocol/packet.h	/^  int bit_size() { return size_bits; }$/;"	f	class:itpp::Packet	access:public	signature:()
bitalloc	/usr/include/itpp/srccode/vqtrain.h	/^ivec bitalloc(const vec& variances, int nobits);$/;"	p	namespace:itpp	signature:(const vec& variances, int nobits)
bitmap	/usr/include/itpp/comm/modulator.h	/^  bmat bitmap;$/;"	m	class:itpp::Modulator	access:protected
bitmap	/usr/include/itpp/comm/modulator_nd.h	/^  Array<bmat> bitmap;$/;"	m	class:itpp::Modulator_ND	access:protected
bitrv	/usr/include/itpp/signal/transforms.h	/^void bitrv(Vec<T> &out)$/;"	f	namespace:itpp	signature:(Vec<T> &out)
bits2symbols	/usr/include/itpp/comm/modulator.h	/^  ivec bits2symbols;$/;"	m	class:itpp::Modulator	access:protected
bits2symbols	/usr/include/itpp/comm/modulator_nd.h	/^  Array<ivec> bits2symbols;$/;"	m	class:itpp::Modulator_ND	access:protected
bits_per_symbol	/usr/include/itpp/comm/modulator.h	/^  virtual int bits_per_symbol() const { return k; }$/;"	f	class:itpp::Modulator	access:public	signature:() const
blackman	/usr/include/itpp/signal/window.h	/^vec blackman(int n);$/;"	p	namespace:itpp	signature:(int n)
blas	/usr/include/itpp/base/blas.h	/^namespace blas$/;"	n
blas::daxpy_	/usr/include/itpp/base/blas.h	/^  void daxpy_(const int *n,$/;"	p	signature:(const int *n, const double *alpha, const double *x, const int *incx, double *y, const int *incy)
blas::dcopy_	/usr/include/itpp/base/blas.h	/^  void dcopy_(const int *n,$/;"	p	signature:(const int *n, const double *x, const int *incx, double *y, const int *incy)
blas::ddot_	/usr/include/itpp/base/blas.h	/^  double ddot_(const int *n,$/;"	p	signature:(const int *n, const double *x, const int *incx, const double *y, const int *incy)
blas::dgemm_	/usr/include/itpp/base/blas.h	/^  void dgemm_(const char *transA, const char *transB,$/;"	p	signature:(const char *transA, const char *transB, const int *m, const int *n, const int *k, const double *alpha, const double *A, const int *ldA, const double *B, const int *ldB, const double *beta, double *C, const int *ldC)
blas::dgemv_	/usr/include/itpp/base/blas.h	/^  void dgemv_(const char *transA, const int *m, const int *n,$/;"	p	signature:(const char *transA, const int *m, const int *n, const double *alpha, const double *A, const int *ldA, const double *x, const int *incx, const double *beta, double *y, const int *incy)
blas::dger_	/usr/include/itpp/base/blas.h	/^  void dger_(const int *m, const int *n,$/;"	p	signature:(const int *m, const int *n, const double *alpha, const double *x, const int *incx, const double *y, const int *incy, double *A, const int *ldA)
blas::dscal_	/usr/include/itpp/base/blas.h	/^  void dscal_(const int *n,$/;"	p	signature:(const int *n, const double *alpha, double *x, const int *incx)
blas::dswap_	/usr/include/itpp/base/blas.h	/^  void dswap_(const int *n,$/;"	p	signature:(const int *n, double *x, const int *incx, double *y, const int *incy)
blas::zaxpy_	/usr/include/itpp/base/blas.h	/^  void zaxpy_(const int *n,$/;"	p	signature:(const int *n, const std::complex<double> *alpha, const std::complex<double> *x, const int *incx, std::complex<double> *y, const int *incy)
blas::zcopy_	/usr/include/itpp/base/blas.h	/^  void zcopy_(const int *n,$/;"	p	signature:(const int *n, const std::complex<double> *x, const int *incx, std::complex<double> *y, const int *incy)
blas::zdotusub_	/usr/include/itpp/base/blas.h	/^  void zdotusub_(std::complex<double> *dot,$/;"	p	signature:(std::complex<double> *dot, const int *n, const std::complex<double> *x, const int *incx, const std::complex<double> *y, const int *incy)
blas::zgemm_	/usr/include/itpp/base/blas.h	/^  void zgemm_(const char *transA, const char *transB,$/;"	p	signature:(const char *transA, const char *transB, const int *m, const int *n, const int *k, const std::complex<double> *alpha, const std::complex<double> *A, const int *ldA, const std::complex<double> *B, const int *ldB, const std::complex<double> *beta, std::complex<double> *C, const int *ldC)
blas::zgemv_	/usr/include/itpp/base/blas.h	/^  void zgemv_(const char *transA, const int *m, const int *n,$/;"	p	signature:(const char *transA, const int *m, const int *n, const std::complex<double> *alpha, const std::complex<double> *A, const int *ldA, const std::complex<double> *x, const int *incx, const std::complex<double> *beta, std::complex<double> *y, const int *incy)
blas::zgerc_	/usr/include/itpp/base/blas.h	/^  void zgerc_(const int *m, const int *n,$/;"	p	signature:(const int *m, const int *n, const std::complex<double> *alpha, const std::complex<double> *x, const int *inxx, const std::complex<double> *y, const int *incy, std::complex<double> *A, const int *ldA)
blas::zgeru_	/usr/include/itpp/base/blas.h	/^  void zgeru_(const int *m, const int *n,$/;"	p	signature:(const int *m, const int *n, const std::complex<double> *alpha, const std::complex<double> *x, const int *inxx, const std::complex<double> *y, const int *incy, std::complex<double> *A, const int *ldA)
blas::zscal_	/usr/include/itpp/base/blas.h	/^  void zscal_(const int *n,$/;"	p	signature:(const int *n, const std::complex<double> *alpha, std::complex<double> *x, const int *incx)
blas::zswap_	/usr/include/itpp/base/blas.h	/^  void zswap_(const int *n,$/;"	p	signature:(const int *n, std::complex<double> *x, const int *incx, std::complex<double> *y, const int *incy)
blksize	/usr/include/itpp/signal/freq_filt.h	/^  int fftsize, blksize;$/;"	m	class:itpp::Freq_Filt	access:private
block_bytes	/usr/include/itpp/base/itfile.h	/^    uint32_t hdr_bytes, data_bytes, block_bytes;$/;"	m	struct:itpp::it_file_base_old::data_header	access:public
block_bytes	/usr/include/itpp/base/itfile.h	/^    uint64_t block_bytes;$/;"	m	struct:itpp::it_file_base::data_header	access:public
block_rate_loop	/usr/include/itpp/protocol/packet_channel.h	/^  void block_rate_loop();$/;"	p	class:itpp::Packet_Channel	access:private	signature:()
block_time	/usr/include/itpp/protocol/packet_channel.h	/^  double block_time;$/;"	m	class:itpp::Packet_Channel	access:private
blocksize	/usr/include/itpp/comm/error_counters.h	/^  int blocksize;$/;"	m	class:itpp::BLERC	access:private
bmat	/usr/include/itpp/base/mat.h	/^typedef Mat<bin> bmat;$/;"	t	namespace:itpp
bmat2mxArray	/usr/include/itpp/itmex.h	/^void bmat2mxArray(const bmat &in, mxArray *out)$/;"	f	namespace:itpp	signature:(const bmat &in, mxArray *out)
bmat2mxArray	/usr/include/itpp/itmex.h	/^void bmat2mxArray(const bmat &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const bmat &in, mxArray *out)
bofstream	/usr/include/itpp/base/binfile.h	/^  bofstream();$/;"	p	class:itpp::bofstream	access:public	signature:()
bofstream	/usr/include/itpp/base/binfile.h	/^  bofstream(const std::string& name, endian e = b_endian);$/;"	p	class:itpp::bofstream	access:public	signature:(const std::string& name, endian e = b_endian)
bofstream	/usr/include/itpp/base/binfile.h	/^class bofstream : public bfstream_base, public std::ofstream$/;"	c	namespace:itpp	inherits:bfstream_base,std::ofstream
bp_decode	/usr/include/itpp/comm/ldpc.h	/^  int bp_decode(const QLLRvec &LLRin, QLLRvec &LLRout);$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const QLLRvec &LLRin, QLLRvec &LLRout)
buffer_overflow	/usr/include/itpp/protocol/selective_repeat.h	/^  Signal<int> buffer_overflow;           \/\/!< Signals buffer overflows.$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:public
buffer_size	/usr/include/itpp/protocol/selective_repeat.h	/^  int buffer_size();$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:public	signature:()
buffered_non_outstanding	/usr/include/itpp/protocol/selective_repeat.h	/^  int buffered_non_outstanding();$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:()
bvec	/usr/include/itpp/base/vec.h	/^typedef Vec<bin> bvec;$/;"	t	namespace:itpp
bvec2mxArray	/usr/include/itpp/itmex.h	/^void bvec2mxArray(const bvec &in, mxArray *out)$/;"	f	namespace:itpp	signature:(const bvec &in, mxArray *out)
bvec2mxArray	/usr/include/itpp/itmex.h	/^void bvec2mxArray(const bvec &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const bvec &in, mxArray *out)
bvecify	/usr/include/itpp/base/gf2mat.h	/^  bvec bvecify() const;$/;"	p	class:itpp::GF2mat	access:public	signature:() const
byte_size	/usr/include/itpp/protocol/front_drop_queue.h	/^  int byte_size() { return bytes_in_queue; }$/;"	f	class:itpp::Front_Drop_Queue	access:public	signature:()
bytes_in_queue	/usr/include/itpp/protocol/front_drop_queue.h	/^  int bytes_in_queue;$/;"	m	class:itpp::Front_Drop_Queue	access:private
c1	/usr/include/itpp/comm/channel.h	/^  vec f1, f2, c1, c2, th1, th2;$/;"	m	class:itpp::Rice_Fading_Generator	access:protected
c2	/usr/include/itpp/comm/channel.h	/^  vec f1, f2, c1, c2, th1, th2;$/;"	m	class:itpp::Rice_Fading_Generator	access:protected
c_X	/usr/include/itpp/stat/mog_diag_em.h	/^  double ** c_X;$/;"	m	class:itpp::MOG_diag_EM_sup	access:protected
c_X	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  double ** c_X;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:protected
c_acc_covs	/usr/include/itpp/stat/mog_diag_em.h	/^  double ** c_acc_covs;$/;"	m	class:itpp::MOG_diag_EM_sup	access:private
c_acc_loglhood_K	/usr/include/itpp/stat/mog_diag_em.h	/^  double * c_acc_loglhood_K;$/;"	m	class:itpp::MOG_diag_EM_sup	access:private
c_acc_means	/usr/include/itpp/stat/mog_diag_em.h	/^  double ** c_acc_means;$/;"	m	class:itpp::MOG_diag_EM_sup	access:private
c_count	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  int * c_count;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:protected
c_diag_covs	/usr/include/itpp/stat/mog_diag.h	/^  double ** c_diag_covs;$/;"	m	class:itpp::MOG_diag	access:protected
c_diag_covs_inv_etc	/usr/include/itpp/stat/mog_diag.h	/^  double ** c_diag_covs_inv_etc;$/;"	m	class:itpp::MOG_diag	access:protected
c_log_det_etc	/usr/include/itpp/stat/mog_diag.h	/^  double * c_log_det_etc;$/;"	m	class:itpp::MOG_diag	access:protected
c_log_weights	/usr/include/itpp/stat/mog_diag.h	/^  double * c_log_weights;$/;"	m	class:itpp::MOG_diag	access:protected
c_means	/usr/include/itpp/stat/mog_diag.h	/^  double ** c_means;$/;"	m	class:itpp::MOG_diag	access:protected
c_means_old	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  double ** c_means_old;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:protected
c_norm_mu	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  double * c_norm_mu;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:private
c_norm_sd	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  double * c_norm_sd;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:private
c_partitions	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  int ** c_partitions;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:protected
c_tmpvec	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  double * c_tmpvec;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:private
c_tmpvecD	/usr/include/itpp/stat/mog_diag_em.h	/^  double * c_tmpvecD;$/;"	m	class:itpp::MOG_diag_EM_sup	access:private
c_tmpvecK	/usr/include/itpp/stat/mog_diag.h	/^  double * c_tmpvecK;$/;"	m	class:itpp::MOG_diag	access:private
c_tmpvecK	/usr/include/itpp/stat/mog_diag_em.h	/^  double * c_tmpvecK;$/;"	m	class:itpp::MOG_diag_EM_sup	access:private
c_weights	/usr/include/itpp/stat/mog_diag.h	/^  double * c_weights;$/;"	m	class:itpp::MOG_diag	access:protected
calc_covs	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  void calc_covs();$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:protected	signature:()
calc_frequency_response	/usr/include/itpp/comm/channel.h	/^  void calc_frequency_response(const Array<cvec> &channel_coeff, Array<cvec> &frequency_response, const int fft_size);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const Array<cvec> &channel_coeff, Array<cvec> &frequency_response, const int fft_size)
calc_frequency_response	/usr/include/itpp/comm/channel.h	/^  void calc_frequency_response(const cmat &channel_coeff, cmat &frequency_response, const int fft_size);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cmat &channel_coeff, cmat &frequency_response, const int fft_size)
calc_impulse_response	/usr/include/itpp/comm/channel.h	/^  void calc_impulse_response(const Array<cvec> &channel_coeff, Array<cvec> &impulse_response);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const Array<cvec> &channel_coeff, Array<cvec> &impulse_response)
calc_mean_excess_delay	/usr/include/itpp/comm/channel.h	/^  double calc_mean_excess_delay() const;$/;"	p	class:itpp::Channel_Specification	access:public	signature:() const
calc_mean_excess_delay	/usr/include/itpp/comm/channel.h	/^  double calc_mean_excess_delay() const;$/;"	p	class:itpp::TDL_Channel	access:public	signature:() const
calc_means	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  void calc_means();$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:protected	signature:()
calc_metric	/usr/include/itpp/comm/convcode.h	/^  void calc_metric(const vec &rx_codeword, vec &delta_metrics);$/;"	p	class:itpp::Convolutional_Code	access:protected	signature:(const vec &rx_codeword, vec &delta_metrics)
calc_metric_reverse	/usr/include/itpp/comm/convcode.h	/^  void calc_metric_reverse(const int state, const vec &rx_codeword,$/;"	p	class:itpp::Convolutional_Code	access:protected	signature:(const int state, const vec &rx_codeword, double &zero_metric, double &one_metric)
calc_rms_delay_spread	/usr/include/itpp/comm/channel.h	/^  double calc_rms_delay_spread() const;$/;"	p	class:itpp::Channel_Specification	access:public	signature:() const
calc_rms_delay_spread	/usr/include/itpp/comm/channel.h	/^  double calc_rms_delay_spread() const;$/;"	p	class:itpp::TDL_Channel	access:public	signature:() const
calc_state_transition	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  int calc_state_transition(const int instate, const int input, ivec &parity);$/;"	p	class:itpp::Rec_Syst_Conv_Code	access:private	signature:(const int instate, const int input, ivec &parity)
calc_weights	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  void calc_weights();$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:protected	signature:()
calculate_base_matrix	/usr/include/itpp/comm/ldpc.h	/^  void calculate_base_matrix();$/;"	p	class:itpp::BLDPC_Parity	access:private	signature:()
calculate_softbit_matrices	/usr/include/itpp/comm/modulator.h	/^  void calculate_softbit_matrices();$/;"	p	class:itpp::Modulator	access:protected	signature:()
calculate_softbit_matrices	/usr/include/itpp/comm/modulator.h	/^void Modulator<T>::calculate_softbit_matrices()$/;"	f	class:itpp::Modulator	signature:()
calculate_spectrum	/usr/include/itpp/comm/convcode.h	/^  void calculate_spectrum(Array<ivec> &spectrum, int dmax, int no_terms);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(Array<ivec> &spectrum, int dmax, int no_terms)
calculate_spectrum	/usr/include/itpp/comm/punct_convcode.h	/^  void calculate_spectrum(Array<ivec> &spectrum, int dmax, int no_terms);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(Array<ivec> &spectrum, int dmax, int no_terms)
calculate_spectrum	/usr/include/itpp/comm/punct_convcode.h	/^  void calculate_spectrum(Array<ivec> &spectrum, int time, int dmax, int no_terms, int block_length = 0);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(Array<ivec> &spectrum, int time, int dmax, int no_terms, int block_length = 0)
can_be_combined	/usr/include/itpp/protocol/tcp.h	/^  bool can_be_combined(const TCP_Segment &segment) const;$/;"	p	class:itpp::TCP_Segment	access:public	signature:(const TCP_Segment &segment) const
can_be_combined	/usr/include/itpp/protocol/tcp.h	/^inline bool TCP_Segment::can_be_combined(const TCP_Segment &segment) const$/;"	f	class:itpp::TCP_Segment	signature:(const TCP_Segment &segment) const
cancel	/usr/include/itpp/protocol/events.h	/^  void cancel() { active = false; }$/;"	f	class:itpp::Base_Event	access:public	signature:()
cancel	/usr/include/itpp/protocol/signals_slots.h	/^  void cancel() { time_out_signal->cancel(); }$/;"	f	class:itpp::ATimer	access:public	signature:()
cancel	/usr/include/itpp/protocol/signals_slots.h	/^  void cancel();$/;"	p	class:itpp::Signal	access:public	signature:()
cancel	/usr/include/itpp/protocol/signals_slots.h	/^void Signal<DataType>::cancel()$/;"	f	class:itpp::Signal	signature:()
cancel_output	/usr/include/itpp/protocol/selective_repeat.h	/^  void cancel_output(const int Sequence_number);$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:(const int Sequence_number)
catastrophic	/usr/include/itpp/comm/convcode.h	/^  bool catastrophic(void);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(void)
catastrophic	/usr/include/itpp/comm/punct_convcode.h	/^  bool catastrophic(void);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(void)
cbrt	/usr/include/itpp/base/math/elem_math.h	/^double cbrt(double x);$/;"	p	signature:(double x)
cc_method	/usr/include/itpp/comm/convcode.h	/^  CONVOLUTIONAL_CODE_METHOD cc_method;$/;"	m	class:itpp::Convolutional_Code	access:protected
ceil	/usr/include/itpp/base/converters.h	/^inline mat ceil(const mat &x) { return apply_function<double>(std::ceil, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
ceil	/usr/include/itpp/base/converters.h	/^inline vec ceil(const vec &x) { return apply_function<double>(std::ceil, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
ceil_i	/usr/include/itpp/base/converters.h	/^imat ceil_i(const mat &x);$/;"	p	namespace:itpp	signature:(const mat &x)
ceil_i	/usr/include/itpp/base/converters.h	/^inline int ceil_i(double x) { return static_cast<int>(std::ceil(x)); }$/;"	f	namespace:itpp	signature:(double x)
ceil_i	/usr/include/itpp/base/converters.h	/^ivec ceil_i(const vec &x);$/;"	p	namespace:itpp	signature:(const vec &x)
center_vals	/usr/include/itpp/stat/histogram.h	/^  Vec<Num_T> center_vals;$/;"	m	class:itpp::Histogram	access:private
cepstrum2poly	/usr/include/itpp/srccode/lpcfunc.h	/^vec cepstrum2poly(const vec &c);$/;"	p	namespace:itpp	signature:(const vec &c)
cfixed1	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<1, TC, WRAP> cfixed1;$/;"	t	namespace:itpp
cfixed10	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<10, TC, WRAP> cfixed10;$/;"	t	namespace:itpp
cfixed11	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<11, TC, WRAP> cfixed11;$/;"	t	namespace:itpp
cfixed12	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<12, TC, WRAP> cfixed12;$/;"	t	namespace:itpp
cfixed13	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<13, TC, WRAP> cfixed13;$/;"	t	namespace:itpp
cfixed14	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<14, TC, WRAP> cfixed14;$/;"	t	namespace:itpp
cfixed15	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<15, TC, WRAP> cfixed15;$/;"	t	namespace:itpp
cfixed16	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<16, TC, WRAP> cfixed16;$/;"	t	namespace:itpp
cfixed17	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<17, TC, WRAP> cfixed17;$/;"	t	namespace:itpp
cfixed18	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<18, TC, WRAP> cfixed18;$/;"	t	namespace:itpp
cfixed19	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<19, TC, WRAP> cfixed19;$/;"	t	namespace:itpp
cfixed2	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<2, TC, WRAP> cfixed2;$/;"	t	namespace:itpp
cfixed20	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<20, TC, WRAP> cfixed20;$/;"	t	namespace:itpp
cfixed21	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<21, TC, WRAP> cfixed21;$/;"	t	namespace:itpp
cfixed22	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<22, TC, WRAP> cfixed22;$/;"	t	namespace:itpp
cfixed23	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<23, TC, WRAP> cfixed23;$/;"	t	namespace:itpp
cfixed24	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<24, TC, WRAP> cfixed24;$/;"	t	namespace:itpp
cfixed25	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<25, TC, WRAP> cfixed25;$/;"	t	namespace:itpp
cfixed26	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<26, TC, WRAP> cfixed26;$/;"	t	namespace:itpp
cfixed27	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<27, TC, WRAP> cfixed27;$/;"	t	namespace:itpp
cfixed28	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<28, TC, WRAP> cfixed28;$/;"	t	namespace:itpp
cfixed29	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<29, TC, WRAP> cfixed29;$/;"	t	namespace:itpp
cfixed3	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<3, TC, WRAP> cfixed3;$/;"	t	namespace:itpp
cfixed30	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<30, TC, WRAP> cfixed30;$/;"	t	namespace:itpp
cfixed31	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<31, TC, WRAP> cfixed31;$/;"	t	namespace:itpp
cfixed32	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<32, TC, WRAP> cfixed32;$/;"	t	namespace:itpp
cfixed33	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<33, TC, WRAP> cfixed33;$/;"	t	namespace:itpp
cfixed34	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<34, TC, WRAP> cfixed34;$/;"	t	namespace:itpp
cfixed35	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<35, TC, WRAP> cfixed35;$/;"	t	namespace:itpp
cfixed36	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<36, TC, WRAP> cfixed36;$/;"	t	namespace:itpp
cfixed37	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<37, TC, WRAP> cfixed37;$/;"	t	namespace:itpp
cfixed38	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<38, TC, WRAP> cfixed38;$/;"	t	namespace:itpp
cfixed39	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<39, TC, WRAP> cfixed39;$/;"	t	namespace:itpp
cfixed4	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<4, TC, WRAP> cfixed4;$/;"	t	namespace:itpp
cfixed40	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<40, TC, WRAP> cfixed40;$/;"	t	namespace:itpp
cfixed41	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<41, TC, WRAP> cfixed41;$/;"	t	namespace:itpp
cfixed42	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<42, TC, WRAP> cfixed42;$/;"	t	namespace:itpp
cfixed43	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<43, TC, WRAP> cfixed43;$/;"	t	namespace:itpp
cfixed44	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<44, TC, WRAP> cfixed44;$/;"	t	namespace:itpp
cfixed45	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<45, TC, WRAP> cfixed45;$/;"	t	namespace:itpp
cfixed46	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<46, TC, WRAP> cfixed46;$/;"	t	namespace:itpp
cfixed47	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<47, TC, WRAP> cfixed47;$/;"	t	namespace:itpp
cfixed48	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<48, TC, WRAP> cfixed48;$/;"	t	namespace:itpp
cfixed49	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<49, TC, WRAP> cfixed49;$/;"	t	namespace:itpp
cfixed5	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<5, TC, WRAP> cfixed5;$/;"	t	namespace:itpp
cfixed50	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<50, TC, WRAP> cfixed50;$/;"	t	namespace:itpp
cfixed51	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<51, TC, WRAP> cfixed51;$/;"	t	namespace:itpp
cfixed52	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<52, TC, WRAP> cfixed52;$/;"	t	namespace:itpp
cfixed53	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<53, TC, WRAP> cfixed53;$/;"	t	namespace:itpp
cfixed54	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<54, TC, WRAP> cfixed54;$/;"	t	namespace:itpp
cfixed55	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<55, TC, WRAP> cfixed55;$/;"	t	namespace:itpp
cfixed56	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<56, TC, WRAP> cfixed56;$/;"	t	namespace:itpp
cfixed57	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<57, TC, WRAP> cfixed57;$/;"	t	namespace:itpp
cfixed58	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<58, TC, WRAP> cfixed58;$/;"	t	namespace:itpp
cfixed59	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<59, TC, WRAP> cfixed59;$/;"	t	namespace:itpp
cfixed6	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<6, TC, WRAP> cfixed6;$/;"	t	namespace:itpp
cfixed60	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<60, TC, WRAP> cfixed60;$/;"	t	namespace:itpp
cfixed61	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<61, TC, WRAP> cfixed61;$/;"	t	namespace:itpp
cfixed62	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<62, TC, WRAP> cfixed62;$/;"	t	namespace:itpp
cfixed63	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<63, TC, WRAP> cfixed63;$/;"	t	namespace:itpp
cfixed64	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<64, TC, WRAP> cfixed64;$/;"	t	namespace:itpp
cfixed7	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<7, TC, WRAP> cfixed7;$/;"	t	namespace:itpp
cfixed8	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<8, TC, WRAP> cfixed8;$/;"	t	namespace:itpp
cfixed9	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<9, TC, WRAP> cfixed9;$/;"	t	namespace:itpp
cfixmat	/usr/include/itpp/fixed/cfix.h	/^typedef Mat<CFix> cfixmat;$/;"	t	namespace:itpp
cfixvec	/usr/include/itpp/fixed/cfix.h	/^typedef Vec<CFix> cfixvec;$/;"	t	namespace:itpp
channels	/usr/include/itpp/srccode/audiofile.h	/^    unsigned channels;$/;"	m	struct:itpp::SND_Format::__anon1	access:public
channels	/usr/include/itpp/srccode/audiofile.h	/^  int channels() const { return header.channels; }$/;"	f	class:itpp::SND_Format	access:public	signature:() const
check_array_uniformity	/usr/include/itpp/stat/mog_generic.h	/^  bool check_array_uniformity(const Array<vec> & A) const;$/;"	p	class:itpp::MOG_generic	access:protected	signature:(const Array<vec> & A) const
check_big_endianness	/usr/include/itpp/base/math/misc.h	/^bool check_big_endianness();$/;"	p	namespace:itpp	signature:()
check_connectivity	/usr/include/itpp/comm/ldpc.h	/^  int check_connectivity(int from_m, int from_n, int to_m, int to_n,$/;"	p	class:itpp::LDPC_Parity	access:protected	signature:(int from_m, int from_n, int to_m, int to_n, int g, int L) const
check_for_cycles	/usr/include/itpp/comm/ldpc.h	/^  int check_for_cycles(int L) const;$/;"	p	class:itpp::LDPC_Parity	access:protected	signature:(int L) const
check_parity	/usr/include/itpp/comm/crc.h	/^  bool check_parity(const bvec &coded_bits) const;$/;"	p	class:itpp::CRC_Code	access:public	signature:(const bvec &coded_bits) const
check_size	/usr/include/itpp/stat/mog_generic.h	/^  bool check_size(const Array<vec> &X_in) const;$/;"	p	class:itpp::MOG_generic	access:protected	signature:(const Array<vec> &X_in) const
check_size	/usr/include/itpp/stat/mog_generic.h	/^  bool check_size(const vec &x_in) const;$/;"	p	class:itpp::MOG_generic	access:protected	signature:(const vec &x_in) const
check_small_elems_flag	/usr/include/itpp/base/svec.h	/^  bool check_small_elems_flag;$/;"	m	class:itpp::Sparse_Vec	access:private
chirp	/usr/include/itpp/srccode/lpcfunc.h	/^vec chirp(const vec &a, double factor);$/;"	p	namespace:itpp	signature:(const vec &a, double factor)
chol	/usr/include/itpp/base/algebra/cholesky.h	/^bool chol(const cmat &X, cmat &F);$/;"	p	namespace:itpp	signature:(const cmat &X, cmat &F)
chol	/usr/include/itpp/base/algebra/cholesky.h	/^bool chol(const mat &X, mat &F);$/;"	p	namespace:itpp	signature:(const mat &X, mat &F)
chol	/usr/include/itpp/base/algebra/cholesky.h	/^cmat chol(const cmat &X);$/;"	p	namespace:itpp	signature:(const cmat &X)
chol	/usr/include/itpp/base/algebra/cholesky.h	/^mat chol(const mat &X);$/;"	p	namespace:itpp	signature:(const mat &X)
cleanup	/usr/include/itpp/stat/mog_diag.h	/^  void cleanup() { free_all_ptrs(); MOG_generic::cleanup(); }$/;"	f	class:itpp::MOG_diag	access:public	signature:()
cleanup	/usr/include/itpp/stat/mog_generic.h	/^  virtual void cleanup();$/;"	p	class:itpp::MOG_generic	access:public	signature:()
clear	/usr/include/itpp/base/circular_buffer.h	/^  void clear();$/;"	p	class:itpp::Circular_Buffer	access:public	signature:()
clear	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::clear()$/;"	f	class:itpp::Circular_Buffer	signature:()
clear	/usr/include/itpp/base/mat.h	/^  void clear() { zeros(); }$/;"	f	class:itpp::Mat	access:public	signature:()
clear	/usr/include/itpp/base/smat.h	/^  void clear();$/;"	p	class:itpp::Sparse_Mat	access:public	signature:()
clear	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::clear()$/;"	f	class:itpp::Sparse_Mat	signature:()
clear	/usr/include/itpp/base/stack.h	/^  void clear();$/;"	p	class:itpp::Stack	access:public	signature:()
clear	/usr/include/itpp/base/stack.h	/^void Stack<T>::clear()$/;"	f	class:itpp::Stack	signature:()
clear	/usr/include/itpp/base/svec.h	/^  void clear();$/;"	p	class:itpp::Sparse_Vec	access:public	signature:()
clear	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::clear()$/;"	f	class:itpp::Sparse_Vec	signature:()
clear	/usr/include/itpp/base/vec.h	/^  void clear() { zeros(); }$/;"	f	class:itpp::Vec	access:public	signature:()
clear	/usr/include/itpp/comm/error_counters.h	/^  void clear() { errors = 0; corrects = 0; }$/;"	f	class:itpp::BERC	access:public	signature:()
clear	/usr/include/itpp/comm/error_counters.h	/^  void clear() { errors = 0; corrects = 0; }$/;"	f	class:itpp::BLERC	access:public	signature:()
clear	/usr/include/itpp/comm/galois.h	/^  void clear();$/;"	p	class:itpp::GFX	access:public	signature:()
clear	/usr/include/itpp/comm/galois.h	/^inline void GFX::clear()$/;"	f	class:itpp::GFX	signature:()
clear	/usr/include/itpp/comm/pulse_shape.h	/^  void clear(void);$/;"	p	class:itpp::Pulse_Shape	access:public	signature:(void)
clear	/usr/include/itpp/comm/pulse_shape.h	/^void Pulse_Shape<T1, T2, T3>::clear(void)$/;"	f	class:itpp::Pulse_Shape	signature:(void)
clear	/usr/include/itpp/protocol/events.h	/^  static void clear();$/;"	p	class:itpp::Event_Queue	access:public	signature:()
clear	/usr/include/itpp/signal/filter.h	/^  void clear() { mem.clear(); }$/;"	f	class:itpp::ARMA_Filter	access:public	signature:()
clear	/usr/include/itpp/signal/filter.h	/^  void clear() { mem.clear(); }$/;"	f	class:itpp::AR_Filter	access:public	signature:()
clear	/usr/include/itpp/signal/filter.h	/^  void clear() { mem.clear(); }$/;"	f	class:itpp::MA_Filter	access:public	signature:()
clear	/usr/include/itpp/srccode/gmm.h	/^  void clear();$/;"	p	class:itpp::GMM	access:public	signature:()
clear	/usr/include/itpp/stat/misc_stat.h	/^  virtual void clear() {$/;"	f	class:itpp::Stat	access:public	signature:()
clear_elem	/usr/include/itpp/base/smat.h	/^  void clear_elem(const int r, const int c);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const int r, const int c)
clear_elem	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::clear_elem(const int r, const int c)$/;"	f	class:itpp::Sparse_Mat	signature:(const int r, const int c)
clear_elem	/usr/include/itpp/base/svec.h	/^  void clear_elem(const int i);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const int i)
clear_elem	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::clear_elem(const int i)$/;"	f	class:itpp::Sparse_Vec	signature:(const int i)
clone	/usr/include/itpp/protocol/tcp.h	/^  virtual TCP_Packet &clone() const;$/;"	p	class:itpp::TCP_Packet	access:public	signature:() const
close	/usr/include/itpp/base/itfile.h	/^  virtual void close();$/;"	p	class:itpp::it_ifile	access:public	signature:()
close	/usr/include/itpp/base/itfile.h	/^  virtual void close();$/;"	p	class:itpp::it_ifile_old	access:public	signature:()
close	/usr/include/itpp/base/itfile.h	/^  void close();$/;"	p	class:itpp::it_file	access:public	signature:()
close	/usr/include/itpp/base/itfile.h	/^  void close();$/;"	p	class:itpp::it_file_old	access:public	signature:()
close	/usr/include/itpp/srccode/audiofile.h	/^  virtual void close();$/;"	p	class:itpp::SND_IO_File	access:public	signature:()
close	/usr/include/itpp/srccode/audiofile.h	/^  virtual void close();$/;"	p	class:itpp::SND_In_File	access:public	signature:()
close	/usr/include/itpp/srccode/audiofile.h	/^  virtual void close();$/;"	p	class:itpp::SND_Out_File	access:public	signature:()
cmat	/usr/include/itpp/base/mat.h	/^typedef Mat<std::complex<double> > cmat;$/;"	t	namespace:itpp
cmat2mxArray	/usr/include/itpp/itmex.h	/^void cmat2mxArray(const cmat &in, mxArray *out)$/;"	f	namespace:itpp	signature:(const cmat &in, mxArray *out)
cmat2mxArray	/usr/include/itpp/itmex.h	/^void cmat2mxArray(const cmat &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const cmat &in, mxArray *out)
code	/usr/include/itpp/comm/spread.h	/^  vec code;$/;"	m	class:itpp::Spread_1d	access:protected
codes	/usr/include/itpp/comm/spread.h	/^  mat codes;$/;"	m	class:itpp::Multicode_Spread_1d	access:protected
coeffs	/usr/include/itpp/comm/galois.h	/^  Array<GF> coeffs;$/;"	m	class:itpp::GFX	access:private
coeffs	/usr/include/itpp/signal/filter.h	/^  Vec<T2> coeffs;$/;"	m	class:itpp::AR_Filter	access:private
coeffs	/usr/include/itpp/signal/filter.h	/^  Vec<T2> coeffs;$/;"	m	class:itpp::MA_Filter	access:private
col	/usr/include/itpp/base/smat.h	/^  Sparse_Vec<T> *col;$/;"	m	class:itpp::Sparse_Mat	access:private
col_in_range	/usr/include/itpp/base/mat.h	/^  bool col_in_range(int c) const { return ((c >= 0) && (c < no_cols)); }$/;"	f	class:itpp::Mat	access:private	signature:(int c) const
cols	/usr/include/itpp/base/gf2mat.h	/^  int cols() const { return ncols; }$/;"	f	class:itpp::GF2mat	access:public	signature:() const
cols	/usr/include/itpp/base/mat.h	/^  int cols() const { return no_cols; }$/;"	f	class:itpp::Mat	access:public	signature:() const
cols	/usr/include/itpp/base/smat.h	/^  int cols() const { return n_cols; }$/;"	f	class:itpp::Sparse_Mat	access:public	signature:() const
cols	/usr/include/itpp/comm/interleave.h	/^  int rows, cols, input_length;$/;"	m	class:itpp::Block_Interleaver	access:private
combine	/usr/include/itpp/protocol/tcp.h	/^  void combine(const TCP_Segment &segment);$/;"	p	class:itpp::TCP_Segment	access:public	signature:(const TCP_Segment &segment)
compact	/usr/include/itpp/base/smat.h	/^  void compact();$/;"	p	class:itpp::Sparse_Mat	access:public	signature:()
compact	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::compact()$/;"	f	class:itpp::Sparse_Mat	signature:()
compact	/usr/include/itpp/base/svec.h	/^  void compact();$/;"	p	class:itpp::Sparse_Vec	access:public	signature:()
compact	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::compact()$/;"	f	class:itpp::Sparse_Vec	signature:()
compare_spectra	/usr/include/itpp/comm/convcode.h	/^int compare_spectra(ivec v1, ivec v2);$/;"	p	namespace:itpp	signature:(ivec v1, ivec v2)
compare_spectra	/usr/include/itpp/comm/convcode.h	/^int compare_spectra(ivec v1, ivec v2, vec weight_profile);$/;"	p	namespace:itpp	signature:(ivec v1, ivec v2, vec weight_profile)
compute_CR	/usr/include/itpp/comm/ldpc.h	/^  void compute_CR(const vec& var_deg, const vec& chk_deg, const int Nvar,$/;"	p	class:itpp::LDPC_Parity_Unstructured	access:protected	signature:(const vec& var_deg, const vec& chk_deg, const int Nvar, ivec &C, ivec &R)
compute_internals	/usr/include/itpp/srccode/gmm.h	/^  void  compute_internals();$/;"	p	class:itpp::GMM	access:private	signature:()
concat	/usr/include/itpp/base/array.h	/^  friend const Array<T> concat <>(const Array<T> &a1, const Array<T> &a2);$/;"	p	class:itpp::Array	access:friend	signature:(const Array<T> &a1, const Array<T> &a2)
concat	/usr/include/itpp/base/array.h	/^  friend const Array<T> concat <>(const Array<T> &a1, const Array<T> &a2,$/;"	p	class:itpp::Array	access:friend	signature:(const Array<T> &a1, const Array<T> &a2, const Array<T> &a3)
concat	/usr/include/itpp/base/array.h	/^  friend const Array<T> concat <>(const Array<T> &a1, const T e);$/;"	p	class:itpp::Array	access:friend	signature:(const Array<T> &a1, const T e)
concat	/usr/include/itpp/base/array.h	/^  friend const Array<T> concat <>(const T e, const Array<T> &a);$/;"	p	class:itpp::Array	access:friend	signature:(const T e, const Array<T> &a)
concat	/usr/include/itpp/base/array.h	/^const Array<T> concat(const Array<T> &a, const T e)$/;"	f	namespace:itpp	signature:(const Array<T> &a, const T e)
concat	/usr/include/itpp/base/array.h	/^const Array<T> concat(const Array<T> &a1, const Array<T> &a2)$/;"	f	namespace:itpp	signature:(const Array<T> &a1, const Array<T> &a2)
concat	/usr/include/itpp/base/array.h	/^const Array<T> concat(const Array<T> &a1, const Array<T> &a2,$/;"	f	namespace:itpp	signature:(const Array<T> &a1, const Array<T> &a2, const Array<T> &a3)
concat	/usr/include/itpp/base/array.h	/^const Array<T> concat(const T e, const Array<T> &a)$/;"	f	namespace:itpp	signature:(const T e, const Array<T> &a)
concat	/usr/include/itpp/base/array.h	/^template<class T> const Array<T> concat(const Array<T> &a, const T e);$/;"	p	namespace:itpp	signature:(const Array<T> &a, const T e)
concat	/usr/include/itpp/base/array.h	/^template<class T> const Array<T> concat(const Array<T> &a1,$/;"	p	namespace:itpp	signature:(const Array<T> &a1, const Array<T> &a2)
concat	/usr/include/itpp/base/array.h	/^template<class T> const Array<T> concat(const Array<T> &a1,$/;"	p	namespace:itpp	signature:(const Array<T> &a1, const Array<T> &a2, const Array<T> &a3)
concat	/usr/include/itpp/base/array.h	/^template<class T> const Array<T> concat(const T e, const Array<T> &a);$/;"	p	namespace:itpp	signature:(const T e, const Array<T> &a)
concat	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> concat<>(Num_T t, const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:friend	signature:(Num_T t, const Vec<Num_T> &v)
concat	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> concat<>(const Vec<Num_T> &v, Num_T t);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v, Num_T t)
concat	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> concat<>(const Vec<Num_T> &v1, const Vec<Num_T> &v2);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
concat	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> concat<>(const Vec<Num_T> &v1, const Vec<Num_T> &v2,$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2, const Vec<Num_T> &v3)
concat	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> concat<>(const Vec<Num_T> &v1, const Vec<Num_T> &v2,$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2, const Vec<Num_T> &v3, const Vec<Num_T> &v4)
concat	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> concat<>(const Vec<Num_T> &v1, const Vec<Num_T> &v2,$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2, const Vec<Num_T> &v3, const Vec<Num_T> &v4, const Vec<Num_T> &v5)
concat	/usr/include/itpp/base/vec.h	/^Vec<Num_T> concat(Num_T a, const Vec<Num_T> &v);$/;"	p	namespace:itpp	signature:(Num_T a, const Vec<Num_T> &v)
concat	/usr/include/itpp/base/vec.h	/^Vec<Num_T> concat(Num_T t, const Vec<Num_T> &v)$/;"	f	namespace:itpp	signature:(Num_T t, const Vec<Num_T> &v)
concat	/usr/include/itpp/base/vec.h	/^Vec<Num_T> concat(const Vec<Num_T> &v, Num_T a);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v, Num_T a)
concat	/usr/include/itpp/base/vec.h	/^Vec<Num_T> concat(const Vec<Num_T> &v, Num_T t)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v, Num_T t)
concat	/usr/include/itpp/base/vec.h	/^Vec<Num_T> concat(const Vec<Num_T> &v1, const Vec<Num_T> &v2)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
concat	/usr/include/itpp/base/vec.h	/^Vec<Num_T> concat(const Vec<Num_T> &v1, const Vec<Num_T> &v2);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
concat	/usr/include/itpp/base/vec.h	/^Vec<Num_T> concat(const Vec<Num_T> &v1, const Vec<Num_T> &v2,$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2, const Vec<Num_T> &v3)
concat	/usr/include/itpp/base/vec.h	/^Vec<Num_T> concat(const Vec<Num_T> &v1, const Vec<Num_T> &v2,$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2, const Vec<Num_T> &v3, const Vec<Num_T> &v4)
concat	/usr/include/itpp/base/vec.h	/^Vec<Num_T> concat(const Vec<Num_T> &v1, const Vec<Num_T> &v2,$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2, const Vec<Num_T> &v3, const Vec<Num_T> &v4, const Vec<Num_T> &v5)
concat	/usr/include/itpp/base/vec.h	/^Vec<Num_T> concat(const Vec<Num_T> &v1, const Vec<Num_T> &v2,$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2, const Vec<Num_T> &v3)
concat	/usr/include/itpp/base/vec.h	/^Vec<Num_T> concat(const Vec<Num_T> &v1, const Vec<Num_T> &v2,$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2, const Vec<Num_T> &v3, const Vec<Num_T> &v4)
concat	/usr/include/itpp/base/vec.h	/^Vec<Num_T> concat(const Vec<Num_T> &v1, const Vec<Num_T> &v2,$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2, const Vec<Num_T> &v3, const Vec<Num_T> &v4, const Vec<Num_T> &v5)
concat	/usr/include/itpp/base/vec.h	/^extern template bvec concat(bin a, const bvec &v);$/;"	p	namespace:itpp	signature:(bin a, const bvec &v)
concat	/usr/include/itpp/base/vec.h	/^extern template bvec concat(const bvec &v, bin a);$/;"	p	namespace:itpp	signature:(const bvec &v, bin a)
concat	/usr/include/itpp/base/vec.h	/^extern template bvec concat(const bvec &v1, const bvec &v2);$/;"	p	namespace:itpp	signature:(const bvec &v1, const bvec &v2)
concat	/usr/include/itpp/base/vec.h	/^extern template bvec concat(const bvec &v1, const bvec &v2, const bvec &v3);$/;"	p	namespace:itpp	signature:(const bvec &v1, const bvec &v2, const bvec &v3)
concat	/usr/include/itpp/base/vec.h	/^extern template bvec concat(const bvec &v1, const bvec &v2, const bvec &v3,$/;"	p	namespace:itpp	signature:(const bvec &v1, const bvec &v2, const bvec &v3, const bvec &v4, const bvec &v5)
concat	/usr/include/itpp/base/vec.h	/^extern template bvec concat(const bvec &v1, const bvec &v2,$/;"	p	namespace:itpp	signature:(const bvec &v1, const bvec &v2, const bvec &v3, const bvec &v4)
concat	/usr/include/itpp/base/vec.h	/^extern template cvec concat(const cvec &v, std::complex<double> a);$/;"	p	namespace:itpp	signature:(const cvec &v, std::complex<double> a)
concat	/usr/include/itpp/base/vec.h	/^extern template cvec concat(const cvec &v1, const cvec &v2);$/;"	p	namespace:itpp	signature:(const cvec &v1, const cvec &v2)
concat	/usr/include/itpp/base/vec.h	/^extern template cvec concat(const cvec &v1, const cvec &v2, const cvec &v3);$/;"	p	namespace:itpp	signature:(const cvec &v1, const cvec &v2, const cvec &v3)
concat	/usr/include/itpp/base/vec.h	/^extern template cvec concat(const cvec &v1, const cvec &v2, const cvec &v3,$/;"	p	namespace:itpp	signature:(const cvec &v1, const cvec &v2, const cvec &v3, const cvec &v4, const cvec &v5)
concat	/usr/include/itpp/base/vec.h	/^extern template cvec concat(const cvec &v1, const cvec &v2,$/;"	p	namespace:itpp	signature:(const cvec &v1, const cvec &v2, const cvec &v3, const cvec &v4)
concat	/usr/include/itpp/base/vec.h	/^extern template cvec concat(std::complex<double> a, const cvec &v);$/;"	p	namespace:itpp	signature:(std::complex<double> a, const cvec &v)
concat	/usr/include/itpp/base/vec.h	/^extern template ivec concat(const ivec &v, int a);$/;"	p	namespace:itpp	signature:(const ivec &v, int a)
concat	/usr/include/itpp/base/vec.h	/^extern template ivec concat(const ivec &v1, const ivec &v2);$/;"	p	namespace:itpp	signature:(const ivec &v1, const ivec &v2)
concat	/usr/include/itpp/base/vec.h	/^extern template ivec concat(const ivec &v1, const ivec &v2, const ivec &v3);$/;"	p	namespace:itpp	signature:(const ivec &v1, const ivec &v2, const ivec &v3)
concat	/usr/include/itpp/base/vec.h	/^extern template ivec concat(const ivec &v1, const ivec &v2, const ivec &v3,$/;"	p	namespace:itpp	signature:(const ivec &v1, const ivec &v2, const ivec &v3, const ivec &v4, const ivec &v5)
concat	/usr/include/itpp/base/vec.h	/^extern template ivec concat(const ivec &v1, const ivec &v2,$/;"	p	namespace:itpp	signature:(const ivec &v1, const ivec &v2, const ivec &v3, const ivec &v4)
concat	/usr/include/itpp/base/vec.h	/^extern template ivec concat(int a, const ivec &v);$/;"	p	namespace:itpp	signature:(int a, const ivec &v)
concat	/usr/include/itpp/base/vec.h	/^extern template svec concat(const svec &v, short a);$/;"	p	namespace:itpp	signature:(const svec &v, short a)
concat	/usr/include/itpp/base/vec.h	/^extern template svec concat(const svec &v1, const svec &v2);$/;"	p	namespace:itpp	signature:(const svec &v1, const svec &v2)
concat	/usr/include/itpp/base/vec.h	/^extern template svec concat(const svec &v1, const svec &v2, const svec &v3);$/;"	p	namespace:itpp	signature:(const svec &v1, const svec &v2, const svec &v3)
concat	/usr/include/itpp/base/vec.h	/^extern template svec concat(const svec &v1, const svec &v2, const svec &v3,$/;"	p	namespace:itpp	signature:(const svec &v1, const svec &v2, const svec &v3, const svec &v4, const svec &v5)
concat	/usr/include/itpp/base/vec.h	/^extern template svec concat(const svec &v1, const svec &v2,$/;"	p	namespace:itpp	signature:(const svec &v1, const svec &v2, const svec &v3, const svec &v4)
concat	/usr/include/itpp/base/vec.h	/^extern template svec concat(short a, const svec &v);$/;"	p	namespace:itpp	signature:(short a, const svec &v)
concat	/usr/include/itpp/base/vec.h	/^extern template vec concat(const vec &v, double a);$/;"	p	namespace:itpp	signature:(const vec &v, double a)
concat	/usr/include/itpp/base/vec.h	/^extern template vec concat(const vec &v1, const vec &v2);$/;"	p	namespace:itpp	signature:(const vec &v1, const vec &v2)
concat	/usr/include/itpp/base/vec.h	/^extern template vec concat(const vec &v1, const vec &v2, const vec &v3);$/;"	p	namespace:itpp	signature:(const vec &v1, const vec &v2, const vec &v3)
concat	/usr/include/itpp/base/vec.h	/^extern template vec concat(const vec &v1, const vec &v2, const vec &v3,$/;"	p	namespace:itpp	signature:(const vec &v1, const vec &v2, const vec &v3, const vec &v4, const vec &v5)
concat	/usr/include/itpp/base/vec.h	/^extern template vec concat(const vec &v1, const vec &v2,$/;"	p	namespace:itpp	signature:(const vec &v1, const vec &v2, const vec &v3, const vec &v4)
concat	/usr/include/itpp/base/vec.h	/^extern template vec concat(double a, const vec &v);$/;"	p	namespace:itpp	signature:(double a, const vec &v)
concat_horizontal	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> concat_horizontal<>(const Mat<Num_T> &m1,$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
concat_horizontal	/usr/include/itpp/base/mat.h	/^Mat<Num_T> concat_horizontal(const Mat<Num_T> &m1, const Mat<Num_T> &m2)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
concat_horizontal	/usr/include/itpp/base/mat.h	/^Mat<Num_T> concat_horizontal(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
concat_horizontal	/usr/include/itpp/base/mat.h	/^extern template bmat concat_horizontal(const bmat &m1, const bmat &m2);$/;"	p	namespace:itpp	signature:(const bmat &m1, const bmat &m2)
concat_horizontal	/usr/include/itpp/base/mat.h	/^extern template cmat concat_horizontal(const cmat &m1, const cmat &m2);$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2)
concat_horizontal	/usr/include/itpp/base/mat.h	/^extern template imat concat_horizontal(const imat &m1, const imat &m2);$/;"	p	namespace:itpp	signature:(const imat &m1, const imat &m2)
concat_horizontal	/usr/include/itpp/base/mat.h	/^extern template mat concat_horizontal(const mat &m1, const mat &m2);$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2)
concat_horizontal	/usr/include/itpp/base/mat.h	/^extern template smat concat_horizontal(const smat &m1, const smat &m2);$/;"	p	namespace:itpp	signature:(const smat &m1, const smat &m2)
concat_vertical	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> concat_vertical<>(const Mat<Num_T> &m1,$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
concat_vertical	/usr/include/itpp/base/mat.h	/^Mat<Num_T> concat_vertical(const Mat<Num_T> &m1, const Mat<Num_T> &m2)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
concat_vertical	/usr/include/itpp/base/mat.h	/^Mat<Num_T> concat_vertical(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
concat_vertical	/usr/include/itpp/base/mat.h	/^extern template bmat concat_vertical(const bmat &m1, const bmat &m2);$/;"	p	namespace:itpp	signature:(const bmat &m1, const bmat &m2)
concat_vertical	/usr/include/itpp/base/mat.h	/^extern template cmat concat_vertical(const cmat &m1, const cmat &m2);$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2)
concat_vertical	/usr/include/itpp/base/mat.h	/^extern template imat concat_vertical(const imat &m1, const imat &m2);$/;"	p	namespace:itpp	signature:(const imat &m1, const imat &m2)
concat_vertical	/usr/include/itpp/base/mat.h	/^extern template mat concat_vertical(const mat &m1, const mat &m2);$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2)
concat_vertical	/usr/include/itpp/base/mat.h	/^extern template smat concat_vertical(const smat &m1, const smat &m2);$/;"	p	namespace:itpp	signature:(const smat &m1, const smat &m2)
concatenate_horizontal	/usr/include/itpp/base/gf2mat.h	/^  GF2mat concatenate_horizontal(const GF2mat &X) const;$/;"	p	class:itpp::GF2mat	access:public	signature:(const GF2mat &X) const
concatenate_vertical	/usr/include/itpp/base/gf2mat.h	/^  GF2mat concatenate_vertical(const GF2mat &X) const;$/;"	p	class:itpp::GF2mat	access:public	signature:(const GF2mat &X) const
conference	/usr/include/itpp/base/specmat.h	/^imat conference(int n);$/;"	p	namespace:itpp	signature:(int n)
conj	/usr/include/itpp/base/math/elem_math.h	/^cmat conj(const cmat &x);$/;"	p	namespace:itpp	signature:(const cmat &x)
conj	/usr/include/itpp/base/math/elem_math.h	/^cvec conj(const cvec &x);$/;"	p	namespace:itpp	signature:(const cvec &x)
conj	/usr/include/itpp/base/math/elem_math.h	/^inline cmat conj(const cmat &x)$/;"	f	namespace:itpp	signature:(const cmat &x)
conj	/usr/include/itpp/base/math/elem_math.h	/^inline cvec conj(const cvec &x)$/;"	f	namespace:itpp	signature:(const cvec &x)
conj	/usr/include/itpp/fixed/fix_functions.h	/^CFix conj(const CFix &x);$/;"	p	namespace:itpp	signature:(const CFix &x)
connect	/usr/include/itpp/protocol/signals_slots.h	/^  void connect(Base_Slot<DataType>* slot);$/;"	p	class:itpp::Signal	access:public	signature:(Base_Slot<DataType>* slot)
connect	/usr/include/itpp/protocol/signals_slots.h	/^void Signal<DataType>::connect(Base_Slot<DataType>* slot)$/;"	f	class:itpp::Signal	signature:(Base_Slot<DataType>* slot)
connected_signals	/usr/include/itpp/protocol/signals_slots.h	/^  std::list<Signal<DataType>*, std::allocator<Signal<DataType>* > > connected_signals;$/;"	m	class:itpp::Base_Slot	access:protected
connected_slots	/usr/include/itpp/protocol/signals_slots.h	/^  std::list<Base_Slot<DataType>*, std::allocator<Base_Slot<DataType>* > > connected_slots;$/;"	m	class:itpp::Signal	access:protected
construct	/usr/include/itpp/comm/ldpc.h	/^  ivec construct(LDPC_Parity* const H, bool natural_ordering = false,$/;"	p	class:itpp::LDPC_Generator_Systematic	access:public	signature:(LDPC_Parity* const H, bool natural_ordering = false, const ivec& ind = Ó)
construct	/usr/include/itpp/comm/ldpc.h	/^  void construct(const BLDPC_Parity* const H);$/;"	p	class:itpp::BLDPC_Generator	access:public	signature:(const BLDPC_Parity* const H)
construct_logexp_table	/usr/include/itpp/comm/llr.h	/^  ivec construct_logexp_table();$/;"	p	class:itpp::LLR_calc_unit	access:private	signature:()
convert_to_diag	/usr/include/itpp/stat/mog_generic.h	/^  virtual void convert_to_diag();$/;"	p	class:itpp::MOG_generic	access:public	signature:()
convert_to_diag_internal	/usr/include/itpp/stat/mog_generic.h	/^  void convert_to_diag_internal();$/;"	p	class:itpp::MOG_generic	access:protected	signature:()
convert_to_full	/usr/include/itpp/stat/mog_diag.h	/^  void convert_to_full() {};$/;"	f	class:itpp::MOG_diag	access:public	signature:()
convert_to_full	/usr/include/itpp/stat/mog_generic.h	/^  virtual void convert_to_full();$/;"	p	class:itpp::MOG_generic	access:public	signature:()
convert_to_full_internal	/usr/include/itpp/stat/mog_generic.h	/^  void convert_to_full_internal();$/;"	p	class:itpp::MOG_generic	access:protected	signature:()
copy_col	/usr/include/itpp/base/mat.h	/^  void copy_col(int to, int from);$/;"	p	class:itpp::Mat	access:public	signature:(int to, int from)
copy_col	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::copy_col(int to, int from)$/;"	f	class:itpp::Mat	signature:(int to, int from)
copy_row	/usr/include/itpp/base/mat.h	/^  void copy_row(int to, int from);$/;"	p	class:itpp::Mat	access:public	signature:(int to, int from)
copy_row	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::copy_row(int to, int from)$/;"	f	class:itpp::Mat	signature:(int to, int from)
copy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void copy_vector(const int n, const bin *x, bin *y) { memcpy(y, x, (unsigned int)n*sizeof(bin)); }$/;"	f	namespace:itpp	signature:(const int n, const bin *x, bin *y)
copy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void copy_vector(const int n, const double *x, const int incx,$/;"	f	namespace:itpp	signature:(const int n, const double *x, const int incx, double *y, const int incy)
copy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void copy_vector(const int n, const double *x, double *y) { memcpy(y, x, (unsigned int)n*sizeof(double)); }$/;"	f	namespace:itpp	signature:(const int n, const double *x, double *y)
copy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void copy_vector(const int n, const double *x, double *y)$/;"	f	namespace:itpp	signature:(const int n, const double *x, double *y)
copy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void copy_vector(const int n, const float *x, float *y) { memcpy(y, x, (unsigned int)n*sizeof(float)); }$/;"	f	namespace:itpp	signature:(const int n, const float *x, float *y)
copy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void copy_vector(const int n, const int *x, int *y) { memcpy(y, x, (unsigned int)n*sizeof(int)); }$/;"	f	namespace:itpp	signature:(const int n, const int *x, int *y)
copy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void copy_vector(const int n, const short *x, short *y) { memcpy(y, x, (unsigned int)n*sizeof(short)); }$/;"	f	namespace:itpp	signature:(const int n, const short *x, short *y)
copy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void copy_vector(const int n, const std::complex<double> *x, std::complex<double> *y) { memcpy(y, x, (unsigned int)n*sizeof(std::complex<double>)); }$/;"	f	namespace:itpp	signature:(const int n, const std::complex<double> *x, std::complex<double> *y)
copy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void copy_vector(const int n, const std::complex<double> *x,$/;"	f	namespace:itpp	signature:(const int n, const std::complex<double> *x, const int incx, std::complex<double> *y, const int incy)
copy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void copy_vector(const int n, const std::complex<double> *x,$/;"	f	namespace:itpp	signature:(const int n, const std::complex<double> *x, std::complex<double> *y)
copy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void copy_vector(const int n, const std::complex<float> *x, std::complex<float> *y) { memcpy(y, x, (unsigned int)n*sizeof(std::complex<float>)); }$/;"	f	namespace:itpp	signature:(const int n, const std::complex<float> *x, std::complex<float> *y)
copy_vector	/usr/include/itpp/base/copy_vector.h	/^void copy_vector(const int n, const T *x, T *y)$/;"	f	namespace:itpp	signature:(const int n, const T *x, T *y)
copy_vector	/usr/include/itpp/base/copy_vector.h	/^void copy_vector(const int n, const T *x, const int incx, T *y, const int incy)$/;"	f	namespace:itpp	signature:(const int n, const T *x, const int incx, T *y, const int incy)
corrects	/usr/include/itpp/comm/error_counters.h	/^  double corrects;$/;"	m	class:itpp::BERC	access:private
corrects	/usr/include/itpp/comm/error_counters.h	/^  double corrects;$/;"	m	class:itpp::BLERC	access:private
cos	/usr/include/itpp/base/math/trig_hyp.h	/^inline mat cos(const mat &x) { return apply_function<double>(std::cos, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
cos	/usr/include/itpp/base/math/trig_hyp.h	/^inline vec cos(const vec &x) { return apply_function<double>(std::cos, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
cosh	/usr/include/itpp/base/math/trig_hyp.h	/^inline mat cosh(const mat &x) { return apply_function<double>(std::cosh, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
cosh	/usr/include/itpp/base/math/trig_hyp.h	/^inline vec cosh(const vec &x) { return apply_function<double>(std::cosh, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
count	/usr/include/itpp/comm/error_counters.h	/^  void count(const bvec &in1, const bvec &in2);$/;"	p	class:itpp::BERC	access:public	signature:(const bvec &in1, const bvec &in2)
count	/usr/include/itpp/comm/error_counters.h	/^  void count(const bvec &in1, const bvec &in2);$/;"	p	class:itpp::BLERC	access:public	signature:(const bvec &in1, const bvec &in2)
count	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  ivec count;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:protected
count_errors	/usr/include/itpp/comm/error_counters.h	/^  static double count_errors(const bvec &in1, const bvec &in2,$/;"	p	class:itpp::BERC	access:public	signature:(const bvec &in1, const bvec &in2, int indelay = 0, int inignorefirst = 0, int inignorelast = 0)
cov	/usr/include/itpp/signal/sigfun.h	/^mat cov(const mat &X, bool is_zero_mean = false);$/;"	p	namespace:itpp	signature:(const mat &X, bool is_zero_mean = false)
create	/usr/include/itpp/fixed/fix_factory.h	/^  virtual void create(CFix* &ptr, const int n) const;$/;"	p	class:itpp::Fix_Factory	access:public	signature:(CFix* &ptr, const int n) const
create	/usr/include/itpp/fixed/fix_factory.h	/^  virtual void create(Fix* &ptr, const int n) const;$/;"	p	class:itpp::Fix_Factory	access:public	signature:(Fix* &ptr, const int n) const
create_elements	/usr/include/itpp/base/factory.h	/^void create_elements(Array<T>* &ptr, int n, const Factory &f)$/;"	f	namespace:itpp	signature:(Array<T>* &ptr, int n, const Factory &f)
create_elements	/usr/include/itpp/base/factory.h	/^void create_elements(Mat<T>* &ptr, int n, const Factory &f)$/;"	f	namespace:itpp	signature:(Mat<T>* &ptr, int n, const Factory &f)
create_elements	/usr/include/itpp/base/factory.h	/^void create_elements(T* &ptr, int n, const Factory &)$/;"	f	namespace:itpp	signature:(T* &ptr, int n, const Factory &)
create_elements	/usr/include/itpp/base/factory.h	/^void create_elements(Vec<T>* &ptr, int n, const Factory &f)$/;"	f	namespace:itpp	signature:(Vec<T>* &ptr, int n, const Factory &f)
create_elements	/usr/include/itpp/base/factory.h	/^void create_elements<bin>(bin* &ptr, int n, const Factory &)$/;"	f	namespace:itpp	signature:(bin* &ptr, int n, const Factory &)
create_elements	/usr/include/itpp/base/factory.h	/^void create_elements<double>(double* &ptr, int n, const Factory &)$/;"	f	namespace:itpp	signature:(double* &ptr, int n, const Factory &)
create_elements	/usr/include/itpp/base/factory.h	/^void create_elements<int>(int* &ptr, int n, const Factory &)$/;"	f	namespace:itpp	signature:(int* &ptr, int n, const Factory &)
create_elements	/usr/include/itpp/base/factory.h	/^void create_elements<short int>(short int* &ptr, int n, const Factory &)$/;"	f	namespace:itpp	signature:(short int* &ptr, int n, const Factory &)
create_elements	/usr/include/itpp/base/factory.h	/^void create_elements<std::complex<double> >(std::complex<double>* &ptr,$/;"	f	namespace:itpp	signature:(std::complex<double>* &ptr, int n, const Factory &)
create_elements	/usr/include/itpp/base/factory.h	/^void create_elements<unsigned char>(unsigned char* &ptr, int n,$/;"	f	namespace:itpp	signature:(unsigned char* &ptr, int n, const Factory &)
create_elements	/usr/include/itpp/fixed/fix_factory.h	/^void create_elements<CFix>(CFix* &ptr, const int n, const Factory &f);$/;"	p	namespace:itpp	signature:(CFix* &ptr, const int n, const Factory &f)
create_elements	/usr/include/itpp/fixed/fix_factory.h	/^void create_elements<Fix>(Fix* &ptr, const int n, const Factory &f);$/;"	p	namespace:itpp	signature:(Fix* &ptr, const int n, const Factory &f)
cross	/usr/include/itpp/base/matfunc.h	/^Vec<T> cross(const Vec<T> &v1, const Vec<T> &v2)$/;"	f	namespace:itpp	signature:(const Vec<T> &v1, const Vec<T> &v2)
cross	/usr/include/itpp/base/matfunc.h	/^extern template bvec cross(const bvec &v1, const bvec &v2);$/;"	p	namespace:itpp	signature:(const bvec &v1, const bvec &v2)
cross	/usr/include/itpp/base/matfunc.h	/^extern template cvec cross(const cvec &v1, const cvec &v2);$/;"	p	namespace:itpp	signature:(const cvec &v1, const cvec &v2)
cross	/usr/include/itpp/base/matfunc.h	/^extern template ivec cross(const ivec &v1, const ivec &v2);$/;"	p	namespace:itpp	signature:(const ivec &v1, const ivec &v2)
cross	/usr/include/itpp/base/matfunc.h	/^extern template svec cross(const svec &v1, const svec &v2);$/;"	p	namespace:itpp	signature:(const svec &v1, const svec &v2)
cross	/usr/include/itpp/base/matfunc.h	/^extern template vec cross(const vec &v1, const vec &v2);$/;"	p	namespace:itpp	signature:(const vec &v1, const vec &v2)
cumsum	/usr/include/itpp/base/matfunc.h	/^Mat<T> cumsum(const Mat<T> &m, int dim = 1)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, int dim = 1)
cumsum	/usr/include/itpp/base/matfunc.h	/^Vec<T> cumsum(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
cumsum	/usr/include/itpp/base/matfunc.h	/^extern template bmat cumsum(const bmat &m, int dim);$/;"	p	namespace:itpp	signature:(const bmat &m, int dim)
cumsum	/usr/include/itpp/base/matfunc.h	/^extern template bvec cumsum(const bvec &v);$/;"	p	namespace:itpp	signature:(const bvec &v)
cumsum	/usr/include/itpp/base/matfunc.h	/^extern template cmat cumsum(const cmat &m, int dim);$/;"	p	namespace:itpp	signature:(const cmat &m, int dim)
cumsum	/usr/include/itpp/base/matfunc.h	/^extern template cvec cumsum(const cvec &v);$/;"	p	namespace:itpp	signature:(const cvec &v)
cumsum	/usr/include/itpp/base/matfunc.h	/^extern template imat cumsum(const imat &m, int dim);$/;"	p	namespace:itpp	signature:(const imat &m, int dim)
cumsum	/usr/include/itpp/base/matfunc.h	/^extern template ivec cumsum(const ivec &v);$/;"	p	namespace:itpp	signature:(const ivec &v)
cumsum	/usr/include/itpp/base/matfunc.h	/^extern template mat cumsum(const mat &m, int dim);$/;"	p	namespace:itpp	signature:(const mat &m, int dim)
cumsum	/usr/include/itpp/base/matfunc.h	/^extern template smat cumsum(const smat &m, int dim);$/;"	p	namespace:itpp	signature:(const smat &m, int dim)
cumsum	/usr/include/itpp/base/matfunc.h	/^extern template svec cumsum(const svec &v);$/;"	p	namespace:itpp	signature:(const svec &v)
cumsum	/usr/include/itpp/base/matfunc.h	/^extern template vec cumsum(const vec &v);$/;"	p	namespace:itpp	signature:(const vec &v)
cvec	/usr/include/itpp/base/vec.h	/^typedef Vec<std::complex<double> > cvec;$/;"	t	namespace:itpp
cvec2mxArray	/usr/include/itpp/itmex.h	/^void cvec2mxArray(const cvec &in, mxArray *out)$/;"	f	namespace:itpp	signature:(const cvec &in, mxArray *out)
cvec2mxArray	/usr/include/itpp/itmex.h	/^void cvec2mxArray(const cvec &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const cvec &in, mxArray *out)
cvectorize	/usr/include/itpp/base/matfunc.h	/^Vec<T> cvectorize(const Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
cvectorize	/usr/include/itpp/base/matfunc.h	/^extern template bvec cvectorize(const bmat &m);$/;"	p	namespace:itpp	signature:(const bmat &m)
cvectorize	/usr/include/itpp/base/matfunc.h	/^extern template cvec cvectorize(const cmat &m);$/;"	p	namespace:itpp	signature:(const cmat &m)
cvectorize	/usr/include/itpp/base/matfunc.h	/^extern template ivec cvectorize(const imat &m);$/;"	p	namespace:itpp	signature:(const imat &m)
cvectorize	/usr/include/itpp/base/matfunc.h	/^extern template svec cvectorize(const smat &m);$/;"	p	namespace:itpp	signature:(const smat &m)
cvectorize	/usr/include/itpp/base/matfunc.h	/^extern template vec cvectorize(const mat &m);$/;"	p	namespace:itpp	signature:(const mat &m)
cycle_removal_MGW	/usr/include/itpp/comm/ldpc.h	/^  int cycle_removal_MGW(int L);$/;"	p	class:itpp::LDPC_Parity_Unstructured	access:public	signature:(int L)
d	/usr/include/itpp/srccode/gmm.h	/^  int   M, d;$/;"	m	class:itpp::GMM	access:protected
dB	/usr/include/itpp/base/math/log_exp.h	/^inline double dB(double x) { return 10.0 * log10(x); }$/;"	f	namespace:itpp	signature:(double x)
dB	/usr/include/itpp/base/math/log_exp.h	/^inline mat dB(const mat &x)$/;"	f	namespace:itpp	signature:(const mat &x)
dB	/usr/include/itpp/base/math/log_exp.h	/^inline vec dB(const vec &x)$/;"	f	namespace:itpp	signature:(const vec &x)
dF_values	/usr/include/itpp/optim/newton_search.h	/^  vec alpha_values, F_values, dF_values;$/;"	m	class:itpp::Line_Search	access:private
d_prof	/usr/include/itpp/comm/channel.h	/^  ivec d_prof; \/\/!< Delay in samples for each tap$/;"	m	class:itpp::TDL_Channel	access:protected
d_prof	/usr/include/itpp/comm/channel.h	/^  vec d_prof; \/\/!< Delay profile in seconds$/;"	m	class:itpp::Channel_Specification	access:protected
data	/usr/include/itpp/base/array.h	/^  T *data;$/;"	m	class:itpp::Array	access:protected
data	/usr/include/itpp/base/gf2mat.h	/^  Mat<unsigned char> data;   \/\/ data structure$/;"	m	class:itpp::GF2mat	access:private
data	/usr/include/itpp/base/mat.h	/^  Num_T *data;$/;"	m	class:itpp::Mat	access:protected
data	/usr/include/itpp/base/stack.h	/^  T *data;$/;"	m	class:itpp::Stack	access:private
data	/usr/include/itpp/base/svec.h	/^  T *data;$/;"	m	class:itpp::Sparse_Vec	access:private
data	/usr/include/itpp/base/vec.h	/^  Num_T *data;$/;"	m	class:itpp::Vec	access:protected
data_bytes	/usr/include/itpp/base/itfile.h	/^    uint32_t hdr_bytes, data_bytes, block_bytes;$/;"	m	struct:itpp::it_file_base_old::data_header	access:public
data_bytes	/usr/include/itpp/base/itfile.h	/^    uint64_t data_bytes;$/;"	m	struct:itpp::it_file_base::data_header	access:public
data_encoding	/usr/include/itpp/srccode/audiofile.h	/^  enum data_encoding { enc_unknown  =  0,$/;"	g	class:itpp::SND_Format	access:public
data_header	/usr/include/itpp/base/itfile.h	/^  struct data_header {$/;"	s	class:itpp::it_file_base	access:public
data_header	/usr/include/itpp/base/itfile.h	/^  struct data_header {$/;"	s	class:itpp::it_file_base_old	access:public
data_ok	/usr/include/itpp/base/gf2mat.h	/^  bool data_ok;$/;"	m	class:itpp::GF2mat_sparse_alist	access:protected
data_size	/usr/include/itpp/base/svec.h	/^  int v_size, used_size, data_size;$/;"	m	class:itpp::Sparse_Vec	access:private
data_size	/usr/include/itpp/srccode/audiofile.h	/^    unsigned data_size;$/;"	m	struct:itpp::SND_Format::__anon1	access:public
datasize	/usr/include/itpp/base/mat.h	/^  int datasize, no_rows, no_cols;$/;"	m	class:itpp::Mat	access:protected
datasize	/usr/include/itpp/base/vec.h	/^  int datasize;$/;"	m	class:itpp::Vec	access:protected
daxpy_	/usr/include/itpp/base/blas.h	/^  void daxpy_(const int *n,$/;"	p	signature:(const int *n, const double *alpha, const double *x, const int *incx, double *y, const int *incy)
dcopy_	/usr/include/itpp/base/blas.h	/^  void dcopy_(const int *n,$/;"	p	signature:(const int *n, const double *x, const int *incx, double *y, const int *incy)
dct	/usr/include/itpp/signal/transforms.h	/^vec dct(const vec &in);$/;"	p	namespace:itpp	signature:(const vec &in)
dct	/usr/include/itpp/signal/transforms.h	/^void dct(const vec &in, vec &out);$/;"	p	namespace:itpp	signature:(const vec &in, vec &out)
ddot_	/usr/include/itpp/base/blas.h	/^  double ddot_(const int *n,$/;"	p	signature:(const int *n, const double *x, const int *incx, const double *y, const int *incy)
debug	/usr/include/itpp/protocol/front_drop_queue.h	/^  int debug;$/;"	m	class:itpp::Front_Drop_Queue	access:private
debug	/usr/include/itpp/protocol/signals_slots.h	/^  bool debug;$/;"	m	class:itpp::Signal	access:private
dec2bin	/usr/include/itpp/base/converters.h	/^bvec dec2bin(int index, bool msb_first = true);$/;"	p	namespace:itpp	signature:(int index, bool msb_first = true)
dec2bin	/usr/include/itpp/base/converters.h	/^bvec dec2bin(int length, int index);$/;"	p	namespace:itpp	signature:(int length, int index)
dec2bin	/usr/include/itpp/base/converters.h	/^void dec2bin(int index, bvec &v);$/;"	p	namespace:itpp	signature:(int index, bvec &v)
dec_method	/usr/include/itpp/comm/ldpc.h	/^  std::string dec_method; \/\/!< Decoding method$/;"	m	class:itpp::LDPC_Code	access:protected
decode	/usr/include/itpp/comm/bch.h	/^  virtual bvec decode(const bvec &coded_bits);$/;"	p	class:itpp::BCH	access:public	signature:(const bvec &coded_bits)
decode	/usr/include/itpp/comm/bch.h	/^  virtual bvec decode(const vec &received_signal);$/;"	p	class:itpp::BCH	access:public	signature:(const vec &received_signal)
decode	/usr/include/itpp/comm/bch.h	/^  virtual void decode(const bvec &coded_bits, bvec &decoded_bits);$/;"	p	class:itpp::BCH	access:public	signature:(const bvec &coded_bits, bvec &decoded_bits)
decode	/usr/include/itpp/comm/bch.h	/^  virtual void decode(const vec &received_signal, bvec &output);$/;"	p	class:itpp::BCH	access:public	signature:(const vec &received_signal, bvec &output)
decode	/usr/include/itpp/comm/channel_code.h	/^  virtual bvec decode(const bvec &coded_bits) = 0;$/;"	p	class:itpp::Channel_Code	access:public	signature:(const bvec &coded_bits)
decode	/usr/include/itpp/comm/channel_code.h	/^  virtual bvec decode(const bvec &coded_bits) { return coded_bits; }$/;"	f	class:itpp::Dummy_Code	access:public	signature:(const bvec &coded_bits)
decode	/usr/include/itpp/comm/channel_code.h	/^  virtual bvec decode(const vec &received_signal) = 0;$/;"	p	class:itpp::Channel_Code	access:public	signature:(const vec &received_signal)
decode	/usr/include/itpp/comm/channel_code.h	/^  virtual bvec decode(const vec &received_signal) { bvec out; decode(received_signal, out); return out; }$/;"	f	class:itpp::Dummy_Code	access:public	signature:(const vec &received_signal)
decode	/usr/include/itpp/comm/channel_code.h	/^  virtual void decode(const bvec &coded_bits, bvec &decoded_bits) { decoded_bits = coded_bits; }$/;"	f	class:itpp::Dummy_Code	access:public	signature:(const bvec &coded_bits, bvec &decoded_bits)
decode	/usr/include/itpp/comm/channel_code.h	/^  virtual void decode(const bvec &codedbits, bvec &decoded_bits) = 0;$/;"	p	class:itpp::Channel_Code	access:public	signature:(const bvec &codedbits, bvec &decoded_bits)
decode	/usr/include/itpp/comm/channel_code.h	/^  virtual void decode(const vec &received_signal, bvec &decoded_bits) = 0;$/;"	p	class:itpp::Channel_Code	access:public	signature:(const vec &received_signal, bvec &decoded_bits)
decode	/usr/include/itpp/comm/channel_code.h	/^  virtual void decode(const vec &received_signal, bvec &decoded_bits) { BPSK bpsk; bpsk.demodulate_bits(received_signal, decoded_bits); }$/;"	f	class:itpp::Dummy_Code	access:public	signature:(const vec &received_signal, bvec &decoded_bits)
decode	/usr/include/itpp/comm/convcode.h	/^  virtual bvec decode(const bvec &coded_bits);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const bvec &coded_bits)
decode	/usr/include/itpp/comm/convcode.h	/^  virtual bvec decode(const vec &received_signal) {$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(const vec &received_signal)
decode	/usr/include/itpp/comm/convcode.h	/^  virtual void decode(const bvec &coded_bits, bvec &decoded_bits);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const bvec &coded_bits, bvec &decoded_bits)
decode	/usr/include/itpp/comm/convcode.h	/^  virtual void decode(const vec &received_signal, bvec &output);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const vec &received_signal, bvec &output)
decode	/usr/include/itpp/comm/crc.h	/^  bool decode(bvec &bits) const;$/;"	p	class:itpp::CRC_Code	access:public	signature:(bvec &bits) const
decode	/usr/include/itpp/comm/crc.h	/^  bool decode(const bvec &coded_bits, bvec &out) const;$/;"	p	class:itpp::CRC_Code	access:public	signature:(const bvec &coded_bits, bvec &out) const
decode	/usr/include/itpp/comm/egolay.h	/^  virtual bvec decode(const bvec &coded_bits);$/;"	p	class:itpp::Extended_Golay	access:public	signature:(const bvec &coded_bits)
decode	/usr/include/itpp/comm/egolay.h	/^  virtual bvec decode(const vec &received_signal);$/;"	p	class:itpp::Extended_Golay	access:public	signature:(const vec &received_signal)
decode	/usr/include/itpp/comm/egolay.h	/^  virtual void decode(const bvec &coded_bits, bvec &decoded_bits);$/;"	p	class:itpp::Extended_Golay	access:public	signature:(const bvec &coded_bits, bvec &decoded_bits)
decode	/usr/include/itpp/comm/egolay.h	/^  virtual void decode(const vec &received_signal, bvec &output);$/;"	p	class:itpp::Extended_Golay	access:public	signature:(const vec &received_signal, bvec &output)
decode	/usr/include/itpp/comm/hammcode.h	/^  virtual bvec decode(const bvec &coded_bits);$/;"	p	class:itpp::Hamming_Code	access:public	signature:(const bvec &coded_bits)
decode	/usr/include/itpp/comm/hammcode.h	/^  virtual bvec decode(const vec &received_signal);$/;"	p	class:itpp::Hamming_Code	access:public	signature:(const vec &received_signal)
decode	/usr/include/itpp/comm/hammcode.h	/^  virtual void decode(const bvec &coded_bits, bvec &decoded_bits);$/;"	p	class:itpp::Hamming_Code	access:public	signature:(const bvec &coded_bits, bvec &decoded_bits)
decode	/usr/include/itpp/comm/hammcode.h	/^  virtual void decode(const vec &received_signal, bvec &output);$/;"	p	class:itpp::Hamming_Code	access:public	signature:(const vec &received_signal, bvec &output)
decode	/usr/include/itpp/comm/ldpc.h	/^  virtual bvec decode(const bvec &) {$/;"	f	class:itpp::LDPC_Code	access:public	signature:(const bvec &)
decode	/usr/include/itpp/comm/ldpc.h	/^  virtual bvec decode(const vec &llr_in);$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const vec &llr_in)
decode	/usr/include/itpp/comm/ldpc.h	/^  virtual void decode(const bvec &, bvec &) {$/;"	f	class:itpp::LDPC_Code	access:public	signature:(const bvec &, bvec &)
decode	/usr/include/itpp/comm/ldpc.h	/^  virtual void decode(const vec &llr_in, bvec &syst_bits);$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const vec &llr_in, bvec &syst_bits)
decode	/usr/include/itpp/comm/punct_convcode.h	/^  virtual bvec decode(const bvec &coded_bits);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const bvec &coded_bits)
decode	/usr/include/itpp/comm/punct_convcode.h	/^  virtual bvec decode(const vec &received_signal) { bvec output; decode(received_signal, output); return output; }$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const vec &received_signal)
decode	/usr/include/itpp/comm/punct_convcode.h	/^  virtual void decode(const bvec &coded_bits, bvec &decoded_bits);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const bvec &coded_bits, bvec &decoded_bits)
decode	/usr/include/itpp/comm/punct_convcode.h	/^  virtual void decode(const vec &received_signal, bvec &output);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const vec &received_signal, bvec &output)
decode	/usr/include/itpp/comm/reedsolomon.h	/^  virtual bvec decode(const bvec &coded_bits);$/;"	p	class:itpp::Reed_Solomon	access:public	signature:(const bvec &coded_bits)
decode	/usr/include/itpp/comm/reedsolomon.h	/^  virtual bvec decode(const vec &received_signal);$/;"	p	class:itpp::Reed_Solomon	access:public	signature:(const vec &received_signal)
decode	/usr/include/itpp/comm/reedsolomon.h	/^  virtual void decode(const bvec &coded_bits, bvec &decoded_bits);$/;"	p	class:itpp::Reed_Solomon	access:public	signature:(const bvec &coded_bits, bvec &decoded_bits)
decode	/usr/include/itpp/comm/reedsolomon.h	/^  virtual void decode(const vec &received_signal, bvec &output);$/;"	p	class:itpp::Reed_Solomon	access:public	signature:(const vec &received_signal, bvec &output)
decode	/usr/include/itpp/comm/turbo.h	/^  virtual void decode(const vec &received_signal, bvec &decoded_bits, const bvec &true_bits = "0");$/;"	p	class:itpp::Turbo_Codec	access:public	signature:(const vec &received_signal, bvec &decoded_bits, const bvec &true_bits = Ó)
decode	/usr/include/itpp/comm/turbo.h	/^  virtual void decode(const vec &received_signal, bvec &decoded_bits, ivec &nrof_used_iterations,$/;"	p	class:itpp::Turbo_Codec	access:public	signature:(const vec &received_signal, bvec &decoded_bits, ivec &nrof_used_iterations, const bvec &true_bits = Ó)
decode	/usr/include/itpp/srccode/vq.h	/^  Array<vec> decode(const ivec &Index) const;$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:(const ivec &Index) const
decode	/usr/include/itpp/srccode/vq.h	/^  double decode(int Index) const;$/;"	p	class:itpp::Scalar_Quantizer	access:public	signature:(int Index) const
decode	/usr/include/itpp/srccode/vq.h	/^  vec decode(const ivec &Index) const;$/;"	p	class:itpp::Scalar_Quantizer	access:public	signature:(const ivec &Index) const
decode	/usr/include/itpp/srccode/vq.h	/^  vec decode(int Index) const;$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:(int Index) const
decode	/usr/include/itpp/srccode/vq.h	/^inline double Scalar_Quantizer::decode(int Index) const { return Levels(Index); }$/;"	f	class:itpp::Scalar_Quantizer	signature:(int Index) const
decode	/usr/include/itpp/srccode/vq.h	/^inline vec Vector_Quantizer::decode(int Index) const { return get_codevector(Index); }$/;"	f	class:itpp::Vector_Quantizer	signature:(int Index) const
decode_block	/usr/include/itpp/comm/turbo.h	/^  virtual void decode_block(const vec &rec_syst1, const vec &rec_syst2, const mat &rec_parity1, const mat &rec_parity2,$/;"	p	class:itpp::Turbo_Codec	access:public	signature:(const vec &rec_syst1, const vec &rec_syst2, const mat &rec_parity1, const mat &rec_parity2, bmat &decoded_bits_i, int &nrof_used_iterations_i, const bvec &true_bits = Ó)
decode_n3	/usr/include/itpp/comm/turbo.h	/^  void decode_n3(const vec &received_signal, bvec &decoded_bits, ivec &nrof_used_iterations,$/;"	p	class:itpp::Turbo_Codec	access:private	signature:(const vec &received_signal, bvec &decoded_bits, ivec &nrof_used_iterations, const bvec &true_bits = Ó)
decode_soft_out	/usr/include/itpp/comm/ldpc.h	/^  vec decode_soft_out(const vec &llr_in);$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const vec &llr_in)
decode_soft_out	/usr/include/itpp/comm/ldpc.h	/^  void decode_soft_out(const vec &llr_in, vec &llr_out);$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const vec &llr_in, vec &llr_out)
decode_tail	/usr/include/itpp/comm/convcode.h	/^  virtual bvec decode_tail(const vec &received_signal) {$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(const vec &received_signal)
decode_tail	/usr/include/itpp/comm/convcode.h	/^  virtual void decode_tail(const vec &received_signal, bvec &output);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const vec &received_signal, bvec &output)
decode_tail	/usr/include/itpp/comm/punct_convcode.h	/^  bvec decode_tail(const vec &received_signal) { bvec output; decode_tail(received_signal, output); return output; }$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const vec &received_signal)
decode_tail	/usr/include/itpp/comm/punct_convcode.h	/^  void decode_tail(const vec &received_signal, bvec &output);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const vec &received_signal, bvec &output)
decode_tailbite	/usr/include/itpp/comm/convcode.h	/^  virtual bvec decode_tailbite(const vec &received_signal) {$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(const vec &received_signal)
decode_tailbite	/usr/include/itpp/comm/convcode.h	/^  virtual void decode_tailbite(const vec &received_signal, bvec &output);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const vec &received_signal, bvec &output)
decode_tailbite	/usr/include/itpp/comm/punct_convcode.h	/^  bvec decode_tailbite(const vec &received_signal)$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const vec &received_signal)
decode_tailbite	/usr/include/itpp/comm/punct_convcode.h	/^  void decode_tailbite(const vec &received_signal, bvec &output);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const vec &received_signal, bvec &output)
decode_trunc	/usr/include/itpp/comm/convcode.h	/^  virtual bvec decode_trunc(const vec &received_signal) {$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(const vec &received_signal)
decode_trunc	/usr/include/itpp/comm/convcode.h	/^  virtual void decode_trunc(const vec &received_signal, bvec &output);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const vec &received_signal, bvec &output)
decode_trunc	/usr/include/itpp/comm/punct_convcode.h	/^  bvec decode_trunc(const vec &received_signal) { bvec output; decode_trunc(received_signal, output); return output; }$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const vec &received_signal)
decode_trunc	/usr/include/itpp/comm/punct_convcode.h	/^  void decode_trunc(const vec &received_signal, bvec &output);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const vec &received_signal, bvec &output)
decoded_bits_previous_iteration	/usr/include/itpp/comm/turbo.h	/^  bvec decoded_bits_previous_iteration;$/;"	m	class:itpp::Turbo_Codec	access:private
decoder_parameterization	/usr/include/itpp/comm/ldpc.h	/^  void decoder_parameterization(const LDPC_Parity* const H);$/;"	p	class:itpp::LDPC_Code	access:protected	signature:(const LDPC_Parity* const H)
deg_to_rad	/usr/include/itpp/base/converters.h	/^inline double deg_to_rad(double x) { return (itpp::pi \/ 180.0 * x); }$/;"	f	namespace:itpp	signature:(double x)
degree	/usr/include/itpp/comm/galois.h	/^  int degree, q;$/;"	m	class:itpp::GFX	access:private
deinterleave	/usr/include/itpp/comm/interleave.h	/^  Vec<T> deinterleave(const Vec<T> &input, short keepzeros = 0);$/;"	p	class:itpp::Block_Interleaver	access:public	signature:(const Vec<T> &input, short keepzeros = 0)
deinterleave	/usr/include/itpp/comm/interleave.h	/^  Vec<T> deinterleave(const Vec<T> &input, short keepzeros = 0);$/;"	p	class:itpp::Cross_Interleaver	access:public	signature:(const Vec<T> &input, short keepzeros = 0)
deinterleave	/usr/include/itpp/comm/interleave.h	/^  Vec<T> deinterleave(const Vec<T> &input, short keepzeros = 0);$/;"	p	class:itpp::Sequence_Interleaver	access:public	signature:(const Vec<T> &input, short keepzeros = 0)
deinterleave	/usr/include/itpp/comm/interleave.h	/^  void deinterleave(const Vec<T> &input, Vec<T> &output, short keepzeros = 0);$/;"	p	class:itpp::Block_Interleaver	access:public	signature:(const Vec<T> &input, Vec<T> &output, short keepzeros = 0)
deinterleave	/usr/include/itpp/comm/interleave.h	/^  void deinterleave(const Vec<T> &input, Vec<T> &output, short keepzeros = 0);$/;"	p	class:itpp::Cross_Interleaver	access:public	signature:(const Vec<T> &input, Vec<T> &output, short keepzeros = 0)
deinterleave	/usr/include/itpp/comm/interleave.h	/^  void deinterleave(const Vec<T> &input, Vec<T> &output, short keepzeros = 0);$/;"	p	class:itpp::Sequence_Interleaver	access:public	signature:(const Vec<T> &input, Vec<T> &output, short keepzeros = 0)
deinterleave	/usr/include/itpp/comm/interleave.h	/^Vec<T> Block_Interleaver<T>::deinterleave(const Vec<T> &input, short keepzeros)$/;"	f	class:itpp::Block_Interleaver	signature:(const Vec<T> &input, short keepzeros)
deinterleave	/usr/include/itpp/comm/interleave.h	/^Vec<T> Cross_Interleaver<T>::deinterleave(const Vec<T> &input, short keepzeros)$/;"	f	class:itpp::Cross_Interleaver	signature:(const Vec<T> &input, short keepzeros)
deinterleave	/usr/include/itpp/comm/interleave.h	/^Vec<T> Sequence_Interleaver<T>::deinterleave(const Vec<T> &input, short keepzeros)$/;"	f	class:itpp::Sequence_Interleaver	signature:(const Vec<T> &input, short keepzeros)
deinterleave	/usr/include/itpp/comm/interleave.h	/^void Block_Interleaver<T>::deinterleave(const Vec<T> &input, Vec<T> &output, short keepzeros)$/;"	f	class:itpp::Block_Interleaver	signature:(const Vec<T> &input, Vec<T> &output, short keepzeros)
deinterleave	/usr/include/itpp/comm/interleave.h	/^void Cross_Interleaver<T>::deinterleave(const Vec<T> &input, Vec<T> &output, short keepzeros)$/;"	f	class:itpp::Cross_Interleaver	signature:(const Vec<T> &input, Vec<T> &output, short keepzeros)
deinterleave	/usr/include/itpp/comm/interleave.h	/^void Sequence_Interleaver<T>::deinterleave(const Vec<T> &input, Vec<T> &output, short keepzeros)$/;"	f	class:itpp::Sequence_Interleaver	signature:(const Vec<T> &input, Vec<T> &output, short keepzeros)
del	/usr/include/itpp/base/vec.h	/^  void del(int i);$/;"	p	class:itpp::Vec	access:public	signature:(int i)
del	/usr/include/itpp/base/vec.h	/^  void del(int i1, int i2);$/;"	p	class:itpp::Vec	access:public	signature:(int i1, int i2)
del	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::del(int i1, int i2)$/;"	f	class:itpp::Vec	signature:(int i1, int i2)
del	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::del(int index)$/;"	f	class:itpp::Vec	signature:(int index)
del_col	/usr/include/itpp/base/mat.h	/^  void del_col(int c);$/;"	p	class:itpp::Mat	access:public	signature:(int c)
del_col	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::del_col(int c)$/;"	f	class:itpp::Mat	signature:(int c)
del_cols	/usr/include/itpp/base/mat.h	/^  void del_cols(int c1, int c2);$/;"	p	class:itpp::Mat	access:public	signature:(int c1, int c2)
del_cols	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::del_cols(int c1, int c2)$/;"	f	class:itpp::Mat	signature:(int c1, int c2)
del_row	/usr/include/itpp/base/mat.h	/^  void del_row(int r);$/;"	p	class:itpp::Mat	access:public	signature:(int r)
del_row	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::del_row(int r)$/;"	f	class:itpp::Mat	signature:(int r)
del_rows	/usr/include/itpp/base/mat.h	/^  void del_rows(int r1, int r2);$/;"	p	class:itpp::Mat	access:public	signature:(int r1, int r2)
del_rows	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::del_rows(int r1, int r2)$/;"	f	class:itpp::Mat	signature:(int r1, int r2)
delay	/usr/include/itpp/comm/error_counters.h	/^  int delay;$/;"	m	class:itpp::BERC	access:private
delay	/usr/include/itpp/protocol/packet_channel.h	/^  Ttype delay;$/;"	m	class:itpp::ACK_Channel	access:private
delay	/usr/include/itpp/protocol/packet_channel.h	/^  Ttype delay;$/;"	m	class:itpp::Packet_Channel	access:private
delta_t	/usr/include/itpp/protocol/events.h	/^  Ttype delta_t;$/;"	m	class:itpp::Base_Event	access:protected
delta_t	/usr/include/itpp/protocol/packet_generator.h	/^  virtual Ttype delta_t() = 0;$/;"	p	class:itpp::Packet_Generator	access:protected	signature:()
delta_t	/usr/include/itpp/protocol/packet_generator.h	/^  virtual Ttype delta_t();$/;"	p	class:itpp::Burst_WWW_Packet_Generator	access:protected	signature:()
delta_t	/usr/include/itpp/protocol/packet_generator.h	/^  virtual Ttype delta_t();$/;"	p	class:itpp::Constant_Rate_Packet_Generator	access:protected	signature:()
delta_t	/usr/include/itpp/protocol/packet_generator.h	/^  virtual Ttype delta_t();$/;"	p	class:itpp::Poisson_Packet_Generator	access:protected	signature:()
demodulate	/usr/include/itpp/comm/modulator.h	/^  virtual ivec demodulate(const Vec<T>& signal) const;$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& signal) const
demodulate	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate(const Vec<T>& signal, ivec& output) const;$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& signal, ivec& output) const
demodulate	/usr/include/itpp/comm/modulator.h	/^ivec Modulator<T>::demodulate(const Vec<T>& signal) const$/;"	f	class:itpp::Modulator	signature:(const Vec<T>& signal) const
demodulate	/usr/include/itpp/comm/modulator.h	/^void Modulator<T>::demodulate(const Vec<T> &signal, ivec& output) const$/;"	f	class:itpp::Modulator	signature:(const Vec<T> &signal, ivec& output) const
demodulate	/usr/include/itpp/comm/ofdm.h	/^  cvec demodulate(const cvec &input);$/;"	p	class:itpp::OFDM	access:public	signature:(const cvec &input)
demodulate	/usr/include/itpp/comm/ofdm.h	/^  void demodulate(const cvec &input, cvec &output);$/;"	p	class:itpp::OFDM	access:public	signature:(const cvec &input, cvec &output)
demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  bvec demodulate_bits(const cvec& signal) const;$/;"	p	class:itpp::BPSK_c	access:public	signature:(const cvec& signal) const
demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  bvec demodulate_bits(const cvec& signal) const;$/;"	p	class:itpp::PAM_c	access:public	signature:(const cvec& signal) const
demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  bvec demodulate_bits(const cvec& signal) const;$/;"	p	class:itpp::PSK	access:public	signature:(const cvec& signal) const
demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  bvec demodulate_bits(const cvec& signal) const;$/;"	p	class:itpp::QAM	access:public	signature:(const cvec& signal) const
demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  bvec demodulate_bits(const vec& signal) const;$/;"	p	class:itpp::BPSK	access:public	signature:(const vec& signal) const
demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  bvec demodulate_bits(const vec& signal) const;$/;"	p	class:itpp::PAM	access:public	signature:(const vec& signal) const
demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  virtual bvec demodulate_bits(const Vec<T>& signal) const;$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& signal) const
demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate_bits(const Vec<T>& signal, bvec& bits) const;$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& signal, bvec& bits) const
demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  void demodulate_bits(const cvec& signal, bvec& bits) const;$/;"	p	class:itpp::PSK	access:public	signature:(const cvec& signal, bvec& bits) const
demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  void demodulate_bits(const cvec& signal, bvec& bits) const;$/;"	p	class:itpp::QAM	access:public	signature:(const cvec& signal, bvec& bits) const
demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  void demodulate_bits(const cvec& signal, bvec& output) const;$/;"	p	class:itpp::BPSK_c	access:public	signature:(const cvec& signal, bvec& output) const
demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  void demodulate_bits(const cvec& signal, bvec& output) const;$/;"	p	class:itpp::PAM_c	access:public	signature:(const cvec& signal, bvec& output) const
demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  void demodulate_bits(const vec& signal, bvec& output) const;$/;"	p	class:itpp::BPSK	access:public	signature:(const vec& signal, bvec& output) const
demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  void demodulate_bits(const vec& signal, bvec& output) const;$/;"	p	class:itpp::PAM	access:public	signature:(const vec& signal, bvec& output) const
demodulate_bits	/usr/include/itpp/comm/modulator.h	/^bvec Modulator<T>::demodulate_bits(const Vec<T> &signal) const$/;"	f	class:itpp::Modulator	signature:(const Vec<T> &signal) const
demodulate_bits	/usr/include/itpp/comm/modulator.h	/^void Modulator<T>::demodulate_bits(const Vec<T> &signal, bvec &bits) const$/;"	f	class:itpp::Modulator	signature:(const Vec<T> &signal, bvec &bits) const
demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  vec demodulate_soft_bits(const cvec& rx_symbols, const cvec& channel,$/;"	p	class:itpp::BPSK_c	access:public	signature:(const cvec& rx_symbols, const cvec& channel, double N0, Soft_Method method = LOGMAP) const
demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  vec demodulate_soft_bits(const cvec& rx_symbols, const cvec& channel,$/;"	p	class:itpp::QPSK	access:public	signature:(const cvec& rx_symbols, const cvec& channel, double N0, Soft_Method method = LOGMAP) const
demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  vec demodulate_soft_bits(const cvec& rx_symbols, double N0,$/;"	p	class:itpp::BPSK_c	access:public	signature:(const cvec& rx_symbols, double N0, Soft_Method method = LOGMAP) const
demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  vec demodulate_soft_bits(const cvec& rx_symbols, double N0,$/;"	p	class:itpp::QPSK	access:public	signature:(const cvec& rx_symbols, double N0, Soft_Method method = LOGMAP) const
demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  vec demodulate_soft_bits(const vec& rx_symbols, const vec& channel,$/;"	p	class:itpp::BPSK	access:public	signature:(const vec& rx_symbols, const vec& channel, double N0, Soft_Method method = LOGMAP) const
demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  vec demodulate_soft_bits(const vec& rx_symbols, double N0,$/;"	p	class:itpp::BPSK	access:public	signature:(const vec& rx_symbols, double N0, Soft_Method method = LOGMAP) const
demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual vec demodulate_soft_bits(const Vec<T>& rx_symbols, double N0,$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& rx_symbols, double N0, Soft_Method method = LOGMAP) const
demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual vec demodulate_soft_bits(const Vec<T>& rx_symbols,$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& rx_symbols, const Vec<T>& channel, double N0, Soft_Method method = LOGMAP) const
demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual vec demodulate_soft_bits(const cvec& rx_symbols, double N0,$/;"	p	class:itpp::PAM_c	access:public	signature:(const cvec& rx_symbols, double N0, Soft_Method method = LOGMAP) const
demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual vec demodulate_soft_bits(const cvec& rx_symbols,$/;"	p	class:itpp::PAM_c	access:public	signature:(const cvec& rx_symbols, const cvec& channel, double N0, Soft_Method method = LOGMAP) const
demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate_soft_bits(const Vec<T>& rx_symbols, double N0,$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& rx_symbols, double N0, vec& soft_bits, Soft_Method method = LOGMAP) const
demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate_soft_bits(const Vec<T>& rx_symbols,$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& rx_symbols, const Vec<T>& channel, double N0, vec& soft_bits, Soft_Method method = LOGMAP) const
demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate_soft_bits(const cvec& rx_symbols, double N0,$/;"	p	class:itpp::BPSK_c	access:public	signature:(const cvec& rx_symbols, double N0, vec& soft_bits, Soft_Method method = LOGMAP) const
demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate_soft_bits(const cvec& rx_symbols, double N0,$/;"	p	class:itpp::PAM_c	access:public	signature:(const cvec& rx_symbols, double N0, vec& soft_bits, Soft_Method method = LOGMAP) const
demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate_soft_bits(const cvec& rx_symbols, double N0,$/;"	p	class:itpp::QPSK	access:public	signature:(const cvec& rx_symbols, double N0, vec& soft_bits, Soft_Method method = LOGMAP) const
demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate_soft_bits(const cvec& rx_symbols,$/;"	p	class:itpp::BPSK_c	access:public	signature:(const cvec& rx_symbols, const cvec& channel, double N0, vec& soft_bits, Soft_Method method = LOGMAP) const
demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate_soft_bits(const cvec& rx_symbols,$/;"	p	class:itpp::PAM_c	access:public	signature:(const cvec& rx_symbols, const cvec& channel, double N0, vec& soft_bits, Soft_Method method = LOGMAP) const
demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate_soft_bits(const cvec& rx_symbols,$/;"	p	class:itpp::QPSK	access:public	signature:(const cvec& rx_symbols, const cvec& channel, double N0, vec& soft_bits, Soft_Method method = LOGMAP) const
demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate_soft_bits(const vec& rx_symbols, double N0,$/;"	p	class:itpp::BPSK	access:public	signature:(const vec& rx_symbols, double N0, vec& soft_bits, Soft_Method method = LOGMAP) const
demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate_soft_bits(const vec& rx_symbols,$/;"	p	class:itpp::BPSK	access:public	signature:(const vec& rx_symbols, const vec& channel, double N0, vec& soft_bits, Soft_Method method = LOGMAP) const
demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^vec Modulator<T>::demodulate_soft_bits(const Vec<T> &rx_symbols,$/;"	f	class:itpp::Modulator	signature:(const Vec<T> &rx_symbols, const Vec<T> &channel, double N0, Soft_Method method) const
demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^vec Modulator<T>::demodulate_soft_bits(const Vec<T> &rx_symbols,$/;"	f	class:itpp::Modulator	signature:(const Vec<T> &rx_symbols, double N0, Soft_Method method) const
demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^void Modulator<T>::demodulate_soft_bits(const Vec<T> &rx_symbols, double N0,$/;"	f	class:itpp::Modulator	signature:(const Vec<T> &rx_symbols, double N0, vec &soft_bits, Soft_Method method) const
demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^void Modulator<T>::demodulate_soft_bits(const Vec<T> &rx_symbols,$/;"	f	class:itpp::Modulator	signature:(const Vec<T> &rx_symbols, const Vec<T> &channel, double N0, vec &soft_bits, Soft_Method method) const
demodulate_soft_bits	/usr/include/itpp/comm/modulator_nd.h	/^  QLLRvec demodulate_soft_bits(const cvec &y, const cmat &H, double sigma2,$/;"	p	class:itpp::Modulator_NCD	access:public	signature:(const cvec &y, const cmat &H, double sigma2, const QLLRvec &LLR_apriori, Soft_Demod_Method method)
demodulate_soft_bits	/usr/include/itpp/comm/modulator_nd.h	/^  QLLRvec demodulate_soft_bits(const vec &y, const mat &H, double sigma2,$/;"	p	class:itpp::Modulator_NRD	access:public	signature:(const vec &y, const mat &H, double sigma2, const QLLRvec &LLR_apriori, Soft_Demod_Method method)
demodulate_soft_bits	/usr/include/itpp/comm/modulator_nd.h	/^  void demodulate_soft_bits(const cvec &y, const cmat &H, double sigma2,$/;"	p	class:itpp::Modulator_NCD	access:public	signature:(const cvec &y, const cmat &H, double sigma2, const QLLRvec &LLR_apriori, QLLRvec &LLR_aposteriori)
demodulate_soft_bits	/usr/include/itpp/comm/modulator_nd.h	/^  void demodulate_soft_bits(const cvec &y, const cmat &H, double sigma2,$/;"	p	class:itpp::Modulator_NCD	access:public	signature:(const cvec &y, const cmat &H, double sigma2, const QLLRvec &LLR_apriori, QLLRvec &LLR_aposteriori, Soft_Demod_Method method)
demodulate_soft_bits	/usr/include/itpp/comm/modulator_nd.h	/^  void demodulate_soft_bits(const cvec &y, const cvec &H, double sigma2,$/;"	p	class:itpp::Modulator_NCD	access:public	signature:(const cvec &y, const cvec &H, double sigma2, const QLLRvec &LLR_apriori, QLLRvec &LLR_aposteriori)
demodulate_soft_bits	/usr/include/itpp/comm/modulator_nd.h	/^  void demodulate_soft_bits(const vec &y, const mat &H, double sigma2,$/;"	p	class:itpp::Modulator_NRD	access:public	signature:(const vec &y, const mat &H, double sigma2, const QLLRvec &LLR_apriori, QLLRvec &LLR_aposteriori)
demodulate_soft_bits	/usr/include/itpp/comm/modulator_nd.h	/^  void demodulate_soft_bits(const vec &y, const mat &H, double sigma2,$/;"	p	class:itpp::Modulator_NRD	access:public	signature:(const vec &y, const mat &H, double sigma2, const QLLRvec &LLR_apriori, QLLRvec &LLR_aposteriori, Soft_Demod_Method method)
demodulate_soft_bits	/usr/include/itpp/comm/modulator_nd.h	/^  void demodulate_soft_bits(const vec &y, const vec &h, double sigma2,$/;"	p	class:itpp::Modulator_NRD	access:public	signature:(const vec &y, const vec &h, double sigma2, const QLLRvec &LLR_apriori, QLLRvec &LLR_aposteriori)
demodulate_soft_bits_approx	/usr/include/itpp/comm/modulator.h	/^  virtual vec demodulate_soft_bits_approx(const Vec<T>& rx_symbols,$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& rx_symbols, const Vec<T>& channel, double N0) const
demodulate_soft_bits_approx	/usr/include/itpp/comm/modulator.h	/^  virtual vec demodulate_soft_bits_approx(const Vec<T>& rx_symbols,$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& rx_symbols, double N0) const
demodulate_soft_bits_approx	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate_soft_bits_approx(const Vec<T>& rx_symbols,$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& rx_symbols, const Vec<T>& channel, double N0, vec& soft_bits) const
demodulate_soft_bits_approx	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate_soft_bits_approx(const Vec<T>& rx_symbols,$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& rx_symbols, double N0, vec& soft_bits) const
demodulate_soft_bits_approx	/usr/include/itpp/comm/modulator.h	/^vec Modulator<T>::demodulate_soft_bits_approx(const Vec<T> &rx_symbols,$/;"	f	class:itpp::Modulator	signature:(const Vec<T> &rx_symbols, const Vec<T> &channel, double N0) const
demodulate_soft_bits_approx	/usr/include/itpp/comm/modulator.h	/^vec Modulator<T>::demodulate_soft_bits_approx(const Vec<T> &rx_symbols,$/;"	f	class:itpp::Modulator	signature:(const Vec<T> &rx_symbols, double N0) const
demodulate_soft_bits_approx	/usr/include/itpp/comm/modulator.h	/^void Modulator<T>::demodulate_soft_bits_approx(const Vec<T> &rx_symbols,$/;"	f	class:itpp::Modulator	signature:(const Vec<T> &rx_symbols, const Vec<T> &channel, double N0, vec &soft_bits) const
demodulate_soft_bits_approx	/usr/include/itpp/comm/modulator.h	/^void Modulator<T>::demodulate_soft_bits_approx(const Vec<T> &rx_symbols,$/;"	f	class:itpp::Modulator	signature:(const Vec<T> &rx_symbols, double N0, vec &soft_bits) const
denom	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  vec denom;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
denom_q	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  QLLRvec denom_q;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
density	/usr/include/itpp/base/gf2mat.h	/^  double density() const;$/;"	p	class:itpp::GF2mat	access:public	signature:() const
density	/usr/include/itpp/base/smat.h	/^  double density();$/;"	p	class:itpp::Sparse_Mat	access:public	signature:()
density	/usr/include/itpp/base/smat.h	/^double Sparse_Mat<T>::density()$/;"	f	class:itpp::Sparse_Mat	signature:()
density	/usr/include/itpp/base/svec.h	/^  double density();$/;"	p	class:itpp::Sparse_Vec	access:public	signature:()
density	/usr/include/itpp/base/svec.h	/^double Sparse_Vec<T>::density()$/;"	f	class:itpp::Sparse_Vec	signature:()
desc	/usr/include/itpp/base/itfile.h	/^    std::string desc;$/;"	m	struct:itpp::it_file_base::data_header	access:public
desc	/usr/include/itpp/base/itfile.h	/^  const std::string& desc;$/;"	m	class:itpp::Name	access:public
despread	/usr/include/itpp/comm/spread.h	/^  cvec despread(const cvec &rec_signal, int timing)$/;"	f	class:itpp::Spread_2d	access:public	signature:(const cvec &rec_signal, int timing)
despread	/usr/include/itpp/comm/spread.h	/^  cvec despread(const cvec &receivedsignal, int timing);$/;"	p	class:itpp::Multicode_Spread_2d	access:public	signature:(const cvec &receivedsignal, int timing)
despread	/usr/include/itpp/comm/spread.h	/^  vec despread(const vec &rec_signal, int timing)$/;"	f	class:itpp::Spread_1d	access:public	signature:(const vec &rec_signal, int timing)
despread	/usr/include/itpp/comm/spread.h	/^  vec despread(const vec &receivedsignal, int timing);$/;"	p	class:itpp::Multicode_Spread_1d	access:public	signature:(const vec &receivedsignal, int timing)
despread	/usr/include/itpp/comm/spread.h	/^  void despread(const cvec &rec_signal, cvec &out, int timing);$/;"	p	class:itpp::Spread_2d	access:public	signature:(const cvec &rec_signal, cvec &out, int timing)
despread	/usr/include/itpp/comm/spread.h	/^  void despread(const vec &rec_signal, vec &out, int timing);$/;"	p	class:itpp::Spread_1d	access:public	signature:(const vec &rec_signal, vec &out, int timing)
destroy_elements	/usr/include/itpp/base/factory.h	/^void destroy_elements(T* &ptr, int n)$/;"	f	namespace:itpp	signature:(T* &ptr, int n)
destroy_elements	/usr/include/itpp/base/factory.h	/^void destroy_elements<bin>(bin* &ptr, int)$/;"	f	namespace:itpp	signature:(bin* &ptr, int)
destroy_elements	/usr/include/itpp/base/factory.h	/^void destroy_elements<double>(double* &ptr, int)$/;"	f	namespace:itpp	signature:(double* &ptr, int)
destroy_elements	/usr/include/itpp/base/factory.h	/^void destroy_elements<int>(int* &ptr, int)$/;"	f	namespace:itpp	signature:(int* &ptr, int)
destroy_elements	/usr/include/itpp/base/factory.h	/^void destroy_elements<short int>(short int* &ptr, int)$/;"	f	namespace:itpp	signature:(short int* &ptr, int)
destroy_elements	/usr/include/itpp/base/factory.h	/^void destroy_elements<std::complex<double> >(std::complex<double>* &ptr, int)$/;"	f	namespace:itpp	signature:(std::complex<double>* &ptr, int)
destroy_elements	/usr/include/itpp/base/factory.h	/^void destroy_elements<unsigned char>(unsigned char* &ptr, int)$/;"	f	namespace:itpp	signature:(unsigned char* &ptr, int)
det	/usr/include/itpp/base/algebra/det.h	/^double det(const mat &X);$/;"	p	namespace:itpp	signature:(const mat &X)
det	/usr/include/itpp/base/algebra/det.h	/^std::complex<double> det(const cmat &X);$/;"	p	namespace:itpp	signature:(const cmat &X)
dewhiteningMatrix	/usr/include/itpp/signal/fastica.h	/^  mat dewhiteningMatrix;$/;"	m	class:itpp::Fast_ICA	access:private
dezombify_means	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  bool dezombify_means();$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:protected	signature:()
df_dx	/usr/include/itpp/optim/newton_search.h	/^  vec(*df_dx)(const vec&);  \/\/ df\/dx, gradient of f$/;"	m	class:itpp::Line_Search	access:private
df_dx	/usr/include/itpp/optim/newton_search.h	/^  vec(*df_dx)(const vec&);  \/\/ df\/dx, gradient of f$/;"	m	class:itpp::Newton_Search	access:private
dgemm_	/usr/include/itpp/base/blas.h	/^  void dgemm_(const char *transA, const char *transB,$/;"	p	signature:(const char *transA, const char *transB, const int *m, const int *n, const int *k, const double *alpha, const double *A, const int *ldA, const double *B, const int *ldB, const double *beta, double *C, const int *ldC)
dgemv_	/usr/include/itpp/base/blas.h	/^  void dgemv_(const char *transA, const int *m, const int *n,$/;"	p	signature:(const char *transA, const int *m, const int *n, const double *alpha, const double *A, const int *ldA, const double *x, const int *incx, const double *beta, double *y, const int *incy)
dger_	/usr/include/itpp/base/blas.h	/^  void dger_(const int *m, const int *n,$/;"	p	signature:(const int *m, const int *n, const double *alpha, const double *x, const int *incx, const double *y, const int *incy, double *A, const int *ldA)
dht	/usr/include/itpp/signal/transforms.h	/^Vec<T> dht(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
dht	/usr/include/itpp/signal/transforms.h	/^extern template cvec dht(const cvec &v);$/;"	p	namespace:itpp	signature:(const cvec &v)
dht	/usr/include/itpp/signal/transforms.h	/^extern template vec dht(const vec &v);$/;"	p	namespace:itpp	signature:(const vec &v)
dht	/usr/include/itpp/signal/transforms.h	/^extern template void dht(const cvec &vin, cvec &vout);$/;"	p	namespace:itpp	signature:(const cvec &vin, cvec &vout)
dht	/usr/include/itpp/signal/transforms.h	/^extern template void dht(const vec &vin, vec &vout);$/;"	p	namespace:itpp	signature:(const vec &vin, vec &vout)
dht	/usr/include/itpp/signal/transforms.h	/^template <class T> Vec<T> dht(const Vec<T> &v);$/;"	p	namespace:itpp	signature:(const Vec<T> &v)
dht	/usr/include/itpp/signal/transforms.h	/^template <class T> void dht(const Vec<T> &vin, Vec<T> &vout);$/;"	p	namespace:itpp	signature:(const Vec<T> &vin, Vec<T> &vout)
dht	/usr/include/itpp/signal/transforms.h	/^void dht(const Vec<T> &vin, Vec<T> &vout)$/;"	f	namespace:itpp	signature:(const Vec<T> &vin, Vec<T> &vout)
dht2	/usr/include/itpp/signal/transforms.h	/^Mat<T> dht2(const Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
dht2	/usr/include/itpp/signal/transforms.h	/^extern template cmat dht2(const cmat &m);$/;"	p	namespace:itpp	signature:(const cmat &m)
dht2	/usr/include/itpp/signal/transforms.h	/^extern template mat  dht2(const mat &m);$/;"	p	namespace:itpp	signature:(const mat &m)
dht2	/usr/include/itpp/signal/transforms.h	/^template <class T> Mat<T> dht2(const Mat<T> &m);$/;"	p	namespace:itpp	signature:(const Mat<T> &m)
diag	/usr/include/itpp/base/matfunc.h	/^Mat<T> diag(const Vec<T> &v, const int K = 0)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, const int K = 0)
diag	/usr/include/itpp/base/matfunc.h	/^Vec<T> diag(const Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
diag	/usr/include/itpp/base/matfunc.h	/^extern template cmat diag(const cvec &v, const int K);$/;"	p	namespace:itpp	signature:(const cvec &v, const int K)
diag	/usr/include/itpp/base/matfunc.h	/^extern template cvec diag(const cmat &in);$/;"	p	namespace:itpp	signature:(const cmat &in)
diag	/usr/include/itpp/base/matfunc.h	/^extern template mat diag(const vec &v, const int K);$/;"	p	namespace:itpp	signature:(const vec &v, const int K)
diag	/usr/include/itpp/base/matfunc.h	/^extern template vec diag(const mat &in);$/;"	p	namespace:itpp	signature:(const mat &in)
diag	/usr/include/itpp/base/matfunc.h	/^extern template void diag(const cvec &in, cmat &m);$/;"	p	namespace:itpp	signature:(const cvec &in, cmat &m)
diag	/usr/include/itpp/base/matfunc.h	/^extern template void diag(const vec &in, mat &m);$/;"	p	namespace:itpp	signature:(const vec &in, mat &m)
diag	/usr/include/itpp/base/matfunc.h	/^void diag(const Vec<T> &v, Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, Mat<T> &m)
diag_covs	/usr/include/itpp/stat/mog_generic.h	/^  Array<vec> diag_covs;$/;"	m	class:itpp::MOG_generic	access:protected
diag_covs_inv_etc	/usr/include/itpp/stat/mog_generic.h	/^  Array<vec> diag_covs_inv_etc;$/;"	m	class:itpp::MOG_generic	access:protected
dim	/usr/include/itpp/srccode/vq.h	/^  int dim() const;$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:() const
dim	/usr/include/itpp/srccode/vq.h	/^inline int Vector_Quantizer::dim() const { return Dim; }$/;"	f	class:itpp::Vector_Quantizer	signature:() const
disable_c_access	/usr/include/itpp/stat/mog_diag.h	/^  double * disable_c_access(double * v_in);$/;"	p	class:itpp::MOG_diag	access:protected	signature:(double * v_in)
disable_c_access	/usr/include/itpp/stat/mog_diag.h	/^  double ** disable_c_access(double ** A_in);$/;"	p	class:itpp::MOG_diag	access:protected	signature:(double ** A_in)
disable_c_access	/usr/include/itpp/stat/mog_diag.h	/^  int * disable_c_access(int * v_in);$/;"	p	class:itpp::MOG_diag	access:protected	signature:(int * v_in)
disable_c_access	/usr/include/itpp/stat/mog_diag.h	/^  int ** disable_c_access(int ** A_in);$/;"	p	class:itpp::MOG_diag	access:protected	signature:(int ** A_in)
disable_trace	/usr/include/itpp/optim/newton_search.h	/^  void disable_trace() { trace = false; }$/;"	f	class:itpp::Line_Search	access:public	signature:()
disable_trace	/usr/include/itpp/optim/newton_search.h	/^  void disable_trace() { trace = false; }$/;"	f	class:itpp::Newton_Search	access:public	signature:()
disconnect	/usr/include/itpp/protocol/signals_slots.h	/^  void disconnect(Base_Slot<DataType>* slot = NULL);$/;"	p	class:itpp::Signal	access:public	signature:(Base_Slot<DataType>* slot = NULL)
disconnect	/usr/include/itpp/protocol/signals_slots.h	/^void Signal<DataType>::disconnect(Base_Slot<DataType>* slot)$/;"	f	class:itpp::Signal	signature:(Base_Slot<DataType>* slot)
discrete_Ts	/usr/include/itpp/comm/channel.h	/^  double discrete_Ts; \/\/!< Sampling time of discretization$/;"	m	class:itpp::TDL_Channel	access:protected
discretize	/usr/include/itpp/comm/channel.h	/^  void discretize(const vec &delay_profile);$/;"	p	class:itpp::TDL_Channel	access:protected	signature:(const vec &delay_profile)
display_stats	/usr/include/itpp/comm/ldpc.h	/^  virtual void display_stats() const = 0;$/;"	p	class:itpp::LDPC_Parity_Unstructured	access:public	signature:() const
display_stats	/usr/include/itpp/comm/ldpc.h	/^  virtual void display_stats() const;$/;"	p	class:itpp::LDPC_Parity	access:public	signature:() const
display_stats	/usr/include/itpp/comm/ldpc.h	/^  void display_stats() const { LDPC_Parity::display_stats(); }$/;"	f	class:itpp::LDPC_Parity_Irregular	access:public	signature:() const
display_stats	/usr/include/itpp/comm/ldpc.h	/^  void display_stats() const { LDPC_Parity::display_stats(); }$/;"	f	class:itpp::LDPC_Parity_Regular	access:public	signature:() const
dist	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  inline double dist(const double * x, const double * y) const;$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:protected	signature:(const double * x, const double * y) const
distance_profile	/usr/include/itpp/comm/convcode.h	/^  void distance_profile(ivec &dist_prof, int dmax = 100000,$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(ivec &dist_prof, int dmax = 100000, bool reverse = false)
distance_profile	/usr/include/itpp/comm/punct_convcode.h	/^  void distance_profile(ivec &dist_prof, int time, int dmax = 100000, bool reverse = false);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(ivec &dist_prof, int time, int dmax = 100000, bool reverse = false)
divgfx	/usr/include/itpp/comm/galois.h	/^GFX divgfx(const GFX &c, const GFX &g);$/;"	p	namespace:itpp	signature:(const GFX &c, const GFX &g)
do_checks	/usr/include/itpp/stat/mog_generic.h	/^  bool do_checks;$/;"	m	class:itpp::MOG_generic	access:protected
dopp_spectrum	/usr/include/itpp/comm/channel.h	/^  DOPPLER_SPECTRUM dopp_spectrum; \/\/!< Doppler spectrum type (Jakes by default)$/;"	m	class:itpp::Rice_Fading_Generator	access:protected
dot	/usr/include/itpp/base/vec.h	/^  friend Num_T dot<>(const Vec<Num_T> &v1, const Vec<Num_T> &v2);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
dot	/usr/include/itpp/base/vec.h	/^Num_T dot(const Vec<Num_T> &v1, const Vec<Num_T> &v2)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
dot	/usr/include/itpp/base/vec.h	/^Num_T dot(const Vec<Num_T> &v1, const Vec<Num_T> &v2);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
dot	/usr/include/itpp/base/vec.h	/^double dot(const vec &v1, const vec &v2)$/;"	f	namespace:itpp	signature:(const vec &v1, const vec &v2)
dot	/usr/include/itpp/base/vec.h	/^extern template bin dot(const bvec &v1, const bvec &v2);$/;"	p	namespace:itpp	signature:(const bvec &v1, const bvec &v2)
dot	/usr/include/itpp/base/vec.h	/^extern template double dot(const vec &v1, const vec &v2);$/;"	p	namespace:itpp	signature:(const vec &v1, const vec &v2)
dot	/usr/include/itpp/base/vec.h	/^extern template int dot(const ivec &v1, const ivec &v2);$/;"	p	namespace:itpp	signature:(const ivec &v1, const ivec &v2)
dot	/usr/include/itpp/base/vec.h	/^extern template short dot(const svec &v1, const svec &v2);$/;"	p	namespace:itpp	signature:(const svec &v1, const svec &v2)
dot	/usr/include/itpp/base/vec.h	/^extern template std::complex<double> dot(const cvec &v1, const cvec &v2);$/;"	p	namespace:itpp	signature:(const cvec &v1, const cvec &v2)
dot	/usr/include/itpp/base/vec.h	/^std::complex<double> dot(const cvec &v1, const cvec &v2)$/;"	f	namespace:itpp	signature:(const cvec &v1, const cvec &v2)
double2mxArray	/usr/include/itpp/itmex.h	/^void double2mxArray(const double &in, mxArray *out)$/;"	f	namespace:itpp	signature:(const double &in, mxArray *out)
double2mxArray	/usr/include/itpp/itmex.h	/^void double2mxArray(const double &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const double &in, mxArray *out)
double_complex2mxArray	/usr/include/itpp/itmex.h	/^void double_complex2mxArray(const std::complex<double> &in, mxArray *out)$/;"	f	namespace:itpp	signature:(const std::complex<double> &in, mxArray *out)
double_complex2mxArray	/usr/include/itpp/itmex.h	/^void double_complex2mxArray(const std::complex<double> &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const std::complex<double> &in, mxArray *out)
draw_sample	/usr/include/itpp/srccode/gmm.h	/^  vec draw_sample();$/;"	p	class:itpp::GMM	access:public	signature:()
dscal_	/usr/include/itpp/base/blas.h	/^  void dscal_(const int *n,$/;"	p	signature:(const int *n, const double *alpha, double *x, const int *incx)
dswap_	/usr/include/itpp/base/blas.h	/^  void dswap_(const int *n,$/;"	p	signature:(const int *n, double *x, const int *incx, double *y, const int *incy)
dtheta	/usr/include/itpp/signal/source.h	/^  double A, pos, dtheta;$/;"	m	class:itpp::Impulse_Source	access:private
dtheta	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Sawtooth_Source	access:private
dtheta	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Sine_Source	access:private
dtheta	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Square_Source	access:private
dtheta	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Triangle_Source	access:private
dwht	/usr/include/itpp/signal/transforms.h	/^Vec<T> dwht(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
dwht	/usr/include/itpp/signal/transforms.h	/^extern template cvec dwht(const cvec &v);$/;"	p	namespace:itpp	signature:(const cvec &v)
dwht	/usr/include/itpp/signal/transforms.h	/^extern template vec dwht(const vec &v);$/;"	p	namespace:itpp	signature:(const vec &v)
dwht	/usr/include/itpp/signal/transforms.h	/^extern template void dwht(const cvec &vin, cvec &vout);$/;"	p	namespace:itpp	signature:(const cvec &vin, cvec &vout)
dwht	/usr/include/itpp/signal/transforms.h	/^extern template void dwht(const vec &vin, vec &vout);$/;"	p	namespace:itpp	signature:(const vec &vin, vec &vout)
dwht	/usr/include/itpp/signal/transforms.h	/^template <class T> Vec<T> dwht(const Vec<T> &v);$/;"	p	namespace:itpp	signature:(const Vec<T> &v)
dwht	/usr/include/itpp/signal/transforms.h	/^template <class T> void dwht(const Vec<T> &vin, Vec<T> &vout);$/;"	p	namespace:itpp	signature:(const Vec<T> &vin, Vec<T> &vout)
dwht	/usr/include/itpp/signal/transforms.h	/^void dwht(const Vec<T> &vin, Vec<T> &vout)$/;"	f	namespace:itpp	signature:(const Vec<T> &vin, Vec<T> &vout)
dwht2	/usr/include/itpp/signal/transforms.h	/^Mat<T> dwht2(const Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
dwht2	/usr/include/itpp/signal/transforms.h	/^extern template cmat dwht2(const cmat &m);$/;"	p	namespace:itpp	signature:(const cmat &m)
dwht2	/usr/include/itpp/signal/transforms.h	/^extern template mat  dwht2(const mat &m);$/;"	p	namespace:itpp	signature:(const mat &m)
dwht2	/usr/include/itpp/signal/transforms.h	/^template <class T> Mat<T> dwht2(const Mat<T> &m);$/;"	p	namespace:itpp	signature:(const Mat<T> &m)
e	/usr/include/itpp/protocol/signals_slots.h	/^  Data_Event<Signal, DataType> *e;$/;"	m	class:itpp::Signal	access:private
eTCPVersion	/usr/include/itpp/protocol/tcp.h	/^  enum eTCPVersion {kTahoe, kReno, kNewReno};$/;"	g	class:itpp::TCP_Sender	access:private
e_mode	/usr/include/itpp/fixed/fix_base.h	/^enum e_mode {$/;"	g	namespace:itpp
ee	/usr/include/itpp/protocol/packet_generator.h	/^  Exponential_RNG ee;$/;"	m	class:itpp::Poisson_Packet_Generator	access:protected
eig	/usr/include/itpp/base/algebra/eigen.h	/^bool eig(const cmat &A, cvec &d);$/;"	p	namespace:itpp	signature:(const cmat &A, cvec &d)
eig	/usr/include/itpp/base/algebra/eigen.h	/^bool eig(const cmat &A, cvec &d, cmat &V);$/;"	p	namespace:itpp	signature:(const cmat &A, cvec &d, cmat &V)
eig	/usr/include/itpp/base/algebra/eigen.h	/^bool eig(const mat &A, cvec &d);$/;"	p	namespace:itpp	signature:(const mat &A, cvec &d)
eig	/usr/include/itpp/base/algebra/eigen.h	/^bool eig(const mat &A, cvec &d, cmat &V);$/;"	p	namespace:itpp	signature:(const mat &A, cvec &d, cmat &V)
eig	/usr/include/itpp/base/algebra/eigen.h	/^cvec eig(const cmat &A);$/;"	p	namespace:itpp	signature:(const cmat &A)
eig	/usr/include/itpp/base/algebra/eigen.h	/^cvec eig(const mat &A);$/;"	p	namespace:itpp	signature:(const mat &A)
eig_sym	/usr/include/itpp/base/algebra/eigen.h	/^bool eig_sym(const cmat &A, vec &d);$/;"	p	namespace:itpp	signature:(const cmat &A, vec &d)
eig_sym	/usr/include/itpp/base/algebra/eigen.h	/^bool eig_sym(const cmat &A, vec &d, cmat &V);$/;"	p	namespace:itpp	signature:(const cmat &A, vec &d, cmat &V)
eig_sym	/usr/include/itpp/base/algebra/eigen.h	/^bool eig_sym(const mat &A, vec &d);$/;"	p	namespace:itpp	signature:(const mat &A, vec &d)
eig_sym	/usr/include/itpp/base/algebra/eigen.h	/^bool eig_sym(const mat &A, vec &d, mat &V);$/;"	p	namespace:itpp	signature:(const mat &A, vec &d, mat &V)
eig_sym	/usr/include/itpp/base/algebra/eigen.h	/^vec eig_sym(const cmat &A);$/;"	p	namespace:itpp	signature:(const cmat &A)
eig_sym	/usr/include/itpp/base/algebra/eigen.h	/^vec eig_sym(const mat &A);$/;"	p	namespace:itpp	signature:(const mat &A)
elapsed_time	/usr/include/itpp/base/timing.h	/^  double elapsed_time;$/;"	m	class:itpp::Timer	access:protected
elem_div	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> elem_div<>(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
elem_div	/usr/include/itpp/base/mat.h	/^Mat<Num_T> elem_div(const Mat<Num_T> &m1, const Mat<Num_T> &m2)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
elem_div	/usr/include/itpp/base/mat.h	/^Mat<Num_T> elem_div(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
elem_div	/usr/include/itpp/base/mat.h	/^extern template bmat elem_div(const bmat &m1, const bmat &m2);$/;"	p	namespace:itpp	signature:(const bmat &m1, const bmat &m2)
elem_div	/usr/include/itpp/base/mat.h	/^extern template cmat elem_div(const cmat &m1, const cmat &m2);$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2)
elem_div	/usr/include/itpp/base/mat.h	/^extern template imat elem_div(const imat &m1, const imat &m2);$/;"	p	namespace:itpp	signature:(const imat &m1, const imat &m2)
elem_div	/usr/include/itpp/base/mat.h	/^extern template mat elem_div(const mat &m1, const mat &m2);$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2)
elem_div	/usr/include/itpp/base/mat.h	/^extern template smat elem_div(const smat &m1, const smat &m2);$/;"	p	namespace:itpp	signature:(const smat &m1, const smat &m2)
elem_div	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> elem_div<>(Num_T t, const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:friend	signature:(Num_T t, const Vec<Num_T> &v)
elem_div	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> elem_div<>(const Vec<Num_T> &v1, const Vec<Num_T> &v2);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
elem_div	/usr/include/itpp/base/vec.h	/^Vec<Num_T> elem_div(Num_T t, const Vec<Num_T> &v)$/;"	f	namespace:itpp	signature:(Num_T t, const Vec<Num_T> &v)
elem_div	/usr/include/itpp/base/vec.h	/^Vec<Num_T> elem_div(Num_T t, const Vec<Num_T> &v);$/;"	p	namespace:itpp	signature:(Num_T t, const Vec<Num_T> &v)
elem_div	/usr/include/itpp/base/vec.h	/^Vec<Num_T> elem_div(const Vec<Num_T> &a, const Vec<Num_T> &b)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b)
elem_div	/usr/include/itpp/base/vec.h	/^Vec<Num_T> elem_div(const Vec<Num_T> &a, const Vec<Num_T> &b);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b)
elem_div	/usr/include/itpp/base/vec.h	/^extern template bvec elem_div(bin t, const bvec &v);$/;"	p	namespace:itpp	signature:(bin t, const bvec &v)
elem_div	/usr/include/itpp/base/vec.h	/^extern template bvec elem_div(const bvec &a, const bvec &b);$/;"	p	namespace:itpp	signature:(const bvec &a, const bvec &b)
elem_div	/usr/include/itpp/base/vec.h	/^extern template cvec elem_div(const cvec &a, const cvec &b);$/;"	p	namespace:itpp	signature:(const cvec &a, const cvec &b)
elem_div	/usr/include/itpp/base/vec.h	/^extern template cvec elem_div(std::complex<double> t, const cvec &v);$/;"	p	namespace:itpp	signature:(std::complex<double> t, const cvec &v)
elem_div	/usr/include/itpp/base/vec.h	/^extern template ivec elem_div(const ivec &a, const ivec &b);$/;"	p	namespace:itpp	signature:(const ivec &a, const ivec &b)
elem_div	/usr/include/itpp/base/vec.h	/^extern template ivec elem_div(int t, const ivec &v);$/;"	p	namespace:itpp	signature:(int t, const ivec &v)
elem_div	/usr/include/itpp/base/vec.h	/^extern template svec elem_div(const svec &a, const svec &b);$/;"	p	namespace:itpp	signature:(const svec &a, const svec &b)
elem_div	/usr/include/itpp/base/vec.h	/^extern template svec elem_div(short t, const svec &v);$/;"	p	namespace:itpp	signature:(short t, const svec &v)
elem_div	/usr/include/itpp/base/vec.h	/^extern template vec elem_div(const vec &a, const vec &b);$/;"	p	namespace:itpp	signature:(const vec &a, const vec &b)
elem_div	/usr/include/itpp/base/vec.h	/^extern template vec elem_div(double t, const vec &v);$/;"	p	namespace:itpp	signature:(double t, const vec &v)
elem_div_out	/usr/include/itpp/base/mat.h	/^  friend void elem_div_out<>(const Mat<Num_T> &m1, const Mat<Num_T> &m2,$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2, Mat<Num_T> &out)
elem_div_out	/usr/include/itpp/base/mat.h	/^extern template void elem_div_out(const bmat &m1, const bmat &m2, bmat &out);$/;"	p	namespace:itpp	signature:(const bmat &m1, const bmat &m2, bmat &out)
elem_div_out	/usr/include/itpp/base/mat.h	/^extern template void elem_div_out(const cmat &m1, const cmat &m2, cmat &out);$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2, cmat &out)
elem_div_out	/usr/include/itpp/base/mat.h	/^extern template void elem_div_out(const imat &m1, const imat &m2, imat &out);$/;"	p	namespace:itpp	signature:(const imat &m1, const imat &m2, imat &out)
elem_div_out	/usr/include/itpp/base/mat.h	/^extern template void elem_div_out(const mat &m1, const mat &m2, mat &out);$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2, mat &out)
elem_div_out	/usr/include/itpp/base/mat.h	/^extern template void elem_div_out(const smat &m1, const smat &m2, smat &out);$/;"	p	namespace:itpp	signature:(const smat &m1, const smat &m2, smat &out)
elem_div_out	/usr/include/itpp/base/mat.h	/^void elem_div_out(const Mat<Num_T> &m1, const Mat<Num_T> &m2,$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2, Mat<Num_T> &out)
elem_div_out	/usr/include/itpp/base/mat.h	/^void elem_div_out(const Mat<Num_T> &m1, const Mat<Num_T> &m2,$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2, Mat<Num_T> &out)
elem_div_out	/usr/include/itpp/base/vec.h	/^  friend void elem_div_out<>(const Vec<Num_T> &v1, const Vec<Num_T> &v2,$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2, Vec<Num_T> &out)
elem_div_out	/usr/include/itpp/base/vec.h	/^extern template void elem_div_out(const bvec &a, const bvec &b, bvec &out);$/;"	p	namespace:itpp	signature:(const bvec &a, const bvec &b, bvec &out)
elem_div_out	/usr/include/itpp/base/vec.h	/^extern template void elem_div_out(const cvec &a, const cvec &b, cvec &out);$/;"	p	namespace:itpp	signature:(const cvec &a, const cvec &b, cvec &out)
elem_div_out	/usr/include/itpp/base/vec.h	/^extern template void elem_div_out(const ivec &a, const ivec &b, ivec &out);$/;"	p	namespace:itpp	signature:(const ivec &a, const ivec &b, ivec &out)
elem_div_out	/usr/include/itpp/base/vec.h	/^extern template void elem_div_out(const svec &a, const svec &b, svec &out);$/;"	p	namespace:itpp	signature:(const svec &a, const svec &b, svec &out)
elem_div_out	/usr/include/itpp/base/vec.h	/^extern template void elem_div_out(const vec &a, const vec &b, vec &out);$/;"	p	namespace:itpp	signature:(const vec &a, const vec &b, vec &out)
elem_div_out	/usr/include/itpp/base/vec.h	/^void elem_div_out(const Vec<Num_T> &a, const Vec<Num_T> &b, Vec<Num_T> &out)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, Vec<Num_T> &out)
elem_div_out	/usr/include/itpp/base/vec.h	/^void elem_div_out(const Vec<Num_T> &a, const Vec<Num_T> &b, Vec<Num_T> &out);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, Vec<Num_T> &out)
elem_div_sum	/usr/include/itpp/base/mat.h	/^  friend Num_T elem_div_sum<>(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
elem_div_sum	/usr/include/itpp/base/mat.h	/^Num_T elem_div_sum(const Mat<Num_T> &m1, const Mat<Num_T> &m2)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
elem_div_sum	/usr/include/itpp/base/mat.h	/^Num_T elem_div_sum(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
elem_div_sum	/usr/include/itpp/base/mat.h	/^extern template bin elem_div_sum(const bmat &m1, const bmat &m2);$/;"	p	namespace:itpp	signature:(const bmat &m1, const bmat &m2)
elem_div_sum	/usr/include/itpp/base/mat.h	/^extern template double elem_div_sum(const mat &m1, const mat &m2);$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2)
elem_div_sum	/usr/include/itpp/base/mat.h	/^extern template int elem_div_sum(const imat &m1, const imat &m2);$/;"	p	namespace:itpp	signature:(const imat &m1, const imat &m2)
elem_div_sum	/usr/include/itpp/base/mat.h	/^extern template short elem_div_sum(const smat &m1, const smat &m2);$/;"	p	namespace:itpp	signature:(const smat &m1, const smat &m2)
elem_div_sum	/usr/include/itpp/base/mat.h	/^extern template std::complex<double> elem_div_sum(const cmat &m1,$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2)
elem_div_sum	/usr/include/itpp/base/vec.h	/^  friend Num_T elem_div_sum<>(const Vec<Num_T> &a, const Vec<Num_T> &b);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b)
elem_div_sum	/usr/include/itpp/base/vec.h	/^Num_T elem_div_sum(const Vec<Num_T> &a, const Vec<Num_T> &b)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b)
elem_div_sum	/usr/include/itpp/base/vec.h	/^Num_T elem_div_sum(const Vec<Num_T> &a, const Vec<Num_T> &b);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b)
elem_div_sum	/usr/include/itpp/base/vec.h	/^extern template bin elem_div_sum(const bvec &a, const bvec &b);$/;"	p	namespace:itpp	signature:(const bvec &a, const bvec &b)
elem_div_sum	/usr/include/itpp/base/vec.h	/^extern template double elem_div_sum(const vec &a, const vec &b);$/;"	p	namespace:itpp	signature:(const vec &a, const vec &b)
elem_div_sum	/usr/include/itpp/base/vec.h	/^extern template int elem_div_sum(const ivec &a, const ivec &b);$/;"	p	namespace:itpp	signature:(const ivec &a, const ivec &b)
elem_div_sum	/usr/include/itpp/base/vec.h	/^extern template short elem_div_sum(const svec &a, const svec &b);$/;"	p	namespace:itpp	signature:(const svec &a, const svec &b)
elem_div_sum	/usr/include/itpp/base/vec.h	/^extern template std::complex<double> elem_div_sum(const cvec &a,$/;"	p	namespace:itpp	signature:(const cvec &a, const cvec &b)
elem_mult	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> elem_mult<>(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
elem_mult	/usr/include/itpp/base/mat.h	/^Mat<Num_T> elem_mult(const Mat<Num_T> &m1, const Mat<Num_T> &m2)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
elem_mult	/usr/include/itpp/base/mat.h	/^Mat<Num_T> elem_mult(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
elem_mult	/usr/include/itpp/base/mat.h	/^extern template bmat elem_mult(const bmat &m1, const bmat &m2);$/;"	p	namespace:itpp	signature:(const bmat &m1, const bmat &m2)
elem_mult	/usr/include/itpp/base/mat.h	/^extern template cmat elem_mult(const cmat &m1, const cmat &m2);$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2)
elem_mult	/usr/include/itpp/base/mat.h	/^extern template imat elem_mult(const imat &m1, const imat &m2);$/;"	p	namespace:itpp	signature:(const imat &m1, const imat &m2)
elem_mult	/usr/include/itpp/base/mat.h	/^extern template mat elem_mult(const mat &m1, const mat &m2);$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2)
elem_mult	/usr/include/itpp/base/mat.h	/^extern template smat elem_mult(const smat &m1, const smat &m2);$/;"	p	namespace:itpp	signature:(const smat &m1, const smat &m2)
elem_mult	/usr/include/itpp/base/svec.h	/^  friend Sparse_Vec<T> elem_mult <>(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2);$/;"	p	class:itpp::Sparse_Vec	access:friend	signature:(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2)
elem_mult	/usr/include/itpp/base/svec.h	/^  friend Vec<T> elem_mult <>(const Sparse_Vec<T> &v1, const Vec<T> &v2);$/;"	p	class:itpp::Sparse_Vec	access:friend	signature:(const Sparse_Vec<T> &v1, const Vec<T> &v2)
elem_mult	/usr/include/itpp/base/svec.h	/^  friend Vec<T> elem_mult <>(const Vec<T> &v1, const Sparse_Vec<T> &v2);$/;"	p	class:itpp::Sparse_Vec	access:friend	signature:(const Vec<T> &v1, const Sparse_Vec<T> &v2)
elem_mult	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T> elem_mult(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2)$/;"	f	namespace:itpp	signature:(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2)
elem_mult	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T> elem_mult(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2);$/;"	p	namespace:itpp	signature:(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2)
elem_mult	/usr/include/itpp/base/svec.h	/^Vec<T> elem_mult(const Sparse_Vec<T> &v1, const Vec<T> &v2)$/;"	f	namespace:itpp	signature:(const Sparse_Vec<T> &v1, const Vec<T> &v2)
elem_mult	/usr/include/itpp/base/svec.h	/^Vec<T> elem_mult(const Sparse_Vec<T> &v1, const Vec<T> &v2);$/;"	p	namespace:itpp	signature:(const Sparse_Vec<T> &v1, const Vec<T> &v2)
elem_mult	/usr/include/itpp/base/svec.h	/^Vec<T> elem_mult(const Vec<T> &v1, const Sparse_Vec<T> &v2)$/;"	f	namespace:itpp	signature:(const Vec<T> &v1, const Sparse_Vec<T> &v2)
elem_mult	/usr/include/itpp/base/svec.h	/^Vec<T> elem_mult(const Vec<T> &v1, const Sparse_Vec<T> &v2);$/;"	p	namespace:itpp	signature:(const Vec<T> &v1, const Sparse_Vec<T> &v2)
elem_mult	/usr/include/itpp/base/svec.h	/^extern template cvec elem_mult(const cvec &, const sparse_cvec &);$/;"	p	namespace:itpp	signature:(const cvec &, const sparse_cvec &)
elem_mult	/usr/include/itpp/base/svec.h	/^extern template cvec elem_mult(const sparse_cvec &, const cvec &);$/;"	p	namespace:itpp	signature:(const sparse_cvec &, const cvec &)
elem_mult	/usr/include/itpp/base/svec.h	/^extern template ivec elem_mult(const ivec &, const sparse_ivec &);$/;"	p	namespace:itpp	signature:(const ivec &, const sparse_ivec &)
elem_mult	/usr/include/itpp/base/svec.h	/^extern template ivec elem_mult(const sparse_ivec &, const ivec &);$/;"	p	namespace:itpp	signature:(const sparse_ivec &, const ivec &)
elem_mult	/usr/include/itpp/base/svec.h	/^extern template sparse_cvec elem_mult(const sparse_cvec &,$/;"	p	namespace:itpp	signature:(const sparse_cvec &, const sparse_cvec &)
elem_mult	/usr/include/itpp/base/svec.h	/^extern template sparse_ivec elem_mult(const sparse_ivec &,$/;"	p	namespace:itpp	signature:(const sparse_ivec &, const sparse_ivec &)
elem_mult	/usr/include/itpp/base/svec.h	/^extern template sparse_vec elem_mult(const sparse_vec &, const sparse_vec &);$/;"	p	namespace:itpp	signature:(const sparse_vec &, const sparse_vec &)
elem_mult	/usr/include/itpp/base/svec.h	/^extern template vec elem_mult(const sparse_vec &, const vec &);$/;"	p	namespace:itpp	signature:(const sparse_vec &, const vec &)
elem_mult	/usr/include/itpp/base/svec.h	/^extern template vec elem_mult(const vec &, const sparse_vec &);$/;"	p	namespace:itpp	signature:(const vec &, const sparse_vec &)
elem_mult	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> elem_mult<>(const Vec<Num_T> &a, const Vec<Num_T> &b);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b)
elem_mult	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> elem_mult<>(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, const Vec<Num_T> &c)
elem_mult	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> elem_mult<>(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, const Vec<Num_T> &c, const Vec<Num_T> &d)
elem_mult	/usr/include/itpp/base/vec.h	/^Vec<Num_T> elem_mult(const Vec<Num_T> &a, const Vec<Num_T> &b)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b)
elem_mult	/usr/include/itpp/base/vec.h	/^Vec<Num_T> elem_mult(const Vec<Num_T> &a, const Vec<Num_T> &b);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b)
elem_mult	/usr/include/itpp/base/vec.h	/^Vec<Num_T> elem_mult(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, const Vec<Num_T> &c)
elem_mult	/usr/include/itpp/base/vec.h	/^Vec<Num_T> elem_mult(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, const Vec<Num_T> &c, const Vec<Num_T> &d)
elem_mult	/usr/include/itpp/base/vec.h	/^Vec<Num_T> elem_mult(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, const Vec<Num_T> &c)
elem_mult	/usr/include/itpp/base/vec.h	/^Vec<Num_T> elem_mult(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, const Vec<Num_T> &c, const Vec<Num_T> &d)
elem_mult	/usr/include/itpp/base/vec.h	/^extern template bvec elem_mult(const bvec &a, const bvec &b);$/;"	p	namespace:itpp	signature:(const bvec &a, const bvec &b)
elem_mult	/usr/include/itpp/base/vec.h	/^extern template bvec elem_mult(const bvec &a, const bvec &b, const bvec &c);$/;"	p	namespace:itpp	signature:(const bvec &a, const bvec &b, const bvec &c)
elem_mult	/usr/include/itpp/base/vec.h	/^extern template bvec elem_mult(const bvec &a, const bvec &b,$/;"	p	namespace:itpp	signature:(const bvec &a, const bvec &b, const bvec &c, const bvec &d)
elem_mult	/usr/include/itpp/base/vec.h	/^extern template cvec elem_mult(const cvec &a, const cvec &b);$/;"	p	namespace:itpp	signature:(const cvec &a, const cvec &b)
elem_mult	/usr/include/itpp/base/vec.h	/^extern template cvec elem_mult(const cvec &a, const cvec &b, const cvec &c);$/;"	p	namespace:itpp	signature:(const cvec &a, const cvec &b, const cvec &c)
elem_mult	/usr/include/itpp/base/vec.h	/^extern template cvec elem_mult(const cvec &a, const cvec &b,$/;"	p	namespace:itpp	signature:(const cvec &a, const cvec &b, const cvec &c, const cvec &d)
elem_mult	/usr/include/itpp/base/vec.h	/^extern template ivec elem_mult(const ivec &a, const ivec &b);$/;"	p	namespace:itpp	signature:(const ivec &a, const ivec &b)
elem_mult	/usr/include/itpp/base/vec.h	/^extern template ivec elem_mult(const ivec &a, const ivec &b, const ivec &c);$/;"	p	namespace:itpp	signature:(const ivec &a, const ivec &b, const ivec &c)
elem_mult	/usr/include/itpp/base/vec.h	/^extern template ivec elem_mult(const ivec &a, const ivec &b,$/;"	p	namespace:itpp	signature:(const ivec &a, const ivec &b, const ivec &c, const ivec &d)
elem_mult	/usr/include/itpp/base/vec.h	/^extern template svec elem_mult(const svec &a, const svec &b);$/;"	p	namespace:itpp	signature:(const svec &a, const svec &b)
elem_mult	/usr/include/itpp/base/vec.h	/^extern template svec elem_mult(const svec &a, const svec &b, const svec &c);$/;"	p	namespace:itpp	signature:(const svec &a, const svec &b, const svec &c)
elem_mult	/usr/include/itpp/base/vec.h	/^extern template svec elem_mult(const svec &a, const svec &b,$/;"	p	namespace:itpp	signature:(const svec &a, const svec &b, const svec &c, const svec &d)
elem_mult	/usr/include/itpp/base/vec.h	/^extern template vec elem_mult(const vec &a, const vec &b);$/;"	p	namespace:itpp	signature:(const vec &a, const vec &b)
elem_mult	/usr/include/itpp/base/vec.h	/^extern template vec elem_mult(const vec &a, const vec &b, const vec &c);$/;"	p	namespace:itpp	signature:(const vec &a, const vec &b, const vec &c)
elem_mult	/usr/include/itpp/base/vec.h	/^extern template vec elem_mult(const vec &a, const vec &b,$/;"	p	namespace:itpp	signature:(const vec &a, const vec &b, const vec &c, const vec &d)
elem_mult_inplace	/usr/include/itpp/base/mat.h	/^  friend void elem_mult_inplace<>(const Mat<Num_T> &m1, Mat<Num_T> &m2);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, Mat<Num_T> &m2)
elem_mult_inplace	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_inplace(const bmat &m1, bmat &m2);$/;"	p	namespace:itpp	signature:(const bmat &m1, bmat &m2)
elem_mult_inplace	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_inplace(const cmat &m1, cmat &m2);$/;"	p	namespace:itpp	signature:(const cmat &m1, cmat &m2)
elem_mult_inplace	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_inplace(const imat &m1, imat &m2);$/;"	p	namespace:itpp	signature:(const imat &m1, imat &m2)
elem_mult_inplace	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_inplace(const mat &m1, mat &m2);$/;"	p	namespace:itpp	signature:(const mat &m1, mat &m2)
elem_mult_inplace	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_inplace(const smat &m1, smat &m2);$/;"	p	namespace:itpp	signature:(const smat &m1, smat &m2)
elem_mult_inplace	/usr/include/itpp/base/mat.h	/^void elem_mult_inplace(const Mat<Num_T> &m1, Mat<Num_T> &m2)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, Mat<Num_T> &m2)
elem_mult_inplace	/usr/include/itpp/base/mat.h	/^void elem_mult_inplace(const Mat<Num_T> &m1, Mat<Num_T> &m2);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, Mat<Num_T> &m2)
elem_mult_inplace	/usr/include/itpp/base/vec.h	/^  friend void elem_mult_inplace<>(const Vec<Num_T> &a, Vec<Num_T> &b);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &a, Vec<Num_T> &b)
elem_mult_inplace	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_inplace(const bvec &a, bvec &b);$/;"	p	namespace:itpp	signature:(const bvec &a, bvec &b)
elem_mult_inplace	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_inplace(const cvec &a, cvec &b);$/;"	p	namespace:itpp	signature:(const cvec &a, cvec &b)
elem_mult_inplace	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_inplace(const ivec &a, ivec &b);$/;"	p	namespace:itpp	signature:(const ivec &a, ivec &b)
elem_mult_inplace	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_inplace(const svec &a, svec &b);$/;"	p	namespace:itpp	signature:(const svec &a, svec &b)
elem_mult_inplace	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_inplace(const vec &a, vec &b);$/;"	p	namespace:itpp	signature:(const vec &a, vec &b)
elem_mult_inplace	/usr/include/itpp/base/vec.h	/^void elem_mult_inplace(const Vec<Num_T> &a, Vec<Num_T> &b)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &a, Vec<Num_T> &b)
elem_mult_inplace	/usr/include/itpp/base/vec.h	/^void elem_mult_inplace(const Vec<Num_T> &a, Vec<Num_T> &b);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &a, Vec<Num_T> &b)
elem_mult_out	/usr/include/itpp/base/mat.h	/^  friend void elem_mult_out<>(const Mat<Num_T> &m1, const Mat<Num_T> &m2,$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2, Mat<Num_T> &out)
elem_mult_out	/usr/include/itpp/base/mat.h	/^  friend void elem_mult_out<>(const Mat<Num_T> &m1, const Mat<Num_T> &m2,$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2, const Mat<Num_T> &m3, Mat<Num_T> &out)
elem_mult_out	/usr/include/itpp/base/mat.h	/^  friend void elem_mult_out<>(const Mat<Num_T> &m1, const Mat<Num_T> &m2,$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2, const Mat<Num_T> &m3, const Mat<Num_T> &m4, Mat<Num_T> &out)
elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const bmat &m1, const bmat &m2,$/;"	p	namespace:itpp	signature:(const bmat &m1, const bmat &m2, bmat &out)
elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const bmat &m1, const bmat &m2,$/;"	p	namespace:itpp	signature:(const bmat &m1, const bmat &m2, const bmat &m3, bmat &out)
elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const bmat &m1, const bmat &m2,$/;"	p	namespace:itpp	signature:(const bmat &m1, const bmat &m2, const bmat &m3, const bmat &m4, bmat &out)
elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const cmat &m1, const cmat &m2,$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2, cmat &out)
elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const cmat &m1, const cmat &m2,$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2, const cmat &m3, cmat &out)
elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const cmat &m1, const cmat &m2,$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2, const cmat &m3, const cmat &m4, cmat &out)
elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const imat &m1, const imat &m2,$/;"	p	namespace:itpp	signature:(const imat &m1, const imat &m2, const imat &m3, const imat &m4, imat &out)
elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const imat &m1, const imat &m2,$/;"	p	namespace:itpp	signature:(const imat &m1, const imat &m2, const imat &m3, imat &out)
elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const imat &m1, const imat &m2,$/;"	p	namespace:itpp	signature:(const imat &m1, const imat &m2, imat &out)
elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const mat &m1, const mat &m2, mat &out);$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2, mat &out)
elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const mat &m1, const mat &m2,$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2, const mat &m3, const mat &m4, mat &out)
elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const mat &m1, const mat &m2,$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2, const mat &m3, mat &out)
elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const smat &m1, const smat &m2,$/;"	p	namespace:itpp	signature:(const smat &m1, const smat &m2, const smat &m3, const smat &m4, smat &out)
elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const smat &m1, const smat &m2,$/;"	p	namespace:itpp	signature:(const smat &m1, const smat &m2, const smat &m3, smat &out)
elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const smat &m1, const smat &m2,$/;"	p	namespace:itpp	signature:(const smat &m1, const smat &m2, smat &out)
elem_mult_out	/usr/include/itpp/base/mat.h	/^void elem_mult_out(const Mat<Num_T> &m1, const Mat<Num_T> &m2,$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2, Mat<Num_T> &out)
elem_mult_out	/usr/include/itpp/base/mat.h	/^void elem_mult_out(const Mat<Num_T> &m1, const Mat<Num_T> &m2,$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2, const Mat<Num_T> &m3, Mat<Num_T> &out)
elem_mult_out	/usr/include/itpp/base/mat.h	/^void elem_mult_out(const Mat<Num_T> &m1, const Mat<Num_T> &m2,$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2, const Mat<Num_T> &m3, const Mat<Num_T> &m4, Mat<Num_T> &out)
elem_mult_out	/usr/include/itpp/base/mat.h	/^void elem_mult_out(const Mat<Num_T> &m1, const Mat<Num_T> &m2,$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2, Mat<Num_T> &out)
elem_mult_out	/usr/include/itpp/base/mat.h	/^void elem_mult_out(const Mat<Num_T> &m1, const Mat<Num_T> &m2,$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2, const Mat<Num_T> &m3, Mat<Num_T> &out)
elem_mult_out	/usr/include/itpp/base/mat.h	/^void elem_mult_out(const Mat<Num_T> &m1, const Mat<Num_T> &m2,$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2, const Mat<Num_T> &m3, const Mat<Num_T> &m4, Mat<Num_T> &out)
elem_mult_out	/usr/include/itpp/base/vec.h	/^  friend void elem_mult_out<>(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, Vec<Num_T> &out)
elem_mult_out	/usr/include/itpp/base/vec.h	/^  friend void elem_mult_out<>(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, const Vec<Num_T> &c, Vec<Num_T> &out)
elem_mult_out	/usr/include/itpp/base/vec.h	/^  friend void elem_mult_out<>(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, const Vec<Num_T> &c, const Vec<Num_T> &d, Vec<Num_T> &out)
elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const bvec &a, const bvec &b, bvec &out);$/;"	p	namespace:itpp	signature:(const bvec &a, const bvec &b, bvec &out)
elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const bvec &a, const bvec &b,$/;"	p	namespace:itpp	signature:(const bvec &a, const bvec &b, const bvec &c, bvec &out)
elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const bvec &a, const bvec &b,$/;"	p	namespace:itpp	signature:(const bvec &a, const bvec &b, const bvec &c, const bvec &d, bvec &out)
elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const cvec &a, const cvec &b, cvec &out);$/;"	p	namespace:itpp	signature:(const cvec &a, const cvec &b, cvec &out)
elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const cvec &a, const cvec &b,$/;"	p	namespace:itpp	signature:(const cvec &a, const cvec &b, const cvec &c, const cvec &d, cvec &out)
elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const cvec &a, const cvec &b,$/;"	p	namespace:itpp	signature:(const cvec &a, const cvec &b, const cvec &c, cvec &out)
elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const ivec &a, const ivec &b, ivec &out);$/;"	p	namespace:itpp	signature:(const ivec &a, const ivec &b, ivec &out)
elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const ivec &a, const ivec &b,$/;"	p	namespace:itpp	signature:(const ivec &a, const ivec &b, const ivec &c, const ivec &d, ivec &out)
elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const ivec &a, const ivec &b,$/;"	p	namespace:itpp	signature:(const ivec &a, const ivec &b, const ivec &c, ivec &out)
elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const svec &a, const svec &b, svec &out);$/;"	p	namespace:itpp	signature:(const svec &a, const svec &b, svec &out)
elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const svec &a, const svec &b,$/;"	p	namespace:itpp	signature:(const svec &a, const svec &b, const svec &c, const svec &d, svec &out)
elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const svec &a, const svec &b,$/;"	p	namespace:itpp	signature:(const svec &a, const svec &b, const svec &c, svec &out)
elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const vec &a, const vec &b, const vec &c,$/;"	p	namespace:itpp	signature:(const vec &a, const vec &b, const vec &c, const vec &d, vec &out)
elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const vec &a, const vec &b, vec &out);$/;"	p	namespace:itpp	signature:(const vec &a, const vec &b, vec &out)
elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const vec &a, const vec &b,$/;"	p	namespace:itpp	signature:(const vec &a, const vec &b, const vec &c, vec &out)
elem_mult_out	/usr/include/itpp/base/vec.h	/^void elem_mult_out(const Vec<Num_T> &a, const Vec<Num_T> &b, Vec<Num_T> &out)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, Vec<Num_T> &out)
elem_mult_out	/usr/include/itpp/base/vec.h	/^void elem_mult_out(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, const Vec<Num_T> &c, Vec<Num_T> &out)
elem_mult_out	/usr/include/itpp/base/vec.h	/^void elem_mult_out(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, const Vec<Num_T> &c, const Vec<Num_T> &d, Vec<Num_T> &out)
elem_mult_out	/usr/include/itpp/base/vec.h	/^void elem_mult_out(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, Vec<Num_T> &out)
elem_mult_out	/usr/include/itpp/base/vec.h	/^void elem_mult_out(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, const Vec<Num_T> &c, Vec<Num_T> &out)
elem_mult_out	/usr/include/itpp/base/vec.h	/^void elem_mult_out(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, const Vec<Num_T> &c, const Vec<Num_T> &d, Vec<Num_T> &out)
elem_mult_s	/usr/include/itpp/base/svec.h	/^  friend Sparse_Vec<T> elem_mult_s <>(const Sparse_Vec<T> &v1, const Vec<T> &v2);$/;"	p	class:itpp::Sparse_Vec	access:friend	signature:(const Sparse_Vec<T> &v1, const Vec<T> &v2)
elem_mult_s	/usr/include/itpp/base/svec.h	/^  friend Sparse_Vec<T> elem_mult_s <>(const Vec<T> &v1, const Sparse_Vec<T> &v2);$/;"	p	class:itpp::Sparse_Vec	access:friend	signature:(const Vec<T> &v1, const Sparse_Vec<T> &v2)
elem_mult_s	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T> elem_mult_s(const Sparse_Vec<T> &v1, const Vec<T> &v2)$/;"	f	namespace:itpp	signature:(const Sparse_Vec<T> &v1, const Vec<T> &v2)
elem_mult_s	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T> elem_mult_s(const Sparse_Vec<T> &v1, const Vec<T> &v2);$/;"	p	namespace:itpp	signature:(const Sparse_Vec<T> &v1, const Vec<T> &v2)
elem_mult_s	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T> elem_mult_s(const Vec<T> &v1, const Sparse_Vec<T> &v2)$/;"	f	namespace:itpp	signature:(const Vec<T> &v1, const Sparse_Vec<T> &v2)
elem_mult_s	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T> elem_mult_s(const Vec<T> &v1, const Sparse_Vec<T> &v2);$/;"	p	namespace:itpp	signature:(const Vec<T> &v1, const Sparse_Vec<T> &v2)
elem_mult_s	/usr/include/itpp/base/svec.h	/^extern template sparse_cvec elem_mult_s(const cvec &, const sparse_cvec &);$/;"	p	namespace:itpp	signature:(const cvec &, const sparse_cvec &)
elem_mult_s	/usr/include/itpp/base/svec.h	/^extern template sparse_cvec elem_mult_s(const sparse_cvec &, const cvec &);$/;"	p	namespace:itpp	signature:(const sparse_cvec &, const cvec &)
elem_mult_s	/usr/include/itpp/base/svec.h	/^extern template sparse_ivec elem_mult_s(const ivec &, const sparse_ivec &);$/;"	p	namespace:itpp	signature:(const ivec &, const sparse_ivec &)
elem_mult_s	/usr/include/itpp/base/svec.h	/^extern template sparse_ivec elem_mult_s(const sparse_ivec &, const ivec &);$/;"	p	namespace:itpp	signature:(const sparse_ivec &, const ivec &)
elem_mult_s	/usr/include/itpp/base/svec.h	/^extern template sparse_vec elem_mult_s(const sparse_vec &, const vec &);$/;"	p	namespace:itpp	signature:(const sparse_vec &, const vec &)
elem_mult_s	/usr/include/itpp/base/svec.h	/^extern template sparse_vec elem_mult_s(const vec &, const sparse_vec &);$/;"	p	namespace:itpp	signature:(const vec &, const sparse_vec &)
elem_mult_sum	/usr/include/itpp/base/mat.h	/^  friend Num_T elem_mult_sum<>(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
elem_mult_sum	/usr/include/itpp/base/mat.h	/^Num_T elem_mult_sum(const Mat<Num_T> &m1, const Mat<Num_T> &m2)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
elem_mult_sum	/usr/include/itpp/base/mat.h	/^Num_T elem_mult_sum(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
elem_mult_sum	/usr/include/itpp/base/mat.h	/^extern template bin elem_mult_sum(const bmat &m1, const bmat &m2);$/;"	p	namespace:itpp	signature:(const bmat &m1, const bmat &m2)
elem_mult_sum	/usr/include/itpp/base/mat.h	/^extern template double elem_mult_sum(const mat &m1, const mat &m2);$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2)
elem_mult_sum	/usr/include/itpp/base/mat.h	/^extern template int elem_mult_sum(const imat &m1, const imat &m2);$/;"	p	namespace:itpp	signature:(const imat &m1, const imat &m2)
elem_mult_sum	/usr/include/itpp/base/mat.h	/^extern template short elem_mult_sum(const smat &m1, const smat &m2);$/;"	p	namespace:itpp	signature:(const smat &m1, const smat &m2)
elem_mult_sum	/usr/include/itpp/base/mat.h	/^extern template std::complex<double> elem_mult_sum(const cmat &m1,$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2)
elem_mult_sum	/usr/include/itpp/base/vec.h	/^  friend Num_T elem_mult_sum<>(const Vec<Num_T> &a, const Vec<Num_T> &b);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b)
elem_mult_sum	/usr/include/itpp/base/vec.h	/^Num_T elem_mult_sum(const Vec<Num_T> &a, const Vec<Num_T> &b)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b)
elem_mult_sum	/usr/include/itpp/base/vec.h	/^Num_T elem_mult_sum(const Vec<Num_T> &a, const Vec<Num_T> &b);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b)
elem_mult_sum	/usr/include/itpp/base/vec.h	/^extern template bin elem_mult_sum(const bvec &a, const bvec &b);$/;"	p	namespace:itpp	signature:(const bvec &a, const bvec &b)
elem_mult_sum	/usr/include/itpp/base/vec.h	/^extern template double elem_mult_sum(const vec &a, const vec &b);$/;"	p	namespace:itpp	signature:(const vec &a, const vec &b)
elem_mult_sum	/usr/include/itpp/base/vec.h	/^extern template int elem_mult_sum(const ivec &a, const ivec &b);$/;"	p	namespace:itpp	signature:(const ivec &a, const ivec &b)
elem_mult_sum	/usr/include/itpp/base/vec.h	/^extern template short elem_mult_sum(const svec &a, const svec &b);$/;"	p	namespace:itpp	signature:(const svec &a, const svec &b)
elem_mult_sum	/usr/include/itpp/base/vec.h	/^extern template std::complex<double> elem_mult_sum(const cvec &a,$/;"	p	namespace:itpp	signature:(const cvec &a, const cvec &b)
emode	/usr/include/itpp/fixed/fix_base.h	/^  e_mode emode;$/;"	m	class:itpp::Fix_Base	access:protected
emode	/usr/include/itpp/fixed/fix_factory.h	/^  e_mode emode;$/;"	m	class:itpp::Fix_Factory	access:protected
enable_c_access	/usr/include/itpp/stat/mog_diag.h	/^  double * enable_c_access(vec & v_in);$/;"	p	class:itpp::MOG_diag	access:protected	signature:(vec & v_in)
enable_c_access	/usr/include/itpp/stat/mog_diag.h	/^  double ** enable_c_access(Array<vec> & A_in);$/;"	p	class:itpp::MOG_diag	access:protected	signature:(Array<vec> & A_in)
enable_c_access	/usr/include/itpp/stat/mog_diag.h	/^  int * enable_c_access(ivec & v_in);$/;"	p	class:itpp::MOG_diag	access:protected	signature:(ivec & v_in)
enable_c_access	/usr/include/itpp/stat/mog_diag.h	/^  int ** enable_c_access(Array<ivec> & A_in);$/;"	p	class:itpp::MOG_diag	access:protected	signature:(Array<ivec> & A_in)
enable_trace	/usr/include/itpp/optim/newton_search.h	/^  void enable_trace() { trace = true; }$/;"	f	class:itpp::Line_Search	access:public	signature:()
enable_trace	/usr/include/itpp/optim/newton_search.h	/^  void enable_trace() { trace = true; }$/;"	f	class:itpp::Newton_Search	access:public	signature:()
enc_alaw8	/usr/include/itpp/srccode/audiofile.h	/^                       enc_alaw8    = 27,$/;"	e	enum:itpp::SND_Format::data_encoding
enc_double	/usr/include/itpp/srccode/audiofile.h	/^                       enc_double   =  7$/;"	e	enum:itpp::SND_Format::data_encoding
enc_float	/usr/include/itpp/srccode/audiofile.h	/^                       enc_float    =  6,$/;"	e	enum:itpp::SND_Format::data_encoding
enc_linear16	/usr/include/itpp/srccode/audiofile.h	/^                       enc_linear16 =  3,$/;"	e	enum:itpp::SND_Format::data_encoding
enc_linear24	/usr/include/itpp/srccode/audiofile.h	/^                       enc_linear24 =  4,$/;"	e	enum:itpp::SND_Format::data_encoding
enc_linear32	/usr/include/itpp/srccode/audiofile.h	/^                       enc_linear32 =  5,$/;"	e	enum:itpp::SND_Format::data_encoding
enc_linear8	/usr/include/itpp/srccode/audiofile.h	/^                       enc_linear8  =  2,$/;"	e	enum:itpp::SND_Format::data_encoding
enc_mulaw8	/usr/include/itpp/srccode/audiofile.h	/^                       enc_mulaw8   =  1,$/;"	e	enum:itpp::SND_Format::data_encoding
enc_unknown	/usr/include/itpp/srccode/audiofile.h	/^  enum data_encoding { enc_unknown  =  0,$/;"	e	enum:itpp::SND_Format::data_encoding
encode	/usr/include/itpp/comm/bch.h	/^  virtual bvec encode(const bvec &uncoded_bits);$/;"	p	class:itpp::BCH	access:public	signature:(const bvec &uncoded_bits)
encode	/usr/include/itpp/comm/bch.h	/^  virtual void encode(const bvec &uncoded_bits, bvec &coded_bits);$/;"	p	class:itpp::BCH	access:public	signature:(const bvec &uncoded_bits, bvec &coded_bits)
encode	/usr/include/itpp/comm/channel_code.h	/^  virtual bvec encode(const bvec &uncoded_bits) = 0;$/;"	p	class:itpp::Channel_Code	access:public	signature:(const bvec &uncoded_bits)
encode	/usr/include/itpp/comm/channel_code.h	/^  virtual bvec encode(const bvec &uncoded_bits) { return uncoded_bits; }$/;"	f	class:itpp::Dummy_Code	access:public	signature:(const bvec &uncoded_bits)
encode	/usr/include/itpp/comm/channel_code.h	/^  virtual void encode(const bvec &uncoded_bits, bvec &coded_bits) = 0;$/;"	p	class:itpp::Channel_Code	access:public	signature:(const bvec &uncoded_bits, bvec &coded_bits)
encode	/usr/include/itpp/comm/channel_code.h	/^  virtual void encode(const bvec &uncoded_bits, bvec &coded_bits) { coded_bits = uncoded_bits; }$/;"	f	class:itpp::Dummy_Code	access:public	signature:(const bvec &uncoded_bits, bvec &coded_bits)
encode	/usr/include/itpp/comm/convcode.h	/^  virtual bvec encode(const bvec &input) {$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(const bvec &input)
encode	/usr/include/itpp/comm/convcode.h	/^  virtual void encode(const bvec &input, bvec &output);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const bvec &input, bvec &output)
encode	/usr/include/itpp/comm/crc.h	/^  bvec encode(const bvec &in_bits) const;$/;"	p	class:itpp::CRC_Code	access:public	signature:(const bvec &in_bits) const
encode	/usr/include/itpp/comm/crc.h	/^  void encode(const bvec &in_bits, bvec &out) const;$/;"	p	class:itpp::CRC_Code	access:public	signature:(const bvec &in_bits, bvec &out) const
encode	/usr/include/itpp/comm/egolay.h	/^  virtual bvec encode(const bvec &uncoded_bits);$/;"	p	class:itpp::Extended_Golay	access:public	signature:(const bvec &uncoded_bits)
encode	/usr/include/itpp/comm/egolay.h	/^  virtual void encode(const bvec &uncoded_bits, bvec &coded_bits);$/;"	p	class:itpp::Extended_Golay	access:public	signature:(const bvec &uncoded_bits, bvec &coded_bits)
encode	/usr/include/itpp/comm/hammcode.h	/^  virtual bvec encode(const bvec &uncoded_bits);$/;"	p	class:itpp::Hamming_Code	access:public	signature:(const bvec &uncoded_bits)
encode	/usr/include/itpp/comm/hammcode.h	/^  virtual void encode(const bvec &uncoded_bits, bvec &coded_bits);$/;"	p	class:itpp::Hamming_Code	access:public	signature:(const bvec &uncoded_bits, bvec &coded_bits)
encode	/usr/include/itpp/comm/ldpc.h	/^  virtual bvec encode(const bvec &input);$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const bvec &input)
encode	/usr/include/itpp/comm/ldpc.h	/^  virtual void encode(const bvec &input, bvec &output) = 0;$/;"	p	class:itpp::LDPC_Generator	access:public	signature:(const bvec &input, bvec &output)
encode	/usr/include/itpp/comm/ldpc.h	/^  virtual void encode(const bvec &input, bvec &output);$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const bvec &input, bvec &output)
encode	/usr/include/itpp/comm/ldpc.h	/^  virtual void encode(const bvec &input, bvec &output);$/;"	p	class:itpp::LDPC_Generator_Systematic	access:public	signature:(const bvec &input, bvec &output)
encode	/usr/include/itpp/comm/ldpc.h	/^  void encode(const bvec &input, bvec &output);$/;"	p	class:itpp::BLDPC_Generator	access:public	signature:(const bvec &input, bvec &output)
encode	/usr/include/itpp/comm/punct_convcode.h	/^  bvec encode(const bvec &input) { bvec output; encode(input, output); return output; }$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const bvec &input)
encode	/usr/include/itpp/comm/punct_convcode.h	/^  void encode(const bvec &input, bvec &output);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const bvec &input, bvec &output)
encode	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  void encode(const bvec &input, bmat &parity_bits);$/;"	p	class:itpp::Rec_Syst_Conv_Code	access:public	signature:(const bvec &input, bmat &parity_bits)
encode	/usr/include/itpp/comm/reedsolomon.h	/^  virtual bvec encode(const bvec &uncoded_bits);$/;"	p	class:itpp::Reed_Solomon	access:public	signature:(const bvec &uncoded_bits)
encode	/usr/include/itpp/comm/reedsolomon.h	/^  virtual void encode(const bvec &uncoded_bits, bvec &coded_bits);$/;"	p	class:itpp::Reed_Solomon	access:public	signature:(const bvec &uncoded_bits, bvec &coded_bits)
encode	/usr/include/itpp/comm/turbo.h	/^  void encode(const bvec &input, bvec &output);$/;"	p	class:itpp::Turbo_Codec	access:public	signature:(const bvec &input, bvec &output)
encode	/usr/include/itpp/srccode/vq.h	/^  int encode(const vec &x);$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:(const vec &x)
encode	/usr/include/itpp/srccode/vq.h	/^  int encode(double x) const;$/;"	p	class:itpp::Scalar_Quantizer	access:public	signature:(double x) const
encode	/usr/include/itpp/srccode/vq.h	/^  ivec encode(const vec &x) const;$/;"	p	class:itpp::Scalar_Quantizer	access:public	signature:(const vec &x) const
encode	/usr/include/itpp/srccode/vq.h	/^  ivec encode(const vec &x, int num);$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:(const vec &x, int num)
encode_bit	/usr/include/itpp/comm/convcode.h	/^  bvec encode_bit(const bin &input) {$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(const bin &input)
encode_bit	/usr/include/itpp/comm/convcode.h	/^  void encode_bit(const bin &input, bvec &output);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const bin &input, bvec &output)
encode_block	/usr/include/itpp/comm/turbo.h	/^  void encode_block(const bvec &input, bvec &in1, bvec &in2, bmat &parity1, bmat &parity2);$/;"	p	class:itpp::Turbo_Codec	access:public	signature:(const bvec &input, bvec &in1, bvec &in2, bmat &parity1, bmat &parity2)
encode_tail	/usr/include/itpp/comm/convcode.h	/^  bvec encode_tail(const bvec &input) {$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(const bvec &input)
encode_tail	/usr/include/itpp/comm/convcode.h	/^  void encode_tail(const bvec &input, bvec &output);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const bvec &input, bvec &output)
encode_tail	/usr/include/itpp/comm/punct_convcode.h	/^  bvec encode_tail(const bvec &input) { bvec output; encode_tail(input, output); return output; }$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const bvec &input)
encode_tail	/usr/include/itpp/comm/punct_convcode.h	/^  void encode_tail(const bvec &input, bvec &output);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const bvec &input, bvec &output)
encode_tail	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  void encode_tail(const bvec &input, bvec &tail, bmat &parity_bits);$/;"	p	class:itpp::Rec_Syst_Conv_Code	access:public	signature:(const bvec &input, bvec &tail, bmat &parity_bits)
encode_tailbite	/usr/include/itpp/comm/convcode.h	/^  bvec encode_tailbite(const bvec &input) {$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(const bvec &input)
encode_tailbite	/usr/include/itpp/comm/convcode.h	/^  void encode_tailbite(const bvec &input, bvec &output);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const bvec &input, bvec &output)
encode_tailbite	/usr/include/itpp/comm/punct_convcode.h	/^  bvec encode_tailbite(const bvec &input)$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const bvec &input)
encode_tailbite	/usr/include/itpp/comm/punct_convcode.h	/^  void encode_tailbite(const bvec &input, bvec &output);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const bvec &input, bvec &output)
encode_trunc	/usr/include/itpp/comm/convcode.h	/^  bvec encode_trunc(const bvec &input) {$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(const bvec &input)
encode_trunc	/usr/include/itpp/comm/convcode.h	/^  void encode_trunc(const bvec &input, bvec &output);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const bvec &input, bvec &output)
encode_trunc	/usr/include/itpp/comm/punct_convcode.h	/^  bvec encode_trunc(const bvec &input) { bvec output; encode_trunc(input, output); return output; }$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const bvec &input)
encode_trunc	/usr/include/itpp/comm/punct_convcode.h	/^  void encode_trunc(const bvec &input, bvec &output);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const bvec &input, bvec &output)
encoder_state	/usr/include/itpp/comm/convcode.h	/^  int encoder_state;$/;"	m	class:itpp::Convolutional_Code	access:protected
encoder_state	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  int encoder_state, Nstates;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
encoding	/usr/include/itpp/srccode/audiofile.h	/^    unsigned encoding;$/;"	m	struct:itpp::SND_Format::__anon1	access:public
encoding	/usr/include/itpp/srccode/audiofile.h	/^  data_encoding encoding() const { return (data_encoding)header.encoding; }$/;"	f	class:itpp::SND_Format	access:public	signature:() const
end	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number end() const { return seq_end; }$/;"	f	class:itpp::TCP_Segment	access:public	signature:() const
endian	/usr/include/itpp/base/binfile.h	/^  enum endian { l_endian, b_endian };$/;"	g	class:itpp::bfstream_base	access:public
endianity	/usr/include/itpp/base/itfile.h	/^    char endianity;$/;"	m	struct:itpp::it_file_base_old::data_header	access:public
energy	/usr/include/itpp/stat/misc_stat.h	/^double energy(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
eps	/usr/include/itpp/base/math/misc.h	/^const double eps = std::numeric_limits<double>::epsilon();$/;"	m	namespace:itpp
eps	/usr/include/itpp/base/svec.h	/^  T eps;$/;"	m	class:itpp::Sparse_Vec	access:private
epsilon	/usr/include/itpp/signal/fastica.h	/^  double a1, a2, mu, epsilon, sampleSize;$/;"	m	class:itpp::Fast_ICA	access:private
erf	/usr/include/itpp/base/math/error.h	/^double erf(double x);$/;"	p	signature:(double x)
erf	/usr/include/itpp/base/math/error.h	/^inline cmat erf(const cmat &x)$/;"	f	namespace:itpp	signature:(const cmat &x)
erf	/usr/include/itpp/base/math/error.h	/^inline cvec erf(const cvec &x)$/;"	f	namespace:itpp	signature:(const cvec &x)
erf	/usr/include/itpp/base/math/error.h	/^inline mat erf(const mat &x)$/;"	f	namespace:itpp	signature:(const mat &x)
erf	/usr/include/itpp/base/math/error.h	/^inline vec erf(const vec &x)$/;"	f	namespace:itpp	signature:(const vec &x)
erf	/usr/include/itpp/base/math/error.h	/^std::complex<double> erf(const std::complex<double>& z);$/;"	p	namespace:itpp	signature:(const std::complex<double>& z)
erfc	/usr/include/itpp/base/math/error.h	/^double erfc(double x);$/;"	p	signature:(double x)
erfc	/usr/include/itpp/base/math/error.h	/^inline mat erfc(const mat &x)$/;"	f	namespace:itpp	signature:(const mat &x)
erfc	/usr/include/itpp/base/math/error.h	/^inline vec erfc(const vec &x)$/;"	f	namespace:itpp	signature:(const vec &x)
erfinv	/usr/include/itpp/base/math/error.h	/^double erfinv(double x);$/;"	p	namespace:itpp	signature:(double x)
erfinv	/usr/include/itpp/base/math/error.h	/^inline mat erfinv(const mat &x)$/;"	f	namespace:itpp	signature:(const mat &x)
erfinv	/usr/include/itpp/base/math/error.h	/^inline vec erfinv(const vec &x)$/;"	f	namespace:itpp	signature:(const vec &x)
error_msg_style	/usr/include/itpp/base/itassert.h	/^enum error_msg_style { Full, Minimum };$/;"	g	namespace:itpp
errors	/usr/include/itpp/comm/error_counters.h	/^  double errors;$/;"	m	class:itpp::BERC	access:private
errors	/usr/include/itpp/comm/error_counters.h	/^  double errors;$/;"	m	class:itpp::BLERC	access:private
estimate_delay	/usr/include/itpp/comm/error_counters.h	/^  void estimate_delay(const bvec &in1, const bvec &in2, int mindelay = -100,$/;"	p	class:itpp::BERC	access:public	signature:(const bvec &in1, const bvec &in2, int mindelay = -100, int maxdelay = 100)
event_queue	/usr/include/itpp/protocol/events.h	/^  Compare_Base_Event_Times > event_queue; \/\/ Queue for the Events.$/;"	m	class:itpp::Event_Queue	access:private
exec	/usr/include/itpp/protocol/events.h	/^  virtual void exec(void) = 0;$/;"	p	class:itpp::Base_Event	access:protected	signature:(void)
exec	/usr/include/itpp/protocol/events.h	/^  virtual void exec(void) {$/;"	f	class:itpp::Data_Event	access:public	signature:(void)
exec	/usr/include/itpp/protocol/events.h	/^  virtual void exec(void) {(*po.*pm)(); }$/;"	f	class:itpp::Event	access:public	signature:(void)
exist	/usr/include/itpp/base/binfile.h	/^bool exist(const std::string& name);$/;"	p	namespace:itpp	signature:(const std::string& name)
exist	/usr/include/itpp/base/parser.h	/^  bool exist(const std::string &name);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &name)
exists	/usr/include/itpp/base/itfile.h	/^  bool exists(const std::string& name);$/;"	p	class:itpp::it_file	access:public	signature:(const std::string& name)
exists	/usr/include/itpp/base/itfile.h	/^  bool exists(const std::string& name);$/;"	p	class:itpp::it_file_old	access:public	signature:(const std::string& name)
exp	/usr/include/itpp/base/math/log_exp.h	/^inline cmat exp(const cmat &m)$/;"	f	namespace:itpp	signature:(const cmat &m)
exp	/usr/include/itpp/base/math/log_exp.h	/^inline cvec exp(const cvec &x)$/;"	f	namespace:itpp	signature:(const cvec &x)
exp	/usr/include/itpp/base/math/log_exp.h	/^inline mat exp(const mat &m)$/;"	f	namespace:itpp	signature:(const mat &m)
exp	/usr/include/itpp/base/math/log_exp.h	/^inline vec exp(const vec &x)$/;"	f	namespace:itpp	signature:(const vec &x)
expand_base	/usr/include/itpp/comm/ldpc.h	/^  void expand_base(const imat &base_matrix, int exp_factor);$/;"	p	class:itpp::BLDPC_Parity	access:public	signature:(const imat &base_matrix, int exp_factor)
expire_t	/usr/include/itpp/protocol/events.h	/^  Ttype expire_t;$/;"	m	class:itpp::Base_Event	access:protected
explicit_errors	/usr/include/itpp/protocol/packet_channel.h	/^  bool explicit_errors;$/;"	m	class:itpp::ACK_Channel	access:private
explicit_errors	/usr/include/itpp/protocol/packet_channel.h	/^  bool explicit_errors;$/;"	m	class:itpp::Packet_Channel	access:private
export_alist	/usr/include/itpp/comm/ldpc.h	/^  GF2mat_sparse_alist export_alist() const;$/;"	p	class:itpp::LDPC_Parity	access:public	signature:() const
eye	/usr/include/itpp/base/specmat.h	/^mat eye(int size);$/;"	p	namespace:itpp	signature:(int size)
eye	/usr/include/itpp/base/specmat.h	/^void eye(int size, Mat<T> &m);$/;"	p	namespace:itpp	signature:(int size, Mat<T> &m)
eye_b	/usr/include/itpp/base/specmat.h	/^bmat eye_b(int size);$/;"	p	namespace:itpp	signature:(int size)
eye_c	/usr/include/itpp/base/specmat.h	/^cmat eye_c(int size);$/;"	p	namespace:itpp	signature:(int size)
eye_i	/usr/include/itpp/base/specmat.h	/^imat eye_i(int size);$/;"	p	namespace:itpp	signature:(int size)
f	/usr/include/itpp/optim/newton_search.h	/^  double(*f)(const vec&);  \/\/ function to minimize$/;"	m	class:itpp::Line_Search	access:private
f	/usr/include/itpp/optim/newton_search.h	/^  double(*f)(const vec&);  \/\/ function to minimize$/;"	m	class:itpp::Newton_Search	access:private
f01	/usr/include/itpp/comm/channel.h	/^  double f01, f02;$/;"	m	class:itpp::Rice_Fading_Generator	access:protected
f02	/usr/include/itpp/comm/channel.h	/^  double f01, f02;$/;"	m	class:itpp::Rice_Fading_Generator	access:protected
f1	/usr/include/itpp/comm/channel.h	/^  vec f1, f2, c1, c2, th1, th2;$/;"	m	class:itpp::Rice_Fading_Generator	access:protected
f2	/usr/include/itpp/comm/channel.h	/^  vec f1, f2, c1, c2, th1, th2;$/;"	m	class:itpp::Rice_Fading_Generator	access:protected
fACK	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number   fACK;           \/**< \\brief acknowledgment (next expected sn) *\/$/;"	m	class:itpp::TCP_Packet	access:protected
fACKDelayTime	/usr/include/itpp/protocol/tcp.h	/^  Ttype  fACKDelayTime;       \/**< \\brief maximum time for delaying ACKs *\/$/;"	m	class:itpp::TCP_Receiver	access:private
fACKOnBufferRead	/usr/include/itpp/protocol/tcp.h	/^  bool  fACKOnBufferRead;    \/**< \\brief send ACK when segment is read by user *\/$/;"	m	class:itpp::TCP_Receiver	access:private
fACKOnBufferWrite	/usr/include/itpp/protocol/tcp.h	/^  bool  fACKOnBufferWrite;   \/**< \\brief send ACK after segment has been written *\/$/;"	m	class:itpp::TCP_Receiver	access:private
fACKSchedulingDelay	/usr/include/itpp/protocol/tcp.h	/^  Ttype  fACKSchedulingDelay; \/**< \\brief ACK delay due to proc. scheduling *\/$/;"	m	class:itpp::TCP_Receiver	access:private
fACKSchedulingTimer	/usr/include/itpp/protocol/tcp.h	/^  TTimer<TCP_Receiver> fACKSchedulingTimer;$/;"	m	class:itpp::TCP_Receiver	access:private
fAdvRcvNxt	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number fAdvRcvNxt;       \/**< \\brief advertised next expected byte (ACK) *\/$/;"	m	class:itpp::TCP_Receiver	access:private
fAdvRcvWnd	/usr/include/itpp/protocol/tcp.h	/^  unsigned        fAdvRcvWnd;       \/**< \\brief advertised receiver window *\/$/;"	m	class:itpp::TCP_Receiver	access:private
fBackoff	/usr/include/itpp/protocol/tcp.h	/^  int           fBackoff;               \/**< \\brief backoff for rtx timer *\/$/;"	m	class:itpp::TCP_Sender	access:private
fBufList	/usr/include/itpp/protocol/tcp.h	/^  std::list <TCP_Segment> fBufList;$/;"	m	class:itpp::TCP_Receiver_Buffer	access:protected
fBufferSize	/usr/include/itpp/protocol/tcp.h	/^  unsigned  fBufferSize;       \/**< \\brief size of receiver buffer *\/$/;"	m	class:itpp::TCP_Receiver	access:private
fCWnd	/usr/include/itpp/protocol/tcp.h	/^    unsigned   fCWnd; \/\/!< ADD DOCUMENTATION HERE$/;"	m	struct:itpp::TCP_Packet::TDebugInfo	access:public
fCWnd	/usr/include/itpp/protocol/tcp.h	/^  unsigned  fCWnd;       \/\/ congestion window$/;"	m	class:itpp::TCP_Sender	access:private
fCarefulMulFastRtxAvoidance	/usr/include/itpp/protocol/tcp.h	/^  bool  fCarefulMulFastRtxAvoidance; \/**< \\brief see RFC 2582, Section 5 *\/$/;"	m	class:itpp::TCP_Sender	access:private
fCarefulSSThreshReduction	/usr/include/itpp/protocol/tcp.h	/^  bool  fCarefulSSThreshReduction; \/**< \\brief use min(cwnd, flight size)\/2 *\/$/;"	m	class:itpp::TCP_Sender	access:private
fDebug	/usr/include/itpp/protocol/tcp.h	/^  bool         fDebug;              \/**< \\brief print additional information *\/$/;"	m	class:itpp::TCP_Receiver	access:private
fDebug	/usr/include/itpp/protocol/tcp.h	/^  bool   fDebug;      \/\/ print additional information to cout$/;"	m	class:itpp::TCP_Sender	access:private
fDelayedACK	/usr/include/itpp/protocol/tcp.h	/^  bool         fDelayedACK;         \/**< \\brief if true, use delayed ACK *\/$/;"	m	class:itpp::TCP_Receiver	access:private
fDelayedACKTimer	/usr/include/itpp/protocol/tcp.h	/^  TTimer<TCP_Receiver> fDelayedACKTimer; \/**< \\brief timer for delayed ACK *\/$/;"	m	class:itpp::TCP_Receiver	access:private
fDestinationPort	/usr/include/itpp/protocol/tcp.h	/^  unsigned             fDestinationPort;$/;"	m	class:itpp::TCP_Packet	access:protected
fDupACKCnt	/usr/include/itpp/protocol/tcp.h	/^  unsigned fDupACKCnt;     \/**< \\brief counter for duplicate ACKs *\/$/;"	m	class:itpp::TCP_Sender	access:private
fDupACKThreshold	/usr/include/itpp/protocol/tcp.h	/^  unsigned  fDupACKThreshold;   \/**< \\brief duplicate ACK threshold *\/$/;"	m	class:itpp::TCP_Sender	access:private
fExpirationTime	/usr/include/itpp/protocol/signals_slots.h	/^  Ttype  fExpirationTime;$/;"	m	class:itpp::TTimer	access:protected
fFirstByte	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number fFirstByte;         \/**< \\brief first byte stored or missing *\/$/;"	m	class:itpp::TCP_Receiver_Buffer	access:protected
fFlightSizeRecovery	/usr/include/itpp/protocol/tcp.h	/^  bool  fFlightSizeRecovery;\/\/ use flight size on fast rec. exit$/;"	m	class:itpp::TCP_Sender	access:private
fGoBackN	/usr/include/itpp/protocol/tcp.h	/^  bool  fGoBackN;           \/**< \\brief use go-back-N on TO rtx *\/$/;"	m	class:itpp::TCP_Sender	access:private
fIgnoreDupACKOnTORecovery	/usr/include/itpp/protocol/tcp.h	/^  bool  fIgnoreDupACKOnTORecovery; \/**< \\brief avoid fast rtx during TO recovery *\/$/;"	m	class:itpp::TCP_Sender	access:private
fImmediateBackoffReset	/usr/include/itpp/protocol/tcp.h	/^  bool  fImmediateBackoffReset; \/**< \\brief reset backoff on first new ACK *\/$/;"	m	class:itpp::TCP_Sender	access:private
fInfo	/usr/include/itpp/protocol/tcp.h	/^  TDebugInfo  *fInfo;$/;"	m	class:itpp::TCP_Packet	access:protected
fInitialCWnd	/usr/include/itpp/protocol/tcp.h	/^  unsigned  fInitialCWnd;       \/**< \\brief initial congestion window -> RFC 2581 *\/$/;"	m	class:itpp::TCP_Sender	access:private
fInitialRTT	/usr/include/itpp/protocol/tcp.h	/^  double       fInitialRTT;        \/**< \\brief RTT assumed before first measurement *\/$/;"	m	class:itpp::TCP_Sender	access:private
fInitialSSThresh	/usr/include/itpp/protocol/tcp.h	/^  unsigned  fInitialSSThresh;   \/**< \\brief initial ssthresh -> RFC 2581 *\/$/;"	m	class:itpp::TCP_Sender	access:private
fKarn	/usr/include/itpp/protocol/tcp.h	/^  bool  fKarn;              \/**< \\brief exclude rtx packets from RTTM *\/$/;"	m	class:itpp::TCP_Sender	access:private
fLabel	/usr/include/itpp/protocol/tcp.h	/^  unsigned              fLabel;$/;"	m	class:itpp::TCP_Receiver	access:private
fLabel	/usr/include/itpp/protocol/tcp.h	/^  unsigned fLabel; \/\/ end point identification also used at receiver$/;"	m	class:itpp::TCP_Sender	access:private
fLastSendTime	/usr/include/itpp/protocol/tcp.h	/^  Ttype   fLastSendTime; \/**< \\brief idle detection for SSR *\/$/;"	m	class:itpp::TCP_Sender	access:private
fMSS	/usr/include/itpp/protocol/tcp.h	/^  unsigned     fMSS;            \/**< \\brief maximum segment size *\/$/;"	m	class:itpp::TCP_Receiver	access:private
fMSS	/usr/include/itpp/protocol/tcp.h	/^  unsigned  fMSS;             \/\/ maximum segment size$/;"	m	class:itpp::TCP_Sender	access:private
fMaxBackoff	/usr/include/itpp/protocol/tcp.h	/^  unsigned  fMaxBackoff;        \/**< \\brief max value of backoff value (Karn) *\/$/;"	m	class:itpp::TCP_Sender	access:private
fMaxCWnd	/usr/include/itpp/protocol/tcp.h	/^  unsigned   fMaxCWnd;           \/**< \\brief congestion window boundary *\/$/;"	m	class:itpp::TCP_Sender	access:private
fMaxRTO	/usr/include/itpp/protocol/tcp.h	/^  double  fMaxRTO;     \/\/ max value of retransmission TO$/;"	m	class:itpp::TCP_Sender	access:private
fMaxRecWnd	/usr/include/itpp/protocol/tcp.h	/^  unsigned        fMaxRecWnd;        \/**< \\brief maximum observed rec. window *\/$/;"	m	class:itpp::TCP_Sender	access:private
fMaxUserBlockSize	/usr/include/itpp/protocol/tcp.h	/^  unsigned  fMaxUserBlockSize;   \/**< \\brief max size of a user read block *\/$/;"	m	class:itpp::TCP_Receiver	access:private
fMinUserBlockSize	/usr/include/itpp/protocol/tcp.h	/^  unsigned  fMinUserBlockSize;   \/**< \\brief min size of a user read block *\/$/;"	m	class:itpp::TCP_Receiver	access:private
fNagle	/usr/include/itpp/protocol/tcp.h	/^  bool         fNagle;             \/**< \\brief use Nagle algorithm *\/$/;"	m	class:itpp::TCP_Sender	access:private
fNumberOfFastRetransmits	/usr/include/itpp/protocol/tcp.h	/^  unsigned long       fNumberOfFastRetransmits;$/;"	m	class:itpp::TCP_Sender	access:private
fNumberOfIdleTimeouts	/usr/include/itpp/protocol/tcp.h	/^  unsigned long       fNumberOfIdleTimeouts;$/;"	m	class:itpp::TCP_Sender	access:private
fNumberOfRTTMeasurements	/usr/include/itpp/protocol/tcp.h	/^  unsigned long       fNumberOfRTTMeasurements;$/;"	m	class:itpp::TCP_Sender	access:private
fNumberOfReceivedACKs	/usr/include/itpp/protocol/tcp.h	/^  unsigned long       fNumberOfReceivedACKs;$/;"	m	class:itpp::TCP_Sender	access:private
fNumberOfTimeouts	/usr/include/itpp/protocol/tcp.h	/^  unsigned long       fNumberOfTimeouts;$/;"	m	class:itpp::TCP_Sender	access:private
fPending	/usr/include/itpp/protocol/signals_slots.h	/^  bool  fPending;$/;"	m	class:itpp::TTimer	access:protected
fPendingBackoffReset	/usr/include/itpp/protocol/tcp.h	/^  bool          fPendingBackoffReset;  \/**< \\brief reset backoff on next new ACK *\/$/;"	m	class:itpp::TCP_Sender	access:private
fPeriodicACKInterval	/usr/include/itpp/protocol/tcp.h	/^  Ttype  fPeriodicACKInterval;\/\/ interval after which an ACK is repeated$/;"	m	class:itpp::TCP_Receiver	access:private
fPeriodicACKTimer	/usr/include/itpp/protocol/tcp.h	/^  TTimer<TCP_Receiver> fPeriodicACKTimer; \/**< \\brief timer for periodic ACKs *\/$/;"	m	class:itpp::TCP_Receiver	access:private
fRTTEstimate	/usr/include/itpp/protocol/tcp.h	/^    double     fRTTEstimate; \/\/!< ADD DOCUMENTATION HERE$/;"	m	struct:itpp::TCP_Packet::TDebugInfo	access:public
fRTTEstimate	/usr/include/itpp/protocol/tcp.h	/^  double          fRTTEstimate;        \/**< \\brief created from SRTT, RTTVar and gran. *\/$/;"	m	class:itpp::TCP_Sender	access:private
fRTTMByte	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number fRTTMByte;           \/**< \\brief byte for which RTTM is running *\/$/;"	m	class:itpp::TCP_Sender	access:private
fRTTMPending	/usr/include/itpp/protocol/tcp.h	/^  bool            fRTTMPending;        \/**< \\brief is currently RTTN running? *\/$/;"	m	class:itpp::TCP_Sender	access:private
fRTTMStartTime	/usr/include/itpp/protocol/tcp.h	/^  double          fRTTMStartTime;      \/**< \\brief beginning of a measurement *\/$/;"	m	class:itpp::TCP_Sender	access:private
fRTTVar	/usr/include/itpp/protocol/tcp.h	/^  double          fRTTVar;             \/**< \\brief variance of RTT time *\/$/;"	m	class:itpp::TCP_Sender	access:private
fRecWnd	/usr/include/itpp/protocol/tcp.h	/^    unsigned   fRecWnd; \/\/!< ADD DOCUMENTATION HERE$/;"	m	struct:itpp::TCP_Packet::TDebugInfo	access:public
fRecWnd	/usr/include/itpp/protocol/tcp.h	/^  unsigned        fRecWnd;       \/\/ receiver advertised window$/;"	m	class:itpp::TCP_Sender	access:private
fReceiverBuffer	/usr/include/itpp/protocol/tcp.h	/^  TCP_Receiver_Buffer  fReceiverBuffer;$/;"	m	class:itpp::TCP_Receiver	access:private
fRecoveryDupACK	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number  fRecoveryDupACK;  \/**< \\brief sndmax on 3rd dup ACK (see RFC 2582) *\/$/;"	m	class:itpp::TCP_Sender	access:private
fRecoveryTO	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number  fRecoveryTO;  \/**< \\brief sndmax on TO (see RFC 2582) *\/$/;"	m	class:itpp::TCP_Sender	access:private
fRenoConservation	/usr/include/itpp/protocol/tcp.h	/^  bool  fRenoConservation;  \/**< \\brief use cons. of packets on fast rec. (std.) *\/$/;"	m	class:itpp::TCP_Sender	access:private
fRestartAfterIdle	/usr/include/itpp/protocol/tcp.h	/^  bool  fRestartAfterIdle;  \/**< \\brief perform SSR after idle period *\/$/;"	m	class:itpp::TCP_Sender	access:private
fRtxFlag	/usr/include/itpp/protocol/tcp.h	/^    bool   fRtxFlag; \/\/!< ADD DOCUMENTATION HERE$/;"	m	struct:itpp::TCP_Packet::TDebugInfo	access:public
fRtxTimer	/usr/include/itpp/protocol/tcp.h	/^  TTimer<TCP_Sender>   fRtxTimer;     \/**< \\brief retransmission timer *\/$/;"	m	class:itpp::TCP_Sender	access:private
fSRTT	/usr/include/itpp/protocol/tcp.h	/^  double          fSRTT;               \/**< \\brief smoothed mean round trip time *\/$/;"	m	class:itpp::TCP_Sender	access:private
fSSThresh	/usr/include/itpp/protocol/tcp.h	/^    unsigned   fSSThresh; \/\/!< ADD DOCUMENTATION HERE$/;"	m	struct:itpp::TCP_Packet::TDebugInfo	access:public
fSSThresh	/usr/include/itpp/protocol/tcp.h	/^  unsigned  fSSThresh;      \/**< \\brief threshold between slow start and cong. avoid. *\/$/;"	m	class:itpp::TCP_Sender	access:private
fSWSATimer	/usr/include/itpp/protocol/tcp.h	/^  TTimer<TCP_Sender>   fSWSATimer;    \/**< \\brief SWSA\/Nagle timer *\/$/;"	m	class:itpp::TCP_Sender	access:private
fSWSATimerValue	/usr/include/itpp/protocol/tcp.h	/^  double       fSWSATimerValue;    \/**< \\brief timer for silly wind. synd. avoidance *\/$/;"	m	class:itpp::TCP_Sender	access:private
fSegment	/usr/include/itpp/protocol/tcp.h	/^  TCP_Segment   fSegment;     \/**< \\brief data segment to be transmitted *\/$/;"	m	class:itpp::TCP_Packet	access:protected
fSendPeriodicACKs	/usr/include/itpp/protocol/tcp.h	/^  bool  fSendPeriodicACKs;   \/**< \\brief repeat ACKs if no data has been received *\/$/;"	m	class:itpp::TCP_Receiver	access:private
fSessionId	/usr/include/itpp/protocol/tcp.h	/^  int    fSessionId;     \/**< \\brief session identifier *\/$/;"	m	class:itpp::TCP_Packet	access:protected
fSessionId	/usr/include/itpp/protocol/tcp.h	/^  int fSessionId;  \/**< \\brief increased by 1 on connection release *\/$/;"	m	class:itpp::TCP_Receiver	access:private
fSessionId	/usr/include/itpp/protocol/tcp.h	/^  int fSessionId;  \/**< \\brief is increased when Release is called *\/$/;"	m	class:itpp::TCP_Sender	access:private
fSndMax	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number fSndMax;           \/**< \\brief highest byte that has been sent +1 *\/$/;"	m	class:itpp::TCP_Sender	access:private
fSndNxt	/usr/include/itpp/protocol/tcp.h	/^    Sequence_Number   fSndNxt; \/\/!< ADD DOCUMENTATION HERE$/;"	m	struct:itpp::TCP_Packet::TDebugInfo	access:public
fSndNxt	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number fSndNxt;       \/\/ next byte to be sent$/;"	m	class:itpp::TCP_Sender	access:private
fSndUna	/usr/include/itpp/protocol/tcp.h	/^    Sequence_Number   fSndUna; \/\/!< ADD DOCUMENTATION HERE$/;"	m	struct:itpp::TCP_Packet::TDebugInfo	access:public
fSndUna	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number fSndUna;       \/\/ lowest unacknowledged sn$/;"	m	class:itpp::TCP_Sender	access:private
fSourcePort	/usr/include/itpp/protocol/tcp.h	/^  unsigned             fSourcePort;$/;"	m	class:itpp::TCP_Packet	access:protected
fStrictPeriodicACKs	/usr/include/itpp/protocol/tcp.h	/^  bool  fStrictPeriodicACKs; \/**< \\brief repeat ACKs independent of data received *\/$/;"	m	class:itpp::TCP_Receiver	access:private
fTCPIPHeaderLength	/usr/include/itpp/protocol/tcp.h	/^  unsigned     fTCPIPHeaderLength;  \/**< \\brief overhead by TCP\/IP headers *\/$/;"	m	class:itpp::TCP_Receiver	access:private
fTCPIPHeaderLength	/usr/include/itpp/protocol/tcp.h	/^  unsigned  fTCPIPHeaderLength; \/**< \\brief additional msg length (normally 40 bytes) *\/$/;"	m	class:itpp::TCP_Sender	access:private
fTCPVersion	/usr/include/itpp/protocol/tcp.h	/^  eTCPVersion  fTCPVersion;     \/\/ one of Reno, Tahoe, NewReno$/;"	m	class:itpp::TCP_Sender	access:private
fTimUna	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number      fTimUna;       \/**< \\brief byte rtx timer is running for *\/$/;"	m	class:itpp::TCP_Sender	access:private
fTimerGranularity	/usr/include/itpp/protocol/tcp.h	/^  double  fTimerGranularity;  \/**< \\brief granularity for rtx\/idle timer values *\/$/;"	m	class:itpp::TCP_Sender	access:private
fTrace	/usr/include/itpp/protocol/tcp.h	/^  bool   fTrace;      \/\/ store trace info in vectors$/;"	m	class:itpp::TCP_Sender	access:private
fTrace	/usr/include/itpp/protocol/tcp.h	/^  bool  fTrace;              \/**< \\brief trace end bytes of received packets *\/$/;"	m	class:itpp::TCP_Receiver	access:private
fTraceACKedSeqNo	/usr/include/itpp/protocol/tcp.h	/^  bool  fTraceACKedSeqNo;   \/**< \\brief print trace of received ACKs to cout *\/$/;"	m	class:itpp::TCP_Sender	access:private
fTraceCWnd	/usr/include/itpp/protocol/tcp.h	/^  bool  fTraceCWnd;     \/\/ print CWnd trace to cout$/;"	m	class:itpp::TCP_Sender	access:private
fTraceSentSeqNo	/usr/include/itpp/protocol/tcp.h	/^  bool  fTraceSentSeqNo;    \/**< \\brief print trace of sent SNs to cout *\/$/;"	m	class:itpp::TCP_Sender	access:private
fUserBlockProcDelay	/usr/include/itpp/protocol/tcp.h	/^  double  fUserBlockProcDelay; \/**< \\brief time to read data from buffer + forward *\/$/;"	m	class:itpp::TCP_Receiver	access:private
fUserBlockProcTimer	/usr/include/itpp/protocol/tcp.h	/^  TTimer<TCP_Receiver> fUserBlockProcTimer;$/;"	m	class:itpp::TCP_Receiver	access:private
fUserMessage	/usr/include/itpp/protocol/tcp.h	/^  Packet * fUserMessage;$/;"	m	class:itpp::TCP_Receiver	access:private
fUserNxt	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number fUserNxt;       \/\/ next byte to be received from user$/;"	m	class:itpp::TCP_Sender	access:private
fWaitingACKMsg	/usr/include/itpp/protocol/tcp.h	/^  TCP_Packet *  fWaitingACKMsg;$/;"	m	class:itpp::TCP_Receiver	access:private
fWnd	/usr/include/itpp/protocol/tcp.h	/^  unsigned         fWnd;           \/**< \\brief window size (advertised by receiver) *\/$/;"	m	class:itpp::TCP_Packet	access:protected
fact	/usr/include/itpp/base/math/elem_math.h	/^double fact(int index);$/;"	p	namespace:itpp	signature:(int index)
factory	/usr/include/itpp/base/array.h	/^  const Factory &factory;$/;"	m	class:itpp::Array	access:protected
factory	/usr/include/itpp/base/mat.h	/^  const Factory &factory;$/;"	m	class:itpp::Mat	access:protected
factory	/usr/include/itpp/base/vec.h	/^  const Factory &factory;$/;"	m	class:itpp::Vec	access:protected
factr	/usr/include/itpp/base/random.h	/^  double mem, r, factr, mean, var, r1, r2;$/;"	m	class:itpp::AR1_Normal_RNG	access:private
fading_gen	/usr/include/itpp/comm/channel.h	/^  Array<Fading_Generator *> fading_gen; \/\/!< Fading generators for each tap$/;"	m	class:itpp::TDL_Channel	access:protected
fading_type	/usr/include/itpp/comm/channel.h	/^  FADING_TYPE fading_type; \/\/!< Fading type: Independent (default), Static or Correlated$/;"	m	class:itpp::TDL_Channel	access:protected
fast	/usr/include/itpp/comm/convcode.h	/^  int fast(Array<ivec> &spectrum, const int dfree, const int no_terms,$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(Array<ivec> &spectrum, const int dfree, const int no_terms, const int Cdfree = 1000000, const bool test_catastrophic = false)
fast	/usr/include/itpp/comm/punct_convcode.h	/^  int fast(Array<ivec> &spectrum, int time, int dfree, int no_terms, int d_best_so_far = 0, bool test_catastrophic = false);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(Array<ivec> &spectrum, int time, int dfree, int no_terms, int d_best_so_far = 0, bool test_catastrophic = false)
feasable_blocks	/usr/include/itpp/protocol/selective_repeat.h	/^  int feasable_blocks();$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:()
fft	/usr/include/itpp/signal/transforms.h	/^cvec fft(const cvec &in);$/;"	p	namespace:itpp	signature:(const cvec &in)
fft	/usr/include/itpp/signal/transforms.h	/^cvec fft(const cvec &in, const int N);$/;"	p	namespace:itpp	signature:(const cvec &in, const int N)
fft	/usr/include/itpp/signal/transforms.h	/^void fft(const cvec &in, cvec &out);$/;"	p	namespace:itpp	signature:(const cvec &in, cvec &out)
fft_real	/usr/include/itpp/signal/transforms.h	/^cvec fft_real(const vec &in, const int N);$/;"	p	namespace:itpp	signature:(const vec &in, const int N)
fft_real	/usr/include/itpp/signal/transforms.h	/^cvec fft_real(const vec& in);$/;"	p	namespace:itpp	signature:(const vec& in)
fft_real	/usr/include/itpp/signal/transforms.h	/^void fft_real(const vec& in, cvec &out);$/;"	p	namespace:itpp	signature:(const vec& in, cvec &out)
fftsize	/usr/include/itpp/signal/freq_filt.h	/^  int fftsize, blksize;$/;"	m	class:itpp::Freq_Filt	access:private
file	/usr/include/itpp/srccode/audiofile.h	/^  std::fstream file;$/;"	m	class:itpp::Audio_File	access:protected
file_header	/usr/include/itpp/base/itfile.h	/^  struct file_header {$/;"	s	class:itpp::it_file_base	access:protected
file_header	/usr/include/itpp/base/itfile.h	/^  struct file_header {$/;"	s	class:itpp::it_file_base_old	access:protected
file_magic	/usr/include/itpp/base/itfile.h	/^  static char file_magic[4];$/;"	m	class:itpp::it_file_base	access:protected
file_magic	/usr/include/itpp/base/itfile.h	/^  static char file_magic[4];$/;"	m	class:itpp::it_file_base_old	access:protected
file_version	/usr/include/itpp/base/itfile.h	/^  static char file_version;$/;"	m	class:itpp::it_file_base	access:protected
file_version	/usr/include/itpp/base/itfile.h	/^  static char file_version;$/;"	m	class:itpp::it_file_base_old	access:protected
fill_output	/usr/include/itpp/protocol/selective_repeat.h	/^  void fill_output();$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:()
filter	/usr/include/itpp/comm/channel.h	/^  cvec filter(const cvec &input);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cvec &input)
filter	/usr/include/itpp/comm/channel.h	/^  cvec filter(const cvec &input, Array<cvec> &channel_coeff);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cvec &input, Array<cvec> &channel_coeff)
filter	/usr/include/itpp/comm/channel.h	/^  cvec filter(const cvec &input, cmat &channel_coeff);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cvec &input, cmat &channel_coeff)
filter	/usr/include/itpp/comm/channel.h	/^  void filter(const cvec &input, cvec &output);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cvec &input, cvec &output)
filter	/usr/include/itpp/comm/channel.h	/^  void filter(const cvec &input, cvec &output, Array<cvec> &channel_coeff);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cvec &input, cvec &output, Array<cvec> &channel_coeff)
filter	/usr/include/itpp/comm/channel.h	/^  void filter(const cvec &input, cvec &output, cmat &channel_coeff);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cvec &input, cvec &output, cmat &channel_coeff)
filter	/usr/include/itpp/signal/filter.h	/^  virtual T3 filter(const T1 Sample) = 0;$/;"	p	class:itpp::Filter	access:protected	signature:(const T1 Sample)
filter	/usr/include/itpp/signal/filter.h	/^  virtual T3 filter(const T1 Sample);$/;"	p	class:itpp::ARMA_Filter	access:private	signature:(const T1 Sample)
filter	/usr/include/itpp/signal/filter.h	/^  virtual T3 filter(const T1 Sample);$/;"	p	class:itpp::AR_Filter	access:private	signature:(const T1 Sample)
filter	/usr/include/itpp/signal/filter.h	/^  virtual T3 filter(const T1 Sample);$/;"	p	class:itpp::MA_Filter	access:private	signature:(const T1 Sample)
filter	/usr/include/itpp/signal/filter.h	/^T3 ARMA_Filter<T1, T2, T3>::filter(const T1 Sample)$/;"	f	class:itpp::ARMA_Filter	signature:(const T1 Sample)
filter	/usr/include/itpp/signal/filter.h	/^T3 AR_Filter<T1, T2, T3>::filter(const T1 Sample)$/;"	f	class:itpp::AR_Filter	signature:(const T1 Sample)
filter	/usr/include/itpp/signal/filter.h	/^T3 MA_Filter<T1, T2, T3>::filter(const T1 Sample)$/;"	f	class:itpp::MA_Filter	signature:(const T1 Sample)
filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const cvec &b, const cvec &a, const cvec &input);$/;"	p	namespace:itpp	signature:(const cvec &b, const cvec &a, const cvec &input)
filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const cvec &b, const cvec &a, const cvec &input, const cvec &state_in, cvec &state_out);$/;"	p	namespace:itpp	signature:(const cvec &b, const cvec &a, const cvec &input, const cvec &state_in, cvec &state_out)
filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const cvec &b, const cvec &a, const vec &input);$/;"	p	namespace:itpp	signature:(const cvec &b, const cvec &a, const vec &input)
filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const cvec &b, const cvec &a, const vec &input, const cvec &state_in, cvec &state_out);$/;"	p	namespace:itpp	signature:(const cvec &b, const cvec &a, const vec &input, const cvec &state_in, cvec &state_out)
filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const cvec &b, const int one, const cvec &input);$/;"	p	namespace:itpp	signature:(const cvec &b, const int one, const cvec &input)
filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const cvec &b, const int one, const cvec &input, const cvec &state_in, cvec &state_out);$/;"	p	namespace:itpp	signature:(const cvec &b, const int one, const cvec &input, const cvec &state_in, cvec &state_out)
filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const cvec &b, const int one, const vec &input);$/;"	p	namespace:itpp	signature:(const cvec &b, const int one, const vec &input)
filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const cvec &b, const int one, const vec &input, const cvec &state_in, cvec &state_out);$/;"	p	namespace:itpp	signature:(const cvec &b, const int one, const vec &input, const cvec &state_in, cvec &state_out)
filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const int one, const cvec &a, const cvec &input);$/;"	p	namespace:itpp	signature:(const int one, const cvec &a, const cvec &input)
filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const int one, const cvec &a, const cvec &input, const cvec &state_in, cvec &state_out);$/;"	p	namespace:itpp	signature:(const int one, const cvec &a, const cvec &input, const cvec &state_in, cvec &state_out)
filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const int one, const cvec &a, const vec &input);$/;"	p	namespace:itpp	signature:(const int one, const cvec &a, const vec &input)
filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const int one, const cvec &a, const vec &input, const cvec &state_in, cvec &state_out);$/;"	p	namespace:itpp	signature:(const int one, const cvec &a, const vec &input, const cvec &state_in, cvec &state_out)
filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const int one, const vec &a, const cvec &input);$/;"	p	namespace:itpp	signature:(const int one, const vec &a, const cvec &input)
filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const int one, const vec &a, const cvec &input, const cvec &state_in, cvec &state_out);$/;"	p	namespace:itpp	signature:(const int one, const vec &a, const cvec &input, const cvec &state_in, cvec &state_out)
filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const vec &b, const int one, const cvec &input);$/;"	p	namespace:itpp	signature:(const vec &b, const int one, const cvec &input)
filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const vec &b, const int one, const cvec &input, const cvec &state_in, cvec &state_out);$/;"	p	namespace:itpp	signature:(const vec &b, const int one, const cvec &input, const cvec &state_in, cvec &state_out)
filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const vec &b, const vec &a, const cvec &input);$/;"	p	namespace:itpp	signature:(const vec &b, const vec &a, const cvec &input)
filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const vec &b, const vec &a, const cvec &input, const cvec &state_in, cvec &state_out);$/;"	p	namespace:itpp	signature:(const vec &b, const vec &a, const cvec &input, const cvec &state_in, cvec &state_out)
filter	/usr/include/itpp/signal/filter.h	/^vec filter(const int one, const vec &a, const vec &input);$/;"	p	namespace:itpp	signature:(const int one, const vec &a, const vec &input)
filter	/usr/include/itpp/signal/filter.h	/^vec filter(const int one, const vec &a, const vec &input, const vec &state_in, vec &state_out);$/;"	p	namespace:itpp	signature:(const int one, const vec &a, const vec &input, const vec &state_in, vec &state_out)
filter	/usr/include/itpp/signal/filter.h	/^vec filter(const vec &b, const int one, const vec &input);$/;"	p	namespace:itpp	signature:(const vec &b, const int one, const vec &input)
filter	/usr/include/itpp/signal/filter.h	/^vec filter(const vec &b, const int one, const vec &input, const vec &state_in, vec &state_out);$/;"	p	namespace:itpp	signature:(const vec &b, const int one, const vec &input, const vec &state_in, vec &state_out)
filter	/usr/include/itpp/signal/filter.h	/^vec filter(const vec &b, const vec &a, const vec &input);$/;"	p	namespace:itpp	signature:(const vec &b, const vec &a, const vec &input)
filter	/usr/include/itpp/signal/filter.h	/^vec filter(const vec &b, const vec &a, const vec &input, const vec &state_in, vec &state_out);$/;"	p	namespace:itpp	signature:(const vec &b, const vec &a, const vec &input, const vec &state_in, vec &state_out)
filter	/usr/include/itpp/signal/freq_filt.h	/^  Vec<Num_T> filter(const Vec<Num_T> &x, const int strm = 0);$/;"	p	class:itpp::Freq_Filt	access:public	signature:(const Vec<Num_T> &x, const int strm = 0)
filter	/usr/include/itpp/signal/freq_filt.h	/^Vec<Num_T> Freq_Filt<Num_T>::filter(const Vec<Num_T> &input, const int strm)$/;"	f	class:itpp::Freq_Filt	signature:(const Vec<Num_T> &input, const int strm)
filter_design_autocorrelation	/usr/include/itpp/signal/filter_design.h	/^void filter_design_autocorrelation(const int N, const vec &f, const vec &m, vec &R);$/;"	p	namespace:itpp	signature:(const int N, const vec &f, const vec &m, vec &R)
filter_known_channel	/usr/include/itpp/comm/channel.h	/^  void filter_known_channel(const cvec &input, cvec &output, const Array<cvec> &channel_coeff);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cvec &input, cvec &output, const Array<cvec> &channel_coeff)
filter_known_channel	/usr/include/itpp/comm/channel.h	/^  void filter_known_channel(const cvec &input, cvec &output, const cmat &channel_coeff);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cvec &input, cvec &output, const cmat &channel_coeff)
filter_length	/usr/include/itpp/comm/channel.h	/^  int filter_length; \/\/!< Filter length of FIR fading generator$/;"	m	class:itpp::TDL_Channel	access:protected
filter_spectrum	/usr/include/itpp/signal/sigfun.h	/^vec filter_spectrum(const vec &a, const vec &b, int nfft = 256);$/;"	p	namespace:itpp	signature:(const vec &a, const vec &b, int nfft = 256)
filter_spectrum	/usr/include/itpp/signal/sigfun.h	/^vec filter_spectrum(const vec &a, int nfft = 256);$/;"	p	namespace:itpp	signature:(const vec &a, int nfft = 256)
find	/usr/include/itpp/base/specmat.h	/^ivec find(const bvec &invector);$/;"	p	namespace:itpp	signature:(const bvec &invector)
findname	/usr/include/itpp/base/parser.h	/^  std::string findname(const std::string &name,$/;"	p	class:itpp::Parser	access:private	signature:(const std::string &name, bool &error_flag, bool &print_flag, int num = 0, bool keep_brackets = false)
finetune	/usr/include/itpp/signal/fastica.h	/^  bool finetune, stabilization, PCAonly;$/;"	m	class:itpp::Fast_ICA	access:private
finished	/usr/include/itpp/optim/newton_search.h	/^  bool finished; \/\/ true if functions and starting points are set$/;"	m	class:itpp::Line_Search	access:private
finished	/usr/include/itpp/optim/newton_search.h	/^  bool init, finished, trace;$/;"	m	class:itpp::Newton_Search	access:private
finite	/usr/include/itpp/config.h	236;"	d
fir1	/usr/include/itpp/signal/filter.h	/^vec fir1(int N, double cutoff);$/;"	p	namespace:itpp	signature:(int N, double cutoff)
fir_filter	/usr/include/itpp/comm/channel.h	/^  MA_Filter<std::complex<double>, double, std::complex<double> > fir_filter;$/;"	m	class:itpp::FIR_Fading_Generator	access:protected
fir_length	/usr/include/itpp/comm/channel.h	/^  int fir_length; \/\/!< Size of FIR filter$/;"	m	class:itpp::FIR_Fading_Generator	access:protected
firstEig	/usr/include/itpp/signal/fastica.h	/^  int firstEig, lastEig;$/;"	m	class:itpp::Fast_ICA	access:private
first_block_size	/usr/include/itpp/protocol/tcp.h	/^  unsigned first_block_size() const;        \/**< \\brief size of first complete block *\/$/;"	p	class:itpp::TCP_Receiver_Buffer	access:public	signature:() const
first_byte	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number first_byte() const;      \/**< \\brief first byte stored or missing *\/$/;"	p	class:itpp::TCP_Receiver_Buffer	access:public	signature:() const
first_byte	/usr/include/itpp/protocol/tcp.h	/^inline Sequence_Number TCP_Receiver_Buffer::first_byte() const$/;"	f	class:itpp::TCP_Receiver_Buffer	signature:() const
fixed1	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<1, TC, WRAP> fixed1;$/;"	t	namespace:itpp
fixed10	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<10, TC, WRAP> fixed10;$/;"	t	namespace:itpp
fixed11	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<11, TC, WRAP> fixed11;$/;"	t	namespace:itpp
fixed12	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<12, TC, WRAP> fixed12;$/;"	t	namespace:itpp
fixed13	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<13, TC, WRAP> fixed13;$/;"	t	namespace:itpp
fixed14	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<14, TC, WRAP> fixed14;$/;"	t	namespace:itpp
fixed15	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<15, TC, WRAP> fixed15;$/;"	t	namespace:itpp
fixed16	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<16, TC, WRAP> fixed16;$/;"	t	namespace:itpp
fixed17	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<17, TC, WRAP> fixed17;$/;"	t	namespace:itpp
fixed18	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<18, TC, WRAP> fixed18;$/;"	t	namespace:itpp
fixed19	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<19, TC, WRAP> fixed19;$/;"	t	namespace:itpp
fixed2	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<2, TC, WRAP> fixed2;$/;"	t	namespace:itpp
fixed20	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<20, TC, WRAP> fixed20;$/;"	t	namespace:itpp
fixed21	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<21, TC, WRAP> fixed21;$/;"	t	namespace:itpp
fixed22	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<22, TC, WRAP> fixed22;$/;"	t	namespace:itpp
fixed23	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<23, TC, WRAP> fixed23;$/;"	t	namespace:itpp
fixed24	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<24, TC, WRAP> fixed24;$/;"	t	namespace:itpp
fixed25	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<25, TC, WRAP> fixed25;$/;"	t	namespace:itpp
fixed26	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<26, TC, WRAP> fixed26;$/;"	t	namespace:itpp
fixed27	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<27, TC, WRAP> fixed27;$/;"	t	namespace:itpp
fixed28	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<28, TC, WRAP> fixed28;$/;"	t	namespace:itpp
fixed29	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<29, TC, WRAP> fixed29;$/;"	t	namespace:itpp
fixed3	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<3, TC, WRAP> fixed3;$/;"	t	namespace:itpp
fixed30	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<30, TC, WRAP> fixed30;$/;"	t	namespace:itpp
fixed31	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<31, TC, WRAP> fixed31;$/;"	t	namespace:itpp
fixed32	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<32, TC, WRAP> fixed32;$/;"	t	namespace:itpp
fixed33	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<33, TC, WRAP> fixed33;$/;"	t	namespace:itpp
fixed34	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<34, TC, WRAP> fixed34;$/;"	t	namespace:itpp
fixed35	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<35, TC, WRAP> fixed35;$/;"	t	namespace:itpp
fixed36	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<36, TC, WRAP> fixed36;$/;"	t	namespace:itpp
fixed37	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<37, TC, WRAP> fixed37;$/;"	t	namespace:itpp
fixed38	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<38, TC, WRAP> fixed38;$/;"	t	namespace:itpp
fixed39	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<39, TC, WRAP> fixed39;$/;"	t	namespace:itpp
fixed4	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<4, TC, WRAP> fixed4;$/;"	t	namespace:itpp
fixed40	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<40, TC, WRAP> fixed40;$/;"	t	namespace:itpp
fixed41	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<41, TC, WRAP> fixed41;$/;"	t	namespace:itpp
fixed42	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<42, TC, WRAP> fixed42;$/;"	t	namespace:itpp
fixed43	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<43, TC, WRAP> fixed43;$/;"	t	namespace:itpp
fixed44	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<44, TC, WRAP> fixed44;$/;"	t	namespace:itpp
fixed45	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<45, TC, WRAP> fixed45;$/;"	t	namespace:itpp
fixed46	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<46, TC, WRAP> fixed46;$/;"	t	namespace:itpp
fixed47	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<47, TC, WRAP> fixed47;$/;"	t	namespace:itpp
fixed48	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<48, TC, WRAP> fixed48;$/;"	t	namespace:itpp
fixed49	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<49, TC, WRAP> fixed49;$/;"	t	namespace:itpp
fixed5	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<5, TC, WRAP> fixed5;$/;"	t	namespace:itpp
fixed50	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<50, TC, WRAP> fixed50;$/;"	t	namespace:itpp
fixed51	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<51, TC, WRAP> fixed51;$/;"	t	namespace:itpp
fixed52	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<52, TC, WRAP> fixed52;$/;"	t	namespace:itpp
fixed53	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<53, TC, WRAP> fixed53;$/;"	t	namespace:itpp
fixed54	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<54, TC, WRAP> fixed54;$/;"	t	namespace:itpp
fixed55	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<55, TC, WRAP> fixed55;$/;"	t	namespace:itpp
fixed56	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<56, TC, WRAP> fixed56;$/;"	t	namespace:itpp
fixed57	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<57, TC, WRAP> fixed57;$/;"	t	namespace:itpp
fixed58	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<58, TC, WRAP> fixed58;$/;"	t	namespace:itpp
fixed59	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<59, TC, WRAP> fixed59;$/;"	t	namespace:itpp
fixed6	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<6, TC, WRAP> fixed6;$/;"	t	namespace:itpp
fixed60	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<60, TC, WRAP> fixed60;$/;"	t	namespace:itpp
fixed61	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<61, TC, WRAP> fixed61;$/;"	t	namespace:itpp
fixed62	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<62, TC, WRAP> fixed62;$/;"	t	namespace:itpp
fixed63	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<63, TC, WRAP> fixed63;$/;"	t	namespace:itpp
fixed64	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<64, TC, WRAP> fixed64;$/;"	t	namespace:itpp
fixed7	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<7, TC, WRAP> fixed7;$/;"	t	namespace:itpp
fixed8	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<8, TC, WRAP> fixed8;$/;"	t	namespace:itpp
fixed9	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<9, TC, WRAP> fixed9;$/;"	t	namespace:itpp
fixmat	/usr/include/itpp/fixed/fix.h	/^typedef Mat<Fix> fixmat;$/;"	t	namespace:itpp
fixrep	/usr/include/itpp/fixed/fix_base.h	/^typedef int64_t fixrep;$/;"	t	namespace:itpp
fixvec	/usr/include/itpp/fixed/fix.h	/^typedef Vec<Fix> fixvec;$/;"	t	namespace:itpp
float_interleaver	/usr/include/itpp/comm/turbo.h	/^  Sequence_Interleaver<double> float_interleaver;$/;"	m	class:itpp::Turbo_Codec	access:private
floor	/usr/include/itpp/base/converters.h	/^inline mat floor(const mat &x) { return apply_function<double>(std::floor, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
floor	/usr/include/itpp/base/converters.h	/^inline vec floor(const vec &x) { return apply_function<double>(std::floor, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
floor_i	/usr/include/itpp/base/converters.h	/^imat floor_i(const mat &x);$/;"	p	namespace:itpp	signature:(const mat &x)
floor_i	/usr/include/itpp/base/converters.h	/^inline int floor_i(double x) { return static_cast<int>(std::floor(x)); }$/;"	f	namespace:itpp	signature:(double x)
floor_i	/usr/include/itpp/base/converters.h	/^ivec floor_i(const vec &x);$/;"	p	namespace:itpp	signature:(const vec &x)
flush	/usr/include/itpp/base/itfile.h	/^  void flush();$/;"	p	class:itpp::it_file	access:public	signature:()
flush	/usr/include/itpp/base/itfile.h	/^  void flush();$/;"	p	class:itpp::it_file_old	access:public	signature:()
flush	/usr/include/itpp/base/itfile.h	/^inline it_file& flush(it_file& f)$/;"	f	namespace:itpp	signature:(it_file& f)
flush	/usr/include/itpp/base/itfile.h	/^inline it_file_old& flush(it_file_old& f)$/;"	f	namespace:itpp	signature:(it_file_old& f)
fminunc	/usr/include/itpp/optim/newton_search.h	/^vec fminunc(double(*function)(const vec&), vec(*gradient)(const vec&), const vec &x0);$/;"	p	namespace:itpp	signature:(double(*function)(const vec&), vec(*gradient)(const vec&), const vec &x0)
fname	/usr/include/itpp/base/itfile.h	/^  std::string fname;$/;"	m	class:itpp::it_file	access:private
forward	/usr/include/itpp/protocol/signals_slots.h	/^  void forward(ObjectType *object_pointer, void(ObjectType::*object_function_pointer)(DataType u));$/;"	p	class:itpp::Slot	access:public	signature:(ObjectType *object_pointer, void(ObjectType::*object_function_pointer)(DataType u))
forward	/usr/include/itpp/protocol/signals_slots.h	/^  void forward(ObjectType *po, void(ObjectType::*pm)(DataType u)) { time_out_slot->forward(po, pm); }$/;"	f	class:itpp::ATimer	access:public	signature:(ObjectType *po, void(ObjectType::*pm)(DataType u))
forward	/usr/include/itpp/protocol/signals_slots.h	/^void Slot<ObjectType, DataType>::forward(ObjectType *object_pointer, void(ObjectType::*object_function_pointer)(DataType u))$/;"	f	class:itpp::Slot	signature:(ObjectType *object_pointer, void(ObjectType::*object_function_pointer)(DataType u))
forward_substitution	/usr/include/itpp/base/algebra/ls_solve.h	/^vec forward_substitution(const mat &L, const vec &b);$/;"	p	namespace:itpp	signature:(const mat &L, const vec &b)
forward_substitution	/usr/include/itpp/base/algebra/ls_solve.h	/^vec forward_substitution(const mat &L, int p, const vec &b);$/;"	p	namespace:itpp	signature:(const mat &L, int p, const vec &b)
forward_substitution	/usr/include/itpp/base/algebra/ls_solve.h	/^void forward_substitution(const mat &L, const vec &b, vec &x);$/;"	p	namespace:itpp	signature:(const mat &L, const vec &b, vec &x)
forward_substitution	/usr/include/itpp/base/algebra/ls_solve.h	/^void forward_substitution(const mat &L, int p, const vec &b, vec &x);$/;"	p	namespace:itpp	signature:(const mat &L, int p, const vec &b, vec &x)
fpclass	/usr/include/itpp/config.h	242;"	d
free	/usr/include/itpp/base/array.h	/^  void free();$/;"	p	class:itpp::Array	access:protected	signature:()
free	/usr/include/itpp/base/array.h	/^void Array<T>::free()$/;"	f	class:itpp::Array	signature:()
free	/usr/include/itpp/base/circular_buffer.h	/^  void free();$/;"	p	class:itpp::Circular_Buffer	access:private	signature:()
free	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::free()$/;"	f	class:itpp::Circular_Buffer	signature:()
free	/usr/include/itpp/base/mat.h	/^  void free();$/;"	p	class:itpp::Mat	access:protected	signature:()
free	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::free()$/;"	f	class:itpp::Mat	signature:()
free	/usr/include/itpp/base/smat.h	/^  void free();$/;"	p	class:itpp::Sparse_Mat	access:private	signature:()
free	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::free()$/;"	f	class:itpp::Sparse_Mat	signature:()
free	/usr/include/itpp/base/stack.h	/^  void free();$/;"	p	class:itpp::Stack	access:private	signature:()
free	/usr/include/itpp/base/stack.h	/^void Stack<T>::free()$/;"	f	class:itpp::Stack	signature:()
free	/usr/include/itpp/base/svec.h	/^  void free();$/;"	p	class:itpp::Sparse_Vec	access:private	signature:()
free	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::free()$/;"	f	class:itpp::Sparse_Vec	signature:()
free	/usr/include/itpp/base/vec.h	/^  void free();$/;"	p	class:itpp::Vec	access:protected	signature:()
free	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::free()$/;"	f	class:itpp::Vec	signature:()
free_all_ptrs	/usr/include/itpp/stat/mog_diag.h	/^  void free_all_ptrs();$/;"	p	class:itpp::MOG_diag	access:protected	signature:()
free_sequence_numbers	/usr/include/itpp/protocol/selective_repeat.h	/^  int free_sequence_numbers();$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:()
freqz	/usr/include/itpp/signal/filter_design.h	/^cvec freqz(const cvec &b, const cvec& a, const int N = 512);$/;"	p	namespace:itpp	signature:(const cvec &b, const cvec& a, const int N = 512)
freqz	/usr/include/itpp/signal/filter_design.h	/^cvec freqz(const cvec &b, const cvec& a, const vec &w);$/;"	p	namespace:itpp	signature:(const cvec &b, const cvec& a, const vec &w)
freqz	/usr/include/itpp/signal/filter_design.h	/^cvec freqz(const vec &b, const vec& a, const int N = 512);$/;"	p	namespace:itpp	signature:(const vec &b, const vec& a, const int N = 512)
freqz	/usr/include/itpp/signal/filter_design.h	/^cvec freqz(const vec &b, const vec& a, const vec &w);$/;"	p	namespace:itpp	signature:(const vec &b, const vec& a, const vec &w)
freqz	/usr/include/itpp/signal/filter_design.h	/^void freqz(const cvec &b, const cvec& a, const int N, cvec &h, vec &w);$/;"	p	namespace:itpp	signature:(const cvec &b, const cvec& a, const int N, cvec &h, vec &w)
freqz	/usr/include/itpp/signal/filter_design.h	/^void freqz(const vec &b, const vec& a, const int N, cvec &h, vec &w);$/;"	p	namespace:itpp	signature:(const vec &b, const vec& a, const int N, cvec &h, vec &w)
from_sparse	/usr/include/itpp/base/gf2mat.h	/^  void from_sparse(const GF2mat_sparse &mat, bool transpose = false);$/;"	p	class:itpp::GF2mat_sparse_alist	access:public	signature:(const GF2mat_sparse &mat, bool transpose = false)
full	/usr/include/itpp/base/smat.h	/^  Mat<T> full() const;$/;"	p	class:itpp::Sparse_Mat	access:public	signature:() const
full	/usr/include/itpp/base/smat.h	/^  void full(Mat<T> &m) const;$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(Mat<T> &m) const
full	/usr/include/itpp/base/smat.h	/^Mat<T> Sparse_Mat<T>::full() const$/;"	f	class:itpp::Sparse_Mat	signature:() const
full	/usr/include/itpp/base/smat.h	/^inline Mat<T> full(const Sparse_Mat<T> &s)$/;"	f	namespace:itpp	signature:(const Sparse_Mat<T> &s)
full	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::full(Mat<T> &m) const$/;"	f	class:itpp::Sparse_Mat	signature:(Mat<T> &m) const
full	/usr/include/itpp/base/svec.h	/^  Vec<T> full() const;$/;"	p	class:itpp::Sparse_Vec	access:public	signature:() const
full	/usr/include/itpp/base/svec.h	/^  void full(Vec<T> &v) const;$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(Vec<T> &v) const
full	/usr/include/itpp/base/svec.h	/^Vec<T> Sparse_Vec<T>::full() const$/;"	f	class:itpp::Sparse_Vec	signature:() const
full	/usr/include/itpp/base/svec.h	/^inline Vec<T> full(const Sparse_Vec<T> &s)$/;"	f	namespace:itpp	signature:(const Sparse_Vec<T> &s)
full	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::full(Vec<T> &v) const$/;"	f	class:itpp::Sparse_Vec	signature:(Vec<T> &v) const
full	/usr/include/itpp/stat/mog_generic.h	/^  bool full;$/;"	m	class:itpp::MOG_generic	access:protected
full_covs	/usr/include/itpp/stat/mog_generic.h	/^  Array<mat> full_covs;$/;"	m	class:itpp::MOG_generic	access:protected
full_covs_inv	/usr/include/itpp/stat/mog_generic.h	/^  Array<mat> full_covs_inv;$/;"	m	class:itpp::MOG_generic	access:protected
g	/usr/include/itpp/comm/bch.h	/^  GFX g;$/;"	m	class:itpp::BCH	access:private
g	/usr/include/itpp/comm/reedsolomon.h	/^  GFX g;$/;"	m	class:itpp::Reed_Solomon	access:protected
g	/usr/include/itpp/signal/fastica.h	/^  int approach, numOfIC, g, initState;$/;"	m	class:itpp::Fast_ICA	access:private
g_end	/usr/include/itpp/optim/newton_search.h	/^  vec x_end, g_end;$/;"	m	class:itpp::Line_Search	access:private
g_start	/usr/include/itpp/optim/newton_search.h	/^  vec x_start, g_start, h_start;$/;"	m	class:itpp::Line_Search	access:private
gamma	/usr/include/itpp/base/math/elem_math.h	/^inline double gamma(double x) { return tgamma(x); }$/;"	f	namespace:itpp	signature:(double x)
gamma	/usr/include/itpp/base/math/elem_math.h	/^inline mat gamma(const mat &x) { return apply_function<double>(tgamma, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
gamma	/usr/include/itpp/base/math/elem_math.h	/^inline vec gamma(const vec &x) { return apply_function<double>(tgamma, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
gamma	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  mat gamma, alpha, beta;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
gamma_q	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  QLLRmat gamma_q, alpha_q, beta_q;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
gcd	/usr/include/itpp/base/math/elem_math.h	/^int gcd(int a, int b);$/;"	p	namespace:itpp	signature:(int a, int b)
gen_pol	/usr/include/itpp/comm/convcode.h	/^  ivec gen_pol;$/;"	m	class:itpp::Convolutional_Code	access:protected
gen_pol	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  ivec gen_pol, gen_pol_rev;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
gen_pol_rev	/usr/include/itpp/comm/convcode.h	/^  ivec gen_pol_rev;$/;"	m	class:itpp::Convolutional_Code	access:protected
gen_pol_rev	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  ivec gen_pol, gen_pol_rev;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
generate	/usr/include/itpp/comm/channel.h	/^  cvec generate(int no_samples);$/;"	p	class:itpp::Fading_Generator	access:public	signature:(int no_samples)
generate	/usr/include/itpp/comm/channel.h	/^  virtual void generate(int no_samples, cvec &output) = 0;$/;"	p	class:itpp::Fading_Generator	access:public	signature:(int no_samples, cvec &output)
generate	/usr/include/itpp/comm/channel.h	/^  virtual void generate(int no_samples, cvec &output);$/;"	p	class:itpp::FIR_Fading_Generator	access:public	signature:(int no_samples, cvec &output)
generate	/usr/include/itpp/comm/channel.h	/^  virtual void generate(int no_samples, cvec &output);$/;"	p	class:itpp::IFFT_Fading_Generator	access:public	signature:(int no_samples, cvec &output)
generate	/usr/include/itpp/comm/channel.h	/^  virtual void generate(int no_samples, cvec &output);$/;"	p	class:itpp::Rice_Fading_Generator	access:public	signature:(int no_samples, cvec &output)
generate	/usr/include/itpp/comm/channel.h	/^  virtual void generate(int no_samples, cvec& output) = 0;$/;"	p	class:itpp::Correlated_Fading_Generator	access:public	signature:(int no_samples, cvec& output)
generate	/usr/include/itpp/comm/channel.h	/^  virtual void generate(int no_samples, cvec& output);$/;"	p	class:itpp::Independent_Fading_Generator	access:public	signature:(int no_samples, cvec& output)
generate	/usr/include/itpp/comm/channel.h	/^  virtual void generate(int no_samples, cvec& output);$/;"	p	class:itpp::Static_Fading_Generator	access:public	signature:(int no_samples, cvec& output)
generate	/usr/include/itpp/comm/channel.h	/^  void generate(int no_samples, Array<cvec> &channel_coeff);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(int no_samples, Array<cvec> &channel_coeff)
generate	/usr/include/itpp/comm/channel.h	/^  void generate(int no_samples, cmat &channel_coeff);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(int no_samples, cmat &channel_coeff)
generate	/usr/include/itpp/comm/ldpc.h	/^  void generate(int Nvar, const vec& var_deg, const vec& chk_deg,$/;"	p	class:itpp::LDPC_Parity_Irregular	access:public	signature:(int Nvar, const vec& var_deg, const vec& chk_deg, const std::string& method = Ó, const ivec& options = Ó)
generate	/usr/include/itpp/comm/ldpc.h	/^  void generate(int Nvar, int k, int l,$/;"	p	class:itpp::LDPC_Parity_Regular	access:public	signature:(int Nvar, int k, int l, const std::string& method = Ó, const ivec& options = Ó)
generate_G	/usr/include/itpp/comm/hammcode.h	/^  void generate_G(void);$/;"	p	class:itpp::Hamming_Code	access:private	signature:(void)
generate_H	/usr/include/itpp/comm/hammcode.h	/^  void generate_H(void);$/;"	p	class:itpp::Hamming_Code	access:private	signature:(void)
generate_Jakes	/usr/include/itpp/comm/channel.h	/^  void generate_Jakes(int no_samples, cvec &output);$/;"	p	class:itpp::IFFT_Fading_Generator	access:protected	signature:(int no_samples, cvec &output)
generate_random_H	/usr/include/itpp/comm/ldpc.h	/^  void generate_random_H(const ivec& C, const ivec& R, const ivec& cycopt);$/;"	p	class:itpp::LDPC_Parity_Unstructured	access:protected	signature:(const ivec& C, const ivec& R, const ivec& cycopt)
geometric_mean	/usr/include/itpp/stat/misc_stat.h	/^double geometric_mean(const Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
geometric_mean	/usr/include/itpp/stat/misc_stat.h	/^double geometric_mean(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
get	/usr/include/itpp/base/circular_buffer.h	/^  T get();$/;"	p	class:itpp::Circular_Buffer	access:public	signature:()
get	/usr/include/itpp/base/circular_buffer.h	/^  void get(Array<T>& out, const int N = -1);$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(Array<T>& out, const int N = -1)
get	/usr/include/itpp/base/circular_buffer.h	/^  void get(T& out);$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(T& out)
get	/usr/include/itpp/base/circular_buffer.h	/^  void get(Vec<T>& out, const int N = -1);$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(Vec<T>& out, const int N = -1)
get	/usr/include/itpp/base/circular_buffer.h	/^T Circular_Buffer<T>::get()$/;"	f	class:itpp::Circular_Buffer	signature:()
get	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::get(Array<T>& out, const int N)$/;"	f	class:itpp::Circular_Buffer	signature:(Array<T>& out, const int N)
get	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::get(T& out)$/;"	f	class:itpp::Circular_Buffer	signature:(T& out)
get	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::get(Vec<T>& out, const int N)$/;"	f	class:itpp::Circular_Buffer	signature:(Vec<T>& out, const int N)
get	/usr/include/itpp/base/gf2mat.h	/^  inline bin get(int i, int j) const;$/;"	p	class:itpp::GF2mat	access:public	signature:(int i, int j) const
get	/usr/include/itpp/base/gf2mat.h	/^inline bin GF2mat::get(int i, int j) const$/;"	f	class:itpp::GF2mat	signature:(int i, int j) const
get	/usr/include/itpp/base/mat.h	/^  Mat<Num_T> get(int r1, int r2, int c1, int c2) const;$/;"	p	class:itpp::Mat	access:public	signature:(int r1, int r2, int c1, int c2) const
get	/usr/include/itpp/base/mat.h	/^  const Num_T &get(int r, int c) const;$/;"	p	class:itpp::Mat	access:public	signature:(int r, int c) const
get	/usr/include/itpp/base/mat.h	/^Mat<Num_T> Mat<Num_T>::get(int r1, int r2, int c1, int c2) const$/;"	f	class:itpp::Mat	signature:(int r1, int r2, int c1, int c2) const
get	/usr/include/itpp/base/mat.h	/^const Num_T& Mat<Num_T>::get(int r, int c) const$/;"	f	class:itpp::Mat	signature:(int r, int c) const
get	/usr/include/itpp/base/parser.h	/^  bool get(T &var, const std::string &name, int num = -1);$/;"	p	class:itpp::Parser	access:public	signature:(T &var, const std::string &name, int num = -1)
get	/usr/include/itpp/base/parser.h	/^bool Parser::get(T &var, const std::string &name, int num)$/;"	f	class:itpp::Parser	signature:(T &var, const std::string &name, int num)
get	/usr/include/itpp/base/parser.h	/^bool Parser::get(bool &var, const std::string &name, int num);$/;"	p	class:itpp::Parser	signature:(bool &var, const std::string &name, int num)
get	/usr/include/itpp/base/parser.h	/^bool Parser::get(int &var, const std::string &name, int num);$/;"	p	class:itpp::Parser	signature:(int &var, const std::string &name, int num)
get	/usr/include/itpp/base/parser.h	/^bool Parser::get(std::string &var, const std::string &name, int num);$/;"	p	class:itpp::Parser	signature:(std::string &var, const std::string &name, int num)
get	/usr/include/itpp/base/vec.h	/^  Vec<Num_T> get(const Vec<bin> &binlist) const;$/;"	p	class:itpp::Vec	access:public	signature:(const Vec<bin> &binlist) const
get	/usr/include/itpp/base/vec.h	/^  Vec<Num_T> get(int i1, int i2) const;$/;"	p	class:itpp::Vec	access:public	signature:(int i1, int i2) const
get	/usr/include/itpp/base/vec.h	/^  const Num_T &get(int i) const;$/;"	p	class:itpp::Vec	access:public	signature:(int i) const
get	/usr/include/itpp/base/vec.h	/^Vec<Num_T> Vec<Num_T>::get(const Vec<bin> &binlist) const$/;"	f	class:itpp::Vec	signature:(const Vec<bin> &binlist) const
get	/usr/include/itpp/base/vec.h	/^Vec<Num_T> Vec<Num_T>::get(int i1, int i2) const$/;"	f	class:itpp::Vec	signature:(int i1, int i2) const
get	/usr/include/itpp/base/vec.h	/^const Num_T& Vec<Num_T>::get(int i) const$/;"	f	class:itpp::Vec	signature:(int i) const
get	/usr/include/itpp/comm/ldpc.h	/^  bin get(int i, int j) const {$/;"	f	class:itpp::LDPC_Parity	access:public	signature:(int i, int j) const
get_ACK	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number get_ACK() const { return fACK; }$/;"	f	class:itpp::TCP_Packet	access:public	signature:() const
get_D	/usr/include/itpp/stat/mog_generic.h	/^  int get_D() const { if (valid) return(D); else return(0); }$/;"	f	class:itpp::MOG_generic	access:public	signature:() const
get_Dint	/usr/include/itpp/comm/llr.h	/^  ivec get_Dint();$/;"	p	class:itpp::LLR_calc_unit	access:public	signature:()
get_G	/usr/include/itpp/comm/egolay.h	/^  bmat get_G() const { return G; }$/;"	f	class:itpp::Extended_Golay	access:public	signature:() const
get_G	/usr/include/itpp/comm/hammcode.h	/^  bmat get_G() const { return G; };$/;"	f	class:itpp::Hamming_Code	access:public	signature:() const
get_H	/usr/include/itpp/comm/hammcode.h	/^  bmat get_H() const { return H; };$/;"	f	class:itpp::Hamming_Code	access:public	signature:() const
get_H	/usr/include/itpp/comm/ldpc.h	/^  GF2mat_sparse get_H(bool transpose = false) const {$/;"	f	class:itpp::LDPC_Parity	access:public	signature:(bool transpose = false) const
get_K	/usr/include/itpp/stat/mog_generic.h	/^  int get_K() const { if (valid) return(K); else return(0); }$/;"	f	class:itpp::MOG_generic	access:public	signature:() const
get_LOS_doppler	/usr/include/itpp/comm/channel.h	/^  double get_LOS_doppler(int tap_number) const { return los_dopp(tap_number); }$/;"	f	class:itpp::Channel_Specification	access:public	signature:(int tap_number) const
get_LOS_doppler	/usr/include/itpp/comm/channel.h	/^  double get_LOS_doppler(int tap_number) const { return los_dopp(tap_number); }$/;"	f	class:itpp::TDL_Channel	access:public	signature:(int tap_number) const
get_LOS_doppler	/usr/include/itpp/comm/channel.h	/^  vec get_LOS_doppler() const { return los_dopp; }$/;"	f	class:itpp::Channel_Specification	access:public	signature:() const
get_LOS_doppler	/usr/include/itpp/comm/channel.h	/^  vec get_LOS_doppler() const { return los_dopp; }$/;"	f	class:itpp::TDL_Channel	access:public	signature:() const
get_LOS_doppler	/usr/include/itpp/comm/channel.h	/^  virtual double get_LOS_doppler() const { return los_dopp; }$/;"	f	class:itpp::Correlated_Fading_Generator	access:public	signature:() const
get_LOS_doppler	/usr/include/itpp/comm/channel.h	/^  virtual double get_LOS_doppler() const;$/;"	p	class:itpp::Fading_Generator	access:public	signature:() const
get_LOS_power	/usr/include/itpp/comm/channel.h	/^  double get_LOS_power() const { return los_power; }$/;"	f	class:itpp::Fading_Generator	access:public	signature:() const
get_LOS_power	/usr/include/itpp/comm/channel.h	/^  double get_LOS_power(int tap_number) const { return los_power(tap_number); }$/;"	f	class:itpp::Channel_Specification	access:public	signature:(int tap_number) const
get_LOS_power	/usr/include/itpp/comm/channel.h	/^  double get_LOS_power(int tap_number) const { return los_power(tap_number); }$/;"	f	class:itpp::TDL_Channel	access:public	signature:(int tap_number) const
get_LOS_power	/usr/include/itpp/comm/channel.h	/^  vec get_LOS_power() const { return los_power; }$/;"	f	class:itpp::Channel_Specification	access:public	signature:() const
get_LOS_power	/usr/include/itpp/comm/channel.h	/^  vec get_LOS_power() const { return los_power; }$/;"	f	class:itpp::TDL_Channel	access:public	signature:() const
get_M	/usr/include/itpp/comm/modulator_nd.h	/^  ivec get_M() const { return M; }$/;"	f	class:itpp::Modulator_ND	access:public	signature:() const
get_Ncoded	/usr/include/itpp/comm/turbo.h	/^  int get_Ncoded() const { return Ncoded; }$/;"	f	class:itpp::Turbo_Codec	access:public	signature:() const
get_Nuncoded	/usr/include/itpp/comm/turbo.h	/^  int get_Nuncoded() const { return Nuncoded; }$/;"	f	class:itpp::Turbo_Codec	access:public	signature:() const
get_alpha	/usr/include/itpp/optim/newton_search.h	/^  double get_alpha();$/;"	p	class:itpp::Line_Search	access:public	signature:()
get_avg_bit_rate	/usr/include/itpp/protocol/packet_generator.h	/^  double get_avg_bit_rate();$/;"	p	class:itpp::Poisson_Packet_Generator	access:public	signature:()
get_avg_power_dB	/usr/include/itpp/comm/channel.h	/^  vec get_avg_power_dB() const { return a_prof_dB; }$/;"	f	class:itpp::Channel_Specification	access:public	signature:() const
get_avg_power_dB	/usr/include/itpp/comm/channel.h	/^  vec get_avg_power_dB() const;$/;"	p	class:itpp::TDL_Channel	access:public	signature:() const
get_base_matrix	/usr/include/itpp/comm/ldpc.h	/^  imat get_base_matrix() const;$/;"	p	class:itpp::BLDPC_Parity	access:public	signature:() const
get_beta	/usr/include/itpp/optim/newton_search.h	/^  double get_beta() { return stop_beta; }$/;"	f	class:itpp::Line_Search	access:public	signature:()
get_bin	/usr/include/itpp/stat/histogram.h	/^  int get_bin(int ix) const { return bins(ix); };$/;"	f	class:itpp::Histogram	access:public	signature:(int ix) const
get_bin_center	/usr/include/itpp/stat/histogram.h	/^  Num_T get_bin_center(int ix) const { return center_vals(ix); };$/;"	f	class:itpp::Histogram	access:public	signature:(int ix) const
get_bin_centers	/usr/include/itpp/stat/histogram.h	/^  Vec<Num_T> get_bin_centers() const { return center_vals; };$/;"	f	class:itpp::Histogram	access:public	signature:() const
get_bin_left	/usr/include/itpp/stat/histogram.h	/^  Num_T get_bin_left(int ix) const { return lo_vals(ix); };$/;"	f	class:itpp::Histogram	access:public	signature:(int ix) const
get_bin_lefts	/usr/include/itpp/stat/histogram.h	/^  Vec<Num_T> get_bin_lefts() const { return lo_vals; };$/;"	f	class:itpp::Histogram	access:public	signature:() const
get_bin_right	/usr/include/itpp/stat/histogram.h	/^  Num_T get_bin_right(int ix) const { return hi_vals(ix); };$/;"	f	class:itpp::Histogram	access:public	signature:(int ix) const
get_bin_rights	/usr/include/itpp/stat/histogram.h	/^  Vec<Num_T> get_bin_rights() const { return hi_vals; };$/;"	f	class:itpp::Histogram	access:public	signature:() const
get_bins	/usr/include/itpp/stat/histogram.h	/^  ivec get_bins() const { return bins; };$/;"	f	class:itpp::Histogram	access:public	signature:() const
get_bits2symbols	/usr/include/itpp/comm/modulator.h	/^  virtual ivec get_bits2symbols() const { return bits2symbols; }$/;"	f	class:itpp::Modulator	access:public	signature:() const
get_blk_size	/usr/include/itpp/signal/freq_filt.h	/^  int get_blk_size() { return blksize; }$/;"	f	class:itpp::Freq_Filt	access:public	signature:()
get_bmat	/usr/include/itpp/base/parser.h	/^  bmat get_bmat(const std::string &name, int num = -1);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &name, int num = -1)
get_bool	/usr/include/itpp/base/parser.h	/^  bool get_bool(const std::string &name,  int num = -1);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &name, int num = -1)
get_bvec	/usr/include/itpp/base/parser.h	/^  bvec get_bvec(const std::string &name, int num = -1);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &name, int num = -1)
get_cdf	/usr/include/itpp/stat/histogram.h	/^  vec get_cdf() const;$/;"	p	class:itpp::Histogram	access:public	signature:() const
get_cdf	/usr/include/itpp/stat/histogram.h	/^inline vec Histogram<Num_T>::get_cdf() const$/;"	f	class:itpp::Histogram	signature:() const
get_channel_profile	/usr/include/itpp/comm/channel.h	/^  void get_channel_profile(vec &avg_power_dB, ivec &delay_prof) const;$/;"	p	class:itpp::TDL_Channel	access:public	signature:(vec &avg_power_dB, ivec &delay_prof) const
get_channel_profile	/usr/include/itpp/comm/channel.h	/^  void get_channel_profile(vec &avg_power_dB, vec &delay_prof) const;$/;"	p	class:itpp::Channel_Specification	access:public	signature:(vec &avg_power_dB, vec &delay_prof) const
get_code	/usr/include/itpp/comm/spread.h	/^  vec get_code();$/;"	p	class:itpp::Spread_1d	access:public	signature:()
get_codeI	/usr/include/itpp/comm/spread.h	/^  vec get_codeI();$/;"	p	class:itpp::Spread_2d	access:public	signature:()
get_codeQ	/usr/include/itpp/comm/spread.h	/^  vec get_codeQ();$/;"	p	class:itpp::Spread_2d	access:public	signature:()
get_codebook	/usr/include/itpp/srccode/vq.h	/^  mat get_codebook() const;$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:() const
get_codes	/usr/include/itpp/comm/spread.h	/^  mat get_codes();$/;"	p	class:itpp::Multicode_Spread_1d	access:public	signature:()
get_codesI	/usr/include/itpp/comm/spread.h	/^  mat get_codesI();$/;"	p	class:itpp::Multicode_Spread_2d	access:public	signature:()
get_codesQ	/usr/include/itpp/comm/spread.h	/^  mat get_codesQ();$/;"	p	class:itpp::Multicode_Spread_2d	access:public	signature:()
get_codevector	/usr/include/itpp/srccode/vq.h	/^  vec get_codevector(int Index) const;$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:(int Index) const
get_coeffs	/usr/include/itpp/signal/filter.h	/^  Vec<T2> get_coeffs() const { return coeffs; }$/;"	f	class:itpp::AR_Filter	access:public	signature:() const
get_coeffs	/usr/include/itpp/signal/filter.h	/^  Vec<T2> get_coeffs() const { return coeffs; }$/;"	f	class:itpp::MA_Filter	access:public	signature:() const
get_coeffs	/usr/include/itpp/signal/filter.h	/^  void get_coeffs(Vec<T2> &b, Vec<T2> &a) const { b = bcoeffs; a = acoeffs; }$/;"	f	class:itpp::ARMA_Filter	access:public	signature:(Vec<T2> &b, Vec<T2> &a) const
get_coeffs_a	/usr/include/itpp/signal/filter.h	/^  Vec<T2> get_coeffs_a() const { return acoeffs; }$/;"	f	class:itpp::ARMA_Filter	access:public	signature:() const
get_coeffs_b	/usr/include/itpp/signal/filter.h	/^  Vec<T2> get_coeffs_b() const { return bcoeffs; }$/;"	f	class:itpp::ARMA_Filter	access:public	signature:() const
get_col	/usr/include/itpp/base/gf2mat.h	/^  bvec get_col(int j) const;$/;"	p	class:itpp::GF2mat	access:public	signature:(int j) const
get_col	/usr/include/itpp/base/mat.h	/^  Vec<Num_T> get_col(int c) const;$/;"	p	class:itpp::Mat	access:public	signature:(int c) const
get_col	/usr/include/itpp/base/mat.h	/^Vec<Num_T> Mat<Num_T>::get_col(int c) const$/;"	f	class:itpp::Mat	signature:(int c) const
get_col	/usr/include/itpp/base/smat.h	/^  Sparse_Vec<T> get_col(int c) const;$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(int c) const
get_col	/usr/include/itpp/base/smat.h	/^  void get_col(int c, Sparse_Vec<T> &v) const;$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(int c, Sparse_Vec<T> &v) const
get_col	/usr/include/itpp/base/smat.h	/^Sparse_Vec<T> Sparse_Mat<T>::get_col(int c) const$/;"	f	class:itpp::Sparse_Mat	signature:(int c) const
get_col	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::get_col(int c, Sparse_Vec<T> &v) const$/;"	f	class:itpp::Sparse_Mat	signature:(int c, Sparse_Vec<T> &v) const
get_col	/usr/include/itpp/comm/ldpc.h	/^  Sparse_Vec<bin> get_col(int c) const { return H.get_col(c); }$/;"	f	class:itpp::LDPC_Parity	access:public	signature:(int c) const
get_cols	/usr/include/itpp/base/mat.h	/^  Mat<Num_T> get_cols(const Vec<int> &indexlist) const;$/;"	p	class:itpp::Mat	access:public	signature:(const Vec<int> &indexlist) const
get_cols	/usr/include/itpp/base/mat.h	/^  Mat<Num_T> get_cols(int c1, int c2) const;$/;"	p	class:itpp::Mat	access:public	signature:(int c1, int c2) const
get_cols	/usr/include/itpp/base/mat.h	/^Mat<Num_T> Mat<Num_T>::get_cols(const Vec<int> &indexlist) const$/;"	f	class:itpp::Mat	signature:(const Vec<int> &indexlist) const
get_cols	/usr/include/itpp/base/mat.h	/^Mat<Num_T> Mat<Num_T>::get_cols(int c1, int c2) const$/;"	f	class:itpp::Mat	signature:(int c1, int c2) const
get_cols	/usr/include/itpp/comm/interleave.h	/^  int get_cols(void) {return cols;};$/;"	f	class:itpp::Block_Interleaver	access:public	signature:(void)
get_corrects	/usr/include/itpp/comm/error_counters.h	/^  double get_corrects() const { return corrects; }$/;"	f	class:itpp::BERC	access:public	signature:() const
get_corrects	/usr/include/itpp/comm/error_counters.h	/^  double get_corrects() const { return corrects; }$/;"	f	class:itpp::BLERC	access:public	signature:() const
get_correlated_method	/usr/include/itpp/comm/channel.h	/^  CORRELATED_METHOD get_correlated_method() const { return method; }$/;"	f	class:itpp::TDL_Channel	access:public	signature:() const
get_covariance	/usr/include/itpp/srccode/gmm.h	/^  vec get_covariance();$/;"	p	class:itpp::GMM	access:public	signature:()
get_covariance	/usr/include/itpp/srccode/gmm.h	/^  vec get_covariance(int i);$/;"	p	class:itpp::GMM	access:public	signature:(int i)
get_covariance	/usr/include/itpp/srccode/gmm.h	/^inline vec GMM::get_covariance() {return sigma;}$/;"	f	class:itpp::GMM	signature:()
get_covariance	/usr/include/itpp/srccode/gmm.h	/^inline vec GMM::get_covariance(int i) {return sigma.mid(i*d, d);}$/;"	f	class:itpp::GMM	signature:(int i)
get_current_time	/usr/include/itpp/base/timing.h	/^  double get_current_time() const;$/;"	p	class:itpp::CPU_Timer	access:protected	signature:() const
get_current_time	/usr/include/itpp/base/timing.h	/^  double get_current_time() const;$/;"	p	class:itpp::Real_Timer	access:protected	signature:() const
get_current_time	/usr/include/itpp/base/timing.h	/^  virtual double get_current_time() const = 0;$/;"	p	class:itpp::Timer	access:protected	signature:() const
get_decoding_method	/usr/include/itpp/comm/ldpc.h	/^  std::string get_decoding_method() const { return dec_method; }$/;"	f	class:itpp::LDPC_Code	access:public	signature:() const
get_degree	/usr/include/itpp/comm/galois.h	/^  int get_degree() const;$/;"	p	class:itpp::GFX	access:public	signature:() const
get_degree	/usr/include/itpp/comm/galois.h	/^inline int GFX::get_degree() const$/;"	f	class:itpp::GFX	signature:() const
get_delay	/usr/include/itpp/comm/error_counters.h	/^  int get_delay() const { return delay; }$/;"	f	class:itpp::BERC	access:public	signature:() const
get_delay_prof	/usr/include/itpp/comm/channel.h	/^  ivec get_delay_prof() const { return d_prof; }$/;"	f	class:itpp::TDL_Channel	access:public	signature:() const
get_delay_prof	/usr/include/itpp/comm/channel.h	/^  vec get_delay_prof() const { return d_prof; }$/;"	f	class:itpp::Channel_Specification	access:public	signature:() const
get_destination_port	/usr/include/itpp/protocol/tcp.h	/^  unsigned get_destination_port() const { return fDestinationPort; }$/;"	f	class:itpp::TCP_Packet	access:public	signature:() const
get_dewhitening_matrix	/usr/include/itpp/signal/fastica.h	/^  mat get_dewhitening_matrix();$/;"	p	class:itpp::Fast_ICA	access:public	signature:()
get_diag_covs	/usr/include/itpp/stat/mog_generic.h	/^  Array<vec> get_diag_covs() const { Array<vec> tmp; if (valid && !full) { tmp = diag_covs; } return tmp; }$/;"	f	class:itpp::MOG_generic	access:public	signature:() const
get_dim	/usr/include/itpp/comm/modulator_nd.h	/^  int get_dim() const { return nt; }$/;"	f	class:itpp::Modulator_ND	access:public	signature:() const
get_dimension	/usr/include/itpp/srccode/gmm.h	/^  int get_dimension();$/;"	p	class:itpp::GMM	access:public	signature:()
get_dimension	/usr/include/itpp/srccode/gmm.h	/^inline int GMM::get_dimension() {return d;}$/;"	f	class:itpp::GMM	signature:()
get_doppler_spectrum	/usr/include/itpp/comm/channel.h	/^  Array<DOPPLER_SPECTRUM> get_doppler_spectrum() const { return tap_doppler_spectrum; }$/;"	f	class:itpp::Channel_Specification	access:public	signature:() const
get_doppler_spectrum	/usr/include/itpp/comm/channel.h	/^  DOPPLER_SPECTRUM get_doppler_spectrum(int index) const;$/;"	p	class:itpp::Channel_Specification	access:public	signature:(int index) const
get_doppler_spectrum	/usr/include/itpp/comm/channel.h	/^  virtual DOPPLER_SPECTRUM get_doppler_spectrum() const { return dopp_spectrum; }$/;"	f	class:itpp::Rice_Fading_Generator	access:public	signature:() const
get_doppler_spectrum	/usr/include/itpp/comm/channel.h	/^  virtual DOPPLER_SPECTRUM get_doppler_spectrum() const;$/;"	p	class:itpp::Fading_Generator	access:public	signature:() const
get_double	/usr/include/itpp/base/parser.h	/^  double get_double(const std::string &name, int num = -1);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &name, int num = -1)
get_e_mode	/usr/include/itpp/fixed/fix_base.h	/^  e_mode get_e_mode() const {return emode;}$/;"	f	class:itpp::Fix_Base	access:public	signature:() const
get_encoder_state	/usr/include/itpp/comm/convcode.h	/^  int get_encoder_state(void) const { return encoder_state; }$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(void) const
get_endianity	/usr/include/itpp/base/binfile.h	/^  endian get_endianity() const {$/;"	f	class:itpp::bfstream_base	access:public	signature:() const
get_epsilon_1	/usr/include/itpp/optim/newton_search.h	/^  double get_epsilon_1() { return stop_epsilon_1; }$/;"	f	class:itpp::Newton_Search	access:public	signature:()
get_epsilon_2	/usr/include/itpp/optim/newton_search.h	/^  double get_epsilon_2() { return stop_epsilon_2; }$/;"	f	class:itpp::Newton_Search	access:public	signature:()
get_errorrate	/usr/include/itpp/comm/error_counters.h	/^  double get_errorrate() const { return (errors \/ (corrects + errors)); }$/;"	f	class:itpp::BERC	access:public	signature:() const
get_errorrate	/usr/include/itpp/comm/error_counters.h	/^  double get_errorrate() const { return (errors \/ (corrects + errors)); }$/;"	f	class:itpp::BLERC	access:public	signature:() const
get_errors	/usr/include/itpp/comm/error_counters.h	/^  double get_errors() const { return errors; }$/;"	f	class:itpp::BERC	access:public	signature:() const
get_errors	/usr/include/itpp/comm/error_counters.h	/^  double get_errors() const { return errors; }$/;"	f	class:itpp::BLERC	access:public	signature:() const
get_exp_factor	/usr/include/itpp/comm/ldpc.h	/^  int get_exp_factor() const { return Z; }$/;"	f	class:itpp::BLDPC_Generator	access:public	signature:() const
get_exp_factor	/usr/include/itpp/comm/ldpc.h	/^  int get_exp_factor() const;$/;"	p	class:itpp::BLDPC_Parity	access:public	signature:() const
get_fading_type	/usr/include/itpp/comm/channel.h	/^  FADING_TYPE get_fading_type() const { return fading_type; }$/;"	f	class:itpp::TDL_Channel	access:public	signature:() const
get_family	/usr/include/itpp/comm/sequence.h	/^  bmat get_family(void);$/;"	p	class:itpp::Gold	access:public	signature:(void)
get_fft_size	/usr/include/itpp/signal/freq_filt.h	/^  int get_fft_size() { return fftsize; }$/;"	f	class:itpp::Freq_Filt	access:public	signature:()
get_filter_length	/usr/include/itpp/comm/channel.h	/^  virtual int get_filter_length() const { return fir_length; }$/;"	f	class:itpp::FIR_Fading_Generator	access:public	signature:() const
get_filter_length	/usr/include/itpp/comm/channel.h	/^  virtual int get_filter_length() const;$/;"	p	class:itpp::Fading_Generator	access:public	signature:() const
get_filter_length	/usr/include/itpp/comm/pulse_shape.h	/^  int get_filter_length() const;$/;"	p	class:itpp::Pulse_Shape	access:public	signature:() const
get_filter_length	/usr/include/itpp/comm/pulse_shape.h	/^int Pulse_Shape<T1, T2, T3>::get_filter_length(void) const$/;"	f	class:itpp::Pulse_Shape	signature:(void) const
get_full_covs	/usr/include/itpp/stat/mog_generic.h	/^  Array<mat> get_full_covs() const { Array<mat> tmp; if (valid && full) { tmp = full_covs; } return tmp; }$/;"	f	class:itpp::MOG_generic	access:public	signature:() const
get_function_value	/usr/include/itpp/optim/newton_search.h	/^  double get_function_value();$/;"	p	class:itpp::Newton_Search	access:public	signature:()
get_generator_polynomials	/usr/include/itpp/comm/convcode.h	/^  ivec get_generator_polynomials(void) const { return gen_pol; }$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(void) const
get_generator_polynomials	/usr/include/itpp/comm/punct_convcode.h	/^  ivec get_generator_polynomials() const { return gen_pol; }$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:() const
get_im	/usr/include/itpp/fixed/cfix.h	/^  fixrep get_im() const {return im;}$/;"	f	class:itpp::CFix	access:public	signature:() const
get_imat	/usr/include/itpp/base/parser.h	/^  imat get_imat(const std::string &name, int num = -1);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &name, int num = -1)
get_independent_components	/usr/include/itpp/signal/fastica.h	/^  mat get_independent_components();$/;"	p	class:itpp::Fast_ICA	access:public	signature:()
get_initial_stepsize	/usr/include/itpp/optim/newton_search.h	/^  double get_initial_stepsize() { return initial_stepsize; }$/;"	f	class:itpp::Newton_Search	access:public	signature:()
get_input	/usr/include/itpp/comm/convcode.h	/^  int get_input(const int state) { return (state >> (m - 1)); }$/;"	f	class:itpp::Convolutional_Code	access:protected	signature:(const int state)
get_int	/usr/include/itpp/base/parser.h	/^  int get_int(const std::string &name,  int num = -1);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &name, int num = -1)
get_interleaver_depth	/usr/include/itpp/comm/interleave.h	/^  int get_interleaver_depth(void) { return interleaver_depth; };$/;"	f	class:itpp::Sequence_Interleaver	access:public	signature:(void)
get_interleaver_sequence	/usr/include/itpp/comm/interleave.h	/^  ivec get_interleaver_sequence();$/;"	p	class:itpp::Sequence_Interleaver	access:public	signature:()
get_interleaver_sequence	/usr/include/itpp/comm/interleave.h	/^ivec Sequence_Interleaver<T>::get_interleaver_sequence()$/;"	f	class:itpp::Sequence_Interleaver	signature:()
get_ivec	/usr/include/itpp/base/parser.h	/^  ivec get_ivec(const std::string &name, int num = -1);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &name, int num = -1)
get_k	/usr/include/itpp/comm/hammcode.h	/^  short get_k() const { return k; };$/;"	f	class:itpp::Hamming_Code	access:public	signature:() const
get_k	/usr/include/itpp/comm/modulator_nd.h	/^  ivec get_k() const { return k; }$/;"	f	class:itpp::Modulator_ND	access:public	signature:() const
get_length	/usr/include/itpp/comm/sequence.h	/^  int get_length(void);$/;"	p	class:itpp::LFSR	access:public	signature:(void)
get_length	/usr/include/itpp/comm/sequence.h	/^inline int LFSR::get_length(void) {return memory.size();}$/;"	f	class:itpp::LFSR	signature:(void)
get_levels	/usr/include/itpp/srccode/vq.h	/^  vec get_levels() const;$/;"	p	class:itpp::Scalar_Quantizer	access:public	signature:() const
get_levels	/usr/include/itpp/srccode/vq.h	/^inline vec Scalar_Quantizer::get_levels() const {return Levels; }$/;"	f	class:itpp::Scalar_Quantizer	signature:() const
get_link_packets	/usr/include/itpp/protocol/selective_repeat.h	/^  void get_link_packets(const int K, Array<Packet*> &pa);$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:public	signature:(const int K, Array<Packet*> &pa)
get_llrcalc	/usr/include/itpp/comm/ldpc.h	/^  LLR_calc_unit get_llrcalc() const { return llrcalc; }$/;"	f	class:itpp::LDPC_Code	access:public	signature:() const
get_llrcalc	/usr/include/itpp/comm/modulator_nd.h	/^  LLR_calc_unit get_llrcalc() const { return llrcalc; }$/;"	f	class:itpp::Modulator_ND	access:public	signature:() const
get_low_precision	/usr/include/itpp/base/itfile.h	/^  bool get_low_precision() const { return low_prec; }$/;"	f	class:itpp::it_file	access:public	signature:() const
get_low_precision	/usr/include/itpp/base/itfile.h	/^  bool get_low_precision() { return low_prec; }$/;"	f	class:itpp::it_file_old	access:public	signature:()
get_mat	/usr/include/itpp/base/parser.h	/^  mat get_mat(const std::string &name, int num = -1);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &name, int num = -1)
get_max	/usr/include/itpp/fixed/fix_base.h	/^  fixrep get_max() const {return max;}$/;"	f	class:itpp::Fix_Base	access:public	signature:() const
get_max_evaluations	/usr/include/itpp/optim/newton_search.h	/^  int get_max_evaluations() { return max_evaluations; }$/;"	f	class:itpp::Newton_Search	access:public	signature:()
get_max_iterations	/usr/include/itpp/optim/newton_search.h	/^  int get_max_iterations() { return max_iterations; }$/;"	f	class:itpp::Line_Search	access:public	signature:()
get_max_packets	/usr/include/itpp/protocol/packet_generator.h	/^  int get_max_packets();$/;"	p	class:itpp::Packet_Generator	access:public	signature:()
get_max_stepsize	/usr/include/itpp/optim/newton_search.h	/^  double get_max_stepsize() { return max_stepsize; }$/;"	f	class:itpp::Line_Search	access:public	signature:()
get_mean	/usr/include/itpp/srccode/gmm.h	/^  vec get_mean();$/;"	p	class:itpp::GMM	access:public	signature:()
get_mean	/usr/include/itpp/srccode/gmm.h	/^  vec get_mean(int i);$/;"	p	class:itpp::GMM	access:public	signature:(int i)
get_mean	/usr/include/itpp/srccode/gmm.h	/^inline vec GMM::get_mean() {return m;}$/;"	f	class:itpp::GMM	signature:()
get_mean	/usr/include/itpp/srccode/gmm.h	/^inline vec GMM::get_mean(int i) {return m.mid(i*d, d);}$/;"	f	class:itpp::GMM	signature:(int i)
get_means	/usr/include/itpp/stat/mog_generic.h	/^  Array<vec> get_means() const { Array<vec> tmp; if (valid) { tmp = means; } return tmp; }$/;"	f	class:itpp::MOG_generic	access:public	signature:() const
get_method	/usr/include/itpp/base/sort.h	/^  SORTING_METHOD get_method() const { return sort_method; }$/;"	f	class:itpp::Sort	access:public	signature:() const
get_min	/usr/include/itpp/fixed/fix_base.h	/^  fixrep get_min() const {return min;}$/;"	f	class:itpp::Fix_Base	access:public	signature:() const
get_mixing_matrix	/usr/include/itpp/signal/fastica.h	/^  mat get_mixing_matrix();$/;"	p	class:itpp::Fast_ICA	access:public	signature:()
get_n	/usr/include/itpp/comm/hammcode.h	/^  short get_n() const { return n; };$/;"	f	class:itpp::Hamming_Code	access:public	signature:() const
get_native_endianity	/usr/include/itpp/base/binfile.h	/^  endian get_native_endianity() const { return native_endianity; }$/;"	f	class:itpp::bfstream_base	access:public	signature:() const
get_ncheck	/usr/include/itpp/comm/ldpc.h	/^  int get_ncheck() const { return ncheck; }$/;"	f	class:itpp::LDPC_Code	access:public	signature:() const
get_ncheck	/usr/include/itpp/comm/ldpc.h	/^  int get_ncheck() const {$/;"	f	class:itpp::LDPC_Parity	access:public	signature:() const
get_no_frequencies	/usr/include/itpp/comm/channel.h	/^  int get_no_frequencies() const { return nrof_freq; }$/;"	f	class:itpp::TDL_Channel	access:public	signature:() const
get_no_frequencies	/usr/include/itpp/comm/channel.h	/^  virtual int get_no_frequencies() const { return Ni; }$/;"	f	class:itpp::Rice_Fading_Generator	access:public	signature:() const
get_no_frequencies	/usr/include/itpp/comm/channel.h	/^  virtual int get_no_frequencies() const;$/;"	p	class:itpp::Fading_Generator	access:public	signature:() const
get_no_function_evaluations	/usr/include/itpp/optim/newton_search.h	/^  int get_no_function_evaluations();$/;"	p	class:itpp::Line_Search	access:public	signature:()
get_no_function_evaluations	/usr/include/itpp/optim/newton_search.h	/^  int get_no_function_evaluations();$/;"	p	class:itpp::Newton_Search	access:public	signature:()
get_no_gaussians	/usr/include/itpp/srccode/gmm.h	/^  int get_no_gaussians() const { return M; }$/;"	f	class:itpp::GMM	access:public	signature:() const
get_no_iterations	/usr/include/itpp/optim/newton_search.h	/^  int get_no_iterations();$/;"	p	class:itpp::Newton_Search	access:public	signature:()
get_no_mixtures	/usr/include/itpp/srccode/gmm.h	/^  int get_no_mixtures();$/;"	p	class:itpp::GMM	access:public	signature:()
get_no_mixtures	/usr/include/itpp/srccode/gmm.h	/^inline int GMM::get_no_mixtures()$/;"	f	class:itpp::GMM	signature:()
get_nocodes	/usr/include/itpp/comm/spread.h	/^  short get_nocodes() { return L; }$/;"	f	class:itpp::Multicode_Spread_1d	access:public	signature:()
get_nof_inputs	/usr/include/itpp/protocol/packet_channel.h	/^  Signal<void*> get_nof_inputs;$/;"	m	class:itpp::Packet_Channel	access:public
get_noise	/usr/include/itpp/comm/channel.h	/^  double get_noise() const { return sqr(sigma); }$/;"	f	class:itpp::AWGN_Channel	access:public	signature:() const
get_norm_doppler	/usr/include/itpp/comm/channel.h	/^  double get_norm_doppler() const { return n_dopp; }$/;"	f	class:itpp::TDL_Channel	access:public	signature:() const
get_norm_doppler	/usr/include/itpp/comm/channel.h	/^  virtual double get_norm_doppler() const { return n_dopp; }$/;"	f	class:itpp::Correlated_Fading_Generator	access:public	signature:() const
get_norm_doppler	/usr/include/itpp/comm/channel.h	/^  virtual double get_norm_doppler() const;$/;"	p	class:itpp::Fading_Generator	access:public	signature:() const
get_nrof_independent_components	/usr/include/itpp/signal/fastica.h	/^  int get_nrof_independent_components();$/;"	p	class:itpp::Fast_ICA	access:public	signature:()
get_nrof_iterations	/usr/include/itpp/comm/ldpc.h	/^  int get_nrof_iterations() const { return max_iters; }$/;"	f	class:itpp::LDPC_Code	access:public	signature:() const
get_nvar	/usr/include/itpp/comm/ldpc.h	/^  int get_nvar() const { return nvar; }$/;"	f	class:itpp::LDPC_Code	access:public	signature:() const
get_nvar	/usr/include/itpp/comm/ldpc.h	/^  int get_nvar() const {$/;"	f	class:itpp::LDPC_Parity	access:public	signature:() const
get_nz	/usr/include/itpp/base/svec.h	/^  inline void get_nz(int p, int &idx, T &dat) {$/;"	f	class:itpp::Sparse_Vec	access:public	signature:(int p, int &idx, T &dat)
get_nz_data	/usr/include/itpp/base/svec.h	/^  inline T get_nz_data(int p) {$/;"	f	class:itpp::Sparse_Vec	access:public	signature:(int p)
get_nz_data	/usr/include/itpp/base/svec.h	/^  inline void get_nz_data(int p, T& data_out) {$/;"	f	class:itpp::Sparse_Vec	access:public	signature:(int p, T& data_out)
get_nz_index	/usr/include/itpp/base/svec.h	/^  inline int get_nz_index(int p) {$/;"	f	class:itpp::Sparse_Vec	access:public	signature:(int p)
get_nz_indices	/usr/include/itpp/base/svec.h	/^  ivec get_nz_indices();$/;"	p	class:itpp::Sparse_Vec	access:public	signature:()
get_nz_indices	/usr/include/itpp/base/svec.h	/^ivec Sparse_Vec<T>::get_nz_indices()$/;"	f	class:itpp::Sparse_Vec	signature:()
get_o_mode	/usr/include/itpp/fixed/fix_base.h	/^  o_mode get_o_mode() const {return omode;}$/;"	f	class:itpp::Fix_Base	access:public	signature:() const
get_order	/usr/include/itpp/comm/interleave.h	/^  int get_order(void) {return order;};$/;"	f	class:itpp::Cross_Interleaver	access:public	signature:(void)
get_output_mode	/usr/include/itpp/fixed/fix_base.h	/^  output_mode get_output_mode() const {return outputmode;}$/;"	f	class:itpp::Fix_Base	access:public	signature:() const
get_packet_size	/usr/include/itpp/protocol/packet_generator.h	/^  int get_packet_size();$/;"	p	class:itpp::Packet_Generator	access:public	signature:()
get_pdf	/usr/include/itpp/stat/histogram.h	/^  vec get_pdf() const;$/;"	p	class:itpp::Histogram	access:public	signature:() const
get_pdf	/usr/include/itpp/stat/histogram.h	/^inline vec Histogram<Num_T>::get_pdf() const$/;"	f	class:itpp::Histogram	signature:() const
get_period	/usr/include/itpp/comm/spread.h	/^  short get_period() { return N; }$/;"	f	class:itpp::Multicode_Spread_1d	access:public	signature:()
get_period	/usr/include/itpp/comm/spread.h	/^  short get_period() { return N; }$/;"	f	class:itpp::Spread_1d	access:public	signature:()
get_period	/usr/include/itpp/comm/spread.h	/^  short get_period() { return mcspreadI.get_period(); }$/;"	f	class:itpp::Multicode_Spread_2d	access:public	signature:()
get_period	/usr/include/itpp/comm/spread.h	/^  short get_period() { return spreadI.get_period(); }$/;"	f	class:itpp::Spread_2d	access:public	signature:()
get_principal_eigenvectors	/usr/include/itpp/signal/fastica.h	/^  mat get_principal_eigenvectors();$/;"	p	class:itpp::Fast_ICA	access:public	signature:()
get_prob	/usr/include/itpp/comm/channel.h	/^  double get_prob() const { return p; };$/;"	f	class:itpp::BSC	access:public	signature:() const
get_pulse_length	/usr/include/itpp/comm/pulse_shape.h	/^  int get_pulse_length() const;$/;"	p	class:itpp::Pulse_Shape	access:public	signature:() const
get_pulse_length	/usr/include/itpp/comm/pulse_shape.h	/^int Pulse_Shape<T1, T2, T3>::get_pulse_length(void) const$/;"	f	class:itpp::Pulse_Shape	signature:(void) const
get_pulse_shape	/usr/include/itpp/comm/pulse_shape.h	/^  Vec<T2> get_pulse_shape(void) const;$/;"	p	class:itpp::Pulse_Shape	access:public	signature:(void) const
get_pulse_shape	/usr/include/itpp/comm/pulse_shape.h	/^Vec<T2> Pulse_Shape<T1, T2, T3>::get_pulse_shape(void) const$/;"	f	class:itpp::Pulse_Shape	signature:(void) const
get_puncture_matrix	/usr/include/itpp/comm/punct_convcode.h	/^  bmat get_puncture_matrix() const { return puncture_matrix; }$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:() const
get_puncture_period	/usr/include/itpp/comm/punct_convcode.h	/^  int get_puncture_period() const { return Period; }$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:() const
get_q_mode	/usr/include/itpp/fixed/fix_base.h	/^  q_mode get_q_mode() const {return qmode;}$/;"	f	class:itpp::Fix_Base	access:public	signature:() const
get_rate	/usr/include/itpp/comm/bch.h	/^  virtual double get_rate() const {return static_cast<double>(k) \/ n; }$/;"	f	class:itpp::BCH	access:public	signature:() const
get_rate	/usr/include/itpp/comm/channel_code.h	/^  virtual double get_rate() const = 0;$/;"	p	class:itpp::Channel_Code	access:public	signature:() const
get_rate	/usr/include/itpp/comm/channel_code.h	/^  virtual double get_rate() const { return 1.0; }$/;"	f	class:itpp::Dummy_Code	access:public	signature:() const
get_rate	/usr/include/itpp/comm/convcode.h	/^  virtual double get_rate(void) const { return rate; }$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(void) const
get_rate	/usr/include/itpp/comm/egolay.h	/^  virtual double get_rate() const { return 0.5; };$/;"	f	class:itpp::Extended_Golay	access:public	signature:() const
get_rate	/usr/include/itpp/comm/hammcode.h	/^  virtual double get_rate() const { return static_cast<double>(k) \/ n; };$/;"	f	class:itpp::Hamming_Code	access:public	signature:() const
get_rate	/usr/include/itpp/comm/ldpc.h	/^  double get_rate() const {$/;"	f	class:itpp::LDPC_Code	access:public	signature:() const
get_rate	/usr/include/itpp/comm/ldpc.h	/^  double get_rate() const {$/;"	f	class:itpp::LDPC_Parity	access:public	signature:() const
get_rate	/usr/include/itpp/comm/punct_convcode.h	/^  virtual double get_rate() const { return rate; }$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:() const
get_rate	/usr/include/itpp/comm/reedsolomon.h	/^  virtual double get_rate() const { return static_cast<double>(k) \/ n; }$/;"	f	class:itpp::Reed_Solomon	access:public	signature:() const
get_re	/usr/include/itpp/fixed/cfix.h	/^  fixrep get_re() const {return re;}$/;"	f	class:itpp::CFix	access:public	signature:() const
get_re	/usr/include/itpp/fixed/fix.h	/^  fixrep get_re() const {return re;}$/;"	f	class:itpp::Fix	access:public	signature:() const
get_rho	/usr/include/itpp/optim/newton_search.h	/^  double get_rho() { return stop_rho; }$/;"	f	class:itpp::Line_Search	access:public	signature:()
get_rice_method	/usr/include/itpp/comm/channel.h	/^  virtual RICE_METHOD get_rice_method() const { return rice_method; }$/;"	f	class:itpp::Rice_Fading_Generator	access:public	signature:() const
get_rice_method	/usr/include/itpp/comm/channel.h	/^  virtual RICE_METHOD get_rice_method() const;$/;"	p	class:itpp::Fading_Generator	access:public	signature:() const
get_roll_off	/usr/include/itpp/comm/pulse_shape.h	/^  double get_roll_off(void) const;$/;"	p	class:itpp::Raised_Cosine	access:public	signature:(void) const
get_roll_off	/usr/include/itpp/comm/pulse_shape.h	/^  double get_roll_off(void) const;$/;"	p	class:itpp::Root_Raised_Cosine	access:public	signature:(void) const
get_roll_off	/usr/include/itpp/comm/pulse_shape.h	/^double Raised_Cosine<T1>::get_roll_off(void) const$/;"	f	class:itpp::Raised_Cosine	signature:(void) const
get_roll_off	/usr/include/itpp/comm/pulse_shape.h	/^double Root_Raised_Cosine<T1>::get_roll_off(void) const$/;"	f	class:itpp::Root_Raised_Cosine	signature:(void) const
get_row	/usr/include/itpp/base/gf2mat.h	/^  bvec get_row(int i) const;$/;"	p	class:itpp::GF2mat	access:public	signature:(int i) const
get_row	/usr/include/itpp/base/mat.h	/^  Vec<Num_T> get_row(int r) const;$/;"	p	class:itpp::Mat	access:public	signature:(int r) const
get_row	/usr/include/itpp/base/mat.h	/^Vec<Num_T> Mat<Num_T>::get_row(int r) const$/;"	f	class:itpp::Mat	signature:(int r) const
get_row	/usr/include/itpp/comm/ldpc.h	/^  Sparse_Vec<bin> get_row(int r) const { return Ht.get_col(r); }$/;"	f	class:itpp::LDPC_Parity	access:public	signature:(int r) const
get_rows	/usr/include/itpp/base/mat.h	/^  Mat<Num_T> get_rows(const Vec<int> &indexlist) const;$/;"	p	class:itpp::Mat	access:public	signature:(const Vec<int> &indexlist) const
get_rows	/usr/include/itpp/base/mat.h	/^  Mat<Num_T> get_rows(int r1, int r2) const;$/;"	p	class:itpp::Mat	access:public	signature:(int r1, int r2) const
get_rows	/usr/include/itpp/base/mat.h	/^Mat<Num_T> Mat<Num_T>::get_rows(const Vec<int> &indexlist) const$/;"	f	class:itpp::Mat	signature:(const Vec<int> &indexlist) const
get_rows	/usr/include/itpp/base/mat.h	/^Mat<Num_T> Mat<Num_T>::get_rows(int r1, int r2) const$/;"	f	class:itpp::Mat	signature:(int r1, int r2) const
get_rows	/usr/include/itpp/comm/interleave.h	/^  int get_rows(void) {return rows;};$/;"	f	class:itpp::Block_Interleaver	access:public	signature:(void)
get_sampling_time	/usr/include/itpp/comm/channel.h	/^  double get_sampling_time() const { return discrete_Ts; }$/;"	f	class:itpp::TDL_Channel	access:public	signature:() const
get_segment	/usr/include/itpp/protocol/tcp.h	/^  TCP_Segment get_segment() const { return fSegment; }$/;"	f	class:itpp::TCP_Packet	access:public	signature:() const
get_separating_matrix	/usr/include/itpp/signal/fastica.h	/^  mat get_separating_matrix();$/;"	p	class:itpp::Fast_ICA	access:public	signature:()
get_sequence_length	/usr/include/itpp/comm/sequence.h	/^  int get_sequence_length(void);$/;"	p	class:itpp::Gold	access:public	signature:(void)
get_sequence_length	/usr/include/itpp/comm/sequence.h	/^inline int Gold::get_sequence_length(void) {return N;}$/;"	f	class:itpp::Gold	signature:(void)
get_session_id	/usr/include/itpp/protocol/tcp.h	/^  int get_session_id() const {  return fSessionId; }$/;"	f	class:itpp::TCP_Packet	access:public	signature:() const
get_setup	/usr/include/itpp/base/random.h	/^  double get_setup() const { return p; }$/;"	f	class:itpp::Bernoulli_RNG	access:public	signature:() const
get_setup	/usr/include/itpp/base/random.h	/^  double get_setup() const;$/;"	p	class:itpp::Exponential_RNG	access:public	signature:() const
get_setup	/usr/include/itpp/base/random.h	/^  double get_setup() { return sig; }$/;"	f	class:itpp::Rayleigh_RNG	access:public	signature:()
get_setup	/usr/include/itpp/base/random.h	/^  void get_setup(double &lambda, double &beta) { lambda = l; beta = b; }$/;"	f	class:itpp::Weibull_RNG	access:public	signature:(double &lambda, double &beta)
get_setup	/usr/include/itpp/base/random.h	/^  void get_setup(double &meanval, double &variance) const;$/;"	p	class:itpp::Laplace_RNG	access:public	signature:(double &meanval, double &variance) const
get_setup	/usr/include/itpp/base/random.h	/^  void get_setup(double &meanval, double &variance) const;$/;"	p	class:itpp::Normal_RNG	access:public	signature:(double &meanval, double &variance) const
get_setup	/usr/include/itpp/base/random.h	/^  void get_setup(double &meanval, double &variance, double &rho) const;$/;"	p	class:itpp::AR1_Normal_RNG	access:public	signature:(double &meanval, double &variance, double &rho) const
get_setup	/usr/include/itpp/base/random.h	/^  void get_setup(double &min, double &max) const;$/;"	p	class:itpp::Uniform_RNG	access:public	signature:(double &min, double &max) const
get_setup	/usr/include/itpp/base/random.h	/^  void get_setup(double &sigma, double &v) { sigma = sig; v = s; }$/;"	f	class:itpp::Rice_RNG	access:public	signature:(double &sigma, double &v)
get_setup	/usr/include/itpp/base/random.h	/^  void get_setup(int &min, int &max) const;$/;"	p	class:itpp::I_Uniform_RNG	access:public	signature:(int &min, int &max) const
get_setup	/usr/include/itpp/base/random.h	/^  void get_setup(std::complex<double> &mean, double &variance) {$/;"	f	class:itpp::Complex_Normal_RNG	access:public	signature:(std::complex<double> &mean, double &variance)
get_shift	/usr/include/itpp/fixed/fix_base.h	/^  int get_shift() const {return shift;}$/;"	f	class:itpp::Fix_Base	access:public	signature:() const
get_size	/usr/include/itpp/comm/galois.h	/^  int get_size() const { return ((m != 0) ? q[m] : 0); }$/;"	f	class:itpp::GF	access:public	signature:() const
get_size	/usr/include/itpp/comm/galois.h	/^  int get_size() const;$/;"	p	class:itpp::GFX	access:public	signature:() const
get_size	/usr/include/itpp/comm/galois.h	/^inline int GFX::get_size() const$/;"	f	class:itpp::GFX	signature:() const
get_slope_ratio	/usr/include/itpp/optim/newton_search.h	/^  double get_slope_ratio();$/;"	p	class:itpp::Line_Search	access:public	signature:()
get_smat	/usr/include/itpp/base/parser.h	/^  smat get_smat(const std::string &name, int num = -1);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &name, int num = -1)
get_solution	/usr/include/itpp/optim/newton_search.h	/^  vec get_solution();$/;"	p	class:itpp::Newton_Search	access:public	signature:()
get_solution	/usr/include/itpp/optim/newton_search.h	/^  void get_solution(vec &xn, double &Fn, vec &gn);$/;"	p	class:itpp::Line_Search	access:public	signature:(vec &xn, double &Fn, vec &gn)
get_source_port	/usr/include/itpp/protocol/tcp.h	/^  unsigned get_source_port() const { return fSourcePort; }$/;"	f	class:itpp::TCP_Packet	access:public	signature:() const
get_state	/usr/include/itpp/base/random.h	/^  void get_state(ivec &out_state);$/;"	p	class:itpp::Random_Generator	access:public	signature:(ivec &out_state)
get_state	/usr/include/itpp/comm/sequence.h	/^  bvec get_state(void);$/;"	p	class:itpp::LFSR	access:public	signature:(void)
get_state	/usr/include/itpp/comm/sequence.h	/^inline bvec LFSR::get_state(void) {return memory;}$/;"	f	class:itpp::LFSR	signature:(void)
get_state	/usr/include/itpp/signal/filter.h	/^  Vec<T3> get_state() const;$/;"	p	class:itpp::ARMA_Filter	access:public	signature:() const
get_state	/usr/include/itpp/signal/filter.h	/^  Vec<T3> get_state() const;$/;"	p	class:itpp::AR_Filter	access:public	signature:() const
get_state	/usr/include/itpp/signal/filter.h	/^  Vec<T3> get_state() const;$/;"	p	class:itpp::MA_Filter	access:public	signature:() const
get_state	/usr/include/itpp/signal/filter.h	/^Vec<T3> ARMA_Filter<T1, T2, T3>::get_state() const$/;"	f	class:itpp::ARMA_Filter	signature:() const
get_state	/usr/include/itpp/signal/filter.h	/^Vec<T3> AR_Filter<T1, T2, T3>::get_state() const$/;"	f	class:itpp::AR_Filter	signature:() const
get_state	/usr/include/itpp/signal/filter.h	/^Vec<T3> MA_Filter<T1, T2, T3>::get_state() const$/;"	f	class:itpp::MA_Filter	signature:() const
get_stop_1	/usr/include/itpp/optim/newton_search.h	/^  double get_stop_1();$/;"	p	class:itpp::Newton_Search	access:public	signature:()
get_stop_2	/usr/include/itpp/optim/newton_search.h	/^  double get_stop_2();$/;"	p	class:itpp::Newton_Search	access:public	signature:()
get_string	/usr/include/itpp/base/parser.h	/^  std::string get_string(const std::string &name, int num = -1);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &name, int num = -1)
get_submatrix	/usr/include/itpp/base/gf2mat.h	/^  GF2mat get_submatrix(int m1, int n1, int m2, int n2) const;$/;"	p	class:itpp::GF2mat	access:public	signature:(int m1, int n1, int m2, int n2) const
get_submatrix	/usr/include/itpp/base/smat.h	/^  Sparse_Mat<T> get_submatrix(int r1, int r2, int c1, int c2) const;$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(int r1, int r2, int c1, int c2) const
get_submatrix	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> Sparse_Mat<T>::get_submatrix(int r1, int r2, int c1, int c2) const$/;"	f	class:itpp::Sparse_Mat	signature:(int r1, int r2, int c1, int c2) const
get_submatrix_cols	/usr/include/itpp/base/smat.h	/^  Sparse_Mat<T> get_submatrix_cols(int c1, int c2) const;$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(int c1, int c2) const
get_submatrix_cols	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> Sparse_Mat<T>::get_submatrix_cols(int c1, int c2) const$/;"	f	class:itpp::Sparse_Mat	signature:(int c1, int c2) const
get_subvector	/usr/include/itpp/base/svec.h	/^  Sparse_Vec<T> get_subvector(int i1, int i2) const;$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(int i1, int i2) const
get_subvector	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T> Sparse_Vec<T>::get_subvector(int i1, int i2) const$/;"	f	class:itpp::Sparse_Vec	signature:(int i1, int i2) const
get_svec	/usr/include/itpp/base/parser.h	/^  svec get_svec(const std::string &name, int num = -1);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &name, int num = -1)
get_symbols	/usr/include/itpp/comm/modulator.h	/^  virtual Vec<T> get_symbols() const { return symbols; }$/;"	f	class:itpp::Modulator	access:public	signature:() const
get_symbols	/usr/include/itpp/comm/modulator_nd.h	/^  Array<cvec> get_symbols() const { return symbols; }$/;"	f	class:itpp::Modulator_NCD	access:public	signature:() const
get_symbols	/usr/include/itpp/comm/modulator_nd.h	/^  Array<vec> get_symbols() const { return symbols; }$/;"	f	class:itpp::Modulator_NRD	access:public	signature:() const
get_time	/usr/include/itpp/base/timing.h	/^  double get_time() const;$/;"	p	class:itpp::Timer	access:public	signature:() const
get_time_offset	/usr/include/itpp/comm/channel.h	/^  double get_time_offset() const;$/;"	p	class:itpp::TDL_Channel	access:public	signature:() const
get_time_offset	/usr/include/itpp/comm/channel.h	/^  virtual double get_time_offset() const { return time_offset; }$/;"	f	class:itpp::Correlated_Fading_Generator	access:public	signature:() const
get_time_offset	/usr/include/itpp/comm/channel.h	/^  virtual double get_time_offset() const;$/;"	p	class:itpp::Fading_Generator	access:public	signature:() const
get_total_bits	/usr/include/itpp/comm/error_counters.h	/^  double get_total_bits() const { return (errors + corrects); }$/;"	f	class:itpp::BERC	access:public	signature:() const
get_total_blocks	/usr/include/itpp/comm/error_counters.h	/^  double get_total_blocks() const { return (errors + corrects); }$/;"	f	class:itpp::BLERC	access:public	signature:() const
get_trace	/usr/include/itpp/optim/newton_search.h	/^  void get_trace(Array<vec> & xvalues, vec &Fvalues, vec &ngvalues, vec &dvalues);$/;"	p	class:itpp::Newton_Search	access:public	signature:(Array<vec> & xvalues, vec &Fvalues, vec &ngvalues, vec &dvalues)
get_trace	/usr/include/itpp/optim/newton_search.h	/^  void get_trace(vec &alphavalues, vec &Fvalues, vec &dFvalues);$/;"	p	class:itpp::Line_Search	access:public	signature:(vec &alphavalues, vec &Fvalues, vec &dFvalues)
get_true_degree	/usr/include/itpp/comm/galois.h	/^  int get_true_degree() const;$/;"	p	class:itpp::GFX	access:public	signature:() const
get_true_degree	/usr/include/itpp/comm/galois.h	/^inline int GFX::get_true_degree() const$/;"	f	class:itpp::GFX	signature:() const
get_truncation_length	/usr/include/itpp/comm/convcode.h	/^  int get_truncation_length(void) const { return trunc_length; }$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(void) const
get_type	/usr/include/itpp/comm/ldpc.h	/^  std::string get_type() const { return type; }$/;"	f	class:itpp::LDPC_Generator	access:public	signature:() const
get_upsampling_factor	/usr/include/itpp/comm/pulse_shape.h	/^  int get_upsampling_factor() const;$/;"	p	class:itpp::Pulse_Shape	access:public	signature:() const
get_upsampling_factor	/usr/include/itpp/comm/pulse_shape.h	/^int Pulse_Shape<T1, T2, T3>::get_upsampling_factor(void) const$/;"	f	class:itpp::Pulse_Shape	signature:(void) const
get_user_message	/usr/include/itpp/protocol/tcp.h	/^  itpp::Packet & get_user_message(); \/**< \\brief called by higher layer *\/$/;"	p	class:itpp::TCP_Receiver	access:public	signature:()
get_value	/usr/include/itpp/comm/galois.h	/^  int  get_value() const;$/;"	p	class:itpp::GF	access:public	signature:() const
get_value	/usr/include/itpp/comm/galois.h	/^inline int  GF::get_value() const$/;"	f	class:itpp::GF	signature:() const
get_vec	/usr/include/itpp/base/parser.h	/^  vec get_vec(const std::string &name, int num = -1);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &name, int num = -1)
get_vectorspace	/usr/include/itpp/comm/galois.h	/^  bvec get_vectorspace() const;$/;"	p	class:itpp::GF	access:public	signature:() const
get_vectorspace	/usr/include/itpp/comm/galois.h	/^inline bvec GF::get_vectorspace() const$/;"	f	class:itpp::GF	signature:() const
get_weight	/usr/include/itpp/srccode/gmm.h	/^  double get_weight(int i);$/;"	p	class:itpp::GMM	access:public	signature:(int i)
get_weight	/usr/include/itpp/srccode/gmm.h	/^  vec get_weight();$/;"	p	class:itpp::GMM	access:public	signature:()
get_weight	/usr/include/itpp/srccode/gmm.h	/^inline double GMM::get_weight(int i) {return w(i);}$/;"	f	class:itpp::GMM	signature:(int i)
get_weight	/usr/include/itpp/srccode/gmm.h	/^inline vec GMM::get_weight() {return w;}$/;"	f	class:itpp::GMM	signature:()
get_weights	/usr/include/itpp/stat/mog_generic.h	/^  vec get_weights() const { vec tmp;  if (valid) { tmp = weights; } return tmp; }$/;"	f	class:itpp::MOG_generic	access:public	signature:() const
get_white_sig	/usr/include/itpp/signal/fastica.h	/^  mat get_white_sig();$/;"	p	class:itpp::Fast_ICA	access:public	signature:()
get_whitening_matrix	/usr/include/itpp/signal/fastica.h	/^  mat get_whitening_matrix();$/;"	p	class:itpp::Fast_ICA	access:public	signature:()
get_wnd	/usr/include/itpp/protocol/tcp.h	/^  unsigned get_wnd() const { return fWnd; }$/;"	f	class:itpp::TCP_Packet	access:public	signature:() const
get_wordlen	/usr/include/itpp/fixed/fix_base.h	/^  int get_wordlen() const {return wordlen;}$/;"	f	class:itpp::Fix_Base	access:public	signature:() const
gf2dense_eye	/usr/include/itpp/base/gf2mat.h	/^GF2mat gf2dense_eye(int m);$/;"	p	namespace:itpp	signature:(int m)
givens	/usr/include/itpp/base/specmat.h	/^mat givens(double a, double b);$/;"	p	namespace:itpp	signature:(double a, double b)
givens	/usr/include/itpp/base/specmat.h	/^void givens(double a, double b, double &c, double &s);$/;"	p	namespace:itpp	signature:(double a, double b, double &c, double &s)
givens	/usr/include/itpp/base/specmat.h	/^void givens(double a, double b, mat &m);$/;"	p	namespace:itpp	signature:(double a, double b, mat &m)
givens_t	/usr/include/itpp/base/specmat.h	/^mat givens_t(double a, double b);$/;"	p	namespace:itpp	signature:(double a, double b)
givens_t	/usr/include/itpp/base/specmat.h	/^void givens_t(double a, double b, mat &m);$/;"	p	namespace:itpp	signature:(double a, double b, mat &m)
global_id	/usr/include/itpp/protocol/events.h	/^  static unsigned long long int global_id;$/;"	m	class:itpp::Base_Event	access:protected
gmmtrain	/usr/include/itpp/srccode/gmm.h	/^GMM gmmtrain(Array<vec> &TrainingData, int M, int NOITER = 30, bool VERBOSE = true);$/;"	p	namespace:itpp	signature:(Array<vec> &TrainingData, int M, int NOITER = 30, bool VERBOSE = true)
good	/usr/include/itpp/srccode/audiofile.h	/^  bool good() { return is_valid && file.good(); }$/;"	f	class:itpp::Audio_File	access:public	signature:()
gray_code	/usr/include/itpp/base/converters.h	/^inline int gray_code(int x) { return x ^(x >> 1); }$/;"	f	namespace:itpp	signature:(int x)
graycode	/usr/include/itpp/comm/commfunc.h	/^bmat graycode(int m);$/;"	p	namespace:itpp	signature:(int m)
greater_modulo_L	/usr/include/itpp/protocol/selective_repeat.h	/^  bool greater_modulo_L(const int a, const int b);$/;"	p	class:itpp::Selective_Repeat_ARQ_Receiver	access:private	signature:(const int a, const int b)
h_start	/usr/include/itpp/optim/newton_search.h	/^  vec x_start, g_start, h_start;$/;"	m	class:itpp::Line_Search	access:private
hadamard	/usr/include/itpp/base/specmat.h	/^imat hadamard(int size);$/;"	p	namespace:itpp	signature:(int size)
hamming	/usr/include/itpp/signal/window.h	/^vec hamming(int size);$/;"	p	namespace:itpp	signature:(int size)
hamming_distance	/usr/include/itpp/comm/commfunc.h	/^int hamming_distance(const bvec &a, const bvec &b);$/;"	p	namespace:itpp	signature:(const bvec &a, const bvec &b)
handle_ack_input	/usr/include/itpp/protocol/selective_repeat.h	/^  void handle_ack_input(Array<Packet*> packet_array); \/\/ Take care of incomming ack\/nacks.$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:(Array<Packet*> packet_array)
handle_input	/usr/include/itpp/protocol/packet_channel.h	/^  void handle_input(ACK* M);$/;"	p	class:itpp::ACK_Channel	access:private	signature:(ACK* M)
handle_input	/usr/include/itpp/protocol/packet_channel.h	/^  void handle_input(Link_Packet* M);$/;"	p	class:itpp::Packet_Channel	access:private	signature:(Link_Packet* M)
handle_next	/usr/include/itpp/protocol/packet_generator.h	/^  void handle_next(Packet*);$/;"	p	class:itpp::Packet_Generator	access:private	signature:(Packet*)
handle_nof_inputs	/usr/include/itpp/protocol/packet_channel.h	/^  void handle_nof_inputs(const int N);$/;"	p	class:itpp::Packet_Channel	access:private	signature:(const int N)
handle_packet_input	/usr/include/itpp/protocol/packet_generator.h	/^  void handle_packet_input(Packet* packet);$/;"	p	class:itpp::Sink	access:private	signature:(Packet* packet)
handle_packet_input	/usr/include/itpp/protocol/selective_repeat.h	/^  void handle_packet_input(Array<Packet*>); \/\/ Take care of incomming packets.$/;"	p	class:itpp::Selective_Repeat_ARQ_Receiver	access:private	signature:(Array<Packet*>)
handle_packet_input	/usr/include/itpp/protocol/selective_repeat.h	/^  void handle_packet_input(Packet *P);          \/\/ Take care of incomming packets.$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:(Packet *P)
handle_packet_output_request	/usr/include/itpp/protocol/selective_repeat.h	/^  void handle_packet_output_request(int K);     \/\/ Take care of incomming packet requests.$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:(int K)
handle_query_nof_ready_packets	/usr/include/itpp/protocol/selective_repeat.h	/^  void handle_query_nof_ready_packets(void*);   \/\/ Take care of incomming query for number of packets ready to transmit.$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:(void*)
handle_start	/usr/include/itpp/protocol/packet_channel.h	/^  void handle_start(const bool start);$/;"	p	class:itpp::Packet_Channel	access:private	signature:(const bool start)
handle_start	/usr/include/itpp/protocol/packet_generator.h	/^  void handle_start(const bool run);$/;"	p	class:itpp::Packet_Generator	access:private	signature:(const bool run)
hann	/usr/include/itpp/signal/window.h	/^vec hann(int n);$/;"	p	namespace:itpp	signature:(int n)
hanning	/usr/include/itpp/signal/window.h	/^vec hanning(int n);$/;"	p	namespace:itpp	signature:(int n)
hash	/usr/include/itpp/base/random.h	/^  unsigned int hash(time_t t, clock_t c);$/;"	p	class:itpp::Random_Generator	access:private	signature:(time_t t, clock_t c)
hdr_bytes	/usr/include/itpp/base/itfile.h	/^    uint32_t hdr_bytes, data_bytes, block_bytes;$/;"	m	struct:itpp::it_file_base_old::data_header	access:public
hdr_bytes	/usr/include/itpp/base/itfile.h	/^    uint64_t hdr_bytes;$/;"	m	struct:itpp::it_file_base::data_header	access:public
hdr_size	/usr/include/itpp/srccode/audiofile.h	/^    unsigned hdr_size;$/;"	m	struct:itpp::SND_Format::__anon1	access:public
header	/usr/include/itpp/srccode/audiofile.h	/^  } header; \/\/!< Definition of the header structure$/;"	m	class:itpp::SND_Format	typeref:struct:itpp::SND_Format::__anon1	access:protected
hermitian_transpose	/usr/include/itpp/base/mat.h	/^  Mat<Num_T> hermitian_transpose() const;$/;"	p	class:itpp::Mat	access:public	signature:() const
hermitian_transpose	/usr/include/itpp/base/mat.h	/^Mat<Num_T> Mat<Num_T>::hermitian_transpose() const$/;"	f	class:itpp::Mat	signature:() const
hermitian_transpose	/usr/include/itpp/base/mat.h	/^cmat cmat::hermitian_transpose() const;$/;"	p	class:itpp::cmat	signature:() const
hermitian_transpose	/usr/include/itpp/base/matfunc.h	/^Mat<T> hermitian_transpose(const Mat<T> &m) { return m.H(); }$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
hermitian_transpose	/usr/include/itpp/base/matfunc.h	/^extern template bmat hermitian_transpose(const bmat &m);$/;"	p	namespace:itpp	signature:(const bmat &m)
hermitian_transpose	/usr/include/itpp/base/matfunc.h	/^extern template cmat hermitian_transpose(const cmat &m);$/;"	p	namespace:itpp	signature:(const cmat &m)
hermitian_transpose	/usr/include/itpp/base/matfunc.h	/^extern template imat hermitian_transpose(const imat &m);$/;"	p	namespace:itpp	signature:(const imat &m)
hermitian_transpose	/usr/include/itpp/base/matfunc.h	/^extern template mat hermitian_transpose(const mat &m);$/;"	p	namespace:itpp	signature:(const mat &m)
hermitian_transpose	/usr/include/itpp/base/matfunc.h	/^extern template smat hermitian_transpose(const smat &m);$/;"	p	namespace:itpp	signature:(const smat &m)
hermitian_transpose	/usr/include/itpp/base/matfunc.h	/^extern template void hermitian_transpose(const bmat &m, bmat &out);$/;"	p	namespace:itpp	signature:(const bmat &m, bmat &out)
hermitian_transpose	/usr/include/itpp/base/matfunc.h	/^extern template void hermitian_transpose(const cmat &m, cmat &out);$/;"	p	namespace:itpp	signature:(const cmat &m, cmat &out)
hermitian_transpose	/usr/include/itpp/base/matfunc.h	/^extern template void hermitian_transpose(const imat &m, imat &out);$/;"	p	namespace:itpp	signature:(const imat &m, imat &out)
hermitian_transpose	/usr/include/itpp/base/matfunc.h	/^extern template void hermitian_transpose(const mat &m, mat &out);$/;"	p	namespace:itpp	signature:(const mat &m, mat &out)
hermitian_transpose	/usr/include/itpp/base/matfunc.h	/^extern template void hermitian_transpose(const smat &m, smat &out);$/;"	p	namespace:itpp	signature:(const smat &m, smat &out)
hermitian_transpose	/usr/include/itpp/base/matfunc.h	/^void hermitian_transpose(const Mat<T> &m, Mat<T> &out) { out = m.H(); }$/;"	f	namespace:itpp	signature:(const Mat<T> &m, Mat<T> &out)
hermitian_transpose	/usr/include/itpp/base/vec.h	/^  Mat<Num_T> hermitian_transpose() const;$/;"	p	class:itpp::Vec	access:public	signature:() const
hermitian_transpose	/usr/include/itpp/base/vec.h	/^Mat<Num_T> Vec<Num_T>::hermitian_transpose() const$/;"	f	class:itpp::Vec	signature:() const
hermitian_transpose	/usr/include/itpp/base/vec.h	/^Mat<std::complex<double> > Vec<std::complex<double> >::hermitian_transpose() const;$/;"	p	class:itpp::Vec	signature:() const
hi	/usr/include/itpp/base/random.h	/^  int hi;$/;"	m	class:itpp::I_Uniform_RNG	access:private
hiBit	/usr/include/itpp/base/random.h	/^  unsigned int hiBit(const unsigned int& u) const { return u & 0x80000000U; }$/;"	f	class:itpp::Random_Generator	access:private	signature:(const unsigned int& u) const
hi_bound	/usr/include/itpp/base/random.h	/^  double lo_bound, hi_bound;$/;"	m	class:itpp::Uniform_RNG	access:private
hi_vals	/usr/include/itpp/stat/histogram.h	/^  Vec<Num_T> hi_vals;$/;"	m	class:itpp::Histogram	access:private
histogram	/usr/include/itpp/stat/misc_stat.h	/^  vec histogram() const {return vec(0);}$/;"	f	class:itpp::Stat	access:public	signature:() const
house	/usr/include/itpp/base/specmat.h	/^void house(const vec &x, vec &v, double &beta);$/;"	p	namespace:itpp	signature:(const vec &x, vec &v, double &beta)
icasig	/usr/include/itpp/signal/fastica.h	/^  mat mixedSig, A, W, icasig;$/;"	m	class:itpp::Fast_ICA	access:private
id	/usr/include/itpp/protocol/events.h	/^  unsigned long long int id;$/;"	m	class:itpp::Base_Event	access:protected
id	/usr/include/itpp/protocol/packet.h	/^  int id;$/;"	m	class:itpp::ACK	access:public
id	/usr/include/itpp/protocol/packet_generator.h	/^  unsigned long int id;$/;"	m	class:itpp::Packet_Generator	access:private
id	/usr/include/itpp/protocol/selective_repeat.h	/^  int id;$/;"	m	class:itpp::Selective_Repeat_ARQ_Receiver	access:private
id	/usr/include/itpp/protocol/selective_repeat.h	/^  int id;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
idct	/usr/include/itpp/signal/transforms.h	/^vec idct(const vec &in);$/;"	p	namespace:itpp	signature:(const vec &in)
idct	/usr/include/itpp/signal/transforms.h	/^void idct(const vec &in, vec &out);$/;"	p	namespace:itpp	signature:(const vec &in, vec &out)
ifft	/usr/include/itpp/signal/transforms.h	/^cvec ifft(const cvec &in);$/;"	p	namespace:itpp	signature:(const cvec &in)
ifft	/usr/include/itpp/signal/transforms.h	/^cvec ifft(const cvec &in, const int N);$/;"	p	namespace:itpp	signature:(const cvec &in, const int N)
ifft	/usr/include/itpp/signal/transforms.h	/^void ifft(const cvec &in, cvec &out);$/;"	p	namespace:itpp	signature:(const cvec &in, cvec &out)
ifft_real	/usr/include/itpp/signal/transforms.h	/^vec ifft_real(const cvec &in);$/;"	p	namespace:itpp	signature:(const cvec &in)
ifft_real	/usr/include/itpp/signal/transforms.h	/^vec ifft_real(const cvec &in, const int N);$/;"	p	namespace:itpp	signature:(const cvec &in, const int N)
ifft_real	/usr/include/itpp/signal/transforms.h	/^void ifft_real(const cvec &in, vec &out);$/;"	p	namespace:itpp	signature:(const cvec &in, vec &out)
ignorefirst	/usr/include/itpp/comm/error_counters.h	/^  int ignorefirst;$/;"	m	class:itpp::BERC	access:private
ignorelast	/usr/include/itpp/comm/error_counters.h	/^  int ignorelast;$/;"	m	class:itpp::BERC	access:private
iind	/usr/include/itpp/comm/ldpc.h	/^  ivec C, V, sumX1, sumX2, iind, jind;$/;"	m	class:itpp::LDPC_Code	access:private
im	/usr/include/itpp/fixed/cfix.h	/^  fixrep im;   \/\/!< Imaginary data part$/;"	m	class:itpp::CFix	access:protected
imag	/usr/include/itpp/base/math/elem_math.h	/^mat imag(const cmat &x);$/;"	p	namespace:itpp	signature:(const cmat &x)
imag	/usr/include/itpp/base/math/elem_math.h	/^vec imag(const cvec &x);$/;"	p	namespace:itpp	signature:(const cvec &x)
imag	/usr/include/itpp/fixed/fix_functions.h	/^Fix imag(const CFix &x);$/;"	p	namespace:itpp	signature:(const CFix &x)
imat	/usr/include/itpp/base/mat.h	/^typedef Mat<int> imat;$/;"	t	namespace:itpp
imat2mxArray	/usr/include/itpp/itmex.h	/^void imat2mxArray(const imat &in, mxArray *out)$/;"	f	namespace:itpp	signature:(const imat &in, mxArray *out)
imat2mxArray	/usr/include/itpp/itmex.h	/^void imat2mxArray(const imat &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const imat &in, mxArray *out)
img_double2int	/usr/include/itpp/srccode/pnm.h	/^imat img_double2int(const mat & m,$/;"	p	namespace:itpp	signature:(const mat & m, int max_val = 255, double double_min = 0 , double double_max = 1)
img_int2double	/usr/include/itpp/srccode/pnm.h	/^mat img_int2double(const imat & m,$/;"	p	namespace:itpp	signature:(const imat & m, int max_val = 255, double double_min = 0, double double_max = 1)
import_alist	/usr/include/itpp/comm/ldpc.h	/^  void import_alist(const GF2mat_sparse_alist& H_alist);$/;"	p	class:itpp::LDPC_Parity	access:public	signature:(const GF2mat_sparse_alist& H_alist)
impulse	/usr/include/itpp/base/specmat.h	/^vec impulse(int size);$/;"	p	namespace:itpp	signature:(int size)
impulse	/usr/include/itpp/signal/freq_filt.h	/^  Vec<Num_T> impulse;$/;"	m	class:itpp::Freq_Filt	access:private
impulse_response	/usr/include/itpp/comm/pulse_shape.h	/^  Vec<T2> impulse_response;$/;"	m	class:itpp::Pulse_Shape	access:protected
in_range	/usr/include/itpp/base/array.h	/^  bool in_range(int i) const { return ((i < ndata) && (i >= 0)); }$/;"	f	class:itpp::Array	access:protected	signature:(int i) const
in_range	/usr/include/itpp/base/mat.h	/^  bool in_range(int i) const { return ((i >= 0) && (i < datasize)); }$/;"	f	class:itpp::Mat	access:private	signature:(int i) const
in_range	/usr/include/itpp/base/mat.h	/^  bool in_range(int r, int c) const {$/;"	f	class:itpp::Mat	access:private	signature:(int r, int c) const
in_range	/usr/include/itpp/base/vec.h	/^  bool in_range(int i) const { return ((i < datasize) && (i >= 0)); }$/;"	f	class:itpp::Vec	access:private	signature:(int i) const
index	/usr/include/itpp/base/svec.h	/^  int *index;$/;"	m	class:itpp::Sparse_Vec	access:private
index_zero_pad	/usr/include/itpp/base/matfunc.h	/^T index_zero_pad(const Vec<T> &v, const int index)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, const int index)
infinity	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  const double infinity;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
info	/usr/include/itpp/base/itfile.h	/^  void info(std::string& name, std::string& type, int& bytes);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(std::string& name, std::string& type, int& bytes)
info	/usr/include/itpp/base/itfile.h	/^  void info(std::string& name, std::string& type, std::string& desc,$/;"	p	class:itpp::it_ifile	access:public	signature:(std::string& name, std::string& type, std::string& desc, uint64_t& bytes)
info	/usr/include/itpp/protocol/tcp.h	/^  std::ostream &info(std::ostream &os, int detail = 0) const; \/**< \\brief print info *\/$/;"	p	class:itpp::TCP_Receiver_Buffer	access:public	signature:(std::ostream &os, int detail = 0) const
info	/usr/include/itpp/srccode/audiofile.h	/^    char info[SND_INFO_LEN];$/;"	m	struct:itpp::SND_Format::__anon1	access:public
init	/usr/include/itpp/base/parser.h	/^  void init(const Array<std::string> &setup);$/;"	p	class:itpp::Parser	access:public	signature:(const Array<std::string> &setup)
init	/usr/include/itpp/base/parser.h	/^  void init(const std::string &filename);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &filename)
init	/usr/include/itpp/base/parser.h	/^  void init(const std::string &filename, int argc, char *argv[]);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &filename, int argc, char *argv[])
init	/usr/include/itpp/base/parser.h	/^  void init(int argc, char *argv[]);$/;"	p	class:itpp::Parser	access:public	signature:(int argc, char *argv[])
init	/usr/include/itpp/base/smat.h	/^  void init();$/;"	p	class:itpp::Sparse_Mat	access:private	signature:()
init	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::init()$/;"	f	class:itpp::Sparse_Mat	signature:()
init	/usr/include/itpp/base/svec.h	/^  void init();$/;"	p	class:itpp::Sparse_Vec	access:private	signature:()
init	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::init()$/;"	f	class:itpp::Sparse_Vec	signature:()
init	/usr/include/itpp/comm/channel.h	/^  virtual void init() = 0;$/;"	p	class:itpp::Correlated_Fading_Generator	access:public	signature:()
init	/usr/include/itpp/comm/channel.h	/^  virtual void init() = 0;$/;"	p	class:itpp::Fading_Generator	access:public	signature:()
init	/usr/include/itpp/comm/channel.h	/^  virtual void init() { init_flag = true; }$/;"	f	class:itpp::IFFT_Fading_Generator	access:public	signature:()
init	/usr/include/itpp/comm/channel.h	/^  virtual void init() { init_flag = true; }$/;"	f	class:itpp::Independent_Fading_Generator	access:public	signature:()
init	/usr/include/itpp/comm/channel.h	/^  virtual void init();$/;"	p	class:itpp::FIR_Fading_Generator	access:public	signature:()
init	/usr/include/itpp/comm/channel.h	/^  virtual void init();$/;"	p	class:itpp::Rice_Fading_Generator	access:public	signature:()
init	/usr/include/itpp/comm/channel.h	/^  virtual void init();$/;"	p	class:itpp::Static_Fading_Generator	access:public	signature:()
init	/usr/include/itpp/comm/channel.h	/^  void init();$/;"	p	class:itpp::TDL_Channel	access:public	signature:()
init	/usr/include/itpp/fixed/fix_base.h	/^  void init();$/;"	p	class:itpp::Fix_Base	access:protected	signature:()
init	/usr/include/itpp/optim/newton_search.h	/^  bool init, finished, trace;$/;"	m	class:itpp::Newton_Search	access:private
init	/usr/include/itpp/optim/newton_search.h	/^  bool init; \/\/ true if functions and starting points are set$/;"	m	class:itpp::Line_Search	access:private
init	/usr/include/itpp/signal/filter.h	/^  bool init;$/;"	m	class:itpp::ARMA_Filter	access:private
init	/usr/include/itpp/signal/filter.h	/^  bool init;$/;"	m	class:itpp::AR_Filter	access:private
init	/usr/include/itpp/signal/filter.h	/^  bool init;$/;"	m	class:itpp::MA_Filter	access:private
init	/usr/include/itpp/signal/freq_filt.h	/^  void init(const Vec<Num_T> &b, const int xlength);$/;"	p	class:itpp::Freq_Filt	access:private	signature:(const Vec<Num_T> &b, const int xlength)
init	/usr/include/itpp/signal/freq_filt.h	/^void Freq_Filt<Num_T>::init(const Vec<Num_T> &b, const int xlength)$/;"	f	class:itpp::Freq_Filt	signature:(const Vec<Num_T> &b, const int xlength)
init	/usr/include/itpp/srccode/gmm.h	/^  void init(const vec &w_in, const mat &m_in, const mat &sigma_in);$/;"	p	class:itpp::GMM	access:public	signature:(const vec &w_in, const mat &m_in, const mat &sigma_in)
init	/usr/include/itpp/stat/mog_generic.h	/^  void init();$/;"	p	class:itpp::MOG_generic	access:public	signature:()
init	/usr/include/itpp/stat/mog_generic.h	/^  void init(Array<vec> &means_in, Array<mat> &full_covs_in, vec &weights_in);$/;"	p	class:itpp::MOG_generic	access:public	signature:(Array<vec> &means_in, Array<mat> &full_covs_in, vec &weights_in)
init	/usr/include/itpp/stat/mog_generic.h	/^  void init(Array<vec> &means_in, Array<vec> &diag_covs_in, vec &weights_in);$/;"	p	class:itpp::MOG_generic	access:public	signature:(Array<vec> &means_in, Array<vec> &diag_covs_in, vec &weights_in)
init	/usr/include/itpp/stat/mog_generic.h	/^  void init(Array<vec> &means_in, bool full_in = false);$/;"	p	class:itpp::MOG_generic	access:public	signature:(Array<vec> &means_in, bool full_in = false)
init	/usr/include/itpp/stat/mog_generic.h	/^  void init(const int &K_in, const int &D_in, bool full_in = false);$/;"	p	class:itpp::MOG_generic	access:public	signature:(const int &K_in, const int &D_in, bool full_in = false)
initGuess	/usr/include/itpp/signal/fastica.h	/^  mat initGuess;$/;"	m	class:itpp::Fast_ICA	access:private
initState	/usr/include/itpp/signal/fastica.h	/^  int approach, numOfIC, g, initState;$/;"	m	class:itpp::Fast_ICA	access:private
init_MEDS	/usr/include/itpp/comm/channel.h	/^  void init_MEDS();$/;"	p	class:itpp::Rice_Fading_Generator	access:protected	signature:()
init_encoder	/usr/include/itpp/comm/convcode.h	/^  void init_encoder() { encoder_state = start_state; }$/;"	f	class:itpp::Convolutional_Code	access:public	signature:()
init_encoder	/usr/include/itpp/comm/punct_convcode.h	/^  void init_encoder() { encoder_state = start_state; }$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:()
init_flag	/usr/include/itpp/comm/channel.h	/^  bool init_flag; \/\/!< Channel ready to produce data$/;"	m	class:itpp::TDL_Channel	access:protected
init_flag	/usr/include/itpp/comm/channel.h	/^  bool init_flag; \/\/!< signals if generator is initialized or not$/;"	m	class:itpp::Fading_Generator	access:protected
init_flag	/usr/include/itpp/comm/ldpc.h	/^  bool init_flag;  \/\/!< True if generator is initialized$/;"	m	class:itpp::LDPC_Generator	access:protected
init_flag	/usr/include/itpp/comm/ldpc.h	/^  bool init_flag;$/;"	m	class:itpp::LDPC_Parity	access:protected
init_from_vq	/usr/include/itpp/srccode/gmm.h	/^  void init_from_vq(const vec &codebook, int dim);$/;"	p	class:itpp::GMM	access:public	signature:(const vec &codebook, int dim)
init_llr_tables	/usr/include/itpp/comm/llr.h	/^  void init_llr_tables(short int Dint1 = 12, short int Dint2 = 300,$/;"	p	class:itpp::LLR_calc_unit	access:public	signature:(short int Dint1 = 12, short int Dint2 = 300, short int Dint3 = 7)
initial_means	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  void initial_means();$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:protected	signature:()
initial_stepsize	/usr/include/itpp/optim/newton_search.h	/^  double initial_stepsize; \/\/ opts(1)$/;"	m	class:itpp::Newton_Search	access:private
initialize	/usr/include/itpp/base/random.h	/^  void initialize(unsigned int seed) {$/;"	f	class:itpp::Random_Generator	access:private	signature:(unsigned int seed)
initialize	/usr/include/itpp/comm/ldpc.h	/^  void initialize(int ncheck, int nvar);$/;"	p	class:itpp::LDPC_Parity	access:public	signature:(int ncheck, int nvar)
initialized	/usr/include/itpp/base/random.h	/^  static bool initialized;$/;"	m	class:itpp::Random_Generator	access:private
inptr	/usr/include/itpp/signal/filter.h	/^  int inptr;$/;"	m	class:itpp::ARMA_Filter	access:private
inptr	/usr/include/itpp/signal/filter.h	/^  int inptr;$/;"	m	class:itpp::AR_Filter	access:private
inptr	/usr/include/itpp/signal/filter.h	/^  int inptr;$/;"	m	class:itpp::MA_Filter	access:private
input	/usr/include/itpp/protocol/packet_channel.h	/^  Slot<ACK_Channel, ACK*> input;$/;"	m	class:itpp::ACK_Channel	access:public
input	/usr/include/itpp/protocol/packet_channel.h	/^  Slot<Packet_Channel, Link_Packet*> input;$/;"	m	class:itpp::Packet_Channel	access:public
input_buffer	/usr/include/itpp/protocol/selective_repeat.h	/^  Array<Link_Packet*> input_buffer;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
input_buffer_size	/usr/include/itpp/protocol/selective_repeat.h	/^  int input_buffer_size;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
input_free_space	/usr/include/itpp/protocol/selective_repeat.h	/^  int input_free_space;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
input_length	/usr/include/itpp/comm/interleave.h	/^  int input_length;$/;"	m	class:itpp::Cross_Interleaver	access:private
input_length	/usr/include/itpp/comm/interleave.h	/^  int interleaver_depth, input_length;$/;"	m	class:itpp::Sequence_Interleaver	access:private
input_length	/usr/include/itpp/comm/interleave.h	/^  int rows, cols, input_length;$/;"	m	class:itpp::Block_Interleaver	access:private
input_next	/usr/include/itpp/protocol/selective_repeat.h	/^  int input_next;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
input_request	/usr/include/itpp/protocol/packet_channel.h	/^  Signal<int> input_request;$/;"	m	class:itpp::Packet_Channel	access:public
ins	/usr/include/itpp/base/vec.h	/^  void ins(int i, Num_T t);$/;"	p	class:itpp::Vec	access:public	signature:(int i, Num_T t)
ins	/usr/include/itpp/base/vec.h	/^  void ins(int i, const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:public	signature:(int i, const Vec<Num_T> &v)
ins	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::ins(int index, const Num_T t)$/;"	f	class:itpp::Vec	signature:(int index, const Num_T t)
ins	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::ins(int index, const Vec<Num_T> &v)$/;"	f	class:itpp::Vec	signature:(int index, const Vec<Num_T> &v)
ins_col	/usr/include/itpp/base/mat.h	/^  void ins_col(int c, const Vec<Num_T> &v);$/;"	p	class:itpp::Mat	access:public	signature:(int c, const Vec<Num_T> &v)
ins_col	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::ins_col(int c, const Vec<Num_T> &v)$/;"	f	class:itpp::Mat	signature:(int c, const Vec<Num_T> &v)
ins_row	/usr/include/itpp/base/mat.h	/^  void ins_row(int r, const Vec<Num_T> &v);$/;"	p	class:itpp::Mat	access:public	signature:(int r, const Vec<Num_T> &v)
ins_row	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::ins_row(int r, const Vec<Num_T> &v)$/;"	f	class:itpp::Mat	signature:(int r, const Vec<Num_T> &v)
int16_t	/usr/include/itpp/base/ittypes.h	/^typedef signed short            int16_t;    \/\/!< 16-bit signed integer$/;"	t
int2bits	/usr/include/itpp/base/math/log_exp.h	/^inline int int2bits(int n)$/;"	f	namespace:itpp	signature:(int n)
int2bits	/usr/include/itpp/base/math/log_exp.h	/^inline ivec int2bits(const ivec& v)$/;"	f	namespace:itpp	signature:(const ivec& v)
int2mxArray	/usr/include/itpp/itmex.h	/^void int2mxArray(const int &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const int &in, mxArray *out)
int32_t	/usr/include/itpp/base/ittypes.h	/^typedef signed int              int32_t;    \/\/!< 32-bit signed integer$/;"	t
int64_t	/usr/include/itpp/base/ittypes.h	/^typedef __int64                 int64_t;    \/\/!< 64-bit signed integer$/;"	t
int64_t	/usr/include/itpp/base/ittypes.h	/^typedef signed long             int64_t;    \/\/!< 64-bit signed integer$/;"	t
int64_t	/usr/include/itpp/base/ittypes.h	/^typedef signed long long        int64_t;    \/\/!< 64-bit signed integer$/;"	t
int8_t	/usr/include/itpp/base/ittypes.h	/^typedef signed char             int8_t;     \/\/!< 8-bit signed integer$/;"	t
integrity_check	/usr/include/itpp/comm/ldpc.h	/^  void integrity_check();$/;"	p	class:itpp::LDPC_Code	access:protected	signature:()
inter_matrix	/usr/include/itpp/comm/interleave.h	/^  Mat<T> inter_matrix;$/;"	m	class:itpp::Cross_Interleaver	access:private
interchange_permutations	/usr/include/itpp/base/algebra/lu.h	/^void interchange_permutations(vec &b, const ivec &p);$/;"	p	namespace:itpp	signature:(vec &b, const ivec &p)
interleave	/usr/include/itpp/comm/interleave.h	/^  Vec<T> interleave(const Vec<T> &input);$/;"	p	class:itpp::Block_Interleaver	access:public	signature:(const Vec<T> &input)
interleave	/usr/include/itpp/comm/interleave.h	/^  Vec<T> interleave(const Vec<T> &input);$/;"	p	class:itpp::Cross_Interleaver	access:public	signature:(const Vec<T> &input)
interleave	/usr/include/itpp/comm/interleave.h	/^  Vec<T> interleave(const Vec<T> &input);$/;"	p	class:itpp::Sequence_Interleaver	access:public	signature:(const Vec<T> &input)
interleave	/usr/include/itpp/comm/interleave.h	/^  void interleave(const Vec<T> &input, Vec<T> &output);$/;"	p	class:itpp::Block_Interleaver	access:public	signature:(const Vec<T> &input, Vec<T> &output)
interleave	/usr/include/itpp/comm/interleave.h	/^  void interleave(const Vec<T> &input, Vec<T> &output);$/;"	p	class:itpp::Cross_Interleaver	access:public	signature:(const Vec<T> &input, Vec<T> &output)
interleave	/usr/include/itpp/comm/interleave.h	/^  void interleave(const Vec<T> &input, Vec<T> &output);$/;"	p	class:itpp::Sequence_Interleaver	access:public	signature:(const Vec<T> &input, Vec<T> &output)
interleave	/usr/include/itpp/comm/interleave.h	/^Vec<T> Block_Interleaver<T>::interleave(const Vec<T> &input)$/;"	f	class:itpp::Block_Interleaver	signature:(const Vec<T> &input)
interleave	/usr/include/itpp/comm/interleave.h	/^Vec<T> Cross_Interleaver<T>::interleave(const Vec<T> &input)$/;"	f	class:itpp::Cross_Interleaver	signature:(const Vec<T> &input)
interleave	/usr/include/itpp/comm/interleave.h	/^Vec<T> Sequence_Interleaver<T>::interleave(const Vec<T> &input)$/;"	f	class:itpp::Sequence_Interleaver	signature:(const Vec<T> &input)
interleave	/usr/include/itpp/comm/interleave.h	/^void Block_Interleaver<T>::interleave(const Vec<T> &input, Vec<T> &output)$/;"	f	class:itpp::Block_Interleaver	signature:(const Vec<T> &input, Vec<T> &output)
interleave	/usr/include/itpp/comm/interleave.h	/^void Cross_Interleaver<T>::interleave(const Vec<T> &input, Vec<T> &output)$/;"	f	class:itpp::Cross_Interleaver	signature:(const Vec<T> &input, Vec<T> &output)
interleave	/usr/include/itpp/comm/interleave.h	/^void Sequence_Interleaver<T>::interleave(const Vec<T> &input, Vec<T> &output)$/;"	f	class:itpp::Sequence_Interleaver	signature:(const Vec<T> &input, Vec<T> &output)
interleaver_depth	/usr/include/itpp/comm/interleave.h	/^  int interleaver_depth, input_length;$/;"	m	class:itpp::Sequence_Interleaver	access:private
interleaver_sequence	/usr/include/itpp/comm/interleave.h	/^  ivec interleaver_sequence;$/;"	m	class:itpp::Sequence_Interleaver	access:private
interleaver_size	/usr/include/itpp/comm/turbo.h	/^  int interleaver_size;$/;"	m	class:itpp::Turbo_Codec	access:private
intro_sort	/usr/include/itpp/base/sort.h	/^  void intro_sort(int low, int high, int max_depth, Vec<T> &data);$/;"	p	class:itpp::Sort	access:public	signature:(int low, int high, int max_depth, Vec<T> &data)
intro_sort	/usr/include/itpp/base/sort.h	/^void Sort<T>::intro_sort(int low, int high, int max_depth, Vec<T> &data)$/;"	f	class:itpp::Sort	signature:(int low, int high, int max_depth, Vec<T> &data)
intro_sort_index	/usr/include/itpp/base/sort.h	/^  ivec intro_sort_index(int low, int high, int max_depth,$/;"	p	class:itpp::Sort	access:public	signature:(int low, int high, int max_depth, const Vec<T> &data)
intro_sort_index	/usr/include/itpp/base/sort.h	/^ivec Sort<T>::intro_sort_index(int low, int high, int max_depth,$/;"	f	class:itpp::Sort	signature:(int low, int high, int max_depth, const Vec<T> &data)
inv	/usr/include/itpp/base/algebra/inv.h	/^bool inv(const cmat &X, cmat &Y);$/;"	p	namespace:itpp	signature:(const cmat &X, cmat &Y)
inv	/usr/include/itpp/base/algebra/inv.h	/^bool inv(const mat &X, mat &Y);$/;"	p	namespace:itpp	signature:(const mat &X, mat &Y)
inv	/usr/include/itpp/base/algebra/inv.h	/^cmat inv(const cmat &X);$/;"	p	namespace:itpp	signature:(const cmat &X)
inv	/usr/include/itpp/base/algebra/inv.h	/^mat inv(const mat &X);$/;"	p	namespace:itpp	signature:(const mat &X)
inv_dB	/usr/include/itpp/base/math/log_exp.h	/^inline double inv_dB(double x) { return pow(10.0, 0.1 * x); }$/;"	f	namespace:itpp	signature:(double x)
inv_dB	/usr/include/itpp/base/math/log_exp.h	/^inline mat inv_dB(const mat &x)$/;"	f	namespace:itpp	signature:(const mat &x)
inv_dB	/usr/include/itpp/base/math/log_exp.h	/^inline vec inv_dB(const vec &x)$/;"	f	namespace:itpp	signature:(const vec &x)
inverse	/usr/include/itpp/base/gf2mat.h	/^  GF2mat inverse() const;$/;"	p	class:itpp::GF2mat	access:public	signature:() const
inverse_tail	/usr/include/itpp/comm/convcode.h	/^  bool inverse_tail(const bvec coded_sequence, bvec &input);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const bvec coded_sequence, bvec &input)
inverse_tail	/usr/include/itpp/comm/punct_convcode.h	/^  bool inverse_tail(const bvec coded_sequence, bvec &input);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const bvec coded_sequence, bvec &input)
ip_pkt_queue	/usr/include/itpp/protocol/selective_repeat.h	/^  Front_Drop_Queue ip_pkt_queue;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
is2rc	/usr/include/itpp/srccode/lpcfunc.h	/^vec is2rc(const vec &is);$/;"	p	namespace:itpp	signature:(const vec &is)
is_contained	/usr/include/itpp/protocol/tcp.h	/^  bool is_contained(const TCP_Segment &segment) const;$/;"	p	class:itpp::TCP_Segment	access:public	signature:(const TCP_Segment &segment) const
is_contained	/usr/include/itpp/protocol/tcp.h	/^inline bool TCP_Segment::is_contained(const TCP_Segment &segment) const$/;"	f	class:itpp::TCP_Segment	signature:(const TCP_Segment &segment) const
is_even	/usr/include/itpp/base/math/misc.h	/^inline bool is_even(int x) { return ((x&1) == 0); }$/;"	f	namespace:itpp	signature:(int x)
is_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline bool is_fix(const CFix &) {return true;}$/;"	f	namespace:itpp	signature:(const CFix &)
is_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline bool is_fix(const Fix &) {return true;}$/;"	f	namespace:itpp	signature:(const Fix &)
is_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline bool is_fix(const cfixmat &) {return true;}$/;"	f	namespace:itpp	signature:(const cfixmat &)
is_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline bool is_fix(const cfixvec &) {return true;}$/;"	f	namespace:itpp	signature:(const cfixvec &)
is_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline bool is_fix(const fixmat &) {return true;}$/;"	f	namespace:itpp	signature:(const fixmat &)
is_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline bool is_fix(const fixvec &) {return true;}$/;"	f	namespace:itpp	signature:(const fixvec &)
is_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<class T> inline bool is_fix(const Array<T> &) {return is_fix(T());}$/;"	f	namespace:itpp	signature:(const Array<T> &)
is_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<class T> inline bool is_fix(const T &) {return false;}$/;"	f	namespace:itpp	signature:(const T &)
is_full	/usr/include/itpp/stat/mog_generic.h	/^  bool is_full() const { return full; }$/;"	f	class:itpp::MOG_generic	access:public	signature:() const
is_hermitian	/usr/include/itpp/base/matfunc.h	/^bool is_hermitian(const Mat<Num_T>& X)$/;"	f	namespace:itpp	signature:(const Mat<Num_T>& X)
is_hermitian	/usr/include/itpp/base/matfunc.h	/^extern template bool is_hermitian(const cmat &X);$/;"	p	namespace:itpp	signature:(const cmat &X)
is_hermitian	/usr/include/itpp/base/matfunc.h	/^extern template bool is_hermitian(const mat &X);$/;"	p	namespace:itpp	signature:(const mat &X)
is_int	/usr/include/itpp/base/math/misc.h	/^inline bool is_int(double x)$/;"	f	namespace:itpp	signature:(double x)
is_unitary	/usr/include/itpp/base/matfunc.h	/^bool is_unitary(const Mat<Num_T>& X)$/;"	f	namespace:itpp	signature:(const Mat<Num_T>& X)
is_unitary	/usr/include/itpp/base/matfunc.h	/^extern template bool is_unitary(const cmat &X);$/;"	p	namespace:itpp	signature:(const cmat &X)
is_unitary	/usr/include/itpp/base/matfunc.h	/^extern template bool is_unitary(const mat &X);$/;"	p	namespace:itpp	signature:(const mat &X)
is_user_message_available	/usr/include/itpp/protocol/tcp.h	/^  bool is_user_message_available(); \/**< \\brief called by higher layer *\/$/;"	p	class:itpp::TCP_Receiver	access:public	signature:()
is_valid	/usr/include/itpp/comm/ldpc.h	/^  bool is_valid() const { return H_b_valid && init_flag; }$/;"	f	class:itpp::BLDPC_Parity	access:public	signature:() const
is_valid	/usr/include/itpp/srccode/audiofile.h	/^  bool is_valid;$/;"	m	class:itpp::Audio_File	access:protected
is_valid	/usr/include/itpp/stat/mog_generic.h	/^  bool is_valid() const { return valid; }$/;"	f	class:itpp::MOG_generic	access:public	signature:() const
is_zero	/usr/include/itpp/base/gf2mat.h	/^  bool is_zero() const;$/;"	p	class:itpp::GF2mat	access:public	signature:() const
isfinite	/usr/include/itpp/base/math/misc.h	/^inline int isfinite(double x) { return ::finite(x); }$/;"	f	namespace:std	signature:(double x)
isfinite	/usr/include/itpp/base/math/misc.h	/^inline int isfinite(double x) { return ::isfinite(x); }$/;"	f	namespace:std	signature:(double x)
isfinite	/usr/include/itpp/base/math/misc.h	/^inline int isfinite(double x)$/;"	f	namespace:std	signature:(double x)
isfinite	/usr/include/itpp/config.h	238;"	d
isinf	/usr/include/itpp/base/math/misc.h	/^inline int isinf(double x) { return ::isinf(x); }$/;"	f	namespace:std	signature:(double x)
isnan	/usr/include/itpp/base/math/misc.h	/^inline int isnan(double x) { return ((x != x) ? 1 : 0); }$/;"	f	namespace:std	signature:(double x)
isnan	/usr/include/itpp/base/math/misc.h	/^inline int isnan(double x) { return ::isnan(x); }$/;"	f	namespace:std	signature:(double x)
isnan	/usr/include/itpp/config.h	240;"	d
it_assert	/usr/include/itpp/base/itassert.h	95;"	d
it_assert0	/usr/include/itpp/base/itassert.h	112;"	d
it_assert1	/usr/include/itpp/base/itassert.h	114;"	d
it_assert_debug	/usr/include/itpp/base/itassert.h	105;"	d
it_assert_debug	/usr/include/itpp/base/itassert.h	108;"	d
it_assert_f	/usr/include/itpp/base/itassert.h	/^void it_assert_f(std::string ass, std::string msg, std::string file, int line);$/;"	p	namespace:itpp	signature:(std::string ass, std::string msg, std::string file, int line)
it_disable_warnings	/usr/include/itpp/base/itassert.h	/^void it_disable_warnings();$/;"	p	namespace:itpp	signature:()
it_enable_exceptions	/usr/include/itpp/base/itassert.h	/^void it_enable_exceptions(bool on);$/;"	p	namespace:itpp	signature:(bool on)
it_enable_warnings	/usr/include/itpp/base/itassert.h	/^void it_enable_warnings();$/;"	p	namespace:itpp	signature:()
it_error	/usr/include/itpp/base/itassert.h	127;"	d
it_error_f	/usr/include/itpp/base/itassert.h	/^void it_error_f(std::string msg, std::string file, int line);$/;"	p	namespace:itpp	signature:(std::string msg, std::string file, int line)
it_error_if	/usr/include/itpp/base/itassert.h	118;"	d
it_error_msg_style	/usr/include/itpp/base/itassert.h	/^void it_error_msg_style(error_msg_style style);$/;"	p	namespace:itpp	signature:(error_msg_style style)
it_file	/usr/include/itpp/base/itfile.h	/^  explicit it_file(const std::string& filename, bool trunc = false);$/;"	p	class:itpp::it_file	access:public	signature:(const std::string& filename, bool trunc = false)
it_file	/usr/include/itpp/base/itfile.h	/^  it_file();$/;"	p	class:itpp::it_file	access:public	signature:()
it_file	/usr/include/itpp/base/itfile.h	/^class it_file : public it_ifile$/;"	c	namespace:itpp	inherits:it_ifile
it_file_base	/usr/include/itpp/base/itfile.h	/^class it_file_base$/;"	c	namespace:itpp
it_file_base_old	/usr/include/itpp/base/itfile.h	/^class it_file_base_old$/;"	c	namespace:itpp
it_file_old	/usr/include/itpp/base/itfile.h	/^  explicit it_file_old(const std::string& name, bool trunc = false);$/;"	p	class:itpp::it_file_old	access:public	signature:(const std::string& name, bool trunc = false)
it_file_old	/usr/include/itpp/base/itfile.h	/^  it_file_old();$/;"	p	class:itpp::it_file_old	access:public	signature:()
it_file_old	/usr/include/itpp/base/itfile.h	/^class it_file_old : public it_ifile_old$/;"	c	namespace:itpp	inherits:it_ifile_old
it_ifile	/usr/include/itpp/base/itfile.h	/^  explicit it_ifile(const std::string& filename);$/;"	p	class:itpp::it_ifile	access:public	signature:(const std::string& filename)
it_ifile	/usr/include/itpp/base/itfile.h	/^  it_ifile();$/;"	p	class:itpp::it_ifile	access:public	signature:()
it_ifile	/usr/include/itpp/base/itfile.h	/^class it_ifile : public it_file_base$/;"	c	namespace:itpp	inherits:it_file_base
it_ifile_old	/usr/include/itpp/base/itfile.h	/^  explicit it_ifile_old(const std::string& name);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(const std::string& name)
it_ifile_old	/usr/include/itpp/base/itfile.h	/^  it_ifile_old();$/;"	p	class:itpp::it_ifile_old	access:public	signature:()
it_ifile_old	/usr/include/itpp/base/itfile.h	/^class it_ifile_old : public it_file_base_old$/;"	c	namespace:itpp	inherits:it_file_base_old
it_info	/usr/include/itpp/base/itassert.h	137;"	d
it_info_debug	/usr/include/itpp/base/itassert.h	156;"	d
it_info_debug	/usr/include/itpp/base/itassert.h	164;"	d
it_info_f	/usr/include/itpp/base/itassert.h	/^void it_info_f(std::string msg);$/;"	p	namespace:itpp	signature:(std::string msg)
it_info_no_endl	/usr/include/itpp/base/itassert.h	146;"	d
it_info_no_endl_debug	/usr/include/itpp/base/itassert.h	161;"	d
it_info_no_endl_debug	/usr/include/itpp/base/itassert.h	169;"	d
it_load_var	/usr/include/itpp/base/itfile.h	643;"	d
it_load_var_as	/usr/include/itpp/base/itfile.h	/^void it_load_var_as(T& v, const std::string& name)$/;"	f	namespace:itpp	signature:(T& v, const std::string& name)
it_manip	/usr/include/itpp/base/itfile.h	/^  typedef it_file& (*it_manip)(it_file&);$/;"	t	class:itpp::it_file	access:public
it_manip	/usr/include/itpp/base/itfile.h	/^  typedef it_file_old& (*it_manip)(it_file_old&);$/;"	t	class:itpp::it_file_old	access:public
it_redirect_warnings	/usr/include/itpp/base/itassert.h	/^void it_redirect_warnings(std::ostream *warn_stream);$/;"	p	namespace:itpp	signature:(std::ostream *warn_stream)
it_save_var	/usr/include/itpp/base/itfile.h	641;"	d
it_save_var_as	/usr/include/itpp/base/itfile.h	/^void it_save_var_as(const T& v, const std::string& name)$/;"	f	namespace:itpp	signature:(const T& v, const std::string& name)
it_warning	/usr/include/itpp/base/itassert.h	174;"	d
it_warning_f	/usr/include/itpp/base/itassert.h	/^void it_warning_f(std::string msg, std::string file, int line);$/;"	p	namespace:itpp	signature:(std::string msg, std::string file, int line)
iterate	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  void iterate();$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:protected	signature:()
iterations	/usr/include/itpp/comm/turbo.h	/^  int m_tail, n1, n2, n_tot, iterations;$/;"	m	class:itpp::Turbo_Codec	access:private
itpp	/usr/include/itpp/base/algebra/cholesky.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/algebra/det.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/algebra/eigen.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/algebra/inv.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/algebra/ls_solve.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/algebra/lu.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/algebra/qr.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/algebra/schur.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/algebra/svd.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/array.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/bessel.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/binary.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/binfile.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/circular_buffer.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/converters.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/copy_vector.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/factory.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/fastmath.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/gf2mat.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/help_functions.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/itassert.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/itfile.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/mat.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/matfunc.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/math/elem_math.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/math/error.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/math/integration.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/math/log_exp.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/math/min_max.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/math/misc.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/math/trig_hyp.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/operators.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/parser.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/random.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/smat.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/sort.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/specmat.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/stack.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/svec.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/timing.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/base/vec.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/comm/bch.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/comm/channel.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/comm/channel_code.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/comm/commfunc.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/comm/convcode.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/comm/crc.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/comm/egolay.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/comm/error_counters.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/comm/galois.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/comm/hammcode.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/comm/interleave.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/comm/ldpc.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/comm/llr.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/comm/modulator.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/comm/modulator_nd.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/comm/ofdm.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/comm/pulse_shape.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/comm/punct_convcode.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/comm/rec_syst_conv_code.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/comm/reedsolomon.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/comm/sequence.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/comm/spread.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/comm/turbo.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/fixed/cfix.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/fixed/cfixed.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/fixed/fix.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/fixed/fix_base.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/fixed/fix_factory.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/fixed/fix_functions.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/fixed/fix_operators.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/fixed/fixed.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/itmex.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/optim/newton_search.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/protocol/events.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/protocol/front_drop_queue.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/protocol/packet.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/protocol/packet_channel.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/protocol/packet_generator.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/protocol/selective_repeat.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/protocol/signals_slots.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/protocol/tcp.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/protocol/tcp_client_server.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/signal/fastica.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/signal/filter.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/signal/filter_design.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/signal/freq_filt.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/signal/poly.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/signal/resampling.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/signal/sigfun.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/signal/source.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/signal/transforms.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/signal/window.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/srccode/audiofile.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/srccode/gmm.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/srccode/lpcfunc.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/srccode/pnm.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/srccode/vq.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/srccode/vqtrain.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/stat/histogram.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/stat/misc_stat.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/stat/mog_diag.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/stat/mog_diag_em.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/stat/mog_diag_kmeans.h	/^namespace itpp$/;"	n
itpp	/usr/include/itpp/stat/mog_generic.h	/^namespace itpp$/;"	n
itpp::ACK	/usr/include/itpp/protocol/packet.h	/^class ACK : public Packet$/;"	c	namespace:itpp	inherits:Packet
itpp::ACK::ACK	/usr/include/itpp/protocol/packet.h	/^  ACK(const int Seq_no = -1, const int Id = 0) { seq_no = Seq_no; id = Id; }$/;"	f	class:itpp::ACK	access:public	signature:(const int Seq_no = -1, const int Id = 0)
itpp::ACK::id	/usr/include/itpp/protocol/packet.h	/^  int id;$/;"	m	class:itpp::ACK	access:public
itpp::ACK::seq_no	/usr/include/itpp/protocol/packet.h	/^  int seq_no;$/;"	m	class:itpp::ACK	access:public
itpp::ACK::~ACK	/usr/include/itpp/protocol/packet.h	/^  ~ACK() {}$/;"	f	class:itpp::ACK	access:public	signature:()
itpp::ACK_Channel	/usr/include/itpp/protocol/packet_channel.h	/^class ACK_Channel$/;"	c	namespace:itpp
itpp::ACK_Channel::ACK_Channel	/usr/include/itpp/protocol/packet_channel.h	/^  ACK_Channel();$/;"	p	class:itpp::ACK_Channel	access:public	signature:()
itpp::ACK_Channel::ACK_Channel	/usr/include/itpp/protocol/packet_channel.h	/^  ACK_Channel(const double Pr, const Ttype Delay);$/;"	p	class:itpp::ACK_Channel	access:public	signature:(const double Pr, const Ttype Delay)
itpp::ACK_Channel::K	/usr/include/itpp/protocol/packet_channel.h	/^  int k, K, L;$/;"	m	class:itpp::ACK_Channel	access:private
itpp::ACK_Channel::L	/usr/include/itpp/protocol/packet_channel.h	/^  int k, K, L;$/;"	m	class:itpp::ACK_Channel	access:private
itpp::ACK_Channel::delay	/usr/include/itpp/protocol/packet_channel.h	/^  Ttype delay;$/;"	m	class:itpp::ACK_Channel	access:private
itpp::ACK_Channel::explicit_errors	/usr/include/itpp/protocol/packet_channel.h	/^  bool explicit_errors;$/;"	m	class:itpp::ACK_Channel	access:private
itpp::ACK_Channel::handle_input	/usr/include/itpp/protocol/packet_channel.h	/^  void handle_input(ACK* M);$/;"	p	class:itpp::ACK_Channel	access:private	signature:(ACK* M)
itpp::ACK_Channel::input	/usr/include/itpp/protocol/packet_channel.h	/^  Slot<ACK_Channel, ACK*> input;$/;"	m	class:itpp::ACK_Channel	access:public
itpp::ACK_Channel::k	/usr/include/itpp/protocol/packet_channel.h	/^  int k, K, L;$/;"	m	class:itpp::ACK_Channel	access:private
itpp::ACK_Channel::lose	/usr/include/itpp/protocol/packet_channel.h	/^  bool lose;$/;"	m	class:itpp::ACK_Channel	access:private
itpp::ACK_Channel::lost	/usr/include/itpp/protocol/packet_channel.h	/^  ivec lost;$/;"	m	class:itpp::ACK_Channel	access:private
itpp::ACK_Channel::output	/usr/include/itpp/protocol/packet_channel.h	/^  Signal<ACK*> output;$/;"	m	class:itpp::ACK_Channel	access:public
itpp::ACK_Channel::parameters_ok	/usr/include/itpp/protocol/packet_channel.h	/^  bool parameters_ok;$/;"	m	class:itpp::ACK_Channel	access:private
itpp::ACK_Channel::pr	/usr/include/itpp/protocol/packet_channel.h	/^  double pr;$/;"	m	class:itpp::ACK_Channel	access:private
itpp::ACK_Channel::set_errors	/usr/include/itpp/protocol/packet_channel.h	/^  void set_errors(const ivec& Lost);$/;"	p	class:itpp::ACK_Channel	access:public	signature:(const ivec& Lost)
itpp::ACK_Channel::set_parameters	/usr/include/itpp/protocol/packet_channel.h	/^  void set_parameters(const double Pr, const Ttype Delay);$/;"	p	class:itpp::ACK_Channel	access:public	signature:(const double Pr, const Ttype Delay)
itpp::ACK_Channel::~ACK_Channel	/usr/include/itpp/protocol/packet_channel.h	/^  ~ACK_Channel();$/;"	p	class:itpp::ACK_Channel	access:public	signature:()
itpp::APPROX	/usr/include/itpp/comm/modulator.h	/^  APPROX   \/\/!< Approximate faster method$/;"	e	enum:itpp::Soft_Method
itpp::AR1_Gauss_RNG	/usr/include/itpp/base/random.h	/^typedef AR1_Normal_RNG AR1_Gauss_RNG;$/;"	t	namespace:itpp
itpp::AR1_Normal_RNG	/usr/include/itpp/base/random.h	/^class AR1_Normal_RNG$/;"	c	namespace:itpp
itpp::AR1_Normal_RNG::AR1_Normal_RNG	/usr/include/itpp/base/random.h	/^  AR1_Normal_RNG(double meanval = 0.0, double variance = 1.0,$/;"	p	class:itpp::AR1_Normal_RNG	access:public	signature:(double meanval = 0.0, double variance = 1.0, double rho = 0.0)
itpp::AR1_Normal_RNG::RNG	/usr/include/itpp/base/random.h	/^  Random_Generator RNG;$/;"	m	class:itpp::AR1_Normal_RNG	access:private
itpp::AR1_Normal_RNG::factr	/usr/include/itpp/base/random.h	/^  double mem, r, factr, mean, var, r1, r2;$/;"	m	class:itpp::AR1_Normal_RNG	access:private
itpp::AR1_Normal_RNG::get_setup	/usr/include/itpp/base/random.h	/^  void get_setup(double &meanval, double &variance, double &rho) const;$/;"	p	class:itpp::AR1_Normal_RNG	access:public	signature:(double &meanval, double &variance, double &rho) const
itpp::AR1_Normal_RNG::mean	/usr/include/itpp/base/random.h	/^  double mem, r, factr, mean, var, r1, r2;$/;"	m	class:itpp::AR1_Normal_RNG	access:private
itpp::AR1_Normal_RNG::mem	/usr/include/itpp/base/random.h	/^  double mem, r, factr, mean, var, r1, r2;$/;"	m	class:itpp::AR1_Normal_RNG	access:private
itpp::AR1_Normal_RNG::odd	/usr/include/itpp/base/random.h	/^  bool odd;$/;"	m	class:itpp::AR1_Normal_RNG	access:private
itpp::AR1_Normal_RNG::operator ()	/usr/include/itpp/base/random.h	/^  double operator()() { return sample(); }$/;"	f	class:itpp::AR1_Normal_RNG	access:public	signature:()
itpp::AR1_Normal_RNG::operator ()	/usr/include/itpp/base/random.h	/^  mat operator()(int h, int w);$/;"	p	class:itpp::AR1_Normal_RNG	access:public	signature:(int h, int w)
itpp::AR1_Normal_RNG::operator ()	/usr/include/itpp/base/random.h	/^  vec operator()(int n);$/;"	p	class:itpp::AR1_Normal_RNG	access:public	signature:(int n)
itpp::AR1_Normal_RNG::r	/usr/include/itpp/base/random.h	/^  double mem, r, factr, mean, var, r1, r2;$/;"	m	class:itpp::AR1_Normal_RNG	access:private
itpp::AR1_Normal_RNG::r1	/usr/include/itpp/base/random.h	/^  double mem, r, factr, mean, var, r1, r2;$/;"	m	class:itpp::AR1_Normal_RNG	access:private
itpp::AR1_Normal_RNG::r2	/usr/include/itpp/base/random.h	/^  double mem, r, factr, mean, var, r1, r2;$/;"	m	class:itpp::AR1_Normal_RNG	access:private
itpp::AR1_Normal_RNG::reset	/usr/include/itpp/base/random.h	/^  void reset();$/;"	p	class:itpp::AR1_Normal_RNG	access:public	signature:()
itpp::AR1_Normal_RNG::sample	/usr/include/itpp/base/random.h	/^  double sample() {$/;"	f	class:itpp::AR1_Normal_RNG	access:private	signature:()
itpp::AR1_Normal_RNG::setup	/usr/include/itpp/base/random.h	/^  void setup(double meanval, double variance, double rho);$/;"	p	class:itpp::AR1_Normal_RNG	access:public	signature:(double meanval, double variance, double rho)
itpp::AR1_Normal_RNG::var	/usr/include/itpp/base/random.h	/^  double mem, r, factr, mean, var, r1, r2;$/;"	m	class:itpp::AR1_Normal_RNG	access:private
itpp::ARMA_Filter	/usr/include/itpp/signal/filter.h	/^class ARMA_Filter : public Filter<T1, T2, T3>$/;"	c	namespace:itpp	inherits:Filter
itpp::ARMA_Filter::ARMA_Filter	/usr/include/itpp/signal/filter.h	/^  explicit ARMA_Filter();$/;"	p	class:itpp::ARMA_Filter	access:public	signature:()
itpp::ARMA_Filter::ARMA_Filter	/usr/include/itpp/signal/filter.h	/^  explicit ARMA_Filter(const Vec<T2> &b, const Vec<T2> &a);$/;"	p	class:itpp::ARMA_Filter	access:public	signature:(const Vec<T2> &b, const Vec<T2> &a)
itpp::ARMA_Filter::ARMA_Filter	/usr/include/itpp/signal/filter.h	/^ARMA_Filter<T1, T2, T3>::ARMA_Filter() : Filter<T1, T2, T3>()$/;"	f	class:itpp::ARMA_Filter	signature:()
itpp::ARMA_Filter::ARMA_Filter	/usr/include/itpp/signal/filter.h	/^ARMA_Filter<T1, T2, T3>::ARMA_Filter(const Vec<T2> &b, const Vec<T2> &a) : Filter<T1, T2, T3>()$/;"	f	class:itpp::ARMA_Filter	signature:(const Vec<T2> &b, const Vec<T2> &a)
itpp::ARMA_Filter::acoeffs	/usr/include/itpp/signal/filter.h	/^  Vec<T2> acoeffs, bcoeffs;$/;"	m	class:itpp::ARMA_Filter	access:private
itpp::ARMA_Filter::bcoeffs	/usr/include/itpp/signal/filter.h	/^  Vec<T2> acoeffs, bcoeffs;$/;"	m	class:itpp::ARMA_Filter	access:private
itpp::ARMA_Filter::clear	/usr/include/itpp/signal/filter.h	/^  void clear() { mem.clear(); }$/;"	f	class:itpp::ARMA_Filter	access:public	signature:()
itpp::ARMA_Filter::filter	/usr/include/itpp/signal/filter.h	/^  virtual T3 filter(const T1 Sample);$/;"	p	class:itpp::ARMA_Filter	access:private	signature:(const T1 Sample)
itpp::ARMA_Filter::filter	/usr/include/itpp/signal/filter.h	/^T3 ARMA_Filter<T1, T2, T3>::filter(const T1 Sample)$/;"	f	class:itpp::ARMA_Filter	signature:(const T1 Sample)
itpp::ARMA_Filter::get_coeffs	/usr/include/itpp/signal/filter.h	/^  void get_coeffs(Vec<T2> &b, Vec<T2> &a) const { b = bcoeffs; a = acoeffs; }$/;"	f	class:itpp::ARMA_Filter	access:public	signature:(Vec<T2> &b, Vec<T2> &a) const
itpp::ARMA_Filter::get_coeffs_a	/usr/include/itpp/signal/filter.h	/^  Vec<T2> get_coeffs_a() const { return acoeffs; }$/;"	f	class:itpp::ARMA_Filter	access:public	signature:() const
itpp::ARMA_Filter::get_coeffs_b	/usr/include/itpp/signal/filter.h	/^  Vec<T2> get_coeffs_b() const { return bcoeffs; }$/;"	f	class:itpp::ARMA_Filter	access:public	signature:() const
itpp::ARMA_Filter::get_state	/usr/include/itpp/signal/filter.h	/^  Vec<T3> get_state() const;$/;"	p	class:itpp::ARMA_Filter	access:public	signature:() const
itpp::ARMA_Filter::get_state	/usr/include/itpp/signal/filter.h	/^Vec<T3> ARMA_Filter<T1, T2, T3>::get_state() const$/;"	f	class:itpp::ARMA_Filter	signature:() const
itpp::ARMA_Filter::init	/usr/include/itpp/signal/filter.h	/^  bool init;$/;"	m	class:itpp::ARMA_Filter	access:private
itpp::ARMA_Filter::inptr	/usr/include/itpp/signal/filter.h	/^  int inptr;$/;"	m	class:itpp::ARMA_Filter	access:private
itpp::ARMA_Filter::mem	/usr/include/itpp/signal/filter.h	/^  Vec<T3> mem;$/;"	m	class:itpp::ARMA_Filter	access:private
itpp::ARMA_Filter::set_coeffs	/usr/include/itpp/signal/filter.h	/^  void set_coeffs(const Vec<T2> &b, const Vec<T2> &a);$/;"	p	class:itpp::ARMA_Filter	access:public	signature:(const Vec<T2> &b, const Vec<T2> &a)
itpp::ARMA_Filter::set_coeffs	/usr/include/itpp/signal/filter.h	/^void ARMA_Filter<T1, T2, T3>::set_coeffs(const Vec<T2> &b, const Vec<T2> &a)$/;"	f	class:itpp::ARMA_Filter	signature:(const Vec<T2> &b, const Vec<T2> &a)
itpp::ARMA_Filter::set_state	/usr/include/itpp/signal/filter.h	/^  void set_state(const Vec<T3> &state);$/;"	p	class:itpp::ARMA_Filter	access:public	signature:(const Vec<T3> &state)
itpp::ARMA_Filter::set_state	/usr/include/itpp/signal/filter.h	/^void ARMA_Filter<T1, T2, T3>::set_state(const Vec<T3> &state)$/;"	f	class:itpp::ARMA_Filter	signature:(const Vec<T3> &state)
itpp::ARMA_Filter::~ARMA_Filter	/usr/include/itpp/signal/filter.h	/^  virtual ~ARMA_Filter() { }$/;"	f	class:itpp::ARMA_Filter	access:public	signature:()
itpp::AR_Filter	/usr/include/itpp/signal/filter.h	/^class AR_Filter : public Filter<T1, T2, T3>$/;"	c	namespace:itpp	inherits:Filter
itpp::AR_Filter::AR_Filter	/usr/include/itpp/signal/filter.h	/^  explicit AR_Filter();$/;"	p	class:itpp::AR_Filter	access:public	signature:()
itpp::AR_Filter::AR_Filter	/usr/include/itpp/signal/filter.h	/^  explicit AR_Filter(const Vec<T2> &a);$/;"	p	class:itpp::AR_Filter	access:public	signature:(const Vec<T2> &a)
itpp::AR_Filter::AR_Filter	/usr/include/itpp/signal/filter.h	/^AR_Filter<T1, T2, T3>::AR_Filter() : Filter<T1, T2, T3>()$/;"	f	class:itpp::AR_Filter	signature:()
itpp::AR_Filter::AR_Filter	/usr/include/itpp/signal/filter.h	/^AR_Filter<T1, T2, T3>::AR_Filter(const Vec<T2> &a) : Filter<T1, T2, T3>()$/;"	f	class:itpp::AR_Filter	signature:(const Vec<T2> &a)
itpp::AR_Filter::a0	/usr/include/itpp/signal/filter.h	/^  T2 a0;$/;"	m	class:itpp::AR_Filter	access:private
itpp::AR_Filter::clear	/usr/include/itpp/signal/filter.h	/^  void clear() { mem.clear(); }$/;"	f	class:itpp::AR_Filter	access:public	signature:()
itpp::AR_Filter::coeffs	/usr/include/itpp/signal/filter.h	/^  Vec<T2> coeffs;$/;"	m	class:itpp::AR_Filter	access:private
itpp::AR_Filter::filter	/usr/include/itpp/signal/filter.h	/^  virtual T3 filter(const T1 Sample);$/;"	p	class:itpp::AR_Filter	access:private	signature:(const T1 Sample)
itpp::AR_Filter::filter	/usr/include/itpp/signal/filter.h	/^T3 AR_Filter<T1, T2, T3>::filter(const T1 Sample)$/;"	f	class:itpp::AR_Filter	signature:(const T1 Sample)
itpp::AR_Filter::get_coeffs	/usr/include/itpp/signal/filter.h	/^  Vec<T2> get_coeffs() const { return coeffs; }$/;"	f	class:itpp::AR_Filter	access:public	signature:() const
itpp::AR_Filter::get_state	/usr/include/itpp/signal/filter.h	/^  Vec<T3> get_state() const;$/;"	p	class:itpp::AR_Filter	access:public	signature:() const
itpp::AR_Filter::get_state	/usr/include/itpp/signal/filter.h	/^Vec<T3> AR_Filter<T1, T2, T3>::get_state() const$/;"	f	class:itpp::AR_Filter	signature:() const
itpp::AR_Filter::init	/usr/include/itpp/signal/filter.h	/^  bool init;$/;"	m	class:itpp::AR_Filter	access:private
itpp::AR_Filter::inptr	/usr/include/itpp/signal/filter.h	/^  int inptr;$/;"	m	class:itpp::AR_Filter	access:private
itpp::AR_Filter::mem	/usr/include/itpp/signal/filter.h	/^  Vec<T3> mem;$/;"	m	class:itpp::AR_Filter	access:private
itpp::AR_Filter::set_coeffs	/usr/include/itpp/signal/filter.h	/^  void set_coeffs(const Vec<T2> &a);$/;"	p	class:itpp::AR_Filter	access:public	signature:(const Vec<T2> &a)
itpp::AR_Filter::set_coeffs	/usr/include/itpp/signal/filter.h	/^void AR_Filter<T1, T2, T3>::set_coeffs(const Vec<T2> &a)$/;"	f	class:itpp::AR_Filter	signature:(const Vec<T2> &a)
itpp::AR_Filter::set_state	/usr/include/itpp/signal/filter.h	/^  void set_state(const Vec<T3> &state);$/;"	p	class:itpp::AR_Filter	access:public	signature:(const Vec<T3> &state)
itpp::AR_Filter::set_state	/usr/include/itpp/signal/filter.h	/^void AR_Filter<T1, T2, T3>::set_state(const Vec<T3> &state)$/;"	f	class:itpp::AR_Filter	signature:(const Vec<T3> &state)
itpp::AR_Filter::~AR_Filter	/usr/include/itpp/signal/filter.h	/^  virtual ~AR_Filter() { }$/;"	f	class:itpp::AR_Filter	access:public	signature:()
itpp::ATimer	/usr/include/itpp/protocol/signals_slots.h	/^class ATimer$/;"	c	namespace:itpp
itpp::ATimer::ATimer	/usr/include/itpp/protocol/signals_slots.h	/^  ATimer(const std::string Name = "Unamed ATimer") {$/;"	f	class:itpp::ATimer	access:public	signature:(const std::string Name = Ó)
itpp::ATimer::cancel	/usr/include/itpp/protocol/signals_slots.h	/^  void cancel() { time_out_signal->cancel(); }$/;"	f	class:itpp::ATimer	access:public	signature:()
itpp::ATimer::forward	/usr/include/itpp/protocol/signals_slots.h	/^  void forward(ObjectType *po, void(ObjectType::*pm)(DataType u)) { time_out_slot->forward(po, pm); }$/;"	f	class:itpp::ATimer	access:public	signature:(ObjectType *po, void(ObjectType::*pm)(DataType u))
itpp::ATimer::name	/usr/include/itpp/protocol/signals_slots.h	/^  std::string name;$/;"	m	class:itpp::ATimer	access:protected
itpp::ATimer::set	/usr/include/itpp/protocol/signals_slots.h	/^  void set(DataType u, const Ttype delta_t) {$/;"	f	class:itpp::ATimer	access:public	signature:(DataType u, const Ttype delta_t)
itpp::ATimer::set_name	/usr/include/itpp/protocol/signals_slots.h	/^  void set_name(const std::string Name) {$/;"	f	class:itpp::ATimer	access:public	signature:(const std::string Name)
itpp::ATimer::time_out_signal	/usr/include/itpp/protocol/signals_slots.h	/^  Signal<DataType> *time_out_signal;$/;"	m	class:itpp::ATimer	access:private
itpp::ATimer::time_out_slot	/usr/include/itpp/protocol/signals_slots.h	/^  Slot<ObjectType, DataType> *time_out_slot;$/;"	m	class:itpp::ATimer	access:private
itpp::AWGN_Channel	/usr/include/itpp/comm/channel.h	/^class AWGN_Channel$/;"	c	namespace:itpp
itpp::AWGN_Channel::AWGN_Channel	/usr/include/itpp/comm/channel.h	/^  AWGN_Channel(double noisevar = 0.0): sigma(std::sqrt(noisevar)) {}$/;"	f	class:itpp::AWGN_Channel	access:public	signature:(double noisevar = 0.0)
itpp::AWGN_Channel::get_noise	/usr/include/itpp/comm/channel.h	/^  double get_noise() const { return sqr(sigma); }$/;"	f	class:itpp::AWGN_Channel	access:public	signature:() const
itpp::AWGN_Channel::operator ()	/usr/include/itpp/comm/channel.h	/^  cvec operator()(const cvec &input);$/;"	p	class:itpp::AWGN_Channel	access:public	signature:(const cvec &input)
itpp::AWGN_Channel::operator ()	/usr/include/itpp/comm/channel.h	/^  vec operator()(const vec &input);$/;"	p	class:itpp::AWGN_Channel	access:public	signature:(const vec &input)
itpp::AWGN_Channel::rng_cn	/usr/include/itpp/comm/channel.h	/^  Complex_Normal_RNG rng_cn;$/;"	m	class:itpp::AWGN_Channel	access:private
itpp::AWGN_Channel::rng_n	/usr/include/itpp/comm/channel.h	/^  Normal_RNG rng_n;$/;"	m	class:itpp::AWGN_Channel	access:private
itpp::AWGN_Channel::set_noise	/usr/include/itpp/comm/channel.h	/^  void set_noise(double noisevar) { sigma = std::sqrt(noisevar); }$/;"	f	class:itpp::AWGN_Channel	access:public	signature:(double noisevar)
itpp::AWGN_Channel::sigma	/usr/include/itpp/comm/channel.h	/^  double sigma;$/;"	m	class:itpp::AWGN_Channel	access:private
itpp::Array	/usr/include/itpp/base/array.h	/^class Array$/;"	c	namespace:itpp
itpp::Array::Array	/usr/include/itpp/base/array.h	/^  Array(const Array<T> &a, const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Array	access:public	signature:(const Array<T> &a, const Factory &f = DEFAULT_FACTORY)
itpp::Array::Array	/usr/include/itpp/base/array.h	/^  Array(const char* values, const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Array	access:public	signature:(const char* values, const Factory &f = DEFAULT_FACTORY)
itpp::Array::Array	/usr/include/itpp/base/array.h	/^  Array(const std::string& values, const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Array	access:public	signature:(const std::string& values, const Factory &f = DEFAULT_FACTORY)
itpp::Array::Array	/usr/include/itpp/base/array.h	/^  Array(int n, const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Array	access:public	signature:(int n, const Factory &f = DEFAULT_FACTORY)
itpp::Array::Array	/usr/include/itpp/base/array.h	/^  explicit Array(const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Array	access:public	signature:(const Factory &f = DEFAULT_FACTORY)
itpp::Array::Array	/usr/include/itpp/base/array.h	/^Array<T>::Array(const Array<T> &a, const Factory &f)$/;"	f	class:itpp::Array	signature:(const Array<T> &a, const Factory &f)
itpp::Array::Array	/usr/include/itpp/base/array.h	/^Array<T>::Array(const Factory &f) : ndata(0), data(0), factory(f) {}$/;"	f	class:itpp::Array	signature:(const Factory &f)
itpp::Array::Array	/usr/include/itpp/base/array.h	/^Array<T>::Array(const char* values, const Factory &f)$/;"	f	class:itpp::Array	signature:(const char* values, const Factory &f)
itpp::Array::Array	/usr/include/itpp/base/array.h	/^Array<T>::Array(const int n, const Factory &f) : ndata(0), data(0), factory(f)$/;"	f	class:itpp::Array	signature:(const int n, const Factory &f)
itpp::Array::Array	/usr/include/itpp/base/array.h	/^Array<T>::Array(const std::string& values, const Factory &f)$/;"	f	class:itpp::Array	signature:(const std::string& values, const Factory &f)
itpp::Array::alloc	/usr/include/itpp/base/array.h	/^  void alloc(int n);$/;"	p	class:itpp::Array	access:protected	signature:(int n)
itpp::Array::alloc	/usr/include/itpp/base/array.h	/^void Array<T>::alloc(int n)$/;"	f	class:itpp::Array	signature:(int n)
itpp::Array::concat	/usr/include/itpp/base/array.h	/^  friend const Array<T> concat <>(const Array<T> &a1, const Array<T> &a2);$/;"	p	class:itpp::Array	access:friend	signature:(const Array<T> &a1, const Array<T> &a2)
itpp::Array::concat	/usr/include/itpp/base/array.h	/^  friend const Array<T> concat <>(const Array<T> &a1, const Array<T> &a2,$/;"	p	class:itpp::Array	access:friend	signature:(const Array<T> &a1, const Array<T> &a2, const Array<T> &a3)
itpp::Array::concat	/usr/include/itpp/base/array.h	/^  friend const Array<T> concat <>(const Array<T> &a1, const T e);$/;"	p	class:itpp::Array	access:friend	signature:(const Array<T> &a1, const T e)
itpp::Array::concat	/usr/include/itpp/base/array.h	/^  friend const Array<T> concat <>(const T e, const Array<T> &a);$/;"	p	class:itpp::Array	access:friend	signature:(const T e, const Array<T> &a)
itpp::Array::data	/usr/include/itpp/base/array.h	/^  T *data;$/;"	m	class:itpp::Array	access:protected
itpp::Array::factory	/usr/include/itpp/base/array.h	/^  const Factory &factory;$/;"	m	class:itpp::Array	access:protected
itpp::Array::free	/usr/include/itpp/base/array.h	/^  void free();$/;"	p	class:itpp::Array	access:protected	signature:()
itpp::Array::free	/usr/include/itpp/base/array.h	/^void Array<T>::free()$/;"	f	class:itpp::Array	signature:()
itpp::Array::in_range	/usr/include/itpp/base/array.h	/^  bool in_range(int i) const { return ((i < ndata) && (i >= 0)); }$/;"	f	class:itpp::Array	access:protected	signature:(int i) const
itpp::Array::left	/usr/include/itpp/base/array.h	/^  Array<T> left(int n) const;$/;"	p	class:itpp::Array	access:public	signature:(int n) const
itpp::Array::left	/usr/include/itpp/base/array.h	/^Array<T> Array<T>::left(int n) const$/;"	f	class:itpp::Array	signature:(int n) const
itpp::Array::length	/usr/include/itpp/base/array.h	/^  int length() const { return ndata; }$/;"	f	class:itpp::Array	access:public	signature:() const
itpp::Array::mid	/usr/include/itpp/base/array.h	/^  Array<T> mid(int pos, int n) const;$/;"	p	class:itpp::Array	access:public	signature:(int pos, int n) const
itpp::Array::mid	/usr/include/itpp/base/array.h	/^Array<T> Array<T>::mid(int pos, int n) const$/;"	f	class:itpp::Array	signature:(int pos, int n) const
itpp::Array::ndata	/usr/include/itpp/base/array.h	/^  int ndata;$/;"	m	class:itpp::Array	access:protected
itpp::Array::operator ()	/usr/include/itpp/base/array.h	/^  T &operator()(int i);$/;"	p	class:itpp::Array	access:public	signature:(int i)
itpp::Array::operator ()	/usr/include/itpp/base/array.h	/^  const Array<T> operator()(const Array<int> &indices) const;$/;"	p	class:itpp::Array	access:public	signature:(const Array<int> &indices) const
itpp::Array::operator ()	/usr/include/itpp/base/array.h	/^  const Array<T> operator()(int i1, int i2) const;$/;"	p	class:itpp::Array	access:public	signature:(int i1, int i2) const
itpp::Array::operator ()	/usr/include/itpp/base/array.h	/^  const T &operator()(int i) const;$/;"	p	class:itpp::Array	access:public	signature:(int i) const
itpp::Array::operator ()	/usr/include/itpp/base/array.h	/^T& Array<T>::operator()(int i)$/;"	f	class:itpp::Array	signature:(int i)
itpp::Array::operator ()	/usr/include/itpp/base/array.h	/^const Array<T> Array<T>::operator()(const Array<int> &indices) const$/;"	f	class:itpp::Array	signature:(const Array<int> &indices) const
itpp::Array::operator ()	/usr/include/itpp/base/array.h	/^const Array<T> Array<T>::operator()(int i1, int i2) const$/;"	f	class:itpp::Array	signature:(int i1, int i2) const
itpp::Array::operator ()	/usr/include/itpp/base/array.h	/^const T& Array<T>::operator()(int i) const$/;"	f	class:itpp::Array	signature:(int i) const
itpp::Array::operator =	/usr/include/itpp/base/array.h	/^  Array<T>& operator=(const Array<T> &a);$/;"	p	class:itpp::Array	access:public	signature:(const Array<T> &a)
itpp::Array::operator =	/usr/include/itpp/base/array.h	/^  Array<T>& operator=(const T &e);$/;"	p	class:itpp::Array	access:public	signature:(const T &e)
itpp::Array::operator =	/usr/include/itpp/base/array.h	/^  Array<T>& operator=(const char* values);$/;"	p	class:itpp::Array	access:public	signature:(const char* values)
itpp::Array::operator =	/usr/include/itpp/base/array.h	/^Array<T>& Array<T>::operator=(const Array<T> &a)$/;"	f	class:itpp::Array	signature:(const Array<T> &a)
itpp::Array::operator =	/usr/include/itpp/base/array.h	/^Array<T>& Array<T>::operator=(const T &e)$/;"	f	class:itpp::Array	signature:(const T &e)
itpp::Array::operator =	/usr/include/itpp/base/array.h	/^Array<T>& Array<T>::operator=(const char* values)$/;"	f	class:itpp::Array	signature:(const char* values)
itpp::Array::right	/usr/include/itpp/base/array.h	/^  Array<T> right(int n) const;$/;"	p	class:itpp::Array	access:public	signature:(int n) const
itpp::Array::right	/usr/include/itpp/base/array.h	/^Array<T> Array<T>::right(int n) const$/;"	f	class:itpp::Array	signature:(int n) const
itpp::Array::set_length	/usr/include/itpp/base/array.h	/^  void set_length(int n, bool copy = false) { set_size(n, copy); }$/;"	f	class:itpp::Array	access:public	signature:(int n, bool copy = false)
itpp::Array::set_size	/usr/include/itpp/base/array.h	/^  void set_size(int n, bool copy = false);$/;"	p	class:itpp::Array	access:public	signature:(int n, bool copy = false)
itpp::Array::set_size	/usr/include/itpp/base/array.h	/^void Array<T>::set_size(int size, bool copy)$/;"	f	class:itpp::Array	signature:(int size, bool copy)
itpp::Array::set_subarray	/usr/include/itpp/base/array.h	/^  void set_subarray(int i1, int i2, const Array<T> &a);$/;"	p	class:itpp::Array	access:public	signature:(int i1, int i2, const Array<T> &a)
itpp::Array::set_subarray	/usr/include/itpp/base/array.h	/^  void set_subarray(int i1, int i2, const T t);$/;"	p	class:itpp::Array	access:public	signature:(int i1, int i2, const T t)
itpp::Array::set_subarray	/usr/include/itpp/base/array.h	/^void Array<T>::set_subarray(int i1, int i2, const Array<T> &a)$/;"	f	class:itpp::Array	signature:(int i1, int i2, const Array<T> &a)
itpp::Array::set_subarray	/usr/include/itpp/base/array.h	/^void Array<T>::set_subarray(int i1, int i2, const T t)$/;"	f	class:itpp::Array	signature:(int i1, int i2, const T t)
itpp::Array::shift_left	/usr/include/itpp/base/array.h	/^  T shift_left(const T& e);$/;"	p	class:itpp::Array	access:public	signature:(const T& e)
itpp::Array::shift_left	/usr/include/itpp/base/array.h	/^  const Array<T> shift_left(const Array<T> &a);$/;"	p	class:itpp::Array	access:public	signature:(const Array<T> &a)
itpp::Array::shift_left	/usr/include/itpp/base/array.h	/^T Array<T>::shift_left(const T& x)$/;"	f	class:itpp::Array	signature:(const T& x)
itpp::Array::shift_left	/usr/include/itpp/base/array.h	/^const Array<T> Array<T>::shift_left(const Array<T> &a)$/;"	f	class:itpp::Array	signature:(const Array<T> &a)
itpp::Array::shift_right	/usr/include/itpp/base/array.h	/^  T shift_right(const T& e);$/;"	p	class:itpp::Array	access:public	signature:(const T& e)
itpp::Array::shift_right	/usr/include/itpp/base/array.h	/^  const Array<T> shift_right(const Array<T> &a);$/;"	p	class:itpp::Array	access:public	signature:(const Array<T> &a)
itpp::Array::shift_right	/usr/include/itpp/base/array.h	/^T Array<T>::shift_right(const T& x)$/;"	f	class:itpp::Array	signature:(const T& x)
itpp::Array::shift_right	/usr/include/itpp/base/array.h	/^const Array<T> Array<T>::shift_right(const Array<T> &a)$/;"	f	class:itpp::Array	signature:(const Array<T> &a)
itpp::Array::size	/usr/include/itpp/base/array.h	/^  int size() const { return ndata; }$/;"	f	class:itpp::Array	access:public	signature:() const
itpp::Array::swap	/usr/include/itpp/base/array.h	/^  void swap(int i, int j);$/;"	p	class:itpp::Array	access:public	signature:(int i, int j)
itpp::Array::swap	/usr/include/itpp/base/array.h	/^void Array<T>::swap(int i, int j)$/;"	f	class:itpp::Array	signature:(int i, int j)
itpp::Array::~Array	/usr/include/itpp/base/array.h	/^  virtual ~Array();$/;"	p	class:itpp::Array	access:public	signature:()
itpp::Array::~Array	/usr/include/itpp/base/array.h	/^Array<T>::~Array()$/;"	f	class:itpp::Array	signature:()
itpp::Audio_File	/usr/include/itpp/srccode/audiofile.h	/^class Audio_File$/;"	c	namespace:itpp
itpp::Audio_File::Audio_File	/usr/include/itpp/srccode/audiofile.h	/^  Audio_File();$/;"	p	class:itpp::Audio_File	access:public	signature:()
itpp::Audio_File::file	/usr/include/itpp/srccode/audiofile.h	/^  std::fstream file;$/;"	m	class:itpp::Audio_File	access:protected
itpp::Audio_File::good	/usr/include/itpp/srccode/audiofile.h	/^  bool good() { return is_valid && file.good(); }$/;"	f	class:itpp::Audio_File	access:public	signature:()
itpp::Audio_File::is_valid	/usr/include/itpp/srccode/audiofile.h	/^  bool is_valid;$/;"	m	class:itpp::Audio_File	access:protected
itpp::Audio_File::~Audio_File	/usr/include/itpp/srccode/audiofile.h	/^  virtual ~Audio_File() { }$/;"	f	class:itpp::Audio_File	access:public	signature:()
itpp::BCH	/usr/include/itpp/comm/bch.h	/^class BCH : public Channel_Code$/;"	c	namespace:itpp	inherits:Channel_Code
itpp::BCH::BCH	/usr/include/itpp/comm/bch.h	/^  BCH(int in_n, int in_k, int in_t, ivec genpolynom, bool sys = false);$/;"	p	class:itpp::BCH	access:public	signature:(int in_n, int in_k, int in_t, ivec genpolynom, bool sys = false)
itpp::BCH::decode	/usr/include/itpp/comm/bch.h	/^  virtual bvec decode(const bvec &coded_bits);$/;"	p	class:itpp::BCH	access:public	signature:(const bvec &coded_bits)
itpp::BCH::decode	/usr/include/itpp/comm/bch.h	/^  virtual bvec decode(const vec &received_signal);$/;"	p	class:itpp::BCH	access:public	signature:(const vec &received_signal)
itpp::BCH::decode	/usr/include/itpp/comm/bch.h	/^  virtual void decode(const bvec &coded_bits, bvec &decoded_bits);$/;"	p	class:itpp::BCH	access:public	signature:(const bvec &coded_bits, bvec &decoded_bits)
itpp::BCH::decode	/usr/include/itpp/comm/bch.h	/^  virtual void decode(const vec &received_signal, bvec &output);$/;"	p	class:itpp::BCH	access:public	signature:(const vec &received_signal, bvec &output)
itpp::BCH::encode	/usr/include/itpp/comm/bch.h	/^  virtual bvec encode(const bvec &uncoded_bits);$/;"	p	class:itpp::BCH	access:public	signature:(const bvec &uncoded_bits)
itpp::BCH::encode	/usr/include/itpp/comm/bch.h	/^  virtual void encode(const bvec &uncoded_bits, bvec &coded_bits);$/;"	p	class:itpp::BCH	access:public	signature:(const bvec &uncoded_bits, bvec &coded_bits)
itpp::BCH::g	/usr/include/itpp/comm/bch.h	/^  GFX g;$/;"	m	class:itpp::BCH	access:private
itpp::BCH::get_rate	/usr/include/itpp/comm/bch.h	/^  virtual double get_rate() const {return static_cast<double>(k) \/ n; }$/;"	f	class:itpp::BCH	access:public	signature:() const
itpp::BCH::k	/usr/include/itpp/comm/bch.h	/^  int n, k, t;$/;"	m	class:itpp::BCH	access:private
itpp::BCH::n	/usr/include/itpp/comm/bch.h	/^  int n, k, t;$/;"	m	class:itpp::BCH	access:private
itpp::BCH::operator =	/usr/include/itpp/comm/bch.h	/^  BCH & operator=(const BCH &) { return *this; }$/;"	f	class:itpp::BCH	access:public	signature:(const BCH &)
itpp::BCH::systematic	/usr/include/itpp/comm/bch.h	/^  const bool systematic;$/;"	m	class:itpp::BCH	access:private
itpp::BCH::t	/usr/include/itpp/comm/bch.h	/^  int n, k, t;$/;"	m	class:itpp::BCH	access:private
itpp::BCH::~BCH	/usr/include/itpp/comm/bch.h	/^  virtual ~BCH() { }$/;"	f	class:itpp::BCH	access:public	signature:()
itpp::BERC	/usr/include/itpp/comm/error_counters.h	/^class BERC$/;"	c	namespace:itpp
itpp::BERC::BERC	/usr/include/itpp/comm/error_counters.h	/^  BERC(int indelay = 0, int inignorefirst = 0, int inignorelast = 0);$/;"	p	class:itpp::BERC	access:public	signature:(int indelay = 0, int inignorefirst = 0, int inignorelast = 0)
itpp::BERC::clear	/usr/include/itpp/comm/error_counters.h	/^  void clear() { errors = 0; corrects = 0; }$/;"	f	class:itpp::BERC	access:public	signature:()
itpp::BERC::corrects	/usr/include/itpp/comm/error_counters.h	/^  double corrects;$/;"	m	class:itpp::BERC	access:private
itpp::BERC::count	/usr/include/itpp/comm/error_counters.h	/^  void count(const bvec &in1, const bvec &in2);$/;"	p	class:itpp::BERC	access:public	signature:(const bvec &in1, const bvec &in2)
itpp::BERC::count_errors	/usr/include/itpp/comm/error_counters.h	/^  static double count_errors(const bvec &in1, const bvec &in2,$/;"	p	class:itpp::BERC	access:public	signature:(const bvec &in1, const bvec &in2, int indelay = 0, int inignorefirst = 0, int inignorelast = 0)
itpp::BERC::delay	/usr/include/itpp/comm/error_counters.h	/^  int delay;$/;"	m	class:itpp::BERC	access:private
itpp::BERC::errors	/usr/include/itpp/comm/error_counters.h	/^  double errors;$/;"	m	class:itpp::BERC	access:private
itpp::BERC::estimate_delay	/usr/include/itpp/comm/error_counters.h	/^  void estimate_delay(const bvec &in1, const bvec &in2, int mindelay = -100,$/;"	p	class:itpp::BERC	access:public	signature:(const bvec &in1, const bvec &in2, int mindelay = -100, int maxdelay = 100)
itpp::BERC::get_corrects	/usr/include/itpp/comm/error_counters.h	/^  double get_corrects() const { return corrects; }$/;"	f	class:itpp::BERC	access:public	signature:() const
itpp::BERC::get_delay	/usr/include/itpp/comm/error_counters.h	/^  int get_delay() const { return delay; }$/;"	f	class:itpp::BERC	access:public	signature:() const
itpp::BERC::get_errorrate	/usr/include/itpp/comm/error_counters.h	/^  double get_errorrate() const { return (errors \/ (corrects + errors)); }$/;"	f	class:itpp::BERC	access:public	signature:() const
itpp::BERC::get_errors	/usr/include/itpp/comm/error_counters.h	/^  double get_errors() const { return errors; }$/;"	f	class:itpp::BERC	access:public	signature:() const
itpp::BERC::get_total_bits	/usr/include/itpp/comm/error_counters.h	/^  double get_total_bits() const { return (errors + corrects); }$/;"	f	class:itpp::BERC	access:public	signature:() const
itpp::BERC::ignorefirst	/usr/include/itpp/comm/error_counters.h	/^  int ignorefirst;$/;"	m	class:itpp::BERC	access:private
itpp::BERC::ignorelast	/usr/include/itpp/comm/error_counters.h	/^  int ignorelast;$/;"	m	class:itpp::BERC	access:private
itpp::BERC::report	/usr/include/itpp/comm/error_counters.h	/^  void report() const;$/;"	p	class:itpp::BERC	access:public	signature:() const
itpp::BFGS	/usr/include/itpp/optim/newton_search.h	/^enum Newton_Search_Method {BFGS};$/;"	e	enum:itpp::Newton_Search_Method
itpp::BLDPC_Generator	/usr/include/itpp/comm/ldpc.h	/^class BLDPC_Generator : public LDPC_Generator$/;"	c	namespace:itpp	inherits:LDPC_Generator
itpp::BLDPC_Generator::BLDPC_Generator	/usr/include/itpp/comm/ldpc.h	/^  BLDPC_Generator(const BLDPC_Parity* const H,$/;"	p	class:itpp::BLDPC_Generator	access:public	signature:(const BLDPC_Parity* const H, const std::string type = Ó)
itpp::BLDPC_Generator::BLDPC_Generator	/usr/include/itpp/comm/ldpc.h	/^  BLDPC_Generator(const std::string type = "BLDPC"):$/;"	f	class:itpp::BLDPC_Generator	access:public	signature:(const std::string type = Ó)
itpp::BLDPC_Generator::H_enc	/usr/include/itpp/comm/ldpc.h	/^  GF2mat H_enc;  \/\/!< Preprocessed parity check matrix$/;"	m	class:itpp::BLDPC_Generator	access:protected
itpp::BLDPC_Generator::K	/usr/include/itpp/comm/ldpc.h	/^  int K;   \/\/!< Number of information bits = N-M$/;"	m	class:itpp::BLDPC_Generator	access:protected
itpp::BLDPC_Generator::M	/usr/include/itpp/comm/ldpc.h	/^  int M;       \/\/!< Number of parity check bits = H_enc.rows()$/;"	m	class:itpp::BLDPC_Generator	access:protected
itpp::BLDPC_Generator::N	/usr/include/itpp/comm/ldpc.h	/^  int N;   \/\/!< Codeword length = H_enc.cols()$/;"	m	class:itpp::BLDPC_Generator	access:protected
itpp::BLDPC_Generator::Z	/usr/include/itpp/comm/ldpc.h	/^  int Z;   \/\/!< Expansion factor$/;"	m	class:itpp::BLDPC_Generator	access:protected
itpp::BLDPC_Generator::construct	/usr/include/itpp/comm/ldpc.h	/^  void construct(const BLDPC_Parity* const H);$/;"	p	class:itpp::BLDPC_Generator	access:public	signature:(const BLDPC_Parity* const H)
itpp::BLDPC_Generator::encode	/usr/include/itpp/comm/ldpc.h	/^  void encode(const bvec &input, bvec &output);$/;"	p	class:itpp::BLDPC_Generator	access:public	signature:(const bvec &input, bvec &output)
itpp::BLDPC_Generator::get_exp_factor	/usr/include/itpp/comm/ldpc.h	/^  int get_exp_factor() const { return Z; }$/;"	f	class:itpp::BLDPC_Generator	access:public	signature:() const
itpp::BLDPC_Generator::load	/usr/include/itpp/comm/ldpc.h	/^  void load(const std::string &filename);$/;"	p	class:itpp::BLDPC_Generator	access:protected	signature:(const std::string &filename)
itpp::BLDPC_Generator::save	/usr/include/itpp/comm/ldpc.h	/^  void save(const std::string &filename) const;$/;"	p	class:itpp::BLDPC_Generator	access:protected	signature:(const std::string &filename) const
itpp::BLDPC_Parity	/usr/include/itpp/comm/ldpc.h	/^class BLDPC_Parity : public LDPC_Parity$/;"	c	namespace:itpp	inherits:LDPC_Parity
itpp::BLDPC_Parity::BLDPC_Parity	/usr/include/itpp/comm/ldpc.h	/^  BLDPC_Parity(): LDPC_Parity(), Z(0), H_b(), H_b_valid(false) {}$/;"	f	class:itpp::BLDPC_Parity	access:public	signature:()
itpp::BLDPC_Parity::BLDPC_Parity	/usr/include/itpp/comm/ldpc.h	/^  BLDPC_Parity(const imat &base_matrix, int exp_factor);$/;"	p	class:itpp::BLDPC_Parity	access:public	signature:(const imat &base_matrix, int exp_factor)
itpp::BLDPC_Parity::BLDPC_Parity	/usr/include/itpp/comm/ldpc.h	/^  BLDPC_Parity(const std::string &filename, int exp_factor);$/;"	p	class:itpp::BLDPC_Parity	access:public	signature:(const std::string &filename, int exp_factor)
itpp::BLDPC_Parity::H_b	/usr/include/itpp/comm/ldpc.h	/^  imat H_b;   \/\/!< Base matrix$/;"	m	class:itpp::BLDPC_Parity	access:private
itpp::BLDPC_Parity::H_b_valid	/usr/include/itpp/comm/ldpc.h	/^  bool H_b_valid;  \/\/!< Indicates that base matrix is valid$/;"	m	class:itpp::BLDPC_Parity	access:private
itpp::BLDPC_Parity::Z	/usr/include/itpp/comm/ldpc.h	/^  int Z;   \/\/!< Expansion factor$/;"	m	class:itpp::BLDPC_Parity	access:private
itpp::BLDPC_Parity::calculate_base_matrix	/usr/include/itpp/comm/ldpc.h	/^  void calculate_base_matrix();$/;"	p	class:itpp::BLDPC_Parity	access:private	signature:()
itpp::BLDPC_Parity::expand_base	/usr/include/itpp/comm/ldpc.h	/^  void expand_base(const imat &base_matrix, int exp_factor);$/;"	p	class:itpp::BLDPC_Parity	access:public	signature:(const imat &base_matrix, int exp_factor)
itpp::BLDPC_Parity::get_base_matrix	/usr/include/itpp/comm/ldpc.h	/^  imat get_base_matrix() const;$/;"	p	class:itpp::BLDPC_Parity	access:public	signature:() const
itpp::BLDPC_Parity::get_exp_factor	/usr/include/itpp/comm/ldpc.h	/^  int get_exp_factor() const;$/;"	p	class:itpp::BLDPC_Parity	access:public	signature:() const
itpp::BLDPC_Parity::is_valid	/usr/include/itpp/comm/ldpc.h	/^  bool is_valid() const { return H_b_valid && init_flag; }$/;"	f	class:itpp::BLDPC_Parity	access:public	signature:() const
itpp::BLDPC_Parity::load_base_matrix	/usr/include/itpp/comm/ldpc.h	/^  void load_base_matrix(const std::string &filename);$/;"	p	class:itpp::BLDPC_Parity	access:public	signature:(const std::string &filename)
itpp::BLDPC_Parity::save_base_matrix	/usr/include/itpp/comm/ldpc.h	/^  void save_base_matrix(const std::string &filename) const;$/;"	p	class:itpp::BLDPC_Parity	access:public	signature:(const std::string &filename) const
itpp::BLDPC_Parity::set_exp_factor	/usr/include/itpp/comm/ldpc.h	/^  void set_exp_factor(int exp_factor);$/;"	p	class:itpp::BLDPC_Parity	access:public	signature:(int exp_factor)
itpp::BLERC	/usr/include/itpp/comm/error_counters.h	/^class BLERC$/;"	c	namespace:itpp
itpp::BLERC::BLERC	/usr/include/itpp/comm/error_counters.h	/^  BLERC(int blocksize);$/;"	p	class:itpp::BLERC	access:public	signature:(int blocksize)
itpp::BLERC::BLERC	/usr/include/itpp/comm/error_counters.h	/^  BLERC(void);$/;"	p	class:itpp::BLERC	access:public	signature:(void)
itpp::BLERC::CORR	/usr/include/itpp/comm/error_counters.h	/^  bool CORR;$/;"	m	class:itpp::BLERC	access:private
itpp::BLERC::blocksize	/usr/include/itpp/comm/error_counters.h	/^  int blocksize;$/;"	m	class:itpp::BLERC	access:private
itpp::BLERC::clear	/usr/include/itpp/comm/error_counters.h	/^  void clear() { errors = 0; corrects = 0; }$/;"	f	class:itpp::BLERC	access:public	signature:()
itpp::BLERC::corrects	/usr/include/itpp/comm/error_counters.h	/^  double corrects;$/;"	m	class:itpp::BLERC	access:private
itpp::BLERC::count	/usr/include/itpp/comm/error_counters.h	/^  void count(const bvec &in1, const bvec &in2);$/;"	p	class:itpp::BLERC	access:public	signature:(const bvec &in1, const bvec &in2)
itpp::BLERC::errors	/usr/include/itpp/comm/error_counters.h	/^  double errors;$/;"	m	class:itpp::BLERC	access:private
itpp::BLERC::get_corrects	/usr/include/itpp/comm/error_counters.h	/^  double get_corrects() const { return corrects; }$/;"	f	class:itpp::BLERC	access:public	signature:() const
itpp::BLERC::get_errorrate	/usr/include/itpp/comm/error_counters.h	/^  double get_errorrate() const { return (errors \/ (corrects + errors)); }$/;"	f	class:itpp::BLERC	access:public	signature:() const
itpp::BLERC::get_errors	/usr/include/itpp/comm/error_counters.h	/^  double get_errors() const { return errors; }$/;"	f	class:itpp::BLERC	access:public	signature:() const
itpp::BLERC::get_total_blocks	/usr/include/itpp/comm/error_counters.h	/^  double get_total_blocks() const { return (errors + corrects); }$/;"	f	class:itpp::BLERC	access:public	signature:() const
itpp::BLERC::set_blocksize	/usr/include/itpp/comm/error_counters.h	/^  void set_blocksize(int inblocksize, bool clear = true);$/;"	p	class:itpp::BLERC	access:public	signature:(int inblocksize, bool clear = true)
itpp::BLERC::setup_done	/usr/include/itpp/comm/error_counters.h	/^  bool setup_done;$/;"	m	class:itpp::BLERC	access:private
itpp::BPSK	/usr/include/itpp/comm/modulator.h	/^class BPSK : public Modulator<double>$/;"	c	namespace:itpp	inherits:Modulator
itpp::BPSK::BPSK	/usr/include/itpp/comm/modulator.h	/^  BPSK(): Modulator<double>("1.0 -1.0", "0 1") {}$/;"	f	class:itpp::BPSK	access:public	signature:()
itpp::BPSK::demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  bvec demodulate_bits(const vec& signal) const;$/;"	p	class:itpp::BPSK	access:public	signature:(const vec& signal) const
itpp::BPSK::demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  void demodulate_bits(const vec& signal, bvec& output) const;$/;"	p	class:itpp::BPSK	access:public	signature:(const vec& signal, bvec& output) const
itpp::BPSK::demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  vec demodulate_soft_bits(const vec& rx_symbols, const vec& channel,$/;"	p	class:itpp::BPSK	access:public	signature:(const vec& rx_symbols, const vec& channel, double N0, Soft_Method method = LOGMAP) const
itpp::BPSK::demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  vec demodulate_soft_bits(const vec& rx_symbols, double N0,$/;"	p	class:itpp::BPSK	access:public	signature:(const vec& rx_symbols, double N0, Soft_Method method = LOGMAP) const
itpp::BPSK::demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate_soft_bits(const vec& rx_symbols, double N0,$/;"	p	class:itpp::BPSK	access:public	signature:(const vec& rx_symbols, double N0, vec& soft_bits, Soft_Method method = LOGMAP) const
itpp::BPSK::demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate_soft_bits(const vec& rx_symbols,$/;"	p	class:itpp::BPSK	access:public	signature:(const vec& rx_symbols, const vec& channel, double N0, vec& soft_bits, Soft_Method method = LOGMAP) const
itpp::BPSK::modulate_bits	/usr/include/itpp/comm/modulator.h	/^  vec modulate_bits(const bvec& bits) const;$/;"	p	class:itpp::BPSK	access:public	signature:(const bvec& bits) const
itpp::BPSK::modulate_bits	/usr/include/itpp/comm/modulator.h	/^  void modulate_bits(const bvec& bits, vec& output) const;$/;"	p	class:itpp::BPSK	access:public	signature:(const bvec& bits, vec& output) const
itpp::BPSK::~BPSK	/usr/include/itpp/comm/modulator.h	/^  virtual ~BPSK() {}$/;"	f	class:itpp::BPSK	access:public	signature:()
itpp::BPSK_c	/usr/include/itpp/comm/modulator.h	/^class BPSK_c : public PSK$/;"	c	namespace:itpp	inherits:PSK
itpp::BPSK_c::BPSK_c	/usr/include/itpp/comm/modulator.h	/^  BPSK_c(): PSK(2) {}$/;"	f	class:itpp::BPSK_c	access:public	signature:()
itpp::BPSK_c::demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  bvec demodulate_bits(const cvec& signal) const;$/;"	p	class:itpp::BPSK_c	access:public	signature:(const cvec& signal) const
itpp::BPSK_c::demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  void demodulate_bits(const cvec& signal, bvec& output) const;$/;"	p	class:itpp::BPSK_c	access:public	signature:(const cvec& signal, bvec& output) const
itpp::BPSK_c::demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  vec demodulate_soft_bits(const cvec& rx_symbols, const cvec& channel,$/;"	p	class:itpp::BPSK_c	access:public	signature:(const cvec& rx_symbols, const cvec& channel, double N0, Soft_Method method = LOGMAP) const
itpp::BPSK_c::demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  vec demodulate_soft_bits(const cvec& rx_symbols, double N0,$/;"	p	class:itpp::BPSK_c	access:public	signature:(const cvec& rx_symbols, double N0, Soft_Method method = LOGMAP) const
itpp::BPSK_c::demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate_soft_bits(const cvec& rx_symbols, double N0,$/;"	p	class:itpp::BPSK_c	access:public	signature:(const cvec& rx_symbols, double N0, vec& soft_bits, Soft_Method method = LOGMAP) const
itpp::BPSK_c::demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate_soft_bits(const cvec& rx_symbols,$/;"	p	class:itpp::BPSK_c	access:public	signature:(const cvec& rx_symbols, const cvec& channel, double N0, vec& soft_bits, Soft_Method method = LOGMAP) const
itpp::BPSK_c::modulate_bits	/usr/include/itpp/comm/modulator.h	/^  cvec modulate_bits(const bvec& bits) const;$/;"	p	class:itpp::BPSK_c	access:public	signature:(const bvec& bits) const
itpp::BPSK_c::modulate_bits	/usr/include/itpp/comm/modulator.h	/^  void modulate_bits(const bvec& bits, cvec& output) const;$/;"	p	class:itpp::BPSK_c	access:public	signature:(const bvec& bits, cvec& output) const
itpp::BPSK_c::~BPSK_c	/usr/include/itpp/comm/modulator.h	/^  virtual ~BPSK_c() {}$/;"	f	class:itpp::BPSK_c	access:public	signature:()
itpp::BSC	/usr/include/itpp/comm/channel.h	/^class BSC$/;"	c	namespace:itpp
itpp::BSC::BSC	/usr/include/itpp/comm/channel.h	/^  BSC(double in_p = 0.0) : u(0.0, 1.0) { p = in_p; };$/;"	f	class:itpp::BSC	access:public	signature:(double in_p = 0.0)
itpp::BSC::get_prob	/usr/include/itpp/comm/channel.h	/^  double get_prob() const { return p; };$/;"	f	class:itpp::BSC	access:public	signature:() const
itpp::BSC::operator ()	/usr/include/itpp/comm/channel.h	/^  bvec operator()(const bvec &input);$/;"	p	class:itpp::BSC	access:public	signature:(const bvec &input)
itpp::BSC::p	/usr/include/itpp/comm/channel.h	/^  double p;$/;"	m	class:itpp::BSC	access:private
itpp::BSC::set_prob	/usr/include/itpp/comm/channel.h	/^  void set_prob(double in_p) { p = in_p; };$/;"	f	class:itpp::BSC	access:public	signature:(double in_p)
itpp::BSC::u	/usr/include/itpp/comm/channel.h	/^  Uniform_RNG u;$/;"	m	class:itpp::BSC	access:private
itpp::Base_Event	/usr/include/itpp/protocol/events.h	/^class Base_Event$/;"	c	namespace:itpp
itpp::Base_Event::Base_Event	/usr/include/itpp/protocol/events.h	/^  Base_Event(const Ttype delta_time) {  \/\/ The event will occur in 'delta_time' time units from now!$/;"	f	class:itpp::Base_Event	access:public	signature:(const Ttype delta_time)
itpp::Base_Event::active	/usr/include/itpp/protocol/events.h	/^  bool active;$/;"	m	class:itpp::Base_Event	access:protected
itpp::Base_Event::cancel	/usr/include/itpp/protocol/events.h	/^  void cancel() { active = false; }$/;"	f	class:itpp::Base_Event	access:public	signature:()
itpp::Base_Event::delta_t	/usr/include/itpp/protocol/events.h	/^  Ttype delta_t;$/;"	m	class:itpp::Base_Event	access:protected
itpp::Base_Event::exec	/usr/include/itpp/protocol/events.h	/^  virtual void exec(void) = 0;$/;"	p	class:itpp::Base_Event	access:protected	signature:(void)
itpp::Base_Event::expire_t	/usr/include/itpp/protocol/events.h	/^  Ttype expire_t;$/;"	m	class:itpp::Base_Event	access:protected
itpp::Base_Event::global_id	/usr/include/itpp/protocol/events.h	/^  static unsigned long long int global_id;$/;"	m	class:itpp::Base_Event	access:protected
itpp::Base_Event::id	/usr/include/itpp/protocol/events.h	/^  unsigned long long int id;$/;"	m	class:itpp::Base_Event	access:protected
itpp::Base_Event::~Base_Event	/usr/include/itpp/protocol/events.h	/^  virtual ~Base_Event() {}$/;"	f	class:itpp::Base_Event	access:public	signature:()
itpp::Base_Slot	/usr/include/itpp/protocol/signals_slots.h	/^class Base_Slot$/;"	c	namespace:itpp
itpp::Base_Slot::Base_Slot	/usr/include/itpp/protocol/signals_slots.h	/^  Base_Slot(const std::string slot_name = "Unamed Base_Slot");$/;"	p	class:itpp::Base_Slot	access:public	signature:(const std::string slot_name = Ó)
itpp::Base_Slot::Base_Slot	/usr/include/itpp/protocol/signals_slots.h	/^Base_Slot<DataType>::Base_Slot(const std::string slot_name)$/;"	f	class:itpp::Base_Slot	signature:(const std::string slot_name)
itpp::Base_Slot::Signal_Iterator	/usr/include/itpp/protocol/signals_slots.h	/^  typedef typename std::list<Signal<DataType>*, std::allocator< Signal<DataType>* > >::iterator Signal_Iterator;$/;"	t	class:itpp::Base_Slot	access:protected
itpp::Base_Slot::_connect	/usr/include/itpp/protocol/signals_slots.h	/^  void _connect(Signal<DataType>* signal);$/;"	p	class:itpp::Base_Slot	access:protected	signature:(Signal<DataType>* signal)
itpp::Base_Slot::_connect	/usr/include/itpp/protocol/signals_slots.h	/^void Base_Slot<DataType>::_connect(Signal<DataType>* signal)$/;"	f	class:itpp::Base_Slot	signature:(Signal<DataType>* signal)
itpp::Base_Slot::_disconnect	/usr/include/itpp/protocol/signals_slots.h	/^  void _disconnect(Signal<DataType>* signal);$/;"	p	class:itpp::Base_Slot	access:protected	signature:(Signal<DataType>* signal)
itpp::Base_Slot::_disconnect	/usr/include/itpp/protocol/signals_slots.h	/^void Base_Slot<DataType>::_disconnect(Signal<DataType>* signal)$/;"	f	class:itpp::Base_Slot	signature:(Signal<DataType>* signal)
itpp::Base_Slot::connected_signals	/usr/include/itpp/protocol/signals_slots.h	/^  std::list<Signal<DataType>*, std::allocator<Signal<DataType>* > > connected_signals;$/;"	m	class:itpp::Base_Slot	access:protected
itpp::Base_Slot::name	/usr/include/itpp/protocol/signals_slots.h	/^  std::string name;$/;"	m	class:itpp::Base_Slot	access:protected
itpp::Base_Slot::operator ()	/usr/include/itpp/protocol/signals_slots.h	/^  virtual void operator()(DataType signal) = 0;$/;"	p	class:itpp::Base_Slot	access:public	signature:(DataType signal)
itpp::Base_Slot::set_name	/usr/include/itpp/protocol/signals_slots.h	/^  void set_name(const std::string &slot_name);$/;"	p	class:itpp::Base_Slot	access:public	signature:(const std::string &slot_name)
itpp::Base_Slot::set_name	/usr/include/itpp/protocol/signals_slots.h	/^void Base_Slot<DataType>::set_name(const std::string &slot_name)$/;"	f	class:itpp::Base_Slot	signature:(const std::string &slot_name)
itpp::Base_Slot::~Base_Slot	/usr/include/itpp/protocol/signals_slots.h	/^  virtual ~Base_Slot();$/;"	p	class:itpp::Base_Slot	access:public	signature:()
itpp::Base_Slot::~Base_Slot	/usr/include/itpp/protocol/signals_slots.h	/^Base_Slot<DataType>::~Base_Slot()$/;"	f	class:itpp::Base_Slot	signature:()
itpp::Bernoulli_RNG	/usr/include/itpp/base/random.h	/^class Bernoulli_RNG$/;"	c	namespace:itpp
itpp::Bernoulli_RNG::Bernoulli_RNG	/usr/include/itpp/base/random.h	/^  Bernoulli_RNG() { p = 0.5; }$/;"	f	class:itpp::Bernoulli_RNG	access:public	signature:()
itpp::Bernoulli_RNG::Bernoulli_RNG	/usr/include/itpp/base/random.h	/^  Bernoulli_RNG(double prob) { setup(prob); }$/;"	f	class:itpp::Bernoulli_RNG	access:public	signature:(double prob)
itpp::Bernoulli_RNG::RNG	/usr/include/itpp/base/random.h	/^  Random_Generator RNG;$/;"	m	class:itpp::Bernoulli_RNG	access:private
itpp::Bernoulli_RNG::get_setup	/usr/include/itpp/base/random.h	/^  double get_setup() const { return p; }$/;"	f	class:itpp::Bernoulli_RNG	access:public	signature:() const
itpp::Bernoulli_RNG::operator ()	/usr/include/itpp/base/random.h	/^  bin operator()() { return sample(); }$/;"	f	class:itpp::Bernoulli_RNG	access:public	signature:()
itpp::Bernoulli_RNG::operator ()	/usr/include/itpp/base/random.h	/^  bmat operator()(int h, int w) { bmat temp(h, w); sample_matrix(h, w, temp); return temp; }$/;"	f	class:itpp::Bernoulli_RNG	access:public	signature:(int h, int w)
itpp::Bernoulli_RNG::operator ()	/usr/include/itpp/base/random.h	/^  bvec operator()(int n) { bvec temp(n); sample_vector(n, temp); return temp; }$/;"	f	class:itpp::Bernoulli_RNG	access:public	signature:(int n)
itpp::Bernoulli_RNG::p	/usr/include/itpp/base/random.h	/^  double p;$/;"	m	class:itpp::Bernoulli_RNG	access:private
itpp::Bernoulli_RNG::sample	/usr/include/itpp/base/random.h	/^  bin sample() { return bin(RNG.random_01() < p ? 1 : 0); }$/;"	f	class:itpp::Bernoulli_RNG	access:public	signature:()
itpp::Bernoulli_RNG::sample_matrix	/usr/include/itpp/base/random.h	/^  void sample_matrix(int rows, int cols, bmat &out) {$/;"	f	class:itpp::Bernoulli_RNG	access:public	signature:(int rows, int cols, bmat &out)
itpp::Bernoulli_RNG::sample_vector	/usr/include/itpp/base/random.h	/^  void sample_vector(int size, bvec &out) {$/;"	f	class:itpp::Bernoulli_RNG	access:public	signature:(int size, bvec &out)
itpp::Bernoulli_RNG::setup	/usr/include/itpp/base/random.h	/^  void setup(double prob) {$/;"	f	class:itpp::Bernoulli_RNG	access:public	signature:(double prob)
itpp::Block_Interleaver	/usr/include/itpp/comm/interleave.h	/^class Block_Interleaver$/;"	c	namespace:itpp
itpp::Block_Interleaver::Block_Interleaver	/usr/include/itpp/comm/interleave.h	/^  Block_Interleaver(int in_rows, int in_cols);$/;"	p	class:itpp::Block_Interleaver	access:public	signature:(int in_rows, int in_cols)
itpp::Block_Interleaver::Block_Interleaver	/usr/include/itpp/comm/interleave.h	/^  Block_Interleaver(void) {rows = 0; cols = 0;};$/;"	f	class:itpp::Block_Interleaver	access:public	signature:(void)
itpp::Block_Interleaver::Block_Interleaver	/usr/include/itpp/comm/interleave.h	/^Block_Interleaver<T>::Block_Interleaver(int in_rows, int in_cols)$/;"	f	class:itpp::Block_Interleaver	signature:(int in_rows, int in_cols)
itpp::Block_Interleaver::cols	/usr/include/itpp/comm/interleave.h	/^  int rows, cols, input_length;$/;"	m	class:itpp::Block_Interleaver	access:private
itpp::Block_Interleaver::deinterleave	/usr/include/itpp/comm/interleave.h	/^  Vec<T> deinterleave(const Vec<T> &input, short keepzeros = 0);$/;"	p	class:itpp::Block_Interleaver	access:public	signature:(const Vec<T> &input, short keepzeros = 0)
itpp::Block_Interleaver::deinterleave	/usr/include/itpp/comm/interleave.h	/^  void deinterleave(const Vec<T> &input, Vec<T> &output, short keepzeros = 0);$/;"	p	class:itpp::Block_Interleaver	access:public	signature:(const Vec<T> &input, Vec<T> &output, short keepzeros = 0)
itpp::Block_Interleaver::deinterleave	/usr/include/itpp/comm/interleave.h	/^Vec<T> Block_Interleaver<T>::deinterleave(const Vec<T> &input, short keepzeros)$/;"	f	class:itpp::Block_Interleaver	signature:(const Vec<T> &input, short keepzeros)
itpp::Block_Interleaver::deinterleave	/usr/include/itpp/comm/interleave.h	/^void Block_Interleaver<T>::deinterleave(const Vec<T> &input, Vec<T> &output, short keepzeros)$/;"	f	class:itpp::Block_Interleaver	signature:(const Vec<T> &input, Vec<T> &output, short keepzeros)
itpp::Block_Interleaver::get_cols	/usr/include/itpp/comm/interleave.h	/^  int get_cols(void) {return cols;};$/;"	f	class:itpp::Block_Interleaver	access:public	signature:(void)
itpp::Block_Interleaver::get_rows	/usr/include/itpp/comm/interleave.h	/^  int get_rows(void) {return rows;};$/;"	f	class:itpp::Block_Interleaver	access:public	signature:(void)
itpp::Block_Interleaver::input_length	/usr/include/itpp/comm/interleave.h	/^  int rows, cols, input_length;$/;"	m	class:itpp::Block_Interleaver	access:private
itpp::Block_Interleaver::interleave	/usr/include/itpp/comm/interleave.h	/^  Vec<T> interleave(const Vec<T> &input);$/;"	p	class:itpp::Block_Interleaver	access:public	signature:(const Vec<T> &input)
itpp::Block_Interleaver::interleave	/usr/include/itpp/comm/interleave.h	/^  void interleave(const Vec<T> &input, Vec<T> &output);$/;"	p	class:itpp::Block_Interleaver	access:public	signature:(const Vec<T> &input, Vec<T> &output)
itpp::Block_Interleaver::interleave	/usr/include/itpp/comm/interleave.h	/^Vec<T> Block_Interleaver<T>::interleave(const Vec<T> &input)$/;"	f	class:itpp::Block_Interleaver	signature:(const Vec<T> &input)
itpp::Block_Interleaver::interleave	/usr/include/itpp/comm/interleave.h	/^void Block_Interleaver<T>::interleave(const Vec<T> &input, Vec<T> &output)$/;"	f	class:itpp::Block_Interleaver	signature:(const Vec<T> &input, Vec<T> &output)
itpp::Block_Interleaver::rows	/usr/include/itpp/comm/interleave.h	/^  int rows, cols, input_length;$/;"	m	class:itpp::Block_Interleaver	access:private
itpp::Block_Interleaver::set_cols	/usr/include/itpp/comm/interleave.h	/^  void set_cols(int in_cols) {cols = in_cols;};$/;"	f	class:itpp::Block_Interleaver	access:public	signature:(int in_cols)
itpp::Block_Interleaver::set_rows	/usr/include/itpp/comm/interleave.h	/^  void set_rows(int in_rows) {rows = in_rows;};$/;"	f	class:itpp::Block_Interleaver	access:public	signature:(int in_rows)
itpp::Burst_WWW_Packet_Generator	/usr/include/itpp/protocol/packet_generator.h	/^class Burst_WWW_Packet_Generator : public Poisson_Packet_Generator$/;"	c	namespace:itpp	inherits:Poisson_Packet_Generator
itpp::Burst_WWW_Packet_Generator::Burst_WWW_Packet_Generator	/usr/include/itpp/protocol/packet_generator.h	/^  Burst_WWW_Packet_Generator(const double Avg_bit_rate = 1.0, const int Packet_size = 150, const int Max_packets = 0);$/;"	p	class:itpp::Burst_WWW_Packet_Generator	access:public	signature:(const double Avg_bit_rate = 1.0, const int Packet_size = 150, const int Max_packets = 0)
itpp::Burst_WWW_Packet_Generator::N	/usr/include/itpp/protocol/packet_generator.h	/^  int N;$/;"	m	class:itpp::Burst_WWW_Packet_Generator	access:protected
itpp::Burst_WWW_Packet_Generator::Navg	/usr/include/itpp/protocol/packet_generator.h	/^  int Navg;$/;"	m	class:itpp::Burst_WWW_Packet_Generator	access:protected
itpp::Burst_WWW_Packet_Generator::Ti	/usr/include/itpp/protocol/packet_generator.h	/^  double Ti;$/;"	m	class:itpp::Burst_WWW_Packet_Generator	access:protected
itpp::Burst_WWW_Packet_Generator::Tr	/usr/include/itpp/protocol/packet_generator.h	/^  double Tr;$/;"	m	class:itpp::Burst_WWW_Packet_Generator	access:protected
itpp::Burst_WWW_Packet_Generator::delta_t	/usr/include/itpp/protocol/packet_generator.h	/^  virtual Ttype delta_t();$/;"	p	class:itpp::Burst_WWW_Packet_Generator	access:protected	signature:()
itpp::Burst_WWW_Packet_Generator::~Burst_WWW_Packet_Generator	/usr/include/itpp/protocol/packet_generator.h	/^  virtual ~Burst_WWW_Packet_Generator();$/;"	p	class:itpp::Burst_WWW_Packet_Generator	access:public	signature:()
itpp::C	/usr/include/itpp/comm/channel.h	/^  Jakes = 0, J = 0, Classic = 0, C = 0,$/;"	e	enum:itpp::DOPPLER_SPECTRUM
itpp::CFix	/usr/include/itpp/fixed/cfix.h	/^class CFix : public Fix_Base$/;"	c	namespace:itpp	inherits:Fix_Base
itpp::CFix::CFix	/usr/include/itpp/fixed/cfix.h	/^  CFix(const CFix &x, double, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)$/;"	f	class:itpp::CFix	access:public	signature:(const CFix &x, double, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)
itpp::CFix::CFix	/usr/include/itpp/fixed/cfix.h	/^  CFix(const Fix &r, const Fix &i = 0.0, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)$/;"	f	class:itpp::CFix	access:public	signature:(const Fix &r, const Fix &i = 0.0, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)
itpp::CFix::CFix	/usr/include/itpp/fixed/cfix.h	/^  CFix(double r = 0.0, double i = 0.0, int s = 0, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)$/;"	f	class:itpp::CFix	access:public	signature:(double r = 0.0, double i = 0.0, int s = 0, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)
itpp::CFix::CFix	/usr/include/itpp/fixed/cfix.h	/^  CFix(fixrep r, fixrep i, int s, int, int)$/;"	f	class:itpp::CFix	access:public	signature:(fixrep r, fixrep i, int s, int, int)
itpp::CFix::CFix	/usr/include/itpp/fixed/cfix.h	/^  CFix(std::complex<double> x, double, int s = 0, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)$/;"	f	class:itpp::CFix	access:public	signature:(std::complex<double> x, double, int s = 0, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)
itpp::CFix::CFix	/usr/include/itpp/fixed/cfix.h	/^  explicit CFix(const Fix_Factory &f)$/;"	f	class:itpp::CFix	access:public	signature:(const Fix_Factory &f)
itpp::CFix::assert_shifts	/usr/include/itpp/fixed/cfix.h	/^  friend int assert_shifts(const CFix &x, const CFix &y);$/;"	p	class:itpp::CFix	access:friend	signature:(const CFix &x, const CFix &y)
itpp::CFix::assert_shifts	/usr/include/itpp/fixed/cfix.h	/^  friend int assert_shifts(const CFix &x, const Fix &y);$/;"	p	class:itpp::CFix	access:friend	signature:(const CFix &x, const Fix &y)
itpp::CFix::assert_shifts	/usr/include/itpp/fixed/cfix.h	/^  friend int assert_shifts(const CFix &x, int y);$/;"	p	class:itpp::CFix	access:friend	signature:(const CFix &x, int y)
itpp::CFix::get_im	/usr/include/itpp/fixed/cfix.h	/^  fixrep get_im() const {return im;}$/;"	f	class:itpp::CFix	access:public	signature:() const
itpp::CFix::get_re	/usr/include/itpp/fixed/cfix.h	/^  fixrep get_re() const {return re;}$/;"	f	class:itpp::CFix	access:public	signature:() const
itpp::CFix::im	/usr/include/itpp/fixed/cfix.h	/^  fixrep im;   \/\/!< Imaginary data part$/;"	m	class:itpp::CFix	access:protected
itpp::CFix::lshift	/usr/include/itpp/fixed/cfix.h	/^  void lshift(int n);$/;"	p	class:itpp::CFix	access:public	signature:(int n)
itpp::CFix::operator *=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator*=(const CFix &x);$/;"	p	class:itpp::CFix	access:public	signature:(const CFix &x)
itpp::CFix::operator *=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator*=(const Fix &x);$/;"	p	class:itpp::CFix	access:public	signature:(const Fix &x)
itpp::CFix::operator *=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator*=(const int x);$/;"	p	class:itpp::CFix	access:public	signature:(const int x)
itpp::CFix::operator +=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator+=(const CFix &x);$/;"	p	class:itpp::CFix	access:public	signature:(const CFix &x)
itpp::CFix::operator +=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator+=(const Fix &x);$/;"	p	class:itpp::CFix	access:public	signature:(const Fix &x)
itpp::CFix::operator +=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator+=(const int x);$/;"	p	class:itpp::CFix	access:public	signature:(const int x)
itpp::CFix::operator -	/usr/include/itpp/fixed/cfix.h	/^  CFix operator-() const;$/;"	p	class:itpp::CFix	access:public	signature:() const
itpp::CFix::operator -=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator-=(const CFix &x);$/;"	p	class:itpp::CFix	access:public	signature:(const CFix &x)
itpp::CFix::operator -=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator-=(const Fix &x);$/;"	p	class:itpp::CFix	access:public	signature:(const Fix &x)
itpp::CFix::operator -=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator-=(const int x);$/;"	p	class:itpp::CFix	access:public	signature:(const int x)
itpp::CFix::operator /=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator\/=(const CFix &x);$/;"	p	class:itpp::CFix	access:public	signature:(const CFix &x)
itpp::CFix::operator /=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator\/=(const Fix &x);$/;"	p	class:itpp::CFix	access:public	signature:(const Fix &x)
itpp::CFix::operator /=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator\/=(const int x);$/;"	p	class:itpp::CFix	access:public	signature:(const int x)
itpp::CFix::operator <<=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator<<=(const int n);$/;"	p	class:itpp::CFix	access:public	signature:(const int n)
itpp::CFix::operator =	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator=(const CFix &x);$/;"	p	class:itpp::CFix	access:public	signature:(const CFix &x)
itpp::CFix::operator =	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator=(const Fix &x);$/;"	p	class:itpp::CFix	access:public	signature:(const Fix &x)
itpp::CFix::operator =	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator=(const int x);$/;"	p	class:itpp::CFix	access:public	signature:(const int x)
itpp::CFix::operator =	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator=(const std::complex<double> &x);$/;"	p	class:itpp::CFix	access:public	signature:(const std::complex<double> &x)
itpp::CFix::operator >>=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator>>=(const int n);$/;"	p	class:itpp::CFix	access:public	signature:(const int n)
itpp::CFix::operator std::complex<double>	/usr/include/itpp/fixed/cfix.h	/^  operator std::complex<double>() const {$/;"	f	class:itpp::CFix	access:public	signature:() const
itpp::CFix::print	/usr/include/itpp/fixed/cfix.h	/^  virtual void print() const;$/;"	p	class:itpp::CFix	access:public	signature:() const
itpp::CFix::re	/usr/include/itpp/fixed/cfix.h	/^  fixrep re;   \/\/!< Real data part$/;"	m	class:itpp::CFix	access:protected
itpp::CFix::rshift	/usr/include/itpp/fixed/cfix.h	/^  void rshift(int n);$/;"	p	class:itpp::CFix	access:public	signature:(int n)
itpp::CFix::rshift	/usr/include/itpp/fixed/cfix.h	/^  void rshift(int n, q_mode q);$/;"	p	class:itpp::CFix	access:public	signature:(int n, q_mode q)
itpp::CFix::set	/usr/include/itpp/fixed/cfix.h	/^  void set(const std::complex<double> &x, int n);$/;"	p	class:itpp::CFix	access:public	signature:(const std::complex<double> &x, int n)
itpp::CFix::set	/usr/include/itpp/fixed/cfix.h	/^  void set(const std::complex<double> &x, int n, q_mode q);$/;"	p	class:itpp::CFix	access:public	signature:(const std::complex<double> &x, int n, q_mode q)
itpp::CFix::set	/usr/include/itpp/fixed/cfix.h	/^  void set(double real, double imag, int n);$/;"	p	class:itpp::CFix	access:public	signature:(double real, double imag, int n)
itpp::CFix::set	/usr/include/itpp/fixed/cfix.h	/^  void set(double real, double imag, int n, q_mode q);$/;"	p	class:itpp::CFix	access:public	signature:(double real, double imag, int n, q_mode q)
itpp::CFix::set_im	/usr/include/itpp/fixed/cfix.h	/^  void set_im(fixrep x) {im = apply_o_mode(x);}$/;"	f	class:itpp::CFix	access:public	signature:(fixrep x)
itpp::CFix::set_re	/usr/include/itpp/fixed/cfix.h	/^  void set_re(fixrep x) {re = apply_o_mode(x);}$/;"	f	class:itpp::CFix	access:public	signature:(fixrep x)
itpp::CFix::unfix	/usr/include/itpp/fixed/cfix.h	/^  std::complex<double> unfix() const;$/;"	p	class:itpp::CFix	access:public	signature:() const
itpp::CFix::~CFix	/usr/include/itpp/fixed/cfix.h	/^  virtual ~CFix() {}$/;"	f	class:itpp::CFix	access:public	signature:()
itpp::CFixed	/usr/include/itpp/fixed/cfixed.h	/^class CFixed : public CFix$/;"	c	namespace:itpp	inherits:CFix
itpp::CFixed::CFixed	/usr/include/itpp/fixed/cfixed.h	/^  CFixed(const CFix &x, double, Stat *ptr = 0)$/;"	f	class:itpp::CFixed	access:public	signature:(const CFix &x, double, Stat *ptr = 0)
itpp::CFixed::CFixed	/usr/include/itpp/fixed/cfixed.h	/^  CFixed(const Fix &r, const Fix &i = 0.0, Stat *ptr = 0)$/;"	f	class:itpp::CFixed	access:public	signature:(const Fix &r, const Fix &i = 0.0, Stat *ptr = 0)
itpp::CFixed::CFixed	/usr/include/itpp/fixed/cfixed.h	/^  CFixed(double r = 0.0, double i = 0.0, int s = 0, Stat *ptr = 0)$/;"	f	class:itpp::CFixed	access:public	signature:(double r = 0.0, double i = 0.0, int s = 0, Stat *ptr = 0)
itpp::CFixed::CFixed	/usr/include/itpp/fixed/cfixed.h	/^  CFixed(std::complex<double> x, double, int s = 0, Stat *ptr = 0)$/;"	f	class:itpp::CFixed	access:public	signature:(std::complex<double> x, double, int s = 0, Stat *ptr = 0)
itpp::CFixed::CFixed	/usr/include/itpp/fixed/cfixed.h	/^  explicit CFixed(Stat *ptr)$/;"	f	class:itpp::CFixed	access:public	signature:(Stat *ptr)
itpp::CFixed::operator =	/usr/include/itpp/fixed/cfixed.h	/^  CFixed& operator=(const CFix &x) {$/;"	f	class:itpp::CFixed	access:public	signature:(const CFix &x)
itpp::CFixed::operator =	/usr/include/itpp/fixed/cfixed.h	/^  CFixed& operator=(const Fix &x) {$/;"	f	class:itpp::CFixed	access:public	signature:(const Fix &x)
itpp::CFixed::operator =	/usr/include/itpp/fixed/cfixed.h	/^  CFixed& operator=(const std::complex<double> &x) {$/;"	f	class:itpp::CFixed	access:public	signature:(const std::complex<double> &x)
itpp::CFixed::operator =	/usr/include/itpp/fixed/cfixed.h	/^  CFixed& operator=(int x) {$/;"	f	class:itpp::CFixed	access:public	signature:(int x)
itpp::CFixed::~CFixed	/usr/include/itpp/fixed/cfixed.h	/^  virtual ~CFixed() {}$/;"	f	class:itpp::CFixed	access:public	signature:()
itpp::CHANNEL_PROFILE	/usr/include/itpp/comm/channel.h	/^enum CHANNEL_PROFILE {$/;"	g	namespace:itpp
itpp::CONVOLUTIONAL_CODE_METHOD	/usr/include/itpp/comm/convcode.h	/^enum CONVOLUTIONAL_CODE_METHOD {Trunc, Tail, Tailbite};$/;"	g	namespace:itpp
itpp::CONVOLUTIONAL_CODE_TYPE	/usr/include/itpp/comm/convcode.h	/^enum CONVOLUTIONAL_CODE_TYPE {MFD, ODS};$/;"	g	namespace:itpp
itpp::CORRELATED_METHOD	/usr/include/itpp/comm/channel.h	/^enum CORRELATED_METHOD { Rice_MEDS, IFFT, FIR };$/;"	g	namespace:itpp
itpp::COST207_BU	/usr/include/itpp/comm/channel.h	/^  COST207_BU, COST207_BU6alt, COST207_BU12, COST207_BU12alt,$/;"	e	enum:itpp::CHANNEL_PROFILE
itpp::COST207_BU12	/usr/include/itpp/comm/channel.h	/^  COST207_BU, COST207_BU6alt, COST207_BU12, COST207_BU12alt,$/;"	e	enum:itpp::CHANNEL_PROFILE
itpp::COST207_BU12alt	/usr/include/itpp/comm/channel.h	/^  COST207_BU, COST207_BU6alt, COST207_BU12, COST207_BU12alt,$/;"	e	enum:itpp::CHANNEL_PROFILE
itpp::COST207_BU6alt	/usr/include/itpp/comm/channel.h	/^  COST207_BU, COST207_BU6alt, COST207_BU12, COST207_BU12alt,$/;"	e	enum:itpp::CHANNEL_PROFILE
itpp::COST207_HT	/usr/include/itpp/comm/channel.h	/^  COST207_HT, COST207_HT6alt, COST207_HT12, COST207_HT12alt,$/;"	e	enum:itpp::CHANNEL_PROFILE
itpp::COST207_HT12	/usr/include/itpp/comm/channel.h	/^  COST207_HT, COST207_HT6alt, COST207_HT12, COST207_HT12alt,$/;"	e	enum:itpp::CHANNEL_PROFILE
itpp::COST207_HT12alt	/usr/include/itpp/comm/channel.h	/^  COST207_HT, COST207_HT6alt, COST207_HT12, COST207_HT12alt,$/;"	e	enum:itpp::CHANNEL_PROFILE
itpp::COST207_HT6alt	/usr/include/itpp/comm/channel.h	/^  COST207_HT, COST207_HT6alt, COST207_HT12, COST207_HT12alt,$/;"	e	enum:itpp::CHANNEL_PROFILE
itpp::COST207_RA	/usr/include/itpp/comm/channel.h	/^  COST207_RA, COST207_RA6,$/;"	e	enum:itpp::CHANNEL_PROFILE
itpp::COST207_RA6	/usr/include/itpp/comm/channel.h	/^  COST207_RA, COST207_RA6,$/;"	e	enum:itpp::CHANNEL_PROFILE
itpp::COST207_TU	/usr/include/itpp/comm/channel.h	/^  COST207_TU, COST207_TU6alt, COST207_TU12, COST207_TU12alt,$/;"	e	enum:itpp::CHANNEL_PROFILE
itpp::COST207_TU12	/usr/include/itpp/comm/channel.h	/^  COST207_TU, COST207_TU6alt, COST207_TU12, COST207_TU12alt,$/;"	e	enum:itpp::CHANNEL_PROFILE
itpp::COST207_TU12alt	/usr/include/itpp/comm/channel.h	/^  COST207_TU, COST207_TU6alt, COST207_TU12, COST207_TU12alt,$/;"	e	enum:itpp::CHANNEL_PROFILE
itpp::COST207_TU6alt	/usr/include/itpp/comm/channel.h	/^  COST207_TU, COST207_TU6alt, COST207_TU12, COST207_TU12alt,$/;"	e	enum:itpp::CHANNEL_PROFILE
itpp::COST259_HTx	/usr/include/itpp/comm/channel.h	/^  COST259_TUx, COST259_RAx, COST259_HTx$/;"	e	enum:itpp::CHANNEL_PROFILE
itpp::COST259_RAx	/usr/include/itpp/comm/channel.h	/^  COST259_TUx, COST259_RAx, COST259_HTx$/;"	e	enum:itpp::CHANNEL_PROFILE
itpp::COST259_TUx	/usr/include/itpp/comm/channel.h	/^  COST259_TUx, COST259_RAx, COST259_HTx$/;"	e	enum:itpp::CHANNEL_PROFILE
itpp::CPU_Timer	/usr/include/itpp/base/timing.h	/^class CPU_Timer : public Timer$/;"	c	namespace:itpp	inherits:Timer
itpp::CPU_Timer::CPU_Timer	/usr/include/itpp/base/timing.h	/^  CPU_Timer() { }$/;"	f	class:itpp::CPU_Timer	access:public	signature:()
itpp::CPU_Timer::get_current_time	/usr/include/itpp/base/timing.h	/^  double get_current_time() const;$/;"	p	class:itpp::CPU_Timer	access:protected	signature:() const
itpp::CRC_Code	/usr/include/itpp/comm/crc.h	/^class CRC_Code$/;"	c	namespace:itpp
itpp::CRC_Code::CRC_Code	/usr/include/itpp/comm/crc.h	/^  CRC_Code() { reverse_parity = false; }$/;"	f	class:itpp::CRC_Code	access:public	signature:()
itpp::CRC_Code::CRC_Code	/usr/include/itpp/comm/crc.h	/^  CRC_Code(const std::string &code) { reverse_parity = false; set_code(code); }$/;"	f	class:itpp::CRC_Code	access:public	signature:(const std::string &code)
itpp::CRC_Code::check_parity	/usr/include/itpp/comm/crc.h	/^  bool check_parity(const bvec &coded_bits) const;$/;"	p	class:itpp::CRC_Code	access:public	signature:(const bvec &coded_bits) const
itpp::CRC_Code::decode	/usr/include/itpp/comm/crc.h	/^  bool decode(bvec &bits) const;$/;"	p	class:itpp::CRC_Code	access:public	signature:(bvec &bits) const
itpp::CRC_Code::decode	/usr/include/itpp/comm/crc.h	/^  bool decode(const bvec &coded_bits, bvec &out) const;$/;"	p	class:itpp::CRC_Code	access:public	signature:(const bvec &coded_bits, bvec &out) const
itpp::CRC_Code::encode	/usr/include/itpp/comm/crc.h	/^  bvec encode(const bvec &in_bits) const;$/;"	p	class:itpp::CRC_Code	access:public	signature:(const bvec &in_bits) const
itpp::CRC_Code::encode	/usr/include/itpp/comm/crc.h	/^  void encode(const bvec &in_bits, bvec &out) const;$/;"	p	class:itpp::CRC_Code	access:public	signature:(const bvec &in_bits, bvec &out) const
itpp::CRC_Code::no_parity	/usr/include/itpp/comm/crc.h	/^  int no_parity;$/;"	m	class:itpp::CRC_Code	access:private
itpp::CRC_Code::parity	/usr/include/itpp/comm/crc.h	/^  void parity(const bvec &in_bits, bvec &out) const;$/;"	p	class:itpp::CRC_Code	access:public	signature:(const bvec &in_bits, bvec &out) const
itpp::CRC_Code::polynomial	/usr/include/itpp/comm/crc.h	/^  bvec polynomial;$/;"	m	class:itpp::CRC_Code	access:private
itpp::CRC_Code::reverse_parity	/usr/include/itpp/comm/crc.h	/^  bool reverse_parity;$/;"	m	class:itpp::CRC_Code	access:private
itpp::CRC_Code::set_code	/usr/include/itpp/comm/crc.h	/^  void set_code(const std::string &code);$/;"	p	class:itpp::CRC_Code	access:public	signature:(const std::string &code)
itpp::CRC_Code::set_generator	/usr/include/itpp/comm/crc.h	/^  void set_generator(const bvec &poly);$/;"	p	class:itpp::CRC_Code	access:public	signature:(const bvec &poly)
itpp::Ccmat2mxArray	/usr/include/itpp/itmex.h	/^void Ccmat2mxArray(double **in_real, double **in_imag, mxArray *out)$/;"	f	namespace:itpp	signature:(double **in_real, double **in_imag, mxArray *out)
itpp::Ccmat2mxArray	/usr/include/itpp/itmex.h	/^void Ccmat2mxArray(double **in_real, double **in_imag, mxArray *out);$/;"	p	namespace:itpp	signature:(double **in_real, double **in_imag, mxArray *out)
itpp::Ccvec2mxArray	/usr/include/itpp/itmex.h	/^void Ccvec2mxArray(double *in_real, double *in_imag, mxArray *out)$/;"	f	namespace:itpp	signature:(double *in_real, double *in_imag, mxArray *out)
itpp::Ccvec2mxArray	/usr/include/itpp/itmex.h	/^void Ccvec2mxArray(double *in_real, double *in_imag, mxArray *out);$/;"	p	namespace:itpp	signature:(double *in_real, double *in_imag, mxArray *out)
itpp::Channel_Code	/usr/include/itpp/comm/channel_code.h	/^class Channel_Code$/;"	c	namespace:itpp
itpp::Channel_Code::Channel_Code	/usr/include/itpp/comm/channel_code.h	/^  Channel_Code() {}$/;"	f	class:itpp::Channel_Code	access:public	signature:()
itpp::Channel_Code::decode	/usr/include/itpp/comm/channel_code.h	/^  virtual bvec decode(const bvec &coded_bits) = 0;$/;"	p	class:itpp::Channel_Code	access:public	signature:(const bvec &coded_bits)
itpp::Channel_Code::decode	/usr/include/itpp/comm/channel_code.h	/^  virtual bvec decode(const vec &received_signal) = 0;$/;"	p	class:itpp::Channel_Code	access:public	signature:(const vec &received_signal)
itpp::Channel_Code::decode	/usr/include/itpp/comm/channel_code.h	/^  virtual void decode(const bvec &codedbits, bvec &decoded_bits) = 0;$/;"	p	class:itpp::Channel_Code	access:public	signature:(const bvec &codedbits, bvec &decoded_bits)
itpp::Channel_Code::decode	/usr/include/itpp/comm/channel_code.h	/^  virtual void decode(const vec &received_signal, bvec &decoded_bits) = 0;$/;"	p	class:itpp::Channel_Code	access:public	signature:(const vec &received_signal, bvec &decoded_bits)
itpp::Channel_Code::encode	/usr/include/itpp/comm/channel_code.h	/^  virtual bvec encode(const bvec &uncoded_bits) = 0;$/;"	p	class:itpp::Channel_Code	access:public	signature:(const bvec &uncoded_bits)
itpp::Channel_Code::encode	/usr/include/itpp/comm/channel_code.h	/^  virtual void encode(const bvec &uncoded_bits, bvec &coded_bits) = 0;$/;"	p	class:itpp::Channel_Code	access:public	signature:(const bvec &uncoded_bits, bvec &coded_bits)
itpp::Channel_Code::get_rate	/usr/include/itpp/comm/channel_code.h	/^  virtual double get_rate() const = 0;$/;"	p	class:itpp::Channel_Code	access:public	signature:() const
itpp::Channel_Code::~Channel_Code	/usr/include/itpp/comm/channel_code.h	/^  virtual ~Channel_Code() {}$/;"	f	class:itpp::Channel_Code	access:public	signature:()
itpp::Channel_Specification	/usr/include/itpp/comm/channel.h	/^class Channel_Specification$/;"	c	namespace:itpp
itpp::Channel_Specification::Channel_Specification	/usr/include/itpp/comm/channel.h	/^  Channel_Specification(const CHANNEL_PROFILE profile);$/;"	p	class:itpp::Channel_Specification	access:public	signature:(const CHANNEL_PROFILE profile)
itpp::Channel_Specification::Channel_Specification	/usr/include/itpp/comm/channel.h	/^  Channel_Specification(const vec &avg_power_dB = "0", const vec &delay_prof = "0");$/;"	p	class:itpp::Channel_Specification	access:public	signature:(const vec &avg_power_dB = Ó, const vec &delay_prof = Ó)
itpp::Channel_Specification::N_taps	/usr/include/itpp/comm/channel.h	/^  int N_taps; \/\/!< Number of taps$/;"	m	class:itpp::Channel_Specification	access:protected
itpp::Channel_Specification::a_prof_dB	/usr/include/itpp/comm/channel.h	/^  vec a_prof_dB; \/\/!< Power profile in dB$/;"	m	class:itpp::Channel_Specification	access:protected
itpp::Channel_Specification::calc_mean_excess_delay	/usr/include/itpp/comm/channel.h	/^  double calc_mean_excess_delay() const;$/;"	p	class:itpp::Channel_Specification	access:public	signature:() const
itpp::Channel_Specification::calc_rms_delay_spread	/usr/include/itpp/comm/channel.h	/^  double calc_rms_delay_spread() const;$/;"	p	class:itpp::Channel_Specification	access:public	signature:() const
itpp::Channel_Specification::d_prof	/usr/include/itpp/comm/channel.h	/^  vec d_prof; \/\/!< Delay profile in seconds$/;"	m	class:itpp::Channel_Specification	access:protected
itpp::Channel_Specification::get_LOS_doppler	/usr/include/itpp/comm/channel.h	/^  double get_LOS_doppler(int tap_number) const { return los_dopp(tap_number); }$/;"	f	class:itpp::Channel_Specification	access:public	signature:(int tap_number) const
itpp::Channel_Specification::get_LOS_doppler	/usr/include/itpp/comm/channel.h	/^  vec get_LOS_doppler() const { return los_dopp; }$/;"	f	class:itpp::Channel_Specification	access:public	signature:() const
itpp::Channel_Specification::get_LOS_power	/usr/include/itpp/comm/channel.h	/^  double get_LOS_power(int tap_number) const { return los_power(tap_number); }$/;"	f	class:itpp::Channel_Specification	access:public	signature:(int tap_number) const
itpp::Channel_Specification::get_LOS_power	/usr/include/itpp/comm/channel.h	/^  vec get_LOS_power() const { return los_power; }$/;"	f	class:itpp::Channel_Specification	access:public	signature:() const
itpp::Channel_Specification::get_avg_power_dB	/usr/include/itpp/comm/channel.h	/^  vec get_avg_power_dB() const { return a_prof_dB; }$/;"	f	class:itpp::Channel_Specification	access:public	signature:() const
itpp::Channel_Specification::get_channel_profile	/usr/include/itpp/comm/channel.h	/^  void get_channel_profile(vec &avg_power_dB, vec &delay_prof) const;$/;"	p	class:itpp::Channel_Specification	access:public	signature:(vec &avg_power_dB, vec &delay_prof) const
itpp::Channel_Specification::get_delay_prof	/usr/include/itpp/comm/channel.h	/^  vec get_delay_prof() const { return d_prof; }$/;"	f	class:itpp::Channel_Specification	access:public	signature:() const
itpp::Channel_Specification::get_doppler_spectrum	/usr/include/itpp/comm/channel.h	/^  Array<DOPPLER_SPECTRUM> get_doppler_spectrum() const { return tap_doppler_spectrum; }$/;"	f	class:itpp::Channel_Specification	access:public	signature:() const
itpp::Channel_Specification::get_doppler_spectrum	/usr/include/itpp/comm/channel.h	/^  DOPPLER_SPECTRUM get_doppler_spectrum(int index) const;$/;"	p	class:itpp::Channel_Specification	access:public	signature:(int index) const
itpp::Channel_Specification::los_dopp	/usr/include/itpp/comm/channel.h	/^  vec los_dopp; \/\/!< Relative Rice Doppler for each Rice component$/;"	m	class:itpp::Channel_Specification	access:protected
itpp::Channel_Specification::los_power	/usr/include/itpp/comm/channel.h	/^  vec los_power; \/\/!< Relative power for each Rice component$/;"	m	class:itpp::Channel_Specification	access:protected
itpp::Channel_Specification::set_LOS	/usr/include/itpp/comm/channel.h	/^  void set_LOS(const vec& relative_power, const vec& relative_doppler = "");$/;"	p	class:itpp::Channel_Specification	access:public	signature:(const vec& relative_power, const vec& relative_doppler = Ó)
itpp::Channel_Specification::set_LOS	/usr/include/itpp/comm/channel.h	/^  void set_LOS(int tap_number, double relative_power, double relative_doppler = 0.7);$/;"	p	class:itpp::Channel_Specification	access:public	signature:(int tap_number, double relative_power, double relative_doppler = 0.7)
itpp::Channel_Specification::set_channel_profile	/usr/include/itpp/comm/channel.h	/^  void set_channel_profile(const CHANNEL_PROFILE profile);$/;"	p	class:itpp::Channel_Specification	access:public	signature:(const CHANNEL_PROFILE profile)
itpp::Channel_Specification::set_channel_profile	/usr/include/itpp/comm/channel.h	/^  void set_channel_profile(const vec &avg_power_dB, const vec &delay_prof);$/;"	p	class:itpp::Channel_Specification	access:public	signature:(const vec &avg_power_dB, const vec &delay_prof)
itpp::Channel_Specification::set_doppler_spectrum	/usr/include/itpp/comm/channel.h	/^  void set_doppler_spectrum(DOPPLER_SPECTRUM *tap_spectrum);$/;"	p	class:itpp::Channel_Specification	access:public	signature:(DOPPLER_SPECTRUM *tap_spectrum)
itpp::Channel_Specification::set_doppler_spectrum	/usr/include/itpp/comm/channel.h	/^  void set_doppler_spectrum(int tap_number, DOPPLER_SPECTRUM tap_spectrum);$/;"	p	class:itpp::Channel_Specification	access:public	signature:(int tap_number, DOPPLER_SPECTRUM tap_spectrum)
itpp::Channel_Specification::tap_doppler_spectrum	/usr/include/itpp/comm/channel.h	/^  Array<DOPPLER_SPECTRUM> tap_doppler_spectrum; \/\/!< Doppler spectrum for each tap$/;"	m	class:itpp::Channel_Specification	access:protected
itpp::Channel_Specification::taps	/usr/include/itpp/comm/channel.h	/^  int taps() const { return N_taps; }$/;"	f	class:itpp::Channel_Specification	access:public	signature:() const
itpp::Channel_Specification::~Channel_Specification	/usr/include/itpp/comm/channel.h	/^  virtual ~Channel_Specification() {}$/;"	f	class:itpp::Channel_Specification	access:public	signature:()
itpp::Cimat2mxArray	/usr/include/itpp/itmex.h	/^void Cimat2mxArray(int **in, mxArray *out)$/;"	f	namespace:itpp	signature:(int **in, mxArray *out)
itpp::Cimat2mxArray	/usr/include/itpp/itmex.h	/^void Cimat2mxArray(int **in, mxArray *out);$/;"	p	namespace:itpp	signature:(int **in, mxArray *out)
itpp::Circular_Buffer	/usr/include/itpp/base/circular_buffer.h	/^class Circular_Buffer$/;"	c	namespace:itpp
itpp::Circular_Buffer::Circular_Buffer	/usr/include/itpp/base/circular_buffer.h	/^  Circular_Buffer();$/;"	p	class:itpp::Circular_Buffer	access:public	signature:()
itpp::Circular_Buffer::Circular_Buffer	/usr/include/itpp/base/circular_buffer.h	/^  Circular_Buffer(const Circular_Buffer<T> &s);$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(const Circular_Buffer<T> &s)
itpp::Circular_Buffer::Circular_Buffer	/usr/include/itpp/base/circular_buffer.h	/^  Circular_Buffer(int n);$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(int n)
itpp::Circular_Buffer::Circular_Buffer	/usr/include/itpp/base/circular_buffer.h	/^Circular_Buffer<T>::Circular_Buffer()$/;"	f	class:itpp::Circular_Buffer	signature:()
itpp::Circular_Buffer::Circular_Buffer	/usr/include/itpp/base/circular_buffer.h	/^Circular_Buffer<T>::Circular_Buffer(const Circular_Buffer<T> &cb)$/;"	f	class:itpp::Circular_Buffer	signature:(const Circular_Buffer<T> &cb)
itpp::Circular_Buffer::Circular_Buffer	/usr/include/itpp/base/circular_buffer.h	/^Circular_Buffer<T>::Circular_Buffer(int n)$/;"	f	class:itpp::Circular_Buffer	signature:(int n)
itpp::Circular_Buffer::_data	/usr/include/itpp/base/circular_buffer.h	/^  T *_data;$/;"	m	class:itpp::Circular_Buffer	access:private
itpp::Circular_Buffer::_ndata	/usr/include/itpp/base/circular_buffer.h	/^  int _ndata;$/;"	m	class:itpp::Circular_Buffer	access:private
itpp::Circular_Buffer::_read	/usr/include/itpp/base/circular_buffer.h	/^  int _read;$/;"	m	class:itpp::Circular_Buffer	access:private
itpp::Circular_Buffer::_rw_dist	/usr/include/itpp/base/circular_buffer.h	/^  int _rw_dist;$/;"	m	class:itpp::Circular_Buffer	access:private
itpp::Circular_Buffer::_write	/usr/include/itpp/base/circular_buffer.h	/^  int _write;$/;"	m	class:itpp::Circular_Buffer	access:private
itpp::Circular_Buffer::alloc	/usr/include/itpp/base/circular_buffer.h	/^  void alloc(int n);$/;"	p	class:itpp::Circular_Buffer	access:private	signature:(int n)
itpp::Circular_Buffer::alloc	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::alloc(int n)$/;"	f	class:itpp::Circular_Buffer	signature:(int n)
itpp::Circular_Buffer::clear	/usr/include/itpp/base/circular_buffer.h	/^  void clear();$/;"	p	class:itpp::Circular_Buffer	access:public	signature:()
itpp::Circular_Buffer::clear	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::clear()$/;"	f	class:itpp::Circular_Buffer	signature:()
itpp::Circular_Buffer::free	/usr/include/itpp/base/circular_buffer.h	/^  void free();$/;"	p	class:itpp::Circular_Buffer	access:private	signature:()
itpp::Circular_Buffer::free	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::free()$/;"	f	class:itpp::Circular_Buffer	signature:()
itpp::Circular_Buffer::get	/usr/include/itpp/base/circular_buffer.h	/^  T get();$/;"	p	class:itpp::Circular_Buffer	access:public	signature:()
itpp::Circular_Buffer::get	/usr/include/itpp/base/circular_buffer.h	/^  void get(Array<T>& out, const int N = -1);$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(Array<T>& out, const int N = -1)
itpp::Circular_Buffer::get	/usr/include/itpp/base/circular_buffer.h	/^  void get(T& out);$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(T& out)
itpp::Circular_Buffer::get	/usr/include/itpp/base/circular_buffer.h	/^  void get(Vec<T>& out, const int N = -1);$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(Vec<T>& out, const int N = -1)
itpp::Circular_Buffer::get	/usr/include/itpp/base/circular_buffer.h	/^T Circular_Buffer<T>::get()$/;"	f	class:itpp::Circular_Buffer	signature:()
itpp::Circular_Buffer::get	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::get(Array<T>& out, const int N)$/;"	f	class:itpp::Circular_Buffer	signature:(Array<T>& out, const int N)
itpp::Circular_Buffer::get	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::get(T& out)$/;"	f	class:itpp::Circular_Buffer	signature:(T& out)
itpp::Circular_Buffer::get	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::get(Vec<T>& out, const int N)$/;"	f	class:itpp::Circular_Buffer	signature:(Vec<T>& out, const int N)
itpp::Circular_Buffer::nrof_elements	/usr/include/itpp/base/circular_buffer.h	/^  int nrof_elements() const { return _rw_dist; }$/;"	f	class:itpp::Circular_Buffer	access:public	signature:() const
itpp::Circular_Buffer::operator =	/usr/include/itpp/base/circular_buffer.h	/^  void operator=(const Circular_Buffer<T> &s);$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(const Circular_Buffer<T> &s)
itpp::Circular_Buffer::operator =	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::operator=(const Circular_Buffer<T> &s)$/;"	f	class:itpp::Circular_Buffer	signature:(const Circular_Buffer<T> &s)
itpp::Circular_Buffer::peek	/usr/include/itpp/base/circular_buffer.h	/^  T peek() const;$/;"	p	class:itpp::Circular_Buffer	access:public	signature:() const
itpp::Circular_Buffer::peek	/usr/include/itpp/base/circular_buffer.h	/^  void peek(Array<T>& out, const int N = -1) const;$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(Array<T>& out, const int N = -1) const
itpp::Circular_Buffer::peek	/usr/include/itpp/base/circular_buffer.h	/^  void peek(T& out) const;$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(T& out) const
itpp::Circular_Buffer::peek	/usr/include/itpp/base/circular_buffer.h	/^  void peek(Vec<T>& out, const int N = -1) const;$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(Vec<T>& out, const int N = -1) const
itpp::Circular_Buffer::peek	/usr/include/itpp/base/circular_buffer.h	/^  void peek(const int index, T& out) const;$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(const int index, T& out) const
itpp::Circular_Buffer::peek	/usr/include/itpp/base/circular_buffer.h	/^  void peek(const ivec& index, Array<T>& out) const;$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(const ivec& index, Array<T>& out) const
itpp::Circular_Buffer::peek	/usr/include/itpp/base/circular_buffer.h	/^  void peek(const ivec& index, Vec<T>& out) const;$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(const ivec& index, Vec<T>& out) const
itpp::Circular_Buffer::peek	/usr/include/itpp/base/circular_buffer.h	/^T Circular_Buffer<T>::peek() const$/;"	f	class:itpp::Circular_Buffer	signature:() const
itpp::Circular_Buffer::peek	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::peek(Array<T>& out, const int N) const$/;"	f	class:itpp::Circular_Buffer	signature:(Array<T>& out, const int N) const
itpp::Circular_Buffer::peek	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::peek(T& out) const$/;"	f	class:itpp::Circular_Buffer	signature:(T& out) const
itpp::Circular_Buffer::peek	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::peek(Vec<T>& out, const int N) const$/;"	f	class:itpp::Circular_Buffer	signature:(Vec<T>& out, const int N) const
itpp::Circular_Buffer::peek	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::peek(const int index, T& out) const$/;"	f	class:itpp::Circular_Buffer	signature:(const int index, T& out) const
itpp::Circular_Buffer::peek	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::peek(const ivec& index, Array<T>& out) const$/;"	f	class:itpp::Circular_Buffer	signature:(const ivec& index, Array<T>& out) const
itpp::Circular_Buffer::peek	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::peek(const ivec& index, Vec<T>& out) const$/;"	f	class:itpp::Circular_Buffer	signature:(const ivec& index, Vec<T>& out) const
itpp::Circular_Buffer::peek_reverse	/usr/include/itpp/base/circular_buffer.h	/^  T peek_reverse() const;$/;"	p	class:itpp::Circular_Buffer	access:public	signature:() const
itpp::Circular_Buffer::peek_reverse	/usr/include/itpp/base/circular_buffer.h	/^  void peek_reverse(Array<T>& out, const int N = -1) const;$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(Array<T>& out, const int N = -1) const
itpp::Circular_Buffer::peek_reverse	/usr/include/itpp/base/circular_buffer.h	/^  void peek_reverse(T& out) const;$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(T& out) const
itpp::Circular_Buffer::peek_reverse	/usr/include/itpp/base/circular_buffer.h	/^  void peek_reverse(Vec<T>& out, const int N = -1) const;$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(Vec<T>& out, const int N = -1) const
itpp::Circular_Buffer::peek_reverse	/usr/include/itpp/base/circular_buffer.h	/^T Circular_Buffer<T>::peek_reverse() const$/;"	f	class:itpp::Circular_Buffer	signature:() const
itpp::Circular_Buffer::peek_reverse	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::peek_reverse(Array<T>& out, const int N) const$/;"	f	class:itpp::Circular_Buffer	signature:(Array<T>& out, const int N) const
itpp::Circular_Buffer::peek_reverse	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::peek_reverse(T& out) const$/;"	f	class:itpp::Circular_Buffer	signature:(T& out) const
itpp::Circular_Buffer::peek_reverse	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::peek_reverse(Vec<T>& out, const int N) const$/;"	f	class:itpp::Circular_Buffer	signature:(Vec<T>& out, const int N) const
itpp::Circular_Buffer::put	/usr/include/itpp/base/circular_buffer.h	/^  void put(const Array<T>& in);$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(const Array<T>& in)
itpp::Circular_Buffer::put	/usr/include/itpp/base/circular_buffer.h	/^  void put(const T& in);$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(const T& in)
itpp::Circular_Buffer::put	/usr/include/itpp/base/circular_buffer.h	/^  void put(const Vec<T>& in);$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(const Vec<T>& in)
itpp::Circular_Buffer::put	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::put(const Array<T>& in)$/;"	f	class:itpp::Circular_Buffer	signature:(const Array<T>& in)
itpp::Circular_Buffer::put	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::put(const T& in)$/;"	f	class:itpp::Circular_Buffer	signature:(const T& in)
itpp::Circular_Buffer::put	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::put(const Vec<T>& in)$/;"	f	class:itpp::Circular_Buffer	signature:(const Vec<T>& in)
itpp::Circular_Buffer::set_size	/usr/include/itpp/base/circular_buffer.h	/^  void set_size(int n, bool copy = false);$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(int n, bool copy = false)
itpp::Circular_Buffer::set_size	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::set_size(int sz, bool copy)$/;"	f	class:itpp::Circular_Buffer	signature:(int sz, bool copy)
itpp::Circular_Buffer::size	/usr/include/itpp/base/circular_buffer.h	/^  int size() const { return _ndata; }$/;"	f	class:itpp::Circular_Buffer	access:public	signature:() const
itpp::Circular_Buffer::~Circular_Buffer	/usr/include/itpp/base/circular_buffer.h	/^  virtual ~Circular_Buffer();$/;"	p	class:itpp::Circular_Buffer	access:public	signature:()
itpp::Circular_Buffer::~Circular_Buffer	/usr/include/itpp/base/circular_buffer.h	/^Circular_Buffer<T>::~Circular_Buffer()$/;"	f	class:itpp::Circular_Buffer	signature:()
itpp::Civec2mxArray	/usr/include/itpp/itmex.h	/^void Civec2mxArray(int *in, mxArray *out)$/;"	f	namespace:itpp	signature:(int *in, mxArray *out)
itpp::Civec2mxArray	/usr/include/itpp/itmex.h	/^void Civec2mxArray(int *in, mxArray *out);$/;"	p	namespace:itpp	signature:(int *in, mxArray *out)
itpp::Classic	/usr/include/itpp/comm/channel.h	/^  Jakes = 0, J = 0, Classic = 0, C = 0,$/;"	e	enum:itpp::DOPPLER_SPECTRUM
itpp::Cmat2mxArray	/usr/include/itpp/itmex.h	/^void Cmat2mxArray(double **in, mxArray *out)$/;"	f	namespace:itpp	signature:(double **in, mxArray *out)
itpp::Cmat2mxArray	/usr/include/itpp/itmex.h	/^void Cmat2mxArray(double **in, mxArray *out);$/;"	p	namespace:itpp	signature:(double **in, mxArray *out)
itpp::Compare_Base_Event_Times	/usr/include/itpp/protocol/events.h	/^struct Compare_Base_Event_Times {$/;"	s	namespace:itpp
itpp::Compare_Base_Event_Times::operator ()	/usr/include/itpp/protocol/events.h	/^  bool operator()(Base_Event *event1, Base_Event *event2) {$/;"	f	struct:itpp::Compare_Base_Event_Times	access:public	signature:(Base_Event *event1, Base_Event *event2)
itpp::Complex_Normal_RNG	/usr/include/itpp/base/random.h	/^class Complex_Normal_RNG$/;"	c	namespace:itpp
itpp::Complex_Normal_RNG::Complex_Normal_RNG	/usr/include/itpp/base/random.h	/^  Complex_Normal_RNG(): m(0.0), sigma(1.0), norm_factor(1.0 \/ std::sqrt(2.0)) {}$/;"	f	class:itpp::Complex_Normal_RNG	access:public	signature:()
itpp::Complex_Normal_RNG::Complex_Normal_RNG	/usr/include/itpp/base/random.h	/^  Complex_Normal_RNG(std::complex<double> mean, double variance):$/;"	f	class:itpp::Complex_Normal_RNG	access:public	signature:(std::complex<double> mean, double variance)
itpp::Complex_Normal_RNG::get_setup	/usr/include/itpp/base/random.h	/^  void get_setup(std::complex<double> &mean, double &variance) {$/;"	f	class:itpp::Complex_Normal_RNG	access:public	signature:(std::complex<double> &mean, double &variance)
itpp::Complex_Normal_RNG::m	/usr/include/itpp/base/random.h	/^  std::complex<double> m;$/;"	m	class:itpp::Complex_Normal_RNG	access:private
itpp::Complex_Normal_RNG::nRNG	/usr/include/itpp/base/random.h	/^  Normal_RNG nRNG;$/;"	m	class:itpp::Complex_Normal_RNG	access:private
itpp::Complex_Normal_RNG::norm_factor	/usr/include/itpp/base/random.h	/^  const double norm_factor;$/;"	m	class:itpp::Complex_Normal_RNG	access:private
itpp::Complex_Normal_RNG::operator ()	/usr/include/itpp/base/random.h	/^  cmat operator()(int h, int w) {$/;"	f	class:itpp::Complex_Normal_RNG	access:public	signature:(int h, int w)
itpp::Complex_Normal_RNG::operator ()	/usr/include/itpp/base/random.h	/^  cvec operator()(int n) {$/;"	f	class:itpp::Complex_Normal_RNG	access:public	signature:(int n)
itpp::Complex_Normal_RNG::operator ()	/usr/include/itpp/base/random.h	/^  std::complex<double> operator()() { return sigma*sample() + m; }$/;"	f	class:itpp::Complex_Normal_RNG	access:public	signature:()
itpp::Complex_Normal_RNG::operator =	/usr/include/itpp/base/random.h	/^  Complex_Normal_RNG & operator=(const Complex_Normal_RNG&) { return *this; }$/;"	f	class:itpp::Complex_Normal_RNG	access:public	signature:(const Complex_Normal_RNG&)
itpp::Complex_Normal_RNG::sample	/usr/include/itpp/base/random.h	/^  std::complex<double> sample() {$/;"	f	class:itpp::Complex_Normal_RNG	access:public	signature:()
itpp::Complex_Normal_RNG::sample_matrix	/usr/include/itpp/base/random.h	/^  void sample_matrix(int rows, int cols, cmat &out) {$/;"	f	class:itpp::Complex_Normal_RNG	access:public	signature:(int rows, int cols, cmat &out)
itpp::Complex_Normal_RNG::sample_vector	/usr/include/itpp/base/random.h	/^  void sample_vector(int size, cvec &out) {$/;"	f	class:itpp::Complex_Normal_RNG	access:public	signature:(int size, cvec &out)
itpp::Complex_Normal_RNG::setup	/usr/include/itpp/base/random.h	/^  void setup(std::complex<double> mean, double variance) {$/;"	f	class:itpp::Complex_Normal_RNG	access:public	signature:(std::complex<double> mean, double variance)
itpp::Complex_Normal_RNG::sigma	/usr/include/itpp/base/random.h	/^  double sigma;$/;"	m	class:itpp::Complex_Normal_RNG	access:private
itpp::Constant_Rate_Packet_Generator	/usr/include/itpp/protocol/packet_generator.h	/^class Constant_Rate_Packet_Generator : public Poisson_Packet_Generator$/;"	c	namespace:itpp	inherits:Poisson_Packet_Generator
itpp::Constant_Rate_Packet_Generator::Constant_Rate_Packet_Generator	/usr/include/itpp/protocol/packet_generator.h	/^  Constant_Rate_Packet_Generator(const double Avg_bit_rate = 1.0, const int Packet_size = 150, const unsigned long int Max_packets = 0);$/;"	p	class:itpp::Constant_Rate_Packet_Generator	access:public	signature:(const double Avg_bit_rate = 1.0, const int Packet_size = 150, const unsigned long int Max_packets = 0)
itpp::Constant_Rate_Packet_Generator::delta_t	/usr/include/itpp/protocol/packet_generator.h	/^  virtual Ttype delta_t();$/;"	p	class:itpp::Constant_Rate_Packet_Generator	access:protected	signature:()
itpp::Constant_Rate_Packet_Generator::~Constant_Rate_Packet_Generator	/usr/include/itpp/protocol/packet_generator.h	/^  virtual ~Constant_Rate_Packet_Generator();$/;"	p	class:itpp::Constant_Rate_Packet_Generator	access:public	signature:()
itpp::Convert	/usr/include/itpp/fixed/fix_functions.h	/^class Convert$/;"	c	namespace:itpp
itpp::Convert	/usr/include/itpp/fixed/fix_functions.h	/^class Convert<Array<T> >$/;"	c	namespace:itpp
itpp::Convert	/usr/include/itpp/fixed/fix_functions.h	/^class Convert<CFix>$/;"	c	namespace:itpp
itpp::Convert	/usr/include/itpp/fixed/fix_functions.h	/^class Convert<Mat<T> >$/;"	c	namespace:itpp
itpp::Convert	/usr/include/itpp/fixed/fix_functions.h	/^class Convert<Vec<T> >$/;"	c	namespace:itpp
itpp::Convert	/usr/include/itpp/fixed/fix_functions.h	/^class Convert<std::complex<T> >$/;"	c	namespace:itpp
itpp::Convert::to_double	/usr/include/itpp/fixed/fix_functions.h	/^  typedef Array<typename Convert<T>::to_double> to_double;  \/\/ Recursive$/;"	t	class:itpp::Convert	access:public
itpp::Convert::to_double	/usr/include/itpp/fixed/fix_functions.h	/^  typedef Mat<typename Convert<T>::to_double> to_double;  \/\/ Recursive$/;"	t	class:itpp::Convert	access:public
itpp::Convert::to_double	/usr/include/itpp/fixed/fix_functions.h	/^  typedef Vec<typename Convert<T>::to_double> to_double;  \/\/ Recursive$/;"	t	class:itpp::Convert	access:public
itpp::Convert::to_double	/usr/include/itpp/fixed/fix_functions.h	/^  typedef double to_double;$/;"	t	class:itpp::Convert	access:public
itpp::Convert::to_double	/usr/include/itpp/fixed/fix_functions.h	/^  typedef std::complex<double> to_double;$/;"	t	class:itpp::Convert	access:public
itpp::ConvertU2T	/usr/include/itpp/fixed/fix_functions.h	/^class ConvertU2T$/;"	c	namespace:itpp
itpp::ConvertU2T	/usr/include/itpp/fixed/fix_functions.h	/^class ConvertU2T<T, Array<U> >$/;"	c	namespace:itpp
itpp::ConvertU2T	/usr/include/itpp/fixed/fix_functions.h	/^class ConvertU2T<T, Mat<U> >$/;"	c	namespace:itpp
itpp::ConvertU2T	/usr/include/itpp/fixed/fix_functions.h	/^class ConvertU2T<T, Vec<U> >$/;"	c	namespace:itpp
itpp::ConvertU2T::result	/usr/include/itpp/fixed/fix_functions.h	/^  typedef Array<typename ConvertU2T<T, U>::result> result;  \/\/ Recursive$/;"	t	class:itpp::ConvertU2T	access:public
itpp::ConvertU2T::result	/usr/include/itpp/fixed/fix_functions.h	/^  typedef Mat<T> result;$/;"	t	class:itpp::ConvertU2T	access:public
itpp::ConvertU2T::result	/usr/include/itpp/fixed/fix_functions.h	/^  typedef T result;$/;"	t	class:itpp::ConvertU2T	access:public
itpp::ConvertU2T::result	/usr/include/itpp/fixed/fix_functions.h	/^  typedef Vec<T> result;$/;"	t	class:itpp::ConvertU2T	access:public
itpp::Convolutional_Code	/usr/include/itpp/comm/convcode.h	/^class Convolutional_Code : public Channel_Code$/;"	c	namespace:itpp	inherits:Channel_Code
itpp::Convolutional_Code::Convolutional_Code	/usr/include/itpp/comm/convcode.h	/^  Convolutional_Code(void): K(0), start_state(0), cc_method(Tail) {$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(void)
itpp::Convolutional_Code::K	/usr/include/itpp/comm/convcode.h	/^  int K;$/;"	m	class:itpp::Convolutional_Code	access:protected
itpp::Convolutional_Code::calc_metric	/usr/include/itpp/comm/convcode.h	/^  void calc_metric(const vec &rx_codeword, vec &delta_metrics);$/;"	p	class:itpp::Convolutional_Code	access:protected	signature:(const vec &rx_codeword, vec &delta_metrics)
itpp::Convolutional_Code::calc_metric_reverse	/usr/include/itpp/comm/convcode.h	/^  void calc_metric_reverse(const int state, const vec &rx_codeword,$/;"	p	class:itpp::Convolutional_Code	access:protected	signature:(const int state, const vec &rx_codeword, double &zero_metric, double &one_metric)
itpp::Convolutional_Code::calculate_spectrum	/usr/include/itpp/comm/convcode.h	/^  void calculate_spectrum(Array<ivec> &spectrum, int dmax, int no_terms);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(Array<ivec> &spectrum, int dmax, int no_terms)
itpp::Convolutional_Code::catastrophic	/usr/include/itpp/comm/convcode.h	/^  bool catastrophic(void);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(void)
itpp::Convolutional_Code::cc_method	/usr/include/itpp/comm/convcode.h	/^  CONVOLUTIONAL_CODE_METHOD cc_method;$/;"	m	class:itpp::Convolutional_Code	access:protected
itpp::Convolutional_Code::decode	/usr/include/itpp/comm/convcode.h	/^  virtual bvec decode(const bvec &coded_bits);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const bvec &coded_bits)
itpp::Convolutional_Code::decode	/usr/include/itpp/comm/convcode.h	/^  virtual bvec decode(const vec &received_signal) {$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(const vec &received_signal)
itpp::Convolutional_Code::decode	/usr/include/itpp/comm/convcode.h	/^  virtual void decode(const bvec &coded_bits, bvec &decoded_bits);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const bvec &coded_bits, bvec &decoded_bits)
itpp::Convolutional_Code::decode	/usr/include/itpp/comm/convcode.h	/^  virtual void decode(const vec &received_signal, bvec &output);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const vec &received_signal, bvec &output)
itpp::Convolutional_Code::decode_tail	/usr/include/itpp/comm/convcode.h	/^  virtual bvec decode_tail(const vec &received_signal) {$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(const vec &received_signal)
itpp::Convolutional_Code::decode_tail	/usr/include/itpp/comm/convcode.h	/^  virtual void decode_tail(const vec &received_signal, bvec &output);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const vec &received_signal, bvec &output)
itpp::Convolutional_Code::decode_tailbite	/usr/include/itpp/comm/convcode.h	/^  virtual bvec decode_tailbite(const vec &received_signal) {$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(const vec &received_signal)
itpp::Convolutional_Code::decode_tailbite	/usr/include/itpp/comm/convcode.h	/^  virtual void decode_tailbite(const vec &received_signal, bvec &output);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const vec &received_signal, bvec &output)
itpp::Convolutional_Code::decode_trunc	/usr/include/itpp/comm/convcode.h	/^  virtual bvec decode_trunc(const vec &received_signal) {$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(const vec &received_signal)
itpp::Convolutional_Code::decode_trunc	/usr/include/itpp/comm/convcode.h	/^  virtual void decode_trunc(const vec &received_signal, bvec &output);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const vec &received_signal, bvec &output)
itpp::Convolutional_Code::distance_profile	/usr/include/itpp/comm/convcode.h	/^  void distance_profile(ivec &dist_prof, int dmax = 100000,$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(ivec &dist_prof, int dmax = 100000, bool reverse = false)
itpp::Convolutional_Code::encode	/usr/include/itpp/comm/convcode.h	/^  virtual bvec encode(const bvec &input) {$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(const bvec &input)
itpp::Convolutional_Code::encode	/usr/include/itpp/comm/convcode.h	/^  virtual void encode(const bvec &input, bvec &output);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const bvec &input, bvec &output)
itpp::Convolutional_Code::encode_bit	/usr/include/itpp/comm/convcode.h	/^  bvec encode_bit(const bin &input) {$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(const bin &input)
itpp::Convolutional_Code::encode_bit	/usr/include/itpp/comm/convcode.h	/^  void encode_bit(const bin &input, bvec &output);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const bin &input, bvec &output)
itpp::Convolutional_Code::encode_tail	/usr/include/itpp/comm/convcode.h	/^  bvec encode_tail(const bvec &input) {$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(const bvec &input)
itpp::Convolutional_Code::encode_tail	/usr/include/itpp/comm/convcode.h	/^  void encode_tail(const bvec &input, bvec &output);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const bvec &input, bvec &output)
itpp::Convolutional_Code::encode_tailbite	/usr/include/itpp/comm/convcode.h	/^  bvec encode_tailbite(const bvec &input) {$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(const bvec &input)
itpp::Convolutional_Code::encode_tailbite	/usr/include/itpp/comm/convcode.h	/^  void encode_tailbite(const bvec &input, bvec &output);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const bvec &input, bvec &output)
itpp::Convolutional_Code::encode_trunc	/usr/include/itpp/comm/convcode.h	/^  bvec encode_trunc(const bvec &input) {$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(const bvec &input)
itpp::Convolutional_Code::encode_trunc	/usr/include/itpp/comm/convcode.h	/^  void encode_trunc(const bvec &input, bvec &output);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const bvec &input, bvec &output)
itpp::Convolutional_Code::encoder_state	/usr/include/itpp/comm/convcode.h	/^  int encoder_state;$/;"	m	class:itpp::Convolutional_Code	access:protected
itpp::Convolutional_Code::fast	/usr/include/itpp/comm/convcode.h	/^  int fast(Array<ivec> &spectrum, const int dfree, const int no_terms,$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(Array<ivec> &spectrum, const int dfree, const int no_terms, const int Cdfree = 1000000, const bool test_catastrophic = false)
itpp::Convolutional_Code::gen_pol	/usr/include/itpp/comm/convcode.h	/^  ivec gen_pol;$/;"	m	class:itpp::Convolutional_Code	access:protected
itpp::Convolutional_Code::gen_pol_rev	/usr/include/itpp/comm/convcode.h	/^  ivec gen_pol_rev;$/;"	m	class:itpp::Convolutional_Code	access:protected
itpp::Convolutional_Code::get_encoder_state	/usr/include/itpp/comm/convcode.h	/^  int get_encoder_state(void) const { return encoder_state; }$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(void) const
itpp::Convolutional_Code::get_generator_polynomials	/usr/include/itpp/comm/convcode.h	/^  ivec get_generator_polynomials(void) const { return gen_pol; }$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(void) const
itpp::Convolutional_Code::get_input	/usr/include/itpp/comm/convcode.h	/^  int get_input(const int state) { return (state >> (m - 1)); }$/;"	f	class:itpp::Convolutional_Code	access:protected	signature:(const int state)
itpp::Convolutional_Code::get_rate	/usr/include/itpp/comm/convcode.h	/^  virtual double get_rate(void) const { return rate; }$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(void) const
itpp::Convolutional_Code::get_truncation_length	/usr/include/itpp/comm/convcode.h	/^  int get_truncation_length(void) const { return trunc_length; }$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(void) const
itpp::Convolutional_Code::init_encoder	/usr/include/itpp/comm/convcode.h	/^  void init_encoder() { encoder_state = start_state; }$/;"	f	class:itpp::Convolutional_Code	access:public	signature:()
itpp::Convolutional_Code::inverse_tail	/usr/include/itpp/comm/convcode.h	/^  bool inverse_tail(const bvec coded_sequence, bvec &input);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const bvec coded_sequence, bvec &input)
itpp::Convolutional_Code::m	/usr/include/itpp/comm/convcode.h	/^  int m;$/;"	m	class:itpp::Convolutional_Code	access:protected
itpp::Convolutional_Code::n	/usr/include/itpp/comm/convcode.h	/^  int n;$/;"	m	class:itpp::Convolutional_Code	access:protected
itpp::Convolutional_Code::next_state	/usr/include/itpp/comm/convcode.h	/^  int next_state(const int instate, const int input) {$/;"	f	class:itpp::Convolutional_Code	access:protected	signature:(const int instate, const int input)
itpp::Convolutional_Code::no_states	/usr/include/itpp/comm/convcode.h	/^  int no_states;$/;"	m	class:itpp::Convolutional_Code	access:protected
itpp::Convolutional_Code::output_reverse	/usr/include/itpp/comm/convcode.h	/^  bvec output_reverse(const int state, const int input);$/;"	p	class:itpp::Convolutional_Code	access:protected	signature:(const int state, const int input)
itpp::Convolutional_Code::output_reverse	/usr/include/itpp/comm/convcode.h	/^  void output_reverse(const int state, bvec &zero_output, bvec &one_output);$/;"	p	class:itpp::Convolutional_Code	access:protected	signature:(const int state, bvec &zero_output, bvec &one_output)
itpp::Convolutional_Code::output_reverse	/usr/include/itpp/comm/convcode.h	/^  void output_reverse(const int state, int &zero_output, int &one_output);$/;"	p	class:itpp::Convolutional_Code	access:protected	signature:(const int state, int &zero_output, int &one_output)
itpp::Convolutional_Code::output_reverse_int	/usr/include/itpp/comm/convcode.h	/^  imat output_reverse_int;$/;"	m	class:itpp::Convolutional_Code	access:protected
itpp::Convolutional_Code::path_memory	/usr/include/itpp/comm/convcode.h	/^  imat path_memory;$/;"	m	class:itpp::Convolutional_Code	access:protected
itpp::Convolutional_Code::previous_state	/usr/include/itpp/comm/convcode.h	/^  int previous_state(const int state, const int input) {$/;"	f	class:itpp::Convolutional_Code	access:protected	signature:(const int state, const int input)
itpp::Convolutional_Code::previous_state	/usr/include/itpp/comm/convcode.h	/^  void previous_state(const int state, int &S0, int &S1) {$/;"	f	class:itpp::Convolutional_Code	access:protected	signature:(const int state, int &S0, int &S1)
itpp::Convolutional_Code::rate	/usr/include/itpp/comm/convcode.h	/^  double rate;$/;"	m	class:itpp::Convolutional_Code	access:protected
itpp::Convolutional_Code::reset	/usr/include/itpp/comm/convcode.h	/^  void reset();$/;"	p	class:itpp::Convolutional_Code	access:public	signature:()
itpp::Convolutional_Code::set_code	/usr/include/itpp/comm/convcode.h	/^  void set_code(const CONVOLUTIONAL_CODE_TYPE type_of_code, int inverse_rate,$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const CONVOLUTIONAL_CODE_TYPE type_of_code, int inverse_rate, int constraint_length)
itpp::Convolutional_Code::set_generator_polynomials	/usr/include/itpp/comm/convcode.h	/^  void set_generator_polynomials(const ivec &gen, int constraint_length);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const ivec &gen, int constraint_length)
itpp::Convolutional_Code::set_method	/usr/include/itpp/comm/convcode.h	/^  void set_method(const CONVOLUTIONAL_CODE_METHOD method) {$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(const CONVOLUTIONAL_CODE_METHOD method)
itpp::Convolutional_Code::set_start_state	/usr/include/itpp/comm/convcode.h	/^  void set_start_state(int state) {$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(int state)
itpp::Convolutional_Code::set_truncation_length	/usr/include/itpp/comm/convcode.h	/^  void set_truncation_length(const int length) {$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(const int length)
itpp::Convolutional_Code::start_state	/usr/include/itpp/comm/convcode.h	/^  int start_state;$/;"	m	class:itpp::Convolutional_Code	access:protected
itpp::Convolutional_Code::sum_metric	/usr/include/itpp/comm/convcode.h	/^  vec sum_metric;$/;"	m	class:itpp::Convolutional_Code	access:protected
itpp::Convolutional_Code::trunc_length	/usr/include/itpp/comm/convcode.h	/^  int trunc_length;$/;"	m	class:itpp::Convolutional_Code	access:protected
itpp::Convolutional_Code::trunc_ptr	/usr/include/itpp/comm/convcode.h	/^  int trunc_ptr;$/;"	m	class:itpp::Convolutional_Code	access:protected
itpp::Convolutional_Code::trunc_state	/usr/include/itpp/comm/convcode.h	/^  int trunc_state;$/;"	m	class:itpp::Convolutional_Code	access:protected
itpp::Convolutional_Code::visited_state	/usr/include/itpp/comm/convcode.h	/^  Array<bool> visited_state;$/;"	m	class:itpp::Convolutional_Code	access:protected
itpp::Convolutional_Code::weight	/usr/include/itpp/comm/convcode.h	/^  int weight(const int state, const int input);$/;"	p	class:itpp::Convolutional_Code	access:protected	signature:(const int state, const int input)
itpp::Convolutional_Code::weight	/usr/include/itpp/comm/convcode.h	/^  void weight(const int state, int &w0, int &w1);$/;"	p	class:itpp::Convolutional_Code	access:protected	signature:(const int state, int &w0, int &w1)
itpp::Convolutional_Code::weight_reverse	/usr/include/itpp/comm/convcode.h	/^  int weight_reverse(const int state, const int input);$/;"	p	class:itpp::Convolutional_Code	access:protected	signature:(const int state, const int input)
itpp::Convolutional_Code::weight_reverse	/usr/include/itpp/comm/convcode.h	/^  void weight_reverse(const int state, int &w0, int &w1);$/;"	p	class:itpp::Convolutional_Code	access:protected	signature:(const int state, int &w0, int &w1)
itpp::Convolutional_Code::xor_int_table	/usr/include/itpp/comm/convcode.h	/^  bvec xor_int_table;$/;"	m	class:itpp::Convolutional_Code	access:protected
itpp::Convolutional_Code::~Convolutional_Code	/usr/include/itpp/comm/convcode.h	/^  virtual ~Convolutional_Code(void) {}$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(void)
itpp::Correlated	/usr/include/itpp/comm/channel.h	/^enum FADING_TYPE { Independent, Static, Correlated };$/;"	e	enum:itpp::FADING_TYPE
itpp::Correlated_Fading_Generator	/usr/include/itpp/comm/channel.h	/^class Correlated_Fading_Generator : public Fading_Generator$/;"	c	namespace:itpp	inherits:Fading_Generator
itpp::Correlated_Fading_Generator::Correlated_Fading_Generator	/usr/include/itpp/comm/channel.h	/^  Correlated_Fading_Generator(double norm_doppler);$/;"	p	class:itpp::Correlated_Fading_Generator	access:public	signature:(double norm_doppler)
itpp::Correlated_Fading_Generator::add_LOS	/usr/include/itpp/comm/channel.h	/^  void add_LOS(int idx, std::complex<double>& sample);$/;"	p	class:itpp::Correlated_Fading_Generator	access:protected	signature:(int idx, std::complex<double>& sample)
itpp::Correlated_Fading_Generator::generate	/usr/include/itpp/comm/channel.h	/^  virtual void generate(int no_samples, cvec& output) = 0;$/;"	p	class:itpp::Correlated_Fading_Generator	access:public	signature:(int no_samples, cvec& output)
itpp::Correlated_Fading_Generator::get_LOS_doppler	/usr/include/itpp/comm/channel.h	/^  virtual double get_LOS_doppler() const { return los_dopp; }$/;"	f	class:itpp::Correlated_Fading_Generator	access:public	signature:() const
itpp::Correlated_Fading_Generator::get_norm_doppler	/usr/include/itpp/comm/channel.h	/^  virtual double get_norm_doppler() const { return n_dopp; }$/;"	f	class:itpp::Correlated_Fading_Generator	access:public	signature:() const
itpp::Correlated_Fading_Generator::get_time_offset	/usr/include/itpp/comm/channel.h	/^  virtual double get_time_offset() const { return time_offset; }$/;"	f	class:itpp::Correlated_Fading_Generator	access:public	signature:() const
itpp::Correlated_Fading_Generator::init	/usr/include/itpp/comm/channel.h	/^  virtual void init() = 0;$/;"	p	class:itpp::Correlated_Fading_Generator	access:public	signature:()
itpp::Correlated_Fading_Generator::los_dopp	/usr/include/itpp/comm/channel.h	/^  double los_dopp; \/\/!< Relative Doppler on LOS component (0.7 by default)$/;"	m	class:itpp::Correlated_Fading_Generator	access:protected
itpp::Correlated_Fading_Generator::n_dopp	/usr/include/itpp/comm/channel.h	/^  double n_dopp; \/\/!< Normalized maximum Doppler frequency$/;"	m	class:itpp::Correlated_Fading_Generator	access:protected
itpp::Correlated_Fading_Generator::set_LOS_doppler	/usr/include/itpp/comm/channel.h	/^  virtual void set_LOS_doppler(double relative_doppler);$/;"	p	class:itpp::Correlated_Fading_Generator	access:public	signature:(double relative_doppler)
itpp::Correlated_Fading_Generator::set_norm_doppler	/usr/include/itpp/comm/channel.h	/^  virtual void set_norm_doppler(double norm_doppler);$/;"	p	class:itpp::Correlated_Fading_Generator	access:public	signature:(double norm_doppler)
itpp::Correlated_Fading_Generator::set_time_offset	/usr/include/itpp/comm/channel.h	/^  virtual void set_time_offset(int offset);$/;"	p	class:itpp::Correlated_Fading_Generator	access:public	signature:(int offset)
itpp::Correlated_Fading_Generator::shift_time_offset	/usr/include/itpp/comm/channel.h	/^  virtual void shift_time_offset(int no_samples);$/;"	p	class:itpp::Correlated_Fading_Generator	access:public	signature:(int no_samples)
itpp::Correlated_Fading_Generator::time_offset	/usr/include/itpp/comm/channel.h	/^  double time_offset; \/\/!< Time offset in samples (time state in the generator)$/;"	m	class:itpp::Correlated_Fading_Generator	access:protected
itpp::Correlated_Fading_Generator::~Correlated_Fading_Generator	/usr/include/itpp/comm/channel.h	/^  virtual ~Correlated_Fading_Generator() {}$/;"	f	class:itpp::Correlated_Fading_Generator	access:public	signature:()
itpp::Cross_Interleaver	/usr/include/itpp/comm/interleave.h	/^class Cross_Interleaver$/;"	c	namespace:itpp
itpp::Cross_Interleaver::Cross_Interleaver	/usr/include/itpp/comm/interleave.h	/^  Cross_Interleaver(int in_order);$/;"	p	class:itpp::Cross_Interleaver	access:public	signature:(int in_order)
itpp::Cross_Interleaver::Cross_Interleaver	/usr/include/itpp/comm/interleave.h	/^  Cross_Interleaver(void) {order = 0;};$/;"	f	class:itpp::Cross_Interleaver	access:public	signature:(void)
itpp::Cross_Interleaver::Cross_Interleaver	/usr/include/itpp/comm/interleave.h	/^Cross_Interleaver<T>::Cross_Interleaver(int in_order)$/;"	f	class:itpp::Cross_Interleaver	signature:(int in_order)
itpp::Cross_Interleaver::deinterleave	/usr/include/itpp/comm/interleave.h	/^  Vec<T> deinterleave(const Vec<T> &input, short keepzeros = 0);$/;"	p	class:itpp::Cross_Interleaver	access:public	signature:(const Vec<T> &input, short keepzeros = 0)
itpp::Cross_Interleaver::deinterleave	/usr/include/itpp/comm/interleave.h	/^  void deinterleave(const Vec<T> &input, Vec<T> &output, short keepzeros = 0);$/;"	p	class:itpp::Cross_Interleaver	access:public	signature:(const Vec<T> &input, Vec<T> &output, short keepzeros = 0)
itpp::Cross_Interleaver::deinterleave	/usr/include/itpp/comm/interleave.h	/^Vec<T> Cross_Interleaver<T>::deinterleave(const Vec<T> &input, short keepzeros)$/;"	f	class:itpp::Cross_Interleaver	signature:(const Vec<T> &input, short keepzeros)
itpp::Cross_Interleaver::deinterleave	/usr/include/itpp/comm/interleave.h	/^void Cross_Interleaver<T>::deinterleave(const Vec<T> &input, Vec<T> &output, short keepzeros)$/;"	f	class:itpp::Cross_Interleaver	signature:(const Vec<T> &input, Vec<T> &output, short keepzeros)
itpp::Cross_Interleaver::get_order	/usr/include/itpp/comm/interleave.h	/^  int get_order(void) {return order;};$/;"	f	class:itpp::Cross_Interleaver	access:public	signature:(void)
itpp::Cross_Interleaver::input_length	/usr/include/itpp/comm/interleave.h	/^  int input_length;$/;"	m	class:itpp::Cross_Interleaver	access:private
itpp::Cross_Interleaver::inter_matrix	/usr/include/itpp/comm/interleave.h	/^  Mat<T> inter_matrix;$/;"	m	class:itpp::Cross_Interleaver	access:private
itpp::Cross_Interleaver::interleave	/usr/include/itpp/comm/interleave.h	/^  Vec<T> interleave(const Vec<T> &input);$/;"	p	class:itpp::Cross_Interleaver	access:public	signature:(const Vec<T> &input)
itpp::Cross_Interleaver::interleave	/usr/include/itpp/comm/interleave.h	/^  void interleave(const Vec<T> &input, Vec<T> &output);$/;"	p	class:itpp::Cross_Interleaver	access:public	signature:(const Vec<T> &input, Vec<T> &output)
itpp::Cross_Interleaver::interleave	/usr/include/itpp/comm/interleave.h	/^Vec<T> Cross_Interleaver<T>::interleave(const Vec<T> &input)$/;"	f	class:itpp::Cross_Interleaver	signature:(const Vec<T> &input)
itpp::Cross_Interleaver::interleave	/usr/include/itpp/comm/interleave.h	/^void Cross_Interleaver<T>::interleave(const Vec<T> &input, Vec<T> &output)$/;"	f	class:itpp::Cross_Interleaver	signature:(const Vec<T> &input, Vec<T> &output)
itpp::Cross_Interleaver::order	/usr/include/itpp/comm/interleave.h	/^  int order;$/;"	m	class:itpp::Cross_Interleaver	access:private
itpp::Cross_Interleaver::set_order	/usr/include/itpp/comm/interleave.h	/^  void set_order(int in_order);$/;"	p	class:itpp::Cross_Interleaver	access:public	signature:(int in_order)
itpp::Cross_Interleaver::set_order	/usr/include/itpp/comm/interleave.h	/^void Cross_Interleaver<T>::set_order(int in_order)$/;"	f	class:itpp::Cross_Interleaver	signature:(int in_order)
itpp::Cross_Interleaver::tempvec	/usr/include/itpp/comm/interleave.h	/^  Vec<T> tempvec, zerostemp;$/;"	m	class:itpp::Cross_Interleaver	access:private
itpp::Cross_Interleaver::zerostemp	/usr/include/itpp/comm/interleave.h	/^  Vec<T> tempvec, zerostemp;$/;"	m	class:itpp::Cross_Interleaver	access:private
itpp::Csmat2mxArray	/usr/include/itpp/itmex.h	/^void Csmat2mxArray(short **in, mxArray *out)$/;"	f	namespace:itpp	signature:(short **in, mxArray *out)
itpp::Csmat2mxArray	/usr/include/itpp/itmex.h	/^void Csmat2mxArray(short **in, mxArray *out);$/;"	p	namespace:itpp	signature:(short **in, mxArray *out)
itpp::Csvec2mxArray	/usr/include/itpp/itmex.h	/^void Csvec2mxArray(short *in, mxArray *out)$/;"	f	namespace:itpp	signature:(short *in, mxArray *out)
itpp::Csvec2mxArray	/usr/include/itpp/itmex.h	/^void Csvec2mxArray(short *in, mxArray *out);$/;"	p	namespace:itpp	signature:(short *in, mxArray *out)
itpp::Cvec2mxArray	/usr/include/itpp/itmex.h	/^void Cvec2mxArray(double *in, mxArray *out)$/;"	f	namespace:itpp	signature:(double *in, mxArray *out)
itpp::Cvec2mxArray	/usr/include/itpp/itmex.h	/^void Cvec2mxArray(double *in, mxArray *out);$/;"	p	namespace:itpp	signature:(double *in, mxArray *out)
itpp::DEFAULT_FACTORY	/usr/include/itpp/base/factory.h	/^const Factory DEFAULT_FACTORY;$/;"	m	namespace:itpp
itpp::DOPPLER_SPECTRUM	/usr/include/itpp/comm/channel.h	/^enum DOPPLER_SPECTRUM {$/;"	g	namespace:itpp
itpp::DOUBLE_POW2	/usr/include/itpp/fixed/fix_base.h	/^const double DOUBLE_POW2[128] = {$/;"	m	namespace:itpp
itpp::Data_Event	/usr/include/itpp/protocol/events.h	/^template <class ObjectType, class DataType> class Data_Event : public Base_Event$/;"	c	namespace:itpp	inherits:Base_Event
itpp::Data_Event::Data_Event	/usr/include/itpp/protocol/events.h	/^  Data_Event(ObjectType *object_pointer,$/;"	f	class:itpp::Data_Event	access:public	signature:(ObjectType *object_pointer, void (ObjectType::*object_function_pointer)(DataType data), DataType data, const Ttype delta_time)
itpp::Data_Event::exec	/usr/include/itpp/protocol/events.h	/^  virtual void exec(void) {$/;"	f	class:itpp::Data_Event	access:public	signature:(void)
itpp::Data_Event::pm	/usr/include/itpp/protocol/events.h	/^  void (ObjectType::*pm)(DataType data); \/\/ Pointer to class member function to be executed on event expire.$/;"	m	class:itpp::Data_Event	access:private
itpp::Data_Event::po	/usr/include/itpp/protocol/events.h	/^  ObjectType* po; \/\/ Pointer to object who's member function is to be executed on event expire.$/;"	m	class:itpp::Data_Event	access:private
itpp::Data_Event::u	/usr/include/itpp/protocol/events.h	/^  DataType u; \/\/ User data.$/;"	m	class:itpp::Data_Event	access:private
itpp::Data_Event::~Data_Event	/usr/include/itpp/protocol/events.h	/^  virtual ~Data_Event() {}$/;"	f	class:itpp::Data_Event	access:public	signature:()
itpp::Dummy_Code	/usr/include/itpp/comm/channel_code.h	/^class Dummy_Code : public Channel_Code$/;"	c	namespace:itpp	inherits:Channel_Code
itpp::Dummy_Code::Dummy_Code	/usr/include/itpp/comm/channel_code.h	/^  Dummy_Code() {}$/;"	f	class:itpp::Dummy_Code	access:public	signature:()
itpp::Dummy_Code::decode	/usr/include/itpp/comm/channel_code.h	/^  virtual bvec decode(const bvec &coded_bits) { return coded_bits; }$/;"	f	class:itpp::Dummy_Code	access:public	signature:(const bvec &coded_bits)
itpp::Dummy_Code::decode	/usr/include/itpp/comm/channel_code.h	/^  virtual bvec decode(const vec &received_signal) { bvec out; decode(received_signal, out); return out; }$/;"	f	class:itpp::Dummy_Code	access:public	signature:(const vec &received_signal)
itpp::Dummy_Code::decode	/usr/include/itpp/comm/channel_code.h	/^  virtual void decode(const bvec &coded_bits, bvec &decoded_bits) { decoded_bits = coded_bits; }$/;"	f	class:itpp::Dummy_Code	access:public	signature:(const bvec &coded_bits, bvec &decoded_bits)
itpp::Dummy_Code::decode	/usr/include/itpp/comm/channel_code.h	/^  virtual void decode(const vec &received_signal, bvec &decoded_bits) { BPSK bpsk; bpsk.demodulate_bits(received_signal, decoded_bits); }$/;"	f	class:itpp::Dummy_Code	access:public	signature:(const vec &received_signal, bvec &decoded_bits)
itpp::Dummy_Code::encode	/usr/include/itpp/comm/channel_code.h	/^  virtual bvec encode(const bvec &uncoded_bits) { return uncoded_bits; }$/;"	f	class:itpp::Dummy_Code	access:public	signature:(const bvec &uncoded_bits)
itpp::Dummy_Code::encode	/usr/include/itpp/comm/channel_code.h	/^  virtual void encode(const bvec &uncoded_bits, bvec &coded_bits) { coded_bits = uncoded_bits; }$/;"	f	class:itpp::Dummy_Code	access:public	signature:(const bvec &uncoded_bits, bvec &coded_bits)
itpp::Dummy_Code::get_rate	/usr/include/itpp/comm/channel_code.h	/^  virtual double get_rate() const { return 1.0; }$/;"	f	class:itpp::Dummy_Code	access:public	signature:() const
itpp::Dummy_Code::~Dummy_Code	/usr/include/itpp/comm/channel_code.h	/^  virtual ~Dummy_Code() {}$/;"	f	class:itpp::Dummy_Code	access:public	signature:()
itpp::Event	/usr/include/itpp/protocol/events.h	/^class Event : public Base_Event$/;"	c	namespace:itpp	inherits:Base_Event
itpp::Event::Event	/usr/include/itpp/protocol/events.h	/^  Event(ObjectType *object_pointer, void (ObjectType::*object_function_pointer)(), const Ttype delta_time) : Base_Event(delta_time) {$/;"	f	class:itpp::Event	access:public	signature:(ObjectType *object_pointer, void (ObjectType::*object_function_pointer)(), const Ttype delta_time)
itpp::Event::exec	/usr/include/itpp/protocol/events.h	/^  virtual void exec(void) {(*po.*pm)(); }$/;"	f	class:itpp::Event	access:public	signature:(void)
itpp::Event::pm	/usr/include/itpp/protocol/events.h	/^  void (ObjectType::*pm)(); \/\/ Pointer to class member function to be executed on event expire.$/;"	m	class:itpp::Event	access:private
itpp::Event::po	/usr/include/itpp/protocol/events.h	/^  ObjectType *po; \/\/ Pointer to object who's member function is to be executed on event expire.$/;"	m	class:itpp::Event	access:private
itpp::Event::~Event	/usr/include/itpp/protocol/events.h	/^  virtual ~Event() {}$/;"	f	class:itpp::Event	access:public	signature:()
itpp::Event_Queue	/usr/include/itpp/protocol/events.h	/^class Event_Queue$/;"	c	namespace:itpp
itpp::Event_Queue::Base_Event_Iterator	/usr/include/itpp/protocol/events.h	/^  typedef std::deque<Base_Event*, std::allocator< Base_Event* > >::iterator Base_Event_Iterator;$/;"	t	class:itpp::Event_Queue	access:private
itpp::Event_Queue::Event_Queue	/usr/include/itpp/protocol/events.h	/^  Event_Queue() {}$/;"	f	class:itpp::Event_Queue	access:public	signature:()
itpp::Event_Queue::_run	/usr/include/itpp/protocol/events.h	/^  static void _run();$/;"	p	class:itpp::Event_Queue	access:private	signature:()
itpp::Event_Queue::add	/usr/include/itpp/protocol/events.h	/^  static void add(Base_Event *e);$/;"	p	class:itpp::Event_Queue	access:public	signature:(Base_Event *e)
itpp::Event_Queue::clear	/usr/include/itpp/protocol/events.h	/^  static void clear();$/;"	p	class:itpp::Event_Queue	access:public	signature:()
itpp::Event_Queue::event_queue	/usr/include/itpp/protocol/events.h	/^  Compare_Base_Event_Times > event_queue; \/\/ Queue for the Events.$/;"	m	class:itpp::Event_Queue	access:private
itpp::Event_Queue::keep_running	/usr/include/itpp/protocol/events.h	/^  static bool keep_running;$/;"	m	class:itpp::Event_Queue	access:private
itpp::Event_Queue::now	/usr/include/itpp/protocol/events.h	/^  static Ttype now() {return t;}$/;"	f	class:itpp::Event_Queue	access:public	signature:()
itpp::Event_Queue::start	/usr/include/itpp/protocol/events.h	/^  static void start();$/;"	p	class:itpp::Event_Queue	access:public	signature:()
itpp::Event_Queue::stop	/usr/include/itpp/protocol/events.h	/^  static void stop();$/;"	p	class:itpp::Event_Queue	access:public	signature:()
itpp::Event_Queue::t	/usr/include/itpp/protocol/events.h	/^  static Ttype t; \/\/ Current time.$/;"	m	class:itpp::Event_Queue	access:private
itpp::Event_Queue::~Event_Queue	/usr/include/itpp/protocol/events.h	/^  ~Event_Queue() {}$/;"	f	class:itpp::Event_Queue	access:public	signature:()
itpp::Exact	/usr/include/itpp/optim/newton_search.h	/^enum Line_Search_Method {Soft, Exact};$/;"	e	enum:itpp::Line_Search_Method
itpp::Exponential_RNG	/usr/include/itpp/base/random.h	/^class Exponential_RNG$/;"	c	namespace:itpp
itpp::Exponential_RNG::Exponential_RNG	/usr/include/itpp/base/random.h	/^  Exponential_RNG(double lambda = 1.0);$/;"	p	class:itpp::Exponential_RNG	access:public	signature:(double lambda = 1.0)
itpp::Exponential_RNG::RNG	/usr/include/itpp/base/random.h	/^  Random_Generator RNG;$/;"	m	class:itpp::Exponential_RNG	access:private
itpp::Exponential_RNG::get_setup	/usr/include/itpp/base/random.h	/^  double get_setup() const;$/;"	p	class:itpp::Exponential_RNG	access:public	signature:() const
itpp::Exponential_RNG::l	/usr/include/itpp/base/random.h	/^  double l;$/;"	m	class:itpp::Exponential_RNG	access:private
itpp::Exponential_RNG::operator ()	/usr/include/itpp/base/random.h	/^  double operator()() { return sample(); }$/;"	f	class:itpp::Exponential_RNG	access:public	signature:()
itpp::Exponential_RNG::operator ()	/usr/include/itpp/base/random.h	/^  mat operator()(int h, int w);$/;"	p	class:itpp::Exponential_RNG	access:public	signature:(int h, int w)
itpp::Exponential_RNG::operator ()	/usr/include/itpp/base/random.h	/^  vec operator()(int n);$/;"	p	class:itpp::Exponential_RNG	access:public	signature:(int n)
itpp::Exponential_RNG::sample	/usr/include/itpp/base/random.h	/^  double sample() {  return (-std::log(RNG.random_01()) \/ l); }$/;"	f	class:itpp::Exponential_RNG	access:private	signature:()
itpp::Exponential_RNG::setup	/usr/include/itpp/base/random.h	/^  void setup(double lambda) { l = lambda; }$/;"	f	class:itpp::Exponential_RNG	access:public	signature:(double lambda)
itpp::Extended_Golay	/usr/include/itpp/comm/egolay.h	/^class Extended_Golay : public Channel_Code$/;"	c	namespace:itpp	inherits:Channel_Code
itpp::Extended_Golay::B	/usr/include/itpp/comm/egolay.h	/^  bmat B, G;$/;"	m	class:itpp::Extended_Golay	access:private
itpp::Extended_Golay::Extended_Golay	/usr/include/itpp/comm/egolay.h	/^  Extended_Golay();$/;"	p	class:itpp::Extended_Golay	access:public	signature:()
itpp::Extended_Golay::G	/usr/include/itpp/comm/egolay.h	/^  bmat B, G;$/;"	m	class:itpp::Extended_Golay	access:private
itpp::Extended_Golay::decode	/usr/include/itpp/comm/egolay.h	/^  virtual bvec decode(const bvec &coded_bits);$/;"	p	class:itpp::Extended_Golay	access:public	signature:(const bvec &coded_bits)
itpp::Extended_Golay::decode	/usr/include/itpp/comm/egolay.h	/^  virtual bvec decode(const vec &received_signal);$/;"	p	class:itpp::Extended_Golay	access:public	signature:(const vec &received_signal)
itpp::Extended_Golay::decode	/usr/include/itpp/comm/egolay.h	/^  virtual void decode(const bvec &coded_bits, bvec &decoded_bits);$/;"	p	class:itpp::Extended_Golay	access:public	signature:(const bvec &coded_bits, bvec &decoded_bits)
itpp::Extended_Golay::decode	/usr/include/itpp/comm/egolay.h	/^  virtual void decode(const vec &received_signal, bvec &output);$/;"	p	class:itpp::Extended_Golay	access:public	signature:(const vec &received_signal, bvec &output)
itpp::Extended_Golay::encode	/usr/include/itpp/comm/egolay.h	/^  virtual bvec encode(const bvec &uncoded_bits);$/;"	p	class:itpp::Extended_Golay	access:public	signature:(const bvec &uncoded_bits)
itpp::Extended_Golay::encode	/usr/include/itpp/comm/egolay.h	/^  virtual void encode(const bvec &uncoded_bits, bvec &coded_bits);$/;"	p	class:itpp::Extended_Golay	access:public	signature:(const bvec &uncoded_bits, bvec &coded_bits)
itpp::Extended_Golay::get_G	/usr/include/itpp/comm/egolay.h	/^  bmat get_G() const { return G; }$/;"	f	class:itpp::Extended_Golay	access:public	signature:() const
itpp::Extended_Golay::get_rate	/usr/include/itpp/comm/egolay.h	/^  virtual double get_rate() const { return 0.5; };$/;"	f	class:itpp::Extended_Golay	access:public	signature:() const
itpp::Extended_Golay::~Extended_Golay	/usr/include/itpp/comm/egolay.h	/^  virtual ~Extended_Golay() { }$/;"	f	class:itpp::Extended_Golay	access:public	signature:()
itpp::FADING_TYPE	/usr/include/itpp/comm/channel.h	/^enum FADING_TYPE { Independent, Static, Correlated };$/;"	g	namespace:itpp
itpp::FIR	/usr/include/itpp/comm/channel.h	/^enum CORRELATED_METHOD { Rice_MEDS, IFFT, FIR };$/;"	e	enum:itpp::CORRELATED_METHOD
itpp::FIR_Fading_Generator	/usr/include/itpp/comm/channel.h	/^class FIR_Fading_Generator : public Correlated_Fading_Generator$/;"	c	namespace:itpp	inherits:Correlated_Fading_Generator
itpp::FIR_Fading_Generator::FIR_Fading_Generator	/usr/include/itpp/comm/channel.h	/^  FIR_Fading_Generator(double norm_doppler, int filter_length = 500);$/;"	p	class:itpp::FIR_Fading_Generator	access:public	signature:(double norm_doppler, int filter_length = 500)
itpp::FIR_Fading_Generator::Jakes_filter	/usr/include/itpp/comm/channel.h	/^  vec Jakes_filter(double norm_dopp, int order = 100);$/;"	p	class:itpp::FIR_Fading_Generator	access:protected	signature:(double norm_dopp, int order = 100)
itpp::FIR_Fading_Generator::fir_filter	/usr/include/itpp/comm/channel.h	/^  MA_Filter<std::complex<double>, double, std::complex<double> > fir_filter;$/;"	m	class:itpp::FIR_Fading_Generator	access:protected
itpp::FIR_Fading_Generator::fir_length	/usr/include/itpp/comm/channel.h	/^  int fir_length; \/\/!< Size of FIR filter$/;"	m	class:itpp::FIR_Fading_Generator	access:protected
itpp::FIR_Fading_Generator::generate	/usr/include/itpp/comm/channel.h	/^  virtual void generate(int no_samples, cvec &output);$/;"	p	class:itpp::FIR_Fading_Generator	access:public	signature:(int no_samples, cvec &output)
itpp::FIR_Fading_Generator::get_filter_length	/usr/include/itpp/comm/channel.h	/^  virtual int get_filter_length() const { return fir_length; }$/;"	f	class:itpp::FIR_Fading_Generator	access:public	signature:() const
itpp::FIR_Fading_Generator::init	/usr/include/itpp/comm/channel.h	/^  virtual void init();$/;"	p	class:itpp::FIR_Fading_Generator	access:public	signature:()
itpp::FIR_Fading_Generator::left_overs	/usr/include/itpp/comm/channel.h	/^  cvec left_overs; \/\/!< Left-overs from upsampling$/;"	m	class:itpp::FIR_Fading_Generator	access:protected
itpp::FIR_Fading_Generator::set_filter_length	/usr/include/itpp/comm/channel.h	/^  virtual void set_filter_length(int filter_length);$/;"	p	class:itpp::FIR_Fading_Generator	access:public	signature:(int filter_length)
itpp::FIR_Fading_Generator::upsample_rate	/usr/include/itpp/comm/channel.h	/^  int upsample_rate; \/\/!< Upsampling rate for linear interpolation$/;"	m	class:itpp::FIR_Fading_Generator	access:protected
itpp::FIR_Fading_Generator::~FIR_Fading_Generator	/usr/include/itpp/comm/channel.h	/^  virtual ~FIR_Fading_Generator() {}$/;"	f	class:itpp::FIR_Fading_Generator	access:public	signature:()
itpp::Factory	/usr/include/itpp/base/factory.h	/^class Factory$/;"	c	namespace:itpp
itpp::Factory::Factory	/usr/include/itpp/base/factory.h	/^  Factory() {}$/;"	f	class:itpp::Factory	access:public	signature:()
itpp::Factory::~Factory	/usr/include/itpp/base/factory.h	/^  virtual ~Factory() {}$/;"	f	class:itpp::Factory	access:public	signature:()
itpp::Fading_Generator	/usr/include/itpp/comm/channel.h	/^class Fading_Generator$/;"	c	namespace:itpp
itpp::Fading_Generator::Fading_Generator	/usr/include/itpp/comm/channel.h	/^  Fading_Generator();$/;"	p	class:itpp::Fading_Generator	access:public	signature:()
itpp::Fading_Generator::generate	/usr/include/itpp/comm/channel.h	/^  cvec generate(int no_samples);$/;"	p	class:itpp::Fading_Generator	access:public	signature:(int no_samples)
itpp::Fading_Generator::generate	/usr/include/itpp/comm/channel.h	/^  virtual void generate(int no_samples, cvec &output) = 0;$/;"	p	class:itpp::Fading_Generator	access:public	signature:(int no_samples, cvec &output)
itpp::Fading_Generator::get_LOS_doppler	/usr/include/itpp/comm/channel.h	/^  virtual double get_LOS_doppler() const;$/;"	p	class:itpp::Fading_Generator	access:public	signature:() const
itpp::Fading_Generator::get_LOS_power	/usr/include/itpp/comm/channel.h	/^  double get_LOS_power() const { return los_power; }$/;"	f	class:itpp::Fading_Generator	access:public	signature:() const
itpp::Fading_Generator::get_doppler_spectrum	/usr/include/itpp/comm/channel.h	/^  virtual DOPPLER_SPECTRUM get_doppler_spectrum() const;$/;"	p	class:itpp::Fading_Generator	access:public	signature:() const
itpp::Fading_Generator::get_filter_length	/usr/include/itpp/comm/channel.h	/^  virtual int get_filter_length() const;$/;"	p	class:itpp::Fading_Generator	access:public	signature:() const
itpp::Fading_Generator::get_no_frequencies	/usr/include/itpp/comm/channel.h	/^  virtual int get_no_frequencies() const;$/;"	p	class:itpp::Fading_Generator	access:public	signature:() const
itpp::Fading_Generator::get_norm_doppler	/usr/include/itpp/comm/channel.h	/^  virtual double get_norm_doppler() const;$/;"	p	class:itpp::Fading_Generator	access:public	signature:() const
itpp::Fading_Generator::get_rice_method	/usr/include/itpp/comm/channel.h	/^  virtual RICE_METHOD get_rice_method() const;$/;"	p	class:itpp::Fading_Generator	access:public	signature:() const
itpp::Fading_Generator::get_time_offset	/usr/include/itpp/comm/channel.h	/^  virtual double get_time_offset() const;$/;"	p	class:itpp::Fading_Generator	access:public	signature:() const
itpp::Fading_Generator::init	/usr/include/itpp/comm/channel.h	/^  virtual void init() = 0;$/;"	p	class:itpp::Fading_Generator	access:public	signature:()
itpp::Fading_Generator::init_flag	/usr/include/itpp/comm/channel.h	/^  bool init_flag; \/\/!< signals if generator is initialized or not$/;"	m	class:itpp::Fading_Generator	access:protected
itpp::Fading_Generator::los_diffuse	/usr/include/itpp/comm/channel.h	/^  double los_diffuse; \/\/!< Diffuse component: sqrt(1 \/ (1 + los_power))$/;"	m	class:itpp::Fading_Generator	access:protected
itpp::Fading_Generator::los_direct	/usr/include/itpp/comm/channel.h	/^  double los_direct; \/\/!< Direct component: sqrt(los_power \/ (1 + los_power))$/;"	m	class:itpp::Fading_Generator	access:protected
itpp::Fading_Generator::los_power	/usr/include/itpp/comm/channel.h	/^  double los_power; \/\/!< Relative power of LOS component compared to diffuse component (K factor)$/;"	m	class:itpp::Fading_Generator	access:protected
itpp::Fading_Generator::set_LOS_doppler	/usr/include/itpp/comm/channel.h	/^  virtual void set_LOS_doppler(double relative_doppler);$/;"	p	class:itpp::Fading_Generator	access:public	signature:(double relative_doppler)
itpp::Fading_Generator::set_LOS_power	/usr/include/itpp/comm/channel.h	/^  void set_LOS_power(double relative_power);$/;"	p	class:itpp::Fading_Generator	access:public	signature:(double relative_power)
itpp::Fading_Generator::set_doppler_spectrum	/usr/include/itpp/comm/channel.h	/^  virtual void set_doppler_spectrum(DOPPLER_SPECTRUM spectrum);$/;"	p	class:itpp::Fading_Generator	access:public	signature:(DOPPLER_SPECTRUM spectrum)
itpp::Fading_Generator::set_filter_length	/usr/include/itpp/comm/channel.h	/^  virtual void set_filter_length(int filter_length);$/;"	p	class:itpp::Fading_Generator	access:public	signature:(int filter_length)
itpp::Fading_Generator::set_no_frequencies	/usr/include/itpp/comm/channel.h	/^  virtual void set_no_frequencies(int no_freq);$/;"	p	class:itpp::Fading_Generator	access:public	signature:(int no_freq)
itpp::Fading_Generator::set_norm_doppler	/usr/include/itpp/comm/channel.h	/^  virtual void set_norm_doppler(double norm_doppler);$/;"	p	class:itpp::Fading_Generator	access:public	signature:(double norm_doppler)
itpp::Fading_Generator::set_rice_method	/usr/include/itpp/comm/channel.h	/^  virtual void set_rice_method(RICE_METHOD method);$/;"	p	class:itpp::Fading_Generator	access:public	signature:(RICE_METHOD method)
itpp::Fading_Generator::set_time_offset	/usr/include/itpp/comm/channel.h	/^  virtual void set_time_offset(int offset);$/;"	p	class:itpp::Fading_Generator	access:public	signature:(int offset)
itpp::Fading_Generator::shift_time_offset	/usr/include/itpp/comm/channel.h	/^  virtual void shift_time_offset(int no_samples);$/;"	p	class:itpp::Fading_Generator	access:public	signature:(int no_samples)
itpp::Fading_Generator::~Fading_Generator	/usr/include/itpp/comm/channel.h	/^  virtual ~Fading_Generator() {}$/;"	f	class:itpp::Fading_Generator	access:public	signature:()
itpp::Fast_ICA	/usr/include/itpp/signal/fastica.h	/^class Fast_ICA$/;"	c	namespace:itpp
itpp::Fast_ICA::A	/usr/include/itpp/signal/fastica.h	/^  mat mixedSig, A, W, icasig;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Fast_ICA::D	/usr/include/itpp/signal/fastica.h	/^  vec D;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Fast_ICA::E	/usr/include/itpp/signal/fastica.h	/^  mat E, VecPr;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Fast_ICA::Fast_ICA	/usr/include/itpp/signal/fastica.h	/^  Fast_ICA(mat ma_mixed_sig);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(mat ma_mixed_sig)
itpp::Fast_ICA::PCAonly	/usr/include/itpp/signal/fastica.h	/^  bool finetune, stabilization, PCAonly;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Fast_ICA::VecPr	/usr/include/itpp/signal/fastica.h	/^  mat E, VecPr;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Fast_ICA::W	/usr/include/itpp/signal/fastica.h	/^  mat mixedSig, A, W, icasig;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Fast_ICA::a1	/usr/include/itpp/signal/fastica.h	/^  double a1, a2, mu, epsilon, sampleSize;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Fast_ICA::a2	/usr/include/itpp/signal/fastica.h	/^  double a1, a2, mu, epsilon, sampleSize;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Fast_ICA::approach	/usr/include/itpp/signal/fastica.h	/^  int approach, numOfIC, g, initState;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Fast_ICA::dewhiteningMatrix	/usr/include/itpp/signal/fastica.h	/^  mat dewhiteningMatrix;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Fast_ICA::epsilon	/usr/include/itpp/signal/fastica.h	/^  double a1, a2, mu, epsilon, sampleSize;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Fast_ICA::finetune	/usr/include/itpp/signal/fastica.h	/^  bool finetune, stabilization, PCAonly;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Fast_ICA::firstEig	/usr/include/itpp/signal/fastica.h	/^  int firstEig, lastEig;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Fast_ICA::g	/usr/include/itpp/signal/fastica.h	/^  int approach, numOfIC, g, initState;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Fast_ICA::get_dewhitening_matrix	/usr/include/itpp/signal/fastica.h	/^  mat get_dewhitening_matrix();$/;"	p	class:itpp::Fast_ICA	access:public	signature:()
itpp::Fast_ICA::get_independent_components	/usr/include/itpp/signal/fastica.h	/^  mat get_independent_components();$/;"	p	class:itpp::Fast_ICA	access:public	signature:()
itpp::Fast_ICA::get_mixing_matrix	/usr/include/itpp/signal/fastica.h	/^  mat get_mixing_matrix();$/;"	p	class:itpp::Fast_ICA	access:public	signature:()
itpp::Fast_ICA::get_nrof_independent_components	/usr/include/itpp/signal/fastica.h	/^  int get_nrof_independent_components();$/;"	p	class:itpp::Fast_ICA	access:public	signature:()
itpp::Fast_ICA::get_principal_eigenvectors	/usr/include/itpp/signal/fastica.h	/^  mat get_principal_eigenvectors();$/;"	p	class:itpp::Fast_ICA	access:public	signature:()
itpp::Fast_ICA::get_separating_matrix	/usr/include/itpp/signal/fastica.h	/^  mat get_separating_matrix();$/;"	p	class:itpp::Fast_ICA	access:public	signature:()
itpp::Fast_ICA::get_white_sig	/usr/include/itpp/signal/fastica.h	/^  mat get_white_sig();$/;"	p	class:itpp::Fast_ICA	access:public	signature:()
itpp::Fast_ICA::get_whitening_matrix	/usr/include/itpp/signal/fastica.h	/^  mat get_whitening_matrix();$/;"	p	class:itpp::Fast_ICA	access:public	signature:()
itpp::Fast_ICA::icasig	/usr/include/itpp/signal/fastica.h	/^  mat mixedSig, A, W, icasig;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Fast_ICA::initGuess	/usr/include/itpp/signal/fastica.h	/^  mat initGuess;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Fast_ICA::initState	/usr/include/itpp/signal/fastica.h	/^  int approach, numOfIC, g, initState;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Fast_ICA::lastEig	/usr/include/itpp/signal/fastica.h	/^  int firstEig, lastEig;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Fast_ICA::maxFineTune	/usr/include/itpp/signal/fastica.h	/^  int maxNumIterations, maxFineTune;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Fast_ICA::maxNumIterations	/usr/include/itpp/signal/fastica.h	/^  int maxNumIterations, maxFineTune;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Fast_ICA::mixedSig	/usr/include/itpp/signal/fastica.h	/^  mat mixedSig, A, W, icasig;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Fast_ICA::mu	/usr/include/itpp/signal/fastica.h	/^  double a1, a2, mu, epsilon, sampleSize;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Fast_ICA::numOfIC	/usr/include/itpp/signal/fastica.h	/^  int approach, numOfIC, g, initState;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Fast_ICA::sampleSize	/usr/include/itpp/signal/fastica.h	/^  double a1, a2, mu, epsilon, sampleSize;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Fast_ICA::separate	/usr/include/itpp/signal/fastica.h	/^  void separate(void);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(void)
itpp::Fast_ICA::set_a1	/usr/include/itpp/signal/fastica.h	/^  void set_a1(double fl_a1);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(double fl_a1)
itpp::Fast_ICA::set_a2	/usr/include/itpp/signal/fastica.h	/^  void set_a2(double fl_a2);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(double fl_a2)
itpp::Fast_ICA::set_approach	/usr/include/itpp/signal/fastica.h	/^  void set_approach(int in_approach);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(int in_approach)
itpp::Fast_ICA::set_epsilon	/usr/include/itpp/signal/fastica.h	/^  void set_epsilon(double fl_epsilon);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(double fl_epsilon)
itpp::Fast_ICA::set_fine_tune	/usr/include/itpp/signal/fastica.h	/^  void set_fine_tune(bool in_finetune);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(bool in_finetune)
itpp::Fast_ICA::set_first_eig	/usr/include/itpp/signal/fastica.h	/^  void set_first_eig(int in_firstEig);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(int in_firstEig)
itpp::Fast_ICA::set_init_guess	/usr/include/itpp/signal/fastica.h	/^  void set_init_guess(mat ma_initGuess);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(mat ma_initGuess)
itpp::Fast_ICA::set_last_eig	/usr/include/itpp/signal/fastica.h	/^  void set_last_eig(int in_lastEig);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(int in_lastEig)
itpp::Fast_ICA::set_max_fine_tune	/usr/include/itpp/signal/fastica.h	/^  void set_max_fine_tune(int in_maxFineTune);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(int in_maxFineTune)
itpp::Fast_ICA::set_max_num_iterations	/usr/include/itpp/signal/fastica.h	/^  void set_max_num_iterations(int in_maxNumIterations);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(int in_maxNumIterations)
itpp::Fast_ICA::set_mu	/usr/include/itpp/signal/fastica.h	/^  void set_mu(double fl_mu);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(double fl_mu)
itpp::Fast_ICA::set_non_linearity	/usr/include/itpp/signal/fastica.h	/^  void set_non_linearity(int in_g);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(int in_g)
itpp::Fast_ICA::set_nrof_independent_components	/usr/include/itpp/signal/fastica.h	/^  void set_nrof_independent_components(int in_nrIC);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(int in_nrIC)
itpp::Fast_ICA::set_pca_only	/usr/include/itpp/signal/fastica.h	/^  void set_pca_only(bool in_PCAonly);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(bool in_PCAonly)
itpp::Fast_ICA::set_sample_size	/usr/include/itpp/signal/fastica.h	/^  void set_sample_size(double fl_sampleSize);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(double fl_sampleSize)
itpp::Fast_ICA::set_stabilization	/usr/include/itpp/signal/fastica.h	/^  void set_stabilization(bool in_stabilization);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(bool in_stabilization)
itpp::Fast_ICA::stabilization	/usr/include/itpp/signal/fastica.h	/^  bool finetune, stabilization, PCAonly;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Fast_ICA::whiteningMatrix	/usr/include/itpp/signal/fastica.h	/^  mat whiteningMatrix;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Fast_ICA::whitesig	/usr/include/itpp/signal/fastica.h	/^  mat whitesig;$/;"	m	class:itpp::Fast_ICA	access:private
itpp::Filter	/usr/include/itpp/signal/filter.h	/^class Filter$/;"	c	namespace:itpp
itpp::Filter::Filter	/usr/include/itpp/signal/filter.h	/^  Filter() {}$/;"	f	class:itpp::Filter	access:public	signature:()
itpp::Filter::filter	/usr/include/itpp/signal/filter.h	/^  virtual T3 filter(const T1 Sample) = 0;$/;"	p	class:itpp::Filter	access:protected	signature:(const T1 Sample)
itpp::Filter::operator ()	/usr/include/itpp/signal/filter.h	/^  virtual T3 operator()(const T1 Sample) { return filter(Sample); }$/;"	f	class:itpp::Filter	access:public	signature:(const T1 Sample)
itpp::Filter::operator ()	/usr/include/itpp/signal/filter.h	/^  virtual Vec<T3> operator()(const Vec<T1> &v);$/;"	p	class:itpp::Filter	access:public	signature:(const Vec<T1> &v)
itpp::Filter::operator ()	/usr/include/itpp/signal/filter.h	/^Vec<T3> Filter<T1, T2, T3>::operator()(const Vec<T1> &x)$/;"	f	class:itpp::Filter	signature:(const Vec<T1> &x)
itpp::Filter::~Filter	/usr/include/itpp/signal/filter.h	/^  virtual ~Filter() {}$/;"	f	class:itpp::Filter	access:public	signature:()
itpp::Fix	/usr/include/itpp/fixed/fix.h	/^class Fix : public Fix_Base$/;"	c	namespace:itpp	inherits:Fix_Base
itpp::Fix::Fix	/usr/include/itpp/fixed/fix.h	/^  Fix(const Fix &x, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)$/;"	f	class:itpp::Fix	access:public	signature:(const Fix &x, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)
itpp::Fix::Fix	/usr/include/itpp/fixed/fix.h	/^  Fix(double x = 0.0, int s = 0, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)$/;"	f	class:itpp::Fix	access:public	signature:(double x = 0.0, int s = 0, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)
itpp::Fix::Fix	/usr/include/itpp/fixed/fix.h	/^  Fix(fixrep r, int s, int, int)$/;"	f	class:itpp::Fix	access:public	signature:(fixrep r, int s, int, int)
itpp::Fix::Fix	/usr/include/itpp/fixed/fix.h	/^  explicit Fix(const Fix_Factory &f)$/;"	f	class:itpp::Fix	access:public	signature:(const Fix_Factory &f)
itpp::Fix::assert_shifts	/usr/include/itpp/fixed/fix.h	/^  friend int assert_shifts(const CFix &x, const Fix &y);$/;"	p	class:itpp::Fix	access:friend	signature:(const CFix &x, const Fix &y)
itpp::Fix::assert_shifts	/usr/include/itpp/fixed/fix.h	/^  friend int assert_shifts(const Fix &x, const Fix &y);$/;"	p	class:itpp::Fix	access:friend	signature:(const Fix &x, const Fix &y)
itpp::Fix::assert_shifts	/usr/include/itpp/fixed/fix.h	/^  friend int assert_shifts(const Fix &x, int y);$/;"	p	class:itpp::Fix	access:friend	signature:(const Fix &x, int y)
itpp::Fix::get_re	/usr/include/itpp/fixed/fix.h	/^  fixrep get_re() const {return re;}$/;"	f	class:itpp::Fix	access:public	signature:() const
itpp::Fix::lshift	/usr/include/itpp/fixed/fix.h	/^  void lshift(int n);$/;"	p	class:itpp::Fix	access:public	signature:(int n)
itpp::Fix::operator *=	/usr/include/itpp/fixed/fix.h	/^  Fix& operator*=(const Fix &x);$/;"	p	class:itpp::Fix	access:public	signature:(const Fix &x)
itpp::Fix::operator *=	/usr/include/itpp/fixed/fix.h	/^  Fix& operator*=(const int x);$/;"	p	class:itpp::Fix	access:public	signature:(const int x)
itpp::Fix::operator +=	/usr/include/itpp/fixed/fix.h	/^  Fix& operator+=(const Fix &x);$/;"	p	class:itpp::Fix	access:public	signature:(const Fix &x)
itpp::Fix::operator +=	/usr/include/itpp/fixed/fix.h	/^  Fix& operator+=(const int x);$/;"	p	class:itpp::Fix	access:public	signature:(const int x)
itpp::Fix::operator -	/usr/include/itpp/fixed/fix.h	/^  Fix operator-() const;$/;"	p	class:itpp::Fix	access:public	signature:() const
itpp::Fix::operator -=	/usr/include/itpp/fixed/fix.h	/^  Fix& operator-=(const Fix &x);$/;"	p	class:itpp::Fix	access:public	signature:(const Fix &x)
itpp::Fix::operator -=	/usr/include/itpp/fixed/fix.h	/^  Fix& operator-=(const int x);$/;"	p	class:itpp::Fix	access:public	signature:(const int x)
itpp::Fix::operator /=	/usr/include/itpp/fixed/fix.h	/^  Fix& operator\/=(const Fix &x);$/;"	p	class:itpp::Fix	access:public	signature:(const Fix &x)
itpp::Fix::operator /=	/usr/include/itpp/fixed/fix.h	/^  Fix& operator\/=(const int x);$/;"	p	class:itpp::Fix	access:public	signature:(const int x)
itpp::Fix::operator <<=	/usr/include/itpp/fixed/fix.h	/^  Fix& operator<<=(const int n);$/;"	p	class:itpp::Fix	access:public	signature:(const int n)
itpp::Fix::operator =	/usr/include/itpp/fixed/fix.h	/^  Fix& operator=(const Fix &x);$/;"	p	class:itpp::Fix	access:public	signature:(const Fix &x)
itpp::Fix::operator =	/usr/include/itpp/fixed/fix.h	/^  Fix& operator=(const int x);$/;"	p	class:itpp::Fix	access:public	signature:(const int x)
itpp::Fix::operator >>=	/usr/include/itpp/fixed/fix.h	/^  Fix& operator>>=(const int n);$/;"	p	class:itpp::Fix	access:public	signature:(const int n)
itpp::Fix::operator double	/usr/include/itpp/fixed/fix.h	/^  operator double() const {$/;"	f	class:itpp::Fix	access:public	signature:() const
itpp::Fix::print	/usr/include/itpp/fixed/fix.h	/^  virtual void print() const;$/;"	p	class:itpp::Fix	access:public	signature:() const
itpp::Fix::re	/usr/include/itpp/fixed/fix.h	/^  fixrep re;$/;"	m	class:itpp::Fix	access:protected
itpp::Fix::rshift	/usr/include/itpp/fixed/fix.h	/^  void rshift(int n);$/;"	p	class:itpp::Fix	access:public	signature:(int n)
itpp::Fix::rshift	/usr/include/itpp/fixed/fix.h	/^  void rshift(int n, q_mode q);$/;"	p	class:itpp::Fix	access:public	signature:(int n, q_mode q)
itpp::Fix::set	/usr/include/itpp/fixed/fix.h	/^  void set(double x, int n);$/;"	p	class:itpp::Fix	access:public	signature:(double x, int n)
itpp::Fix::set	/usr/include/itpp/fixed/fix.h	/^  void set(double x, int n, q_mode q);$/;"	p	class:itpp::Fix	access:public	signature:(double x, int n, q_mode q)
itpp::Fix::set_re	/usr/include/itpp/fixed/fix.h	/^  void set_re(fixrep x) {re = apply_o_mode(x);}$/;"	f	class:itpp::Fix	access:public	signature:(fixrep x)
itpp::Fix::unfix	/usr/include/itpp/fixed/fix.h	/^  double unfix() const;$/;"	p	class:itpp::Fix	access:public	signature:() const
itpp::Fix::~Fix	/usr/include/itpp/fixed/fix.h	/^  virtual ~Fix() {}$/;"	f	class:itpp::Fix	access:public	signature:()
itpp::Fix_Base	/usr/include/itpp/fixed/fix_base.h	/^class Fix_Base$/;"	c	namespace:itpp
itpp::Fix_Base::Fix_Base	/usr/include/itpp/fixed/fix_base.h	/^  Fix_Base(const Fix_Base &x)$/;"	f	class:itpp::Fix_Base	access:public	signature:(const Fix_Base &x)
itpp::Fix_Base::Fix_Base	/usr/include/itpp/fixed/fix_base.h	/^  explicit Fix_Base(int s = 0, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)$/;"	f	class:itpp::Fix_Base	access:public	signature:(int s = 0, int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)
itpp::Fix_Base::apply_o_mode	/usr/include/itpp/fixed/fix_base.h	/^  fixrep apply_o_mode(fixrep x) const;$/;"	p	class:itpp::Fix_Base	access:protected	signature:(fixrep x) const
itpp::Fix_Base::emode	/usr/include/itpp/fixed/fix_base.h	/^  e_mode emode;$/;"	m	class:itpp::Fix_Base	access:protected
itpp::Fix_Base::get_e_mode	/usr/include/itpp/fixed/fix_base.h	/^  e_mode get_e_mode() const {return emode;}$/;"	f	class:itpp::Fix_Base	access:public	signature:() const
itpp::Fix_Base::get_max	/usr/include/itpp/fixed/fix_base.h	/^  fixrep get_max() const {return max;}$/;"	f	class:itpp::Fix_Base	access:public	signature:() const
itpp::Fix_Base::get_min	/usr/include/itpp/fixed/fix_base.h	/^  fixrep get_min() const {return min;}$/;"	f	class:itpp::Fix_Base	access:public	signature:() const
itpp::Fix_Base::get_o_mode	/usr/include/itpp/fixed/fix_base.h	/^  o_mode get_o_mode() const {return omode;}$/;"	f	class:itpp::Fix_Base	access:public	signature:() const
itpp::Fix_Base::get_output_mode	/usr/include/itpp/fixed/fix_base.h	/^  output_mode get_output_mode() const {return outputmode;}$/;"	f	class:itpp::Fix_Base	access:public	signature:() const
itpp::Fix_Base::get_q_mode	/usr/include/itpp/fixed/fix_base.h	/^  q_mode get_q_mode() const {return qmode;}$/;"	f	class:itpp::Fix_Base	access:public	signature:() const
itpp::Fix_Base::get_shift	/usr/include/itpp/fixed/fix_base.h	/^  int get_shift() const {return shift;}$/;"	f	class:itpp::Fix_Base	access:public	signature:() const
itpp::Fix_Base::get_wordlen	/usr/include/itpp/fixed/fix_base.h	/^  int get_wordlen() const {return wordlen;}$/;"	f	class:itpp::Fix_Base	access:public	signature:() const
itpp::Fix_Base::init	/usr/include/itpp/fixed/fix_base.h	/^  void init();$/;"	p	class:itpp::Fix_Base	access:protected	signature:()
itpp::Fix_Base::max	/usr/include/itpp/fixed/fix_base.h	/^  fixrep max;$/;"	m	class:itpp::Fix_Base	access:protected
itpp::Fix_Base::min	/usr/include/itpp/fixed/fix_base.h	/^  fixrep min;$/;"	m	class:itpp::Fix_Base	access:protected
itpp::Fix_Base::n_unused_bits	/usr/include/itpp/fixed/fix_base.h	/^  int n_unused_bits;$/;"	m	class:itpp::Fix_Base	access:protected
itpp::Fix_Base::omode	/usr/include/itpp/fixed/fix_base.h	/^  o_mode omode;$/;"	m	class:itpp::Fix_Base	access:protected
itpp::Fix_Base::outputmode	/usr/include/itpp/fixed/fix_base.h	/^  static output_mode outputmode;$/;"	m	class:itpp::Fix_Base	access:private
itpp::Fix_Base::print	/usr/include/itpp/fixed/fix_base.h	/^  virtual void print() const;$/;"	p	class:itpp::Fix_Base	access:public	signature:() const
itpp::Fix_Base::qmode	/usr/include/itpp/fixed/fix_base.h	/^  q_mode qmode;$/;"	m	class:itpp::Fix_Base	access:protected
itpp::Fix_Base::rshift_and_apply_q_mode	/usr/include/itpp/fixed/fix_base.h	/^  fixrep rshift_and_apply_q_mode(fixrep x, int n) const {return rshift_and_apply_q_mode(x, n, qmode);}$/;"	f	class:itpp::Fix_Base	access:protected	signature:(fixrep x, int n) const
itpp::Fix_Base::rshift_and_apply_q_mode	/usr/include/itpp/fixed/fix_base.h	/^  fixrep rshift_and_apply_q_mode(fixrep x, int n, q_mode q) const;$/;"	p	class:itpp::Fix_Base	access:protected	signature:(fixrep x, int n, q_mode q) const
itpp::Fix_Base::scale_and_apply_modes	/usr/include/itpp/fixed/fix_base.h	/^  fixrep scale_and_apply_modes(double x) const {return scale_and_apply_modes(x, qmode);}$/;"	f	class:itpp::Fix_Base	access:protected	signature:(double x) const
itpp::Fix_Base::scale_and_apply_modes	/usr/include/itpp/fixed/fix_base.h	/^  fixrep scale_and_apply_modes(double x, q_mode q) const;$/;"	p	class:itpp::Fix_Base	access:protected	signature:(double x, q_mode q) const
itpp::Fix_Base::set_output_mode	/usr/include/itpp/fixed/fix_base.h	/^  static void set_output_mode(output_mode o) {outputmode = o;}$/;"	f	class:itpp::Fix_Base	access:public	signature:(output_mode o)
itpp::Fix_Base::set_output_mode	/usr/include/itpp/fixed/fix_base.h	/^  static void set_output_mode(std::string o);$/;"	p	class:itpp::Fix_Base	access:public	signature:(std::string o)
itpp::Fix_Base::set_shift	/usr/include/itpp/fixed/fix_base.h	/^  void set_shift(int s) {shift = s;}$/;"	f	class:itpp::Fix_Base	access:public	signature:(int s)
itpp::Fix_Base::shift	/usr/include/itpp/fixed/fix_base.h	/^  int shift;$/;"	m	class:itpp::Fix_Base	access:protected
itpp::Fix_Base::stat_ptr	/usr/include/itpp/fixed/fix_base.h	/^  Stat *stat_ptr;$/;"	m	class:itpp::Fix_Base	access:protected
itpp::Fix_Base::wordlen	/usr/include/itpp/fixed/fix_base.h	/^  int wordlen;$/;"	m	class:itpp::Fix_Base	access:protected
itpp::Fix_Base::~Fix_Base	/usr/include/itpp/fixed/fix_base.h	/^  virtual ~Fix_Base() {}$/;"	f	class:itpp::Fix_Base	access:public	signature:()
itpp::Fix_Factory	/usr/include/itpp/fixed/fix_factory.h	/^class Fix_Factory : public Factory$/;"	c	namespace:itpp	inherits:Factory
itpp::Fix_Factory::Fix_Factory	/usr/include/itpp/fixed/fix_factory.h	/^  explicit Fix_Factory(int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)$/;"	f	class:itpp::Fix_Factory	access:public	signature:(int w = MAX_WORDLEN, e_mode e = TC, o_mode o = WRAP, q_mode q = TRN, Stat *ptr = 0)
itpp::Fix_Factory::create	/usr/include/itpp/fixed/fix_factory.h	/^  virtual void create(CFix* &ptr, const int n) const;$/;"	p	class:itpp::Fix_Factory	access:public	signature:(CFix* &ptr, const int n) const
itpp::Fix_Factory::create	/usr/include/itpp/fixed/fix_factory.h	/^  virtual void create(Fix* &ptr, const int n) const;$/;"	p	class:itpp::Fix_Factory	access:public	signature:(Fix* &ptr, const int n) const
itpp::Fix_Factory::emode	/usr/include/itpp/fixed/fix_factory.h	/^  e_mode emode;$/;"	m	class:itpp::Fix_Factory	access:protected
itpp::Fix_Factory::omode	/usr/include/itpp/fixed/fix_factory.h	/^  o_mode omode;$/;"	m	class:itpp::Fix_Factory	access:protected
itpp::Fix_Factory::operator double	/usr/include/itpp/fixed/fix_factory.h	/^  operator double() const {return 0.0;}$/;"	f	class:itpp::Fix_Factory	access:public	signature:() const
itpp::Fix_Factory::qmode	/usr/include/itpp/fixed/fix_factory.h	/^  q_mode qmode;$/;"	m	class:itpp::Fix_Factory	access:protected
itpp::Fix_Factory::stat_ptr	/usr/include/itpp/fixed/fix_factory.h	/^  Stat *stat_ptr;$/;"	m	class:itpp::Fix_Factory	access:protected
itpp::Fix_Factory::wordlen	/usr/include/itpp/fixed/fix_factory.h	/^  int wordlen;$/;"	m	class:itpp::Fix_Factory	access:protected
itpp::Fix_Factory::~Fix_Factory	/usr/include/itpp/fixed/fix_factory.h	/^  virtual ~Fix_Factory() {}$/;"	f	class:itpp::Fix_Factory	access:public	signature:()
itpp::Fixed	/usr/include/itpp/fixed/fixed.h	/^class Fixed : public Fix$/;"	c	namespace:itpp	inherits:Fix
itpp::Fixed::Fixed	/usr/include/itpp/fixed/fixed.h	/^  Fixed(const Fix &x, Stat *ptr = 0)$/;"	f	class:itpp::Fixed	access:public	signature:(const Fix &x, Stat *ptr = 0)
itpp::Fixed::Fixed	/usr/include/itpp/fixed/fixed.h	/^  Fixed(double x = 0.0, int s = 0, Stat *ptr = 0)$/;"	f	class:itpp::Fixed	access:public	signature:(double x = 0.0, int s = 0, Stat *ptr = 0)
itpp::Fixed::Fixed	/usr/include/itpp/fixed/fixed.h	/^  explicit Fixed(Stat *ptr)$/;"	f	class:itpp::Fixed	access:public	signature:(Stat *ptr)
itpp::Fixed::operator =	/usr/include/itpp/fixed/fixed.h	/^  Fixed& operator=(const Fix &x) {$/;"	f	class:itpp::Fixed	access:public	signature:(const Fix &x)
itpp::Fixed::operator =	/usr/include/itpp/fixed/fixed.h	/^  Fixed& operator=(int x) {$/;"	f	class:itpp::Fixed	access:public	signature:(int x)
itpp::Fixed::~Fixed	/usr/include/itpp/fixed/fixed.h	/^  virtual ~Fixed() {}$/;"	f	class:itpp::Fixed	access:public	signature:()
itpp::Freq_Filt	/usr/include/itpp/signal/freq_filt.h	/^class Freq_Filt$/;"	c	namespace:itpp
itpp::Freq_Filt::B	/usr/include/itpp/signal/freq_filt.h	/^  cvec B; \/\/ FFT of impulse vector$/;"	m	class:itpp::Freq_Filt	access:private
itpp::Freq_Filt::Freq_Filt	/usr/include/itpp/signal/freq_filt.h	/^  Freq_Filt() {}$/;"	f	class:itpp::Freq_Filt	access:public	signature:()
itpp::Freq_Filt::Freq_Filt	/usr/include/itpp/signal/freq_filt.h	/^  Freq_Filt(const Vec<Num_T> &b, const int xlength) {init(b, xlength);}$/;"	f	class:itpp::Freq_Filt	access:public	signature:(const Vec<Num_T> &b, const int xlength)
itpp::Freq_Filt::blksize	/usr/include/itpp/signal/freq_filt.h	/^  int fftsize, blksize;$/;"	m	class:itpp::Freq_Filt	access:private
itpp::Freq_Filt::fftsize	/usr/include/itpp/signal/freq_filt.h	/^  int fftsize, blksize;$/;"	m	class:itpp::Freq_Filt	access:private
itpp::Freq_Filt::filter	/usr/include/itpp/signal/freq_filt.h	/^  Vec<Num_T> filter(const Vec<Num_T> &x, const int strm = 0);$/;"	p	class:itpp::Freq_Filt	access:public	signature:(const Vec<Num_T> &x, const int strm = 0)
itpp::Freq_Filt::filter	/usr/include/itpp/signal/freq_filt.h	/^Vec<Num_T> Freq_Filt<Num_T>::filter(const Vec<Num_T> &input, const int strm)$/;"	f	class:itpp::Freq_Filt	signature:(const Vec<Num_T> &input, const int strm)
itpp::Freq_Filt::get_blk_size	/usr/include/itpp/signal/freq_filt.h	/^  int get_blk_size() { return blksize; }$/;"	f	class:itpp::Freq_Filt	access:public	signature:()
itpp::Freq_Filt::get_fft_size	/usr/include/itpp/signal/freq_filt.h	/^  int get_fft_size() { return fftsize; }$/;"	f	class:itpp::Freq_Filt	access:public	signature:()
itpp::Freq_Filt::impulse	/usr/include/itpp/signal/freq_filt.h	/^  Vec<Num_T> impulse;$/;"	m	class:itpp::Freq_Filt	access:private
itpp::Freq_Filt::init	/usr/include/itpp/signal/freq_filt.h	/^  void init(const Vec<Num_T> &b, const int xlength);$/;"	p	class:itpp::Freq_Filt	access:private	signature:(const Vec<Num_T> &b, const int xlength)
itpp::Freq_Filt::init	/usr/include/itpp/signal/freq_filt.h	/^void Freq_Filt<Num_T>::init(const Vec<Num_T> &b, const int xlength)$/;"	f	class:itpp::Freq_Filt	signature:(const Vec<Num_T> &b, const int xlength)
itpp::Freq_Filt::old_data	/usr/include/itpp/signal/freq_filt.h	/^  Vec<Num_T> old_data;$/;"	m	class:itpp::Freq_Filt	access:private
itpp::Freq_Filt::overlap_add	/usr/include/itpp/signal/freq_filt.h	/^  cvec overlap_add(const cvec &x);$/;"	p	class:itpp::Freq_Filt	access:private	signature:(const cvec &x)
itpp::Freq_Filt::overlap_add	/usr/include/itpp/signal/freq_filt.h	/^  ivec overlap_add(const ivec &x);$/;"	p	class:itpp::Freq_Filt	access:private	signature:(const ivec &x)
itpp::Freq_Filt::overlap_add	/usr/include/itpp/signal/freq_filt.h	/^  svec overlap_add(const svec &x);$/;"	p	class:itpp::Freq_Filt	access:private	signature:(const svec &x)
itpp::Freq_Filt::overlap_add	/usr/include/itpp/signal/freq_filt.h	/^  vec overlap_add(const vec &x);$/;"	p	class:itpp::Freq_Filt	access:private	signature:(const vec &x)
itpp::Freq_Filt::overlap_add	/usr/include/itpp/signal/freq_filt.h	/^  void overlap_add(const cvec &x, cvec &y);$/;"	p	class:itpp::Freq_Filt	access:private	signature:(const cvec &x, cvec &y)
itpp::Freq_Filt::zfinal	/usr/include/itpp/signal/freq_filt.h	/^  cvec zfinal;$/;"	m	class:itpp::Freq_Filt	access:private
itpp::Freq_Filt::~Freq_Filt	/usr/include/itpp/signal/freq_filt.h	/^  ~Freq_Filt() {}$/;"	f	class:itpp::Freq_Filt	access:public	signature:()
itpp::Front_Drop_Queue	/usr/include/itpp/protocol/front_drop_queue.h	/^class Front_Drop_Queue : public virtual std::queue<Packet*>$/;"	c	namespace:itpp	inherits:std::queue
itpp::Front_Drop_Queue::Front_Drop_Queue	/usr/include/itpp/protocol/front_drop_queue.h	/^  Front_Drop_Queue(const int max_bytes = DEFAULT_MAX_BYTES_IN_QUEUE)  {$/;"	f	class:itpp::Front_Drop_Queue	access:public	signature:(const int max_bytes = DEFAULT_MAX_BYTES_IN_QUEUE)
itpp::Front_Drop_Queue::byte_size	/usr/include/itpp/protocol/front_drop_queue.h	/^  int byte_size() { return bytes_in_queue; }$/;"	f	class:itpp::Front_Drop_Queue	access:public	signature:()
itpp::Front_Drop_Queue::bytes_in_queue	/usr/include/itpp/protocol/front_drop_queue.h	/^  int bytes_in_queue;$/;"	m	class:itpp::Front_Drop_Queue	access:private
itpp::Front_Drop_Queue::debug	/usr/include/itpp/protocol/front_drop_queue.h	/^  int debug;$/;"	m	class:itpp::Front_Drop_Queue	access:private
itpp::Front_Drop_Queue::max_byte_size	/usr/include/itpp/protocol/front_drop_queue.h	/^  int max_byte_size() { return max_bytes_in_queue; }$/;"	f	class:itpp::Front_Drop_Queue	access:public	signature:()
itpp::Front_Drop_Queue::max_bytes_in_queue	/usr/include/itpp/protocol/front_drop_queue.h	/^  int max_bytes_in_queue;$/;"	m	class:itpp::Front_Drop_Queue	access:private
itpp::Front_Drop_Queue::pop	/usr/include/itpp/protocol/front_drop_queue.h	/^  void pop();$/;"	p	class:itpp::Front_Drop_Queue	access:public	signature:()
itpp::Front_Drop_Queue::push	/usr/include/itpp/protocol/front_drop_queue.h	/^  void push(Packet *packet);$/;"	p	class:itpp::Front_Drop_Queue	access:public	signature:(Packet *packet)
itpp::Front_Drop_Queue::set_debug	/usr/include/itpp/protocol/front_drop_queue.h	/^  void set_debug(const bool enable_debug = true) {$/;"	f	class:itpp::Front_Drop_Queue	access:public	signature:(const bool enable_debug = true)
itpp::Front_Drop_Queue::set_max_byte_size	/usr/include/itpp/protocol/front_drop_queue.h	/^  void set_max_byte_size(int max_bytes) { max_bytes_in_queue = max_bytes; }$/;"	f	class:itpp::Front_Drop_Queue	access:public	signature:(int max_bytes)
itpp::Full	/usr/include/itpp/base/itassert.h	/^enum error_msg_style { Full, Minimum };$/;"	e	enum:itpp::error_msg_style
itpp::G1	/usr/include/itpp/comm/channel.h	/^  GaussI = 1, Gauss1 = 1, GI = 1, G1 = 1,$/;"	e	enum:itpp::DOPPLER_SPECTRUM
itpp::G2	/usr/include/itpp/comm/channel.h	/^  GaussII = 2, Gauss2 = 2, GII = 2, G2 = 2$/;"	e	enum:itpp::DOPPLER_SPECTRUM
itpp::GF	/usr/include/itpp/comm/galois.h	/^class GF$/;"	c	namespace:itpp
itpp::GF2mat	/usr/include/itpp/base/gf2mat.h	/^class GF2mat$/;"	c	namespace:itpp
itpp::GF2mat::GF2mat	/usr/include/itpp/base/gf2mat.h	/^  GF2mat();$/;"	p	class:itpp::GF2mat	access:public	signature:()
itpp::GF2mat::GF2mat	/usr/include/itpp/base/gf2mat.h	/^  GF2mat(const GF2mat_sparse &X);$/;"	p	class:itpp::GF2mat	access:public	signature:(const GF2mat_sparse &X)
itpp::GF2mat::GF2mat	/usr/include/itpp/base/gf2mat.h	/^  GF2mat(const GF2mat_sparse &X, const ivec &columns);$/;"	p	class:itpp::GF2mat	access:public	signature:(const GF2mat_sparse &X, const ivec &columns)
itpp::GF2mat::GF2mat	/usr/include/itpp/base/gf2mat.h	/^  GF2mat(const GF2mat_sparse &X, int m1, int n1, int m2, int n2);$/;"	p	class:itpp::GF2mat	access:public	signature:(const GF2mat_sparse &X, int m1, int n1, int m2, int n2)
itpp::GF2mat::GF2mat	/usr/include/itpp/base/gf2mat.h	/^  GF2mat(const bmat &X);$/;"	p	class:itpp::GF2mat	access:public	signature:(const bmat &X)
itpp::GF2mat::GF2mat	/usr/include/itpp/base/gf2mat.h	/^  GF2mat(const bvec &x, bool is_column = true);$/;"	p	class:itpp::GF2mat	access:public	signature:(const bvec &x, bool is_column = true)
itpp::GF2mat::GF2mat	/usr/include/itpp/base/gf2mat.h	/^  GF2mat(int m, int n);$/;"	p	class:itpp::GF2mat	access:public	signature:(int m, int n)
itpp::GF2mat::T_fact	/usr/include/itpp/base/gf2mat.h	/^  int T_fact(GF2mat &T, GF2mat &U, ivec &P) const;$/;"	p	class:itpp::GF2mat	access:public	signature:(GF2mat &T, GF2mat &U, ivec &P) const
itpp::GF2mat::T_fact_update_addcol	/usr/include/itpp/base/gf2mat.h	/^  bool T_fact_update_addcol(GF2mat &T, GF2mat &U,$/;"	p	class:itpp::GF2mat	access:public	signature:(GF2mat &T, GF2mat &U, ivec &P, bvec newcol) const
itpp::GF2mat::T_fact_update_bitflip	/usr/include/itpp/base/gf2mat.h	/^  int T_fact_update_bitflip(GF2mat &T, GF2mat &U,$/;"	p	class:itpp::GF2mat	access:public	signature:(GF2mat &T, GF2mat &U, ivec &P, int rank, int r, int c) const
itpp::GF2mat::add_rows	/usr/include/itpp/base/gf2mat.h	/^  void add_rows(int i, int j);$/;"	p	class:itpp::GF2mat	access:public	signature:(int i, int j)
itpp::GF2mat::addto_element	/usr/include/itpp/base/gf2mat.h	/^  inline void addto_element(int i, int j, bin s);$/;"	p	class:itpp::GF2mat	access:public	signature:(int i, int j, bin s)
itpp::GF2mat::addto_element	/usr/include/itpp/base/gf2mat.h	/^inline void GF2mat::addto_element(int i, int j, bin s)$/;"	f	class:itpp::GF2mat	signature:(int i, int j, bin s)
itpp::GF2mat::bvecify	/usr/include/itpp/base/gf2mat.h	/^  bvec bvecify() const;$/;"	p	class:itpp::GF2mat	access:public	signature:() const
itpp::GF2mat::cols	/usr/include/itpp/base/gf2mat.h	/^  int cols() const { return ncols; }$/;"	f	class:itpp::GF2mat	access:public	signature:() const
itpp::GF2mat::concatenate_horizontal	/usr/include/itpp/base/gf2mat.h	/^  GF2mat concatenate_horizontal(const GF2mat &X) const;$/;"	p	class:itpp::GF2mat	access:public	signature:(const GF2mat &X) const
itpp::GF2mat::concatenate_vertical	/usr/include/itpp/base/gf2mat.h	/^  GF2mat concatenate_vertical(const GF2mat &X) const;$/;"	p	class:itpp::GF2mat	access:public	signature:(const GF2mat &X) const
itpp::GF2mat::data	/usr/include/itpp/base/gf2mat.h	/^  Mat<unsigned char> data;   \/\/ data structure$/;"	m	class:itpp::GF2mat	access:private
itpp::GF2mat::density	/usr/include/itpp/base/gf2mat.h	/^  double density() const;$/;"	p	class:itpp::GF2mat	access:public	signature:() const
itpp::GF2mat::get	/usr/include/itpp/base/gf2mat.h	/^  inline bin get(int i, int j) const;$/;"	p	class:itpp::GF2mat	access:public	signature:(int i, int j) const
itpp::GF2mat::get	/usr/include/itpp/base/gf2mat.h	/^inline bin GF2mat::get(int i, int j) const$/;"	f	class:itpp::GF2mat	signature:(int i, int j) const
itpp::GF2mat::get_col	/usr/include/itpp/base/gf2mat.h	/^  bvec get_col(int j) const;$/;"	p	class:itpp::GF2mat	access:public	signature:(int j) const
itpp::GF2mat::get_row	/usr/include/itpp/base/gf2mat.h	/^  bvec get_row(int i) const;$/;"	p	class:itpp::GF2mat	access:public	signature:(int i) const
itpp::GF2mat::get_submatrix	/usr/include/itpp/base/gf2mat.h	/^  GF2mat get_submatrix(int m1, int n1, int m2, int n2) const;$/;"	p	class:itpp::GF2mat	access:public	signature:(int m1, int n1, int m2, int n2) const
itpp::GF2mat::inverse	/usr/include/itpp/base/gf2mat.h	/^  GF2mat inverse() const;$/;"	p	class:itpp::GF2mat	access:public	signature:() const
itpp::GF2mat::is_zero	/usr/include/itpp/base/gf2mat.h	/^  bool is_zero() const;$/;"	p	class:itpp::GF2mat	access:public	signature:() const
itpp::GF2mat::mult_trans	/usr/include/itpp/base/gf2mat.h	/^  friend GF2mat mult_trans(const GF2mat &X, const GF2mat &Y);$/;"	p	class:itpp::GF2mat	access:friend	signature:(const GF2mat &X, const GF2mat &Y)
itpp::GF2mat::ncols	/usr/include/itpp/base/gf2mat.h	/^  int nrows, ncols;            \/\/ number of rows and columns of matrix$/;"	m	class:itpp::GF2mat	access:private
itpp::GF2mat::nrows	/usr/include/itpp/base/gf2mat.h	/^  int nrows, ncols;            \/\/ number of rows and columns of matrix$/;"	m	class:itpp::GF2mat	access:private
itpp::GF2mat::nwords	/usr/include/itpp/base/gf2mat.h	/^  int nwords;                  \/\/ number of bytes used$/;"	m	class:itpp::GF2mat	access:private
itpp::GF2mat::operator ()	/usr/include/itpp/base/gf2mat.h	/^  inline bin operator()(int i, int j) const { return get(i, j); };$/;"	f	class:itpp::GF2mat	access:public	signature:(int i, int j) const
itpp::GF2mat::operator *	/usr/include/itpp/base/gf2mat.h	/^  friend GF2mat operator*(const GF2mat &X, const GF2mat &Y);$/;"	p	class:itpp::GF2mat	access:friend	signature:(const GF2mat &X, const GF2mat &Y)
itpp::GF2mat::operator *	/usr/include/itpp/base/gf2mat.h	/^  friend bvec operator*(const GF2mat &X, const bvec &y);$/;"	p	class:itpp::GF2mat	access:friend	signature:(const GF2mat &X, const bvec &y)
itpp::GF2mat::operator +	/usr/include/itpp/base/gf2mat.h	/^  friend GF2mat operator+(const GF2mat &X, const GF2mat &Y);$/;"	p	class:itpp::GF2mat	access:friend	signature:(const GF2mat &X, const GF2mat &Y)
itpp::GF2mat::operator <<	/usr/include/itpp/base/gf2mat.h	/^  friend it_file &operator<<(it_file &f, const GF2mat &X);$/;"	p	class:itpp::GF2mat	access:friend	signature:(it_file &f, const GF2mat &X)
itpp::GF2mat::operator <<	/usr/include/itpp/base/gf2mat.h	/^  friend std::ostream &operator<<(std::ostream &os, const GF2mat &X);$/;"	p	class:itpp::GF2mat	access:friend	signature:(std::ostream &os, const GF2mat &X)
itpp::GF2mat::operator =	/usr/include/itpp/base/gf2mat.h	/^  void operator=(const GF2mat &X);$/;"	p	class:itpp::GF2mat	access:public	signature:(const GF2mat &X)
itpp::GF2mat::operator ==	/usr/include/itpp/base/gf2mat.h	/^  bool operator==(const GF2mat &X) const;$/;"	p	class:itpp::GF2mat	access:public	signature:(const GF2mat &X) const
itpp::GF2mat::operator >>	/usr/include/itpp/base/gf2mat.h	/^  friend it_ifile &operator>>(it_ifile &f, GF2mat &X);$/;"	p	class:itpp::GF2mat	access:friend	signature:(it_ifile &f, GF2mat &X)
itpp::GF2mat::permute_cols	/usr/include/itpp/base/gf2mat.h	/^  void permute_cols(ivec &perm, bool I);$/;"	p	class:itpp::GF2mat	access:public	signature:(ivec &perm, bool I)
itpp::GF2mat::permute_rows	/usr/include/itpp/base/gf2mat.h	/^  void permute_rows(ivec &perm, bool I);$/;"	p	class:itpp::GF2mat	access:public	signature:(ivec &perm, bool I)
itpp::GF2mat::rem_mask	/usr/include/itpp/base/gf2mat.h	/^  static const unsigned char rem_mask = (1 << shift_divisor) - 1;$/;"	m	class:itpp::GF2mat	access:private
itpp::GF2mat::row_rank	/usr/include/itpp/base/gf2mat.h	/^  int row_rank() const;$/;"	p	class:itpp::GF2mat	access:public	signature:() const
itpp::GF2mat::rows	/usr/include/itpp/base/gf2mat.h	/^  int rows() const { return nrows; }$/;"	f	class:itpp::GF2mat	access:public	signature:() const
itpp::GF2mat::set	/usr/include/itpp/base/gf2mat.h	/^  inline void set(int i, int j, bin s);$/;"	p	class:itpp::GF2mat	access:public	signature:(int i, int j, bin s)
itpp::GF2mat::set	/usr/include/itpp/base/gf2mat.h	/^inline void GF2mat::set(int i, int j, bin s)$/;"	f	class:itpp::GF2mat	signature:(int i, int j, bin s)
itpp::GF2mat::set_col	/usr/include/itpp/base/gf2mat.h	/^  void set_col(int j, bvec x);$/;"	p	class:itpp::GF2mat	access:public	signature:(int j, bvec x)
itpp::GF2mat::set_row	/usr/include/itpp/base/gf2mat.h	/^  void set_row(int i, bvec x);$/;"	p	class:itpp::GF2mat	access:public	signature:(int i, bvec x)
itpp::GF2mat::set_size	/usr/include/itpp/base/gf2mat.h	/^  void set_size(int m, int n, bool copy = false);$/;"	p	class:itpp::GF2mat	access:public	signature:(int m, int n, bool copy = false)
itpp::GF2mat::shift_divisor	/usr/include/itpp/base/gf2mat.h	/^  static const unsigned char shift_divisor = 3;$/;"	m	class:itpp::GF2mat	access:private
itpp::GF2mat::sparsify	/usr/include/itpp/base/gf2mat.h	/^  GF2mat_sparse sparsify() const;$/;"	p	class:itpp::GF2mat	access:public	signature:() const
itpp::GF2mat::swap_cols	/usr/include/itpp/base/gf2mat.h	/^  void swap_cols(int i, int j);$/;"	p	class:itpp::GF2mat	access:public	signature:(int i, int j)
itpp::GF2mat::swap_rows	/usr/include/itpp/base/gf2mat.h	/^  void swap_rows(int i, int j);$/;"	p	class:itpp::GF2mat	access:public	signature:(int i, int j)
itpp::GF2mat::transpose	/usr/include/itpp/base/gf2mat.h	/^  GF2mat transpose() const;$/;"	p	class:itpp::GF2mat	access:public	signature:() const
itpp::GF2mat_sparse	/usr/include/itpp/base/gf2mat.h	/^typedef Sparse_Mat<bin> GF2mat_sparse;$/;"	t	namespace:itpp
itpp::GF2mat_sparse_alist	/usr/include/itpp/base/gf2mat.h	/^class GF2mat_sparse_alist$/;"	c	namespace:itpp
itpp::GF2mat_sparse_alist::GF2mat_sparse_alist	/usr/include/itpp/base/gf2mat.h	/^  GF2mat_sparse_alist() : data_ok(false) {}$/;"	f	class:itpp::GF2mat_sparse_alist	access:public	signature:()
itpp::GF2mat_sparse_alist::GF2mat_sparse_alist	/usr/include/itpp/base/gf2mat.h	/^  GF2mat_sparse_alist(const std::string &fname);$/;"	p	class:itpp::GF2mat_sparse_alist	access:public	signature:(const std::string &fname)
itpp::GF2mat_sparse_alist::M	/usr/include/itpp/base/gf2mat.h	/^  int M;$/;"	m	class:itpp::GF2mat_sparse_alist	access:protected
itpp::GF2mat_sparse_alist::N	/usr/include/itpp/base/gf2mat.h	/^  int N;$/;"	m	class:itpp::GF2mat_sparse_alist	access:protected
itpp::GF2mat_sparse_alist::data_ok	/usr/include/itpp/base/gf2mat.h	/^  bool data_ok;$/;"	m	class:itpp::GF2mat_sparse_alist	access:protected
itpp::GF2mat_sparse_alist::from_sparse	/usr/include/itpp/base/gf2mat.h	/^  void from_sparse(const GF2mat_sparse &mat, bool transpose = false);$/;"	p	class:itpp::GF2mat_sparse_alist	access:public	signature:(const GF2mat_sparse &mat, bool transpose = false)
itpp::GF2mat_sparse_alist::max_num_m	/usr/include/itpp/base/gf2mat.h	/^  int max_num_m;$/;"	m	class:itpp::GF2mat_sparse_alist	access:protected
itpp::GF2mat_sparse_alist::max_num_n	/usr/include/itpp/base/gf2mat.h	/^  int max_num_n;$/;"	m	class:itpp::GF2mat_sparse_alist	access:protected
itpp::GF2mat_sparse_alist::mlist	/usr/include/itpp/base/gf2mat.h	/^  imat mlist;$/;"	m	class:itpp::GF2mat_sparse_alist	access:protected
itpp::GF2mat_sparse_alist::nlist	/usr/include/itpp/base/gf2mat.h	/^  imat nlist;$/;"	m	class:itpp::GF2mat_sparse_alist	access:protected
itpp::GF2mat_sparse_alist::num_mlist	/usr/include/itpp/base/gf2mat.h	/^  ivec num_mlist;$/;"	m	class:itpp::GF2mat_sparse_alist	access:protected
itpp::GF2mat_sparse_alist::num_nlist	/usr/include/itpp/base/gf2mat.h	/^  ivec num_nlist;$/;"	m	class:itpp::GF2mat_sparse_alist	access:protected
itpp::GF2mat_sparse_alist::read	/usr/include/itpp/base/gf2mat.h	/^  void read(const std::string &fname);$/;"	p	class:itpp::GF2mat_sparse_alist	access:public	signature:(const std::string &fname)
itpp::GF2mat_sparse_alist::to_sparse	/usr/include/itpp/base/gf2mat.h	/^  GF2mat_sparse to_sparse(bool transpose = false) const;$/;"	p	class:itpp::GF2mat_sparse_alist	access:public	signature:(bool transpose = false) const
itpp::GF2mat_sparse_alist::write	/usr/include/itpp/base/gf2mat.h	/^  void write(const std::string &fname) const;$/;"	p	class:itpp::GF2mat_sparse_alist	access:public	signature:(const std::string &fname) const
itpp::GF2vec_sparse	/usr/include/itpp/base/gf2mat.h	/^typedef Sparse_Vec<bin> GF2vec_sparse;$/;"	t	namespace:itpp
itpp::GF::GF	/usr/include/itpp/comm/galois.h	/^  GF() { m = 0; }$/;"	f	class:itpp::GF	access:public	signature:()
itpp::GF::GF	/usr/include/itpp/comm/galois.h	/^  GF(const GF &ingf) { m = ingf.m; value = ingf.value; }$/;"	f	class:itpp::GF	access:public	signature:(const GF &ingf)
itpp::GF::GF	/usr/include/itpp/comm/galois.h	/^  GF(int qvalue) {$/;"	f	class:itpp::GF	access:public	signature:(int qvalue)
itpp::GF::GF	/usr/include/itpp/comm/galois.h	/^  GF(int qvalue, int inexp) { m = 0; set(qvalue, inexp); }$/;"	f	class:itpp::GF	access:public	signature:(int qvalue, int inexp)
itpp::GF::alphapow	/usr/include/itpp/comm/galois.h	/^  static Array<Array<int> > alphapow, logalpha;$/;"	m	class:itpp::GF	access:private
itpp::GF::get_size	/usr/include/itpp/comm/galois.h	/^  int get_size() const { return ((m != 0) ? q[m] : 0); }$/;"	f	class:itpp::GF	access:public	signature:() const
itpp::GF::get_value	/usr/include/itpp/comm/galois.h	/^  int  get_value() const;$/;"	p	class:itpp::GF	access:public	signature:() const
itpp::GF::get_value	/usr/include/itpp/comm/galois.h	/^inline int  GF::get_value() const$/;"	f	class:itpp::GF	signature:() const
itpp::GF::get_vectorspace	/usr/include/itpp/comm/galois.h	/^  bvec get_vectorspace() const;$/;"	p	class:itpp::GF	access:public	signature:() const
itpp::GF::get_vectorspace	/usr/include/itpp/comm/galois.h	/^inline bvec GF::get_vectorspace() const$/;"	f	class:itpp::GF	signature:() const
itpp::GF::logalpha	/usr/include/itpp/comm/galois.h	/^  static Array<Array<int> > alphapow, logalpha;$/;"	m	class:itpp::GF	access:private
itpp::GF::m	/usr/include/itpp/comm/galois.h	/^  char m;$/;"	m	class:itpp::GF	access:private
itpp::GF::operator !=	/usr/include/itpp/comm/galois.h	/^  int operator!=(const GF &ingf) const;$/;"	p	class:itpp::GF	access:public	signature:(const GF &ingf) const
itpp::GF::operator !=	/usr/include/itpp/comm/galois.h	/^inline int GF::operator!=(const GF &ingf) const$/;"	f	class:itpp::GF	signature:(const GF &ingf) const
itpp::GF::operator *	/usr/include/itpp/comm/galois.h	/^  GF operator*(const GF &ingf) const;$/;"	p	class:itpp::GF	access:public	signature:(const GF &ingf) const
itpp::GF::operator *	/usr/include/itpp/comm/galois.h	/^inline GF GF::operator*(const GF &ingf) const$/;"	f	class:itpp::GF	signature:(const GF &ingf) const
itpp::GF::operator *=	/usr/include/itpp/comm/galois.h	/^  void operator*=(const GF &ingf);$/;"	p	class:itpp::GF	access:public	signature:(const GF &ingf)
itpp::GF::operator *=	/usr/include/itpp/comm/galois.h	/^inline void GF::operator*=(const GF &ingf)$/;"	f	class:itpp::GF	signature:(const GF &ingf)
itpp::GF::operator +	/usr/include/itpp/comm/galois.h	/^  GF operator+(const GF &ingf) const;$/;"	p	class:itpp::GF	access:public	signature:(const GF &ingf) const
itpp::GF::operator +	/usr/include/itpp/comm/galois.h	/^inline GF GF::operator+(const GF &ingf) const$/;"	f	class:itpp::GF	signature:(const GF &ingf) const
itpp::GF::operator +=	/usr/include/itpp/comm/galois.h	/^  void operator+=(const GF &ingf);$/;"	p	class:itpp::GF	access:public	signature:(const GF &ingf)
itpp::GF::operator +=	/usr/include/itpp/comm/galois.h	/^inline void GF::operator+=(const GF &ingf)$/;"	f	class:itpp::GF	signature:(const GF &ingf)
itpp::GF::operator -	/usr/include/itpp/comm/galois.h	/^  GF operator-(const GF &ingf) const;$/;"	p	class:itpp::GF	access:public	signature:(const GF &ingf) const
itpp::GF::operator -	/usr/include/itpp/comm/galois.h	/^inline GF GF::operator-(const GF &ingf) const$/;"	f	class:itpp::GF	signature:(const GF &ingf) const
itpp::GF::operator -=	/usr/include/itpp/comm/galois.h	/^  void operator-=(const GF &ingf);$/;"	p	class:itpp::GF	access:public	signature:(const GF &ingf)
itpp::GF::operator -=	/usr/include/itpp/comm/galois.h	/^inline void GF::operator-=(const GF &ingf)$/;"	f	class:itpp::GF	signature:(const GF &ingf)
itpp::GF::operator /	/usr/include/itpp/comm/galois.h	/^  GF operator\/(const GF &ingf) const;$/;"	p	class:itpp::GF	access:public	signature:(const GF &ingf) const
itpp::GF::operator /	/usr/include/itpp/comm/galois.h	/^inline GF GF::operator\/(const GF &ingf) const$/;"	f	class:itpp::GF	signature:(const GF &ingf) const
itpp::GF::operator /=	/usr/include/itpp/comm/galois.h	/^  void operator\/=(const GF &ingf);$/;"	p	class:itpp::GF	access:public	signature:(const GF &ingf)
itpp::GF::operator /=	/usr/include/itpp/comm/galois.h	/^inline void GF::operator\/=(const GF &ingf)$/;"	f	class:itpp::GF	signature:(const GF &ingf)
itpp::GF::operator <<	/usr/include/itpp/comm/galois.h	/^  friend std::ostream &operator<<(std::ostream &os, const GF &ingf);$/;"	p	class:itpp::GF	access:friend	signature:(std::ostream &os, const GF &ingf)
itpp::GF::operator =	/usr/include/itpp/comm/galois.h	/^  void operator=(const GF &ingf);$/;"	p	class:itpp::GF	access:public	signature:(const GF &ingf)
itpp::GF::operator =	/usr/include/itpp/comm/galois.h	/^  void operator=(const int inexp);$/;"	p	class:itpp::GF	access:public	signature:(const int inexp)
itpp::GF::operator =	/usr/include/itpp/comm/galois.h	/^inline void GF::operator=(const GF &ingf)$/;"	f	class:itpp::GF	signature:(const GF &ingf)
itpp::GF::operator =	/usr/include/itpp/comm/galois.h	/^inline void GF::operator=(const int inexp)$/;"	f	class:itpp::GF	signature:(const int inexp)
itpp::GF::operator ==	/usr/include/itpp/comm/galois.h	/^  int operator==(const GF &ingf) const;$/;"	p	class:itpp::GF	access:public	signature:(const GF &ingf) const
itpp::GF::operator ==	/usr/include/itpp/comm/galois.h	/^inline int GF::operator==(const GF &ingf) const$/;"	f	class:itpp::GF	signature:(const GF &ingf) const
itpp::GF::q	/usr/include/itpp/comm/galois.h	/^  static ivec q;$/;"	m	class:itpp::GF	access:private
itpp::GF::set	/usr/include/itpp/comm/galois.h	/^  void set(int qvalue, const bvec &vectorspace);$/;"	p	class:itpp::GF	access:public	signature:(int qvalue, const bvec &vectorspace)
itpp::GF::set	/usr/include/itpp/comm/galois.h	/^  void set(int qvalue, int inexp) {$/;"	f	class:itpp::GF	access:public	signature:(int qvalue, int inexp)
itpp::GF::set	/usr/include/itpp/comm/galois.h	/^inline void GF::set(int qvalue, const bvec &vectorspace)$/;"	f	class:itpp::GF	signature:(int qvalue, const bvec &vectorspace)
itpp::GF::set_size	/usr/include/itpp/comm/galois.h	/^  void set_size(int qvalue);$/;"	p	class:itpp::GF	access:public	signature:(int qvalue)
itpp::GF::value	/usr/include/itpp/comm/galois.h	/^  int value;$/;"	m	class:itpp::GF	access:private
itpp::GFX	/usr/include/itpp/comm/galois.h	/^class GFX$/;"	c	namespace:itpp
itpp::GFX::GFX	/usr/include/itpp/comm/galois.h	/^  GFX();$/;"	p	class:itpp::GFX	access:public	signature:()
itpp::GFX::GFX	/usr/include/itpp/comm/galois.h	/^  GFX(const GFX &ingfx);$/;"	p	class:itpp::GFX	access:public	signature:(const GFX &ingfx)
itpp::GFX::GFX	/usr/include/itpp/comm/galois.h	/^  GFX(int qvalue);$/;"	p	class:itpp::GFX	access:public	signature:(int qvalue)
itpp::GFX::GFX	/usr/include/itpp/comm/galois.h	/^  GFX(int qvalue, char *invalues);$/;"	p	class:itpp::GFX	access:public	signature:(int qvalue, char *invalues)
itpp::GFX::GFX	/usr/include/itpp/comm/galois.h	/^  GFX(int qvalue, const ivec &invalues);$/;"	p	class:itpp::GFX	access:public	signature:(int qvalue, const ivec &invalues)
itpp::GFX::GFX	/usr/include/itpp/comm/galois.h	/^  GFX(int qvalue, int indegree);$/;"	p	class:itpp::GFX	access:public	signature:(int qvalue, int indegree)
itpp::GFX::GFX	/usr/include/itpp/comm/galois.h	/^  GFX(int qvalue, std::string invalues);$/;"	p	class:itpp::GFX	access:public	signature:(int qvalue, std::string invalues)
itpp::GFX::GFX	/usr/include/itpp/comm/galois.h	/^inline GFX::GFX()$/;"	f	class:itpp::GFX	signature:()
itpp::GFX::GFX	/usr/include/itpp/comm/galois.h	/^inline GFX::GFX(const GFX &ingfx)$/;"	f	class:itpp::GFX	signature:(const GFX &ingfx)
itpp::GFX::GFX	/usr/include/itpp/comm/galois.h	/^inline GFX::GFX(int qvalue)$/;"	f	class:itpp::GFX	signature:(int qvalue)
itpp::GFX::GFX	/usr/include/itpp/comm/galois.h	/^inline GFX::GFX(int qvalue, char *invalues)$/;"	f	class:itpp::GFX	signature:(int qvalue, char *invalues)
itpp::GFX::GFX	/usr/include/itpp/comm/galois.h	/^inline GFX::GFX(int qvalue, const ivec &invalues)$/;"	f	class:itpp::GFX	signature:(int qvalue, const ivec &invalues)
itpp::GFX::GFX	/usr/include/itpp/comm/galois.h	/^inline GFX::GFX(int qvalue, int indegree)$/;"	f	class:itpp::GFX	signature:(int qvalue, int indegree)
itpp::GFX::GFX	/usr/include/itpp/comm/galois.h	/^inline GFX::GFX(int qvalue, std::string invalues)$/;"	f	class:itpp::GFX	signature:(int qvalue, std::string invalues)
itpp::GFX::clear	/usr/include/itpp/comm/galois.h	/^  void clear();$/;"	p	class:itpp::GFX	access:public	signature:()
itpp::GFX::clear	/usr/include/itpp/comm/galois.h	/^inline void GFX::clear()$/;"	f	class:itpp::GFX	signature:()
itpp::GFX::coeffs	/usr/include/itpp/comm/galois.h	/^  Array<GF> coeffs;$/;"	m	class:itpp::GFX	access:private
itpp::GFX::degree	/usr/include/itpp/comm/galois.h	/^  int degree, q;$/;"	m	class:itpp::GFX	access:private
itpp::GFX::get_degree	/usr/include/itpp/comm/galois.h	/^  int get_degree() const;$/;"	p	class:itpp::GFX	access:public	signature:() const
itpp::GFX::get_degree	/usr/include/itpp/comm/galois.h	/^inline int GFX::get_degree() const$/;"	f	class:itpp::GFX	signature:() const
itpp::GFX::get_size	/usr/include/itpp/comm/galois.h	/^  int get_size() const;$/;"	p	class:itpp::GFX	access:public	signature:() const
itpp::GFX::get_size	/usr/include/itpp/comm/galois.h	/^inline int GFX::get_size() const$/;"	f	class:itpp::GFX	signature:() const
itpp::GFX::get_true_degree	/usr/include/itpp/comm/galois.h	/^  int get_true_degree() const;$/;"	p	class:itpp::GFX	access:public	signature:() const
itpp::GFX::get_true_degree	/usr/include/itpp/comm/galois.h	/^inline int GFX::get_true_degree() const$/;"	f	class:itpp::GFX	signature:() const
itpp::GFX::operator ()	/usr/include/itpp/comm/galois.h	/^  GF operator()(const GF &ingf);$/;"	p	class:itpp::GFX	access:public	signature:(const GF &ingf)
itpp::GFX::operator ()	/usr/include/itpp/comm/galois.h	/^inline GF GFX::operator()(const GF &ingf)$/;"	f	class:itpp::GFX	signature:(const GF &ingf)
itpp::GFX::operator *	/usr/include/itpp/comm/galois.h	/^  GFX operator*(const GFX &ingfx) const;$/;"	p	class:itpp::GFX	access:public	signature:(const GFX &ingfx) const
itpp::GFX::operator *	/usr/include/itpp/comm/galois.h	/^  friend GFX  operator*(const GF &ingf, const GFX &ingfx);$/;"	p	class:itpp::GFX	access:friend	signature:(const GF &ingf, const GFX &ingfx)
itpp::GFX::operator *	/usr/include/itpp/comm/galois.h	/^  friend GFX  operator*(const GFX &ingfx, const GF &ingf);$/;"	p	class:itpp::GFX	access:friend	signature:(const GFX &ingfx, const GF &ingf)
itpp::GFX::operator *	/usr/include/itpp/comm/galois.h	/^inline GFX GFX::operator*(const GFX &ingfx) const$/;"	f	class:itpp::GFX	signature:(const GFX &ingfx) const
itpp::GFX::operator *=	/usr/include/itpp/comm/galois.h	/^  void operator*=(const GFX &ingfx);$/;"	p	class:itpp::GFX	access:public	signature:(const GFX &ingfx)
itpp::GFX::operator *=	/usr/include/itpp/comm/galois.h	/^inline void GFX::operator*=(const GFX &ingfx)$/;"	f	class:itpp::GFX	signature:(const GFX &ingfx)
itpp::GFX::operator +	/usr/include/itpp/comm/galois.h	/^  GFX operator+(const GFX &ingfx) const;$/;"	p	class:itpp::GFX	access:public	signature:(const GFX &ingfx) const
itpp::GFX::operator +	/usr/include/itpp/comm/galois.h	/^inline GFX GFX::operator+(const GFX &ingfx) const$/;"	f	class:itpp::GFX	signature:(const GFX &ingfx) const
itpp::GFX::operator +=	/usr/include/itpp/comm/galois.h	/^  void operator+=(const GFX &ingfx);$/;"	p	class:itpp::GFX	access:public	signature:(const GFX &ingfx)
itpp::GFX::operator +=	/usr/include/itpp/comm/galois.h	/^inline void GFX::operator+=(const GFX &ingfx)$/;"	f	class:itpp::GFX	signature:(const GFX &ingfx)
itpp::GFX::operator -	/usr/include/itpp/comm/galois.h	/^  GFX operator-(const GFX &ingfx) const;$/;"	p	class:itpp::GFX	access:public	signature:(const GFX &ingfx) const
itpp::GFX::operator -	/usr/include/itpp/comm/galois.h	/^inline GFX GFX::operator-(const GFX &ingfx) const$/;"	f	class:itpp::GFX	signature:(const GFX &ingfx) const
itpp::GFX::operator -=	/usr/include/itpp/comm/galois.h	/^  void operator-=(const GFX &ingfx);$/;"	p	class:itpp::GFX	access:public	signature:(const GFX &ingfx)
itpp::GFX::operator -=	/usr/include/itpp/comm/galois.h	/^inline void GFX::operator-=(const GFX &ingfx)$/;"	f	class:itpp::GFX	signature:(const GFX &ingfx)
itpp::GFX::operator /	/usr/include/itpp/comm/galois.h	/^  friend GFX  operator\/(const GFX &ingfx, const GF &ingf);$/;"	p	class:itpp::GFX	access:friend	signature:(const GFX &ingfx, const GF &ingf)
itpp::GFX::operator <<	/usr/include/itpp/comm/galois.h	/^  friend std::ostream &operator<<(std::ostream &os, const GFX &ingfx);$/;"	p	class:itpp::GFX	access:friend	signature:(std::ostream &os, const GFX &ingfx)
itpp::GFX::operator =	/usr/include/itpp/comm/galois.h	/^  void operator=(const GFX &ingfx);$/;"	p	class:itpp::GFX	access:public	signature:(const GFX &ingfx)
itpp::GFX::operator =	/usr/include/itpp/comm/galois.h	/^inline void GFX::operator=(const GFX &ingfx)$/;"	f	class:itpp::GFX	signature:(const GFX &ingfx)
itpp::GFX::operator []	/usr/include/itpp/comm/galois.h	/^  GF &operator[](int index) {$/;"	f	class:itpp::GFX	access:public	signature:(int index)
itpp::GFX::operator []	/usr/include/itpp/comm/galois.h	/^  GF operator[](int index) const {$/;"	f	class:itpp::GFX	access:public	signature:(int index) const
itpp::GFX::q	/usr/include/itpp/comm/galois.h	/^  int degree, q;$/;"	m	class:itpp::GFX	access:private
itpp::GFX::set	/usr/include/itpp/comm/galois.h	/^  void set(int qvalue, const char *invalues);$/;"	p	class:itpp::GFX	access:public	signature:(int qvalue, const char *invalues)
itpp::GFX::set	/usr/include/itpp/comm/galois.h	/^  void set(int qvalue, const ivec &invalues);$/;"	p	class:itpp::GFX	access:public	signature:(int qvalue, const ivec &invalues)
itpp::GFX::set	/usr/include/itpp/comm/galois.h	/^  void set(int qvalue, const std::string invalues);$/;"	p	class:itpp::GFX	access:public	signature:(int qvalue, const std::string invalues)
itpp::GFX::set	/usr/include/itpp/comm/galois.h	/^inline void GFX::set(int qvalue, const char *invalues)$/;"	f	class:itpp::GFX	signature:(int qvalue, const char *invalues)
itpp::GFX::set	/usr/include/itpp/comm/galois.h	/^inline void GFX::set(int qvalue, const ivec &invalues)$/;"	f	class:itpp::GFX	signature:(int qvalue, const ivec &invalues)
itpp::GFX::set	/usr/include/itpp/comm/galois.h	/^inline void GFX::set(int qvalue, const std::string invalues)$/;"	f	class:itpp::GFX	signature:(int qvalue, const std::string invalues)
itpp::GFX::set_degree	/usr/include/itpp/comm/galois.h	/^  void set_degree(int indegree);$/;"	p	class:itpp::GFX	access:public	signature:(int indegree)
itpp::GFX::set_degree	/usr/include/itpp/comm/galois.h	/^inline void GFX::set_degree(int indegree)$/;"	f	class:itpp::GFX	signature:(int indegree)
itpp::GI	/usr/include/itpp/comm/channel.h	/^  GaussI = 1, Gauss1 = 1, GI = 1, G1 = 1,$/;"	e	enum:itpp::DOPPLER_SPECTRUM
itpp::GII	/usr/include/itpp/comm/channel.h	/^  GaussII = 2, Gauss2 = 2, GII = 2, G2 = 2$/;"	e	enum:itpp::DOPPLER_SPECTRUM
itpp::GMM	/usr/include/itpp/srccode/gmm.h	/^class GMM$/;"	c	namespace:itpp
itpp::GMM::GMM	/usr/include/itpp/srccode/gmm.h	/^  GMM();$/;"	p	class:itpp::GMM	access:public	signature:()
itpp::GMM::GMM	/usr/include/itpp/srccode/gmm.h	/^  GMM(int nomix, int dim);$/;"	p	class:itpp::GMM	access:public	signature:(int nomix, int dim)
itpp::GMM::GMM	/usr/include/itpp/srccode/gmm.h	/^  GMM(std::string filename);$/;"	p	class:itpp::GMM	access:public	signature:(std::string filename)
itpp::GMM::M	/usr/include/itpp/srccode/gmm.h	/^  int   M, d;$/;"	m	class:itpp::GMM	access:protected
itpp::GMM::clear	/usr/include/itpp/srccode/gmm.h	/^  void clear();$/;"	p	class:itpp::GMM	access:public	signature:()
itpp::GMM::compute_internals	/usr/include/itpp/srccode/gmm.h	/^  void  compute_internals();$/;"	p	class:itpp::GMM	access:private	signature:()
itpp::GMM::d	/usr/include/itpp/srccode/gmm.h	/^  int   M, d;$/;"	m	class:itpp::GMM	access:protected
itpp::GMM::draw_sample	/usr/include/itpp/srccode/gmm.h	/^  vec draw_sample();$/;"	p	class:itpp::GMM	access:public	signature:()
itpp::GMM::get_covariance	/usr/include/itpp/srccode/gmm.h	/^  vec get_covariance();$/;"	p	class:itpp::GMM	access:public	signature:()
itpp::GMM::get_covariance	/usr/include/itpp/srccode/gmm.h	/^  vec get_covariance(int i);$/;"	p	class:itpp::GMM	access:public	signature:(int i)
itpp::GMM::get_covariance	/usr/include/itpp/srccode/gmm.h	/^inline vec GMM::get_covariance() {return sigma;}$/;"	f	class:itpp::GMM	signature:()
itpp::GMM::get_covariance	/usr/include/itpp/srccode/gmm.h	/^inline vec GMM::get_covariance(int i) {return sigma.mid(i*d, d);}$/;"	f	class:itpp::GMM	signature:(int i)
itpp::GMM::get_dimension	/usr/include/itpp/srccode/gmm.h	/^  int get_dimension();$/;"	p	class:itpp::GMM	access:public	signature:()
itpp::GMM::get_dimension	/usr/include/itpp/srccode/gmm.h	/^inline int GMM::get_dimension() {return d;}$/;"	f	class:itpp::GMM	signature:()
itpp::GMM::get_mean	/usr/include/itpp/srccode/gmm.h	/^  vec get_mean();$/;"	p	class:itpp::GMM	access:public	signature:()
itpp::GMM::get_mean	/usr/include/itpp/srccode/gmm.h	/^  vec get_mean(int i);$/;"	p	class:itpp::GMM	access:public	signature:(int i)
itpp::GMM::get_mean	/usr/include/itpp/srccode/gmm.h	/^inline vec GMM::get_mean() {return m;}$/;"	f	class:itpp::GMM	signature:()
itpp::GMM::get_mean	/usr/include/itpp/srccode/gmm.h	/^inline vec GMM::get_mean(int i) {return m.mid(i*d, d);}$/;"	f	class:itpp::GMM	signature:(int i)
itpp::GMM::get_no_gaussians	/usr/include/itpp/srccode/gmm.h	/^  int get_no_gaussians() const { return M; }$/;"	f	class:itpp::GMM	access:public	signature:() const
itpp::GMM::get_no_mixtures	/usr/include/itpp/srccode/gmm.h	/^  int get_no_mixtures();$/;"	p	class:itpp::GMM	access:public	signature:()
itpp::GMM::get_no_mixtures	/usr/include/itpp/srccode/gmm.h	/^inline int GMM::get_no_mixtures()$/;"	f	class:itpp::GMM	signature:()
itpp::GMM::get_weight	/usr/include/itpp/srccode/gmm.h	/^  double get_weight(int i);$/;"	p	class:itpp::GMM	access:public	signature:(int i)
itpp::GMM::get_weight	/usr/include/itpp/srccode/gmm.h	/^  vec get_weight();$/;"	p	class:itpp::GMM	access:public	signature:()
itpp::GMM::get_weight	/usr/include/itpp/srccode/gmm.h	/^inline double GMM::get_weight(int i) {return w(i);}$/;"	f	class:itpp::GMM	signature:(int i)
itpp::GMM::get_weight	/usr/include/itpp/srccode/gmm.h	/^inline vec GMM::get_weight() {return w;}$/;"	f	class:itpp::GMM	signature:()
itpp::GMM::init	/usr/include/itpp/srccode/gmm.h	/^  void init(const vec &w_in, const mat &m_in, const mat &sigma_in);$/;"	p	class:itpp::GMM	access:public	signature:(const vec &w_in, const mat &m_in, const mat &sigma_in)
itpp::GMM::init_from_vq	/usr/include/itpp/srccode/gmm.h	/^  void init_from_vq(const vec &codebook, int dim);$/;"	p	class:itpp::GMM	access:public	signature:(const vec &codebook, int dim)
itpp::GMM::join	/usr/include/itpp/srccode/gmm.h	/^  void join(const GMM &newgmm);$/;"	p	class:itpp::GMM	access:public	signature:(const GMM &newgmm)
itpp::GMM::likelihood	/usr/include/itpp/srccode/gmm.h	/^  double likelihood(const vec &x);$/;"	p	class:itpp::GMM	access:public	signature:(const vec &x)
itpp::GMM::likelihood_aposteriori	/usr/include/itpp/srccode/gmm.h	/^  double likelihood_aposteriori(const vec &x, int mixture);$/;"	p	class:itpp::GMM	access:public	signature:(const vec &x, int mixture)
itpp::GMM::likelihood_aposteriori	/usr/include/itpp/srccode/gmm.h	/^  vec likelihood_aposteriori(const vec &x);$/;"	p	class:itpp::GMM	access:public	signature:(const vec &x)
itpp::GMM::load	/usr/include/itpp/srccode/gmm.h	/^  void load(std::string filename);$/;"	p	class:itpp::GMM	access:public	signature:(std::string filename)
itpp::GMM::m	/usr/include/itpp/srccode/gmm.h	/^  vec   m, sigma, w;$/;"	m	class:itpp::GMM	access:protected
itpp::GMM::marginalize	/usr/include/itpp/srccode/gmm.h	/^  void marginalize(int d_new);$/;"	p	class:itpp::GMM	access:public	signature:(int d_new)
itpp::GMM::normexp	/usr/include/itpp/srccode/gmm.h	/^  vec   normweight, normexp;$/;"	m	class:itpp::GMM	access:private
itpp::GMM::normweight	/usr/include/itpp/srccode/gmm.h	/^  vec   normweight, normexp;$/;"	m	class:itpp::GMM	access:private
itpp::GMM::save	/usr/include/itpp/srccode/gmm.h	/^  void save(std::string filename);$/;"	p	class:itpp::GMM	access:public	signature:(std::string filename)
itpp::GMM::set_covariance	/usr/include/itpp/srccode/gmm.h	/^  void set_covariance(const mat &sigma_in);$/;"	p	class:itpp::GMM	access:public	signature:(const mat &sigma_in)
itpp::GMM::set_covariance	/usr/include/itpp/srccode/gmm.h	/^  void set_covariance(const vec &covariances, bool compflag = true);$/;"	p	class:itpp::GMM	access:public	signature:(const vec &covariances, bool compflag = true)
itpp::GMM::set_covariance	/usr/include/itpp/srccode/gmm.h	/^  void set_covariance(int i, const vec &covariances, bool compflag = true);$/;"	p	class:itpp::GMM	access:public	signature:(int i, const vec &covariances, bool compflag = true)
itpp::GMM::set_covariance	/usr/include/itpp/srccode/gmm.h	/^inline void GMM::set_covariance(const vec &covariances, bool compflag) {sigma = covariances; if (compflag) compute_internals(); }$/;"	f	class:itpp::GMM	signature:(const vec &covariances, bool compflag)
itpp::GMM::set_mean	/usr/include/itpp/srccode/gmm.h	/^  void set_mean(const mat &m_in);$/;"	p	class:itpp::GMM	access:public	signature:(const mat &m_in)
itpp::GMM::set_mean	/usr/include/itpp/srccode/gmm.h	/^  void set_mean(const vec &means, bool compflag = true);$/;"	p	class:itpp::GMM	access:public	signature:(const vec &means, bool compflag = true)
itpp::GMM::set_mean	/usr/include/itpp/srccode/gmm.h	/^  void set_mean(int i, const vec &means, bool compflag = true);$/;"	p	class:itpp::GMM	access:public	signature:(int i, const vec &means, bool compflag = true)
itpp::GMM::set_mean	/usr/include/itpp/srccode/gmm.h	/^inline void GMM::set_mean(const vec &means, bool compflag) {m = means; if (compflag) compute_internals(); }$/;"	f	class:itpp::GMM	signature:(const vec &means, bool compflag)
itpp::GMM::set_weight	/usr/include/itpp/srccode/gmm.h	/^  void set_weight(const vec &weights, bool compflag = true);$/;"	p	class:itpp::GMM	access:public	signature:(const vec &weights, bool compflag = true)
itpp::GMM::set_weight	/usr/include/itpp/srccode/gmm.h	/^  void set_weight(int i, double weight, bool compflag = true);$/;"	p	class:itpp::GMM	access:public	signature:(int i, double weight, bool compflag = true)
itpp::GMM::set_weight	/usr/include/itpp/srccode/gmm.h	/^inline void GMM::set_weight(const vec &weights, bool compflag) {w = weights; if (compflag) compute_internals(); }$/;"	f	class:itpp::GMM	signature:(const vec &weights, bool compflag)
itpp::GMM::set_weight	/usr/include/itpp/srccode/gmm.h	/^inline void GMM::set_weight(int i, double weight, bool compflag) {w(i) = weight; if (compflag) compute_internals(); }$/;"	f	class:itpp::GMM	signature:(int i, double weight, bool compflag)
itpp::GMM::sigma	/usr/include/itpp/srccode/gmm.h	/^  vec   m, sigma, w;$/;"	m	class:itpp::GMM	access:protected
itpp::GMM::w	/usr/include/itpp/srccode/gmm.h	/^  vec   m, sigma, w;$/;"	m	class:itpp::GMM	access:protected
itpp::Gauss1	/usr/include/itpp/comm/channel.h	/^  GaussI = 1, Gauss1 = 1, GI = 1, G1 = 1,$/;"	e	enum:itpp::DOPPLER_SPECTRUM
itpp::Gauss2	/usr/include/itpp/comm/channel.h	/^  GaussII = 2, Gauss2 = 2, GII = 2, G2 = 2$/;"	e	enum:itpp::DOPPLER_SPECTRUM
itpp::GaussI	/usr/include/itpp/comm/channel.h	/^  GaussI = 1, Gauss1 = 1, GI = 1, G1 = 1,$/;"	e	enum:itpp::DOPPLER_SPECTRUM
itpp::GaussII	/usr/include/itpp/comm/channel.h	/^  GaussII = 2, Gauss2 = 2, GII = 2, G2 = 2$/;"	e	enum:itpp::DOPPLER_SPECTRUM
itpp::Gauss_RNG	/usr/include/itpp/base/random.h	/^typedef Normal_RNG Gauss_RNG;$/;"	t	namespace:itpp
itpp::Gold	/usr/include/itpp/comm/sequence.h	/^class Gold$/;"	c	namespace:itpp
itpp::Gold::Gold	/usr/include/itpp/comm/sequence.h	/^  Gold(const bvec &mseq1_connections, const bvec &mseq2_connections);$/;"	p	class:itpp::Gold	access:public	signature:(const bvec &mseq1_connections, const bvec &mseq2_connections)
itpp::Gold::Gold	/usr/include/itpp/comm/sequence.h	/^  Gold(const ivec &mseq1_connections, const ivec &mseq2_connections);$/;"	p	class:itpp::Gold	access:public	signature:(const ivec &mseq1_connections, const ivec &mseq2_connections)
itpp::Gold::Gold	/usr/include/itpp/comm/sequence.h	/^  Gold(int degree);$/;"	p	class:itpp::Gold	access:public	signature:(int degree)
itpp::Gold::N	/usr/include/itpp/comm/sequence.h	/^  int N;$/;"	m	class:itpp::Gold	access:private
itpp::Gold::get_family	/usr/include/itpp/comm/sequence.h	/^  bmat get_family(void);$/;"	p	class:itpp::Gold	access:public	signature:(void)
itpp::Gold::get_sequence_length	/usr/include/itpp/comm/sequence.h	/^  int get_sequence_length(void);$/;"	p	class:itpp::Gold	access:public	signature:(void)
itpp::Gold::get_sequence_length	/usr/include/itpp/comm/sequence.h	/^inline int Gold::get_sequence_length(void) {return N;}$/;"	f	class:itpp::Gold	signature:(void)
itpp::Gold::mseq1	/usr/include/itpp/comm/sequence.h	/^  LFSR mseq1, mseq2;$/;"	m	class:itpp::Gold	access:private
itpp::Gold::mseq2	/usr/include/itpp/comm/sequence.h	/^  LFSR mseq1, mseq2;$/;"	m	class:itpp::Gold	access:private
itpp::Gold::set_state	/usr/include/itpp/comm/sequence.h	/^  void set_state(const bvec &state1, const bvec &state2);$/;"	p	class:itpp::Gold	access:public	signature:(const bvec &state1, const bvec &state2)
itpp::Gold::set_state	/usr/include/itpp/comm/sequence.h	/^  void set_state(const ivec &state1, const ivec &state2);$/;"	p	class:itpp::Gold	access:public	signature:(const ivec &state1, const ivec &state2)
itpp::Gold::shift	/usr/include/itpp/comm/sequence.h	/^  bin shift(void);$/;"	p	class:itpp::Gold	access:public	signature:(void)
itpp::Gold::shift	/usr/include/itpp/comm/sequence.h	/^  bvec shift(int no_shifts);$/;"	p	class:itpp::Gold	access:public	signature:(int no_shifts)
itpp::Gold::shift	/usr/include/itpp/comm/sequence.h	/^inline bin Gold::shift(void) {return (mseq1.shift() + mseq2.shift());}$/;"	f	class:itpp::Gold	signature:(void)
itpp::HEAPSORT	/usr/include/itpp/base/sort.h	/^enum SORTING_METHOD { INTROSORT = 0, QUICKSORT = 1, HEAPSORT = 2,$/;"	e	enum:itpp::SORTING_METHOD
itpp::Hamming_Code	/usr/include/itpp/comm/hammcode.h	/^class Hamming_Code : public Channel_Code$/;"	c	namespace:itpp	inherits:Channel_Code
itpp::Hamming_Code::G	/usr/include/itpp/comm/hammcode.h	/^  bmat H, G;$/;"	m	class:itpp::Hamming_Code	access:private
itpp::Hamming_Code::H	/usr/include/itpp/comm/hammcode.h	/^  bmat H, G;$/;"	m	class:itpp::Hamming_Code	access:private
itpp::Hamming_Code::Hamming_Code	/usr/include/itpp/comm/hammcode.h	/^  Hamming_Code(short m);$/;"	p	class:itpp::Hamming_Code	access:public	signature:(short m)
itpp::Hamming_Code::decode	/usr/include/itpp/comm/hammcode.h	/^  virtual bvec decode(const bvec &coded_bits);$/;"	p	class:itpp::Hamming_Code	access:public	signature:(const bvec &coded_bits)
itpp::Hamming_Code::decode	/usr/include/itpp/comm/hammcode.h	/^  virtual bvec decode(const vec &received_signal);$/;"	p	class:itpp::Hamming_Code	access:public	signature:(const vec &received_signal)
itpp::Hamming_Code::decode	/usr/include/itpp/comm/hammcode.h	/^  virtual void decode(const bvec &coded_bits, bvec &decoded_bits);$/;"	p	class:itpp::Hamming_Code	access:public	signature:(const bvec &coded_bits, bvec &decoded_bits)
itpp::Hamming_Code::decode	/usr/include/itpp/comm/hammcode.h	/^  virtual void decode(const vec &received_signal, bvec &output);$/;"	p	class:itpp::Hamming_Code	access:public	signature:(const vec &received_signal, bvec &output)
itpp::Hamming_Code::encode	/usr/include/itpp/comm/hammcode.h	/^  virtual bvec encode(const bvec &uncoded_bits);$/;"	p	class:itpp::Hamming_Code	access:public	signature:(const bvec &uncoded_bits)
itpp::Hamming_Code::encode	/usr/include/itpp/comm/hammcode.h	/^  virtual void encode(const bvec &uncoded_bits, bvec &coded_bits);$/;"	p	class:itpp::Hamming_Code	access:public	signature:(const bvec &uncoded_bits, bvec &coded_bits)
itpp::Hamming_Code::generate_G	/usr/include/itpp/comm/hammcode.h	/^  void generate_G(void);$/;"	p	class:itpp::Hamming_Code	access:private	signature:(void)
itpp::Hamming_Code::generate_H	/usr/include/itpp/comm/hammcode.h	/^  void generate_H(void);$/;"	p	class:itpp::Hamming_Code	access:private	signature:(void)
itpp::Hamming_Code::get_G	/usr/include/itpp/comm/hammcode.h	/^  bmat get_G() const { return G; };$/;"	f	class:itpp::Hamming_Code	access:public	signature:() const
itpp::Hamming_Code::get_H	/usr/include/itpp/comm/hammcode.h	/^  bmat get_H() const { return H; };$/;"	f	class:itpp::Hamming_Code	access:public	signature:() const
itpp::Hamming_Code::get_k	/usr/include/itpp/comm/hammcode.h	/^  short get_k() const { return k; };$/;"	f	class:itpp::Hamming_Code	access:public	signature:() const
itpp::Hamming_Code::get_n	/usr/include/itpp/comm/hammcode.h	/^  short get_n() const { return n; };$/;"	f	class:itpp::Hamming_Code	access:public	signature:() const
itpp::Hamming_Code::get_rate	/usr/include/itpp/comm/hammcode.h	/^  virtual double get_rate() const { return static_cast<double>(k) \/ n; };$/;"	f	class:itpp::Hamming_Code	access:public	signature:() const
itpp::Hamming_Code::k	/usr/include/itpp/comm/hammcode.h	/^  short n, k;$/;"	m	class:itpp::Hamming_Code	access:private
itpp::Hamming_Code::n	/usr/include/itpp/comm/hammcode.h	/^  short n, k;$/;"	m	class:itpp::Hamming_Code	access:private
itpp::Hamming_Code::~Hamming_Code	/usr/include/itpp/comm/hammcode.h	/^  virtual ~Hamming_Code() { }$/;"	f	class:itpp::Hamming_Code	access:public	signature:()
itpp::Histogram	/usr/include/itpp/stat/histogram.h	/^class Histogram$/;"	c	namespace:itpp
itpp::Histogram::Histogram	/usr/include/itpp/stat/histogram.h	/^  Histogram(Num_T from = Num_T(0), Num_T to = Num_T(99), int n_bins = 100);$/;"	p	class:itpp::Histogram	access:public	signature:(Num_T from = Num_T(0), Num_T to = Num_T(99), int n_bins = 100)
itpp::Histogram::Histogram	/usr/include/itpp/stat/histogram.h	/^inline Histogram<Num_T>::Histogram(Num_T from, Num_T to, int n_bins)$/;"	f	class:itpp::Histogram	signature:(Num_T from, Num_T to, int n_bins)
itpp::Histogram::bins	/usr/include/itpp/stat/histogram.h	/^  ivec bins;$/;"	m	class:itpp::Histogram	access:private
itpp::Histogram::bins_num	/usr/include/itpp/stat/histogram.h	/^  int bins_num() const { return num_bins; };$/;"	f	class:itpp::Histogram	access:public	signature:() const
itpp::Histogram::center_vals	/usr/include/itpp/stat/histogram.h	/^  Vec<Num_T> center_vals;$/;"	m	class:itpp::Histogram	access:private
itpp::Histogram::get_bin	/usr/include/itpp/stat/histogram.h	/^  int get_bin(int ix) const { return bins(ix); };$/;"	f	class:itpp::Histogram	access:public	signature:(int ix) const
itpp::Histogram::get_bin_center	/usr/include/itpp/stat/histogram.h	/^  Num_T get_bin_center(int ix) const { return center_vals(ix); };$/;"	f	class:itpp::Histogram	access:public	signature:(int ix) const
itpp::Histogram::get_bin_centers	/usr/include/itpp/stat/histogram.h	/^  Vec<Num_T> get_bin_centers() const { return center_vals; };$/;"	f	class:itpp::Histogram	access:public	signature:() const
itpp::Histogram::get_bin_left	/usr/include/itpp/stat/histogram.h	/^  Num_T get_bin_left(int ix) const { return lo_vals(ix); };$/;"	f	class:itpp::Histogram	access:public	signature:(int ix) const
itpp::Histogram::get_bin_lefts	/usr/include/itpp/stat/histogram.h	/^  Vec<Num_T> get_bin_lefts() const { return lo_vals; };$/;"	f	class:itpp::Histogram	access:public	signature:() const
itpp::Histogram::get_bin_right	/usr/include/itpp/stat/histogram.h	/^  Num_T get_bin_right(int ix) const { return hi_vals(ix); };$/;"	f	class:itpp::Histogram	access:public	signature:(int ix) const
itpp::Histogram::get_bin_rights	/usr/include/itpp/stat/histogram.h	/^  Vec<Num_T> get_bin_rights() const { return hi_vals; };$/;"	f	class:itpp::Histogram	access:public	signature:() const
itpp::Histogram::get_bins	/usr/include/itpp/stat/histogram.h	/^  ivec get_bins() const { return bins; };$/;"	f	class:itpp::Histogram	access:public	signature:() const
itpp::Histogram::get_cdf	/usr/include/itpp/stat/histogram.h	/^  vec get_cdf() const;$/;"	p	class:itpp::Histogram	access:public	signature:() const
itpp::Histogram::get_cdf	/usr/include/itpp/stat/histogram.h	/^inline vec Histogram<Num_T>::get_cdf() const$/;"	f	class:itpp::Histogram	signature:() const
itpp::Histogram::get_pdf	/usr/include/itpp/stat/histogram.h	/^  vec get_pdf() const;$/;"	p	class:itpp::Histogram	access:public	signature:() const
itpp::Histogram::get_pdf	/usr/include/itpp/stat/histogram.h	/^inline vec Histogram<Num_T>::get_pdf() const$/;"	f	class:itpp::Histogram	signature:() const
itpp::Histogram::hi_vals	/usr/include/itpp/stat/histogram.h	/^  Vec<Num_T> hi_vals;$/;"	m	class:itpp::Histogram	access:private
itpp::Histogram::lo_vals	/usr/include/itpp/stat/histogram.h	/^  Vec<Num_T> lo_vals;$/;"	m	class:itpp::Histogram	access:private
itpp::Histogram::num_bins	/usr/include/itpp/stat/histogram.h	/^  int num_bins;$/;"	m	class:itpp::Histogram	access:private
itpp::Histogram::reset	/usr/include/itpp/stat/histogram.h	/^  void reset() { trials_cnt = 0; bins.zeros(); };$/;"	f	class:itpp::Histogram	access:public	signature:()
itpp::Histogram::setup	/usr/include/itpp/stat/histogram.h	/^  void setup(Num_T from, Num_T to, int n_bins);$/;"	p	class:itpp::Histogram	access:public	signature:(Num_T from, Num_T to, int n_bins)
itpp::Histogram::setup	/usr/include/itpp/stat/histogram.h	/^inline void Histogram<Num_T>::setup(Num_T from, Num_T to, int n_bins)$/;"	f	class:itpp::Histogram	signature:(Num_T from, Num_T to, int n_bins)
itpp::Histogram::step	/usr/include/itpp/stat/histogram.h	/^  Num_T step;$/;"	m	class:itpp::Histogram	access:private
itpp::Histogram::trials_cnt	/usr/include/itpp/stat/histogram.h	/^  int trials_cnt;$/;"	m	class:itpp::Histogram	access:private
itpp::Histogram::trials_num	/usr/include/itpp/stat/histogram.h	/^  int trials_num() const {return trials_cnt;};$/;"	f	class:itpp::Histogram	access:public	signature:() const
itpp::Histogram::update	/usr/include/itpp/stat/histogram.h	/^  void update(Mat<Num_T> values);$/;"	p	class:itpp::Histogram	access:public	signature:(Mat<Num_T> values)
itpp::Histogram::update	/usr/include/itpp/stat/histogram.h	/^  void update(Num_T value);$/;"	p	class:itpp::Histogram	access:public	signature:(Num_T value)
itpp::Histogram::update	/usr/include/itpp/stat/histogram.h	/^  void update(Vec<Num_T> values);$/;"	p	class:itpp::Histogram	access:public	signature:(Vec<Num_T> values)
itpp::Histogram::update	/usr/include/itpp/stat/histogram.h	/^inline void Histogram<Num_T>::update(Mat<Num_T> values)$/;"	f	class:itpp::Histogram	signature:(Mat<Num_T> values)
itpp::Histogram::update	/usr/include/itpp/stat/histogram.h	/^inline void Histogram<Num_T>::update(Num_T value)$/;"	f	class:itpp::Histogram	signature:(Num_T value)
itpp::Histogram::update	/usr/include/itpp/stat/histogram.h	/^inline void Histogram<Num_T>::update(Vec<Num_T> values)$/;"	f	class:itpp::Histogram	signature:(Vec<Num_T> values)
itpp::Histogram::~Histogram	/usr/include/itpp/stat/histogram.h	/^  ~Histogram() {};$/;"	f	class:itpp::Histogram	access:public	signature:()
itpp::IFFT	/usr/include/itpp/comm/channel.h	/^enum CORRELATED_METHOD { Rice_MEDS, IFFT, FIR };$/;"	e	enum:itpp::CORRELATED_METHOD
itpp::IFFT_Fading_Generator	/usr/include/itpp/comm/channel.h	/^class IFFT_Fading_Generator : public Correlated_Fading_Generator$/;"	c	namespace:itpp	inherits:Correlated_Fading_Generator
itpp::IFFT_Fading_Generator::IFFT_Fading_Generator	/usr/include/itpp/comm/channel.h	/^  IFFT_Fading_Generator(double norm_doppler) :$/;"	f	class:itpp::IFFT_Fading_Generator	access:public	signature:(double norm_doppler)
itpp::IFFT_Fading_Generator::generate	/usr/include/itpp/comm/channel.h	/^  virtual void generate(int no_samples, cvec &output);$/;"	p	class:itpp::IFFT_Fading_Generator	access:public	signature:(int no_samples, cvec &output)
itpp::IFFT_Fading_Generator::generate_Jakes	/usr/include/itpp/comm/channel.h	/^  void generate_Jakes(int no_samples, cvec &output);$/;"	p	class:itpp::IFFT_Fading_Generator	access:protected	signature:(int no_samples, cvec &output)
itpp::IFFT_Fading_Generator::init	/usr/include/itpp/comm/channel.h	/^  virtual void init() { init_flag = true; }$/;"	f	class:itpp::IFFT_Fading_Generator	access:public	signature:()
itpp::IFFT_Fading_Generator::~IFFT_Fading_Generator	/usr/include/itpp/comm/channel.h	/^  virtual ~IFFT_Fading_Generator() {}$/;"	f	class:itpp::IFFT_Fading_Generator	access:public	signature:()
itpp::INSERTSORT	/usr/include/itpp/base/sort.h	/^                      INSERTSORT = 3$/;"	e	enum:itpp::SORTING_METHOD
itpp::INTROSORT	/usr/include/itpp/base/sort.h	/^enum SORTING_METHOD { INTROSORT = 0, QUICKSORT = 1, HEAPSORT = 2,$/;"	e	enum:itpp::SORTING_METHOD
itpp::ITU_Pedestrian_A	/usr/include/itpp/comm/channel.h	/^  ITU_Vehicular_A, ITU_Vehicular_B, ITU_Pedestrian_A, ITU_Pedestrian_B,$/;"	e	enum:itpp::CHANNEL_PROFILE
itpp::ITU_Pedestrian_B	/usr/include/itpp/comm/channel.h	/^  ITU_Vehicular_A, ITU_Vehicular_B, ITU_Pedestrian_A, ITU_Pedestrian_B,$/;"	e	enum:itpp::CHANNEL_PROFILE
itpp::ITU_Vehicular_A	/usr/include/itpp/comm/channel.h	/^  ITU_Vehicular_A, ITU_Vehicular_B, ITU_Pedestrian_A, ITU_Pedestrian_B,$/;"	e	enum:itpp::CHANNEL_PROFILE
itpp::ITU_Vehicular_B	/usr/include/itpp/comm/channel.h	/^  ITU_Vehicular_A, ITU_Vehicular_B, ITU_Pedestrian_A, ITU_Pedestrian_B,$/;"	e	enum:itpp::CHANNEL_PROFILE
itpp::I_Uniform_RNG	/usr/include/itpp/base/random.h	/^class I_Uniform_RNG$/;"	c	namespace:itpp
itpp::I_Uniform_RNG::I_Uniform_RNG	/usr/include/itpp/base/random.h	/^  I_Uniform_RNG(int min = 0, int max = 1);$/;"	p	class:itpp::I_Uniform_RNG	access:public	signature:(int min = 0, int max = 1)
itpp::I_Uniform_RNG::RNG	/usr/include/itpp/base/random.h	/^  Random_Generator RNG;$/;"	m	class:itpp::I_Uniform_RNG	access:private
itpp::I_Uniform_RNG::get_setup	/usr/include/itpp/base/random.h	/^  void get_setup(int &min, int &max) const;$/;"	p	class:itpp::I_Uniform_RNG	access:public	signature:(int &min, int &max) const
itpp::I_Uniform_RNG::hi	/usr/include/itpp/base/random.h	/^  int hi;$/;"	m	class:itpp::I_Uniform_RNG	access:private
itpp::I_Uniform_RNG::lo	/usr/include/itpp/base/random.h	/^  int lo;$/;"	m	class:itpp::I_Uniform_RNG	access:private
itpp::I_Uniform_RNG::operator ()	/usr/include/itpp/base/random.h	/^  imat operator()(int h, int w);$/;"	p	class:itpp::I_Uniform_RNG	access:public	signature:(int h, int w)
itpp::I_Uniform_RNG::operator ()	/usr/include/itpp/base/random.h	/^  int operator()() { return sample(); }$/;"	f	class:itpp::I_Uniform_RNG	access:public	signature:()
itpp::I_Uniform_RNG::operator ()	/usr/include/itpp/base/random.h	/^  ivec operator()(int n);$/;"	p	class:itpp::I_Uniform_RNG	access:public	signature:(int n)
itpp::I_Uniform_RNG::sample	/usr/include/itpp/base/random.h	/^  int sample() { return (floor_i(RNG.random_01() * (hi - lo + 1)) + lo); }$/;"	f	class:itpp::I_Uniform_RNG	access:public	signature:()
itpp::I_Uniform_RNG::setup	/usr/include/itpp/base/random.h	/^  void setup(int min, int max);$/;"	p	class:itpp::I_Uniform_RNG	access:public	signature:(int min, int max)
itpp::Impulse_Source	/usr/include/itpp/signal/source.h	/^class Impulse_Source$/;"	c	namespace:itpp
itpp::Impulse_Source::A	/usr/include/itpp/signal/source.h	/^  double A, pos, dtheta;$/;"	m	class:itpp::Impulse_Source	access:private
itpp::Impulse_Source::Impulse_Source	/usr/include/itpp/signal/source.h	/^  Impulse_Source(double freq, double ampl = 1.0, double inphase = 0.0);$/;"	p	class:itpp::Impulse_Source	access:public	signature:(double freq, double ampl = 1.0, double inphase = 0.0)
itpp::Impulse_Source::dtheta	/usr/include/itpp/signal/source.h	/^  double A, pos, dtheta;$/;"	m	class:itpp::Impulse_Source	access:private
itpp::Impulse_Source::operator ()	/usr/include/itpp/signal/source.h	/^  double operator()() { return sample(); }$/;"	f	class:itpp::Impulse_Source	access:public	signature:()
itpp::Impulse_Source::operator ()	/usr/include/itpp/signal/source.h	/^  mat operator()(int h, int w);$/;"	p	class:itpp::Impulse_Source	access:public	signature:(int h, int w)
itpp::Impulse_Source::operator ()	/usr/include/itpp/signal/source.h	/^  vec operator()(int n);$/;"	p	class:itpp::Impulse_Source	access:public	signature:(int n)
itpp::Impulse_Source::pos	/usr/include/itpp/signal/source.h	/^  double A, pos, dtheta;$/;"	m	class:itpp::Impulse_Source	access:private
itpp::Impulse_Source::sample	/usr/include/itpp/signal/source.h	/^  double sample();$/;"	p	class:itpp::Impulse_Source	access:private	signature:()
itpp::Independent	/usr/include/itpp/comm/channel.h	/^enum FADING_TYPE { Independent, Static, Correlated };$/;"	e	enum:itpp::FADING_TYPE
itpp::Independent_Fading_Generator	/usr/include/itpp/comm/channel.h	/^class Independent_Fading_Generator : public Fading_Generator$/;"	c	namespace:itpp	inherits:Fading_Generator
itpp::Independent_Fading_Generator::Independent_Fading_Generator	/usr/include/itpp/comm/channel.h	/^  Independent_Fading_Generator() : Fading_Generator() {}$/;"	f	class:itpp::Independent_Fading_Generator	access:public	signature:()
itpp::Independent_Fading_Generator::generate	/usr/include/itpp/comm/channel.h	/^  virtual void generate(int no_samples, cvec& output);$/;"	p	class:itpp::Independent_Fading_Generator	access:public	signature:(int no_samples, cvec& output)
itpp::Independent_Fading_Generator::init	/usr/include/itpp/comm/channel.h	/^  virtual void init() { init_flag = true; }$/;"	f	class:itpp::Independent_Fading_Generator	access:public	signature:()
itpp::Independent_Fading_Generator::~Independent_Fading_Generator	/usr/include/itpp/comm/channel.h	/^  virtual ~Independent_Fading_Generator() {}$/;"	f	class:itpp::Independent_Fading_Generator	access:public	signature:()
itpp::J	/usr/include/itpp/comm/channel.h	/^  Jakes = 0, J = 0, Classic = 0, C = 0,$/;"	e	enum:itpp::DOPPLER_SPECTRUM
itpp::Jakes	/usr/include/itpp/comm/channel.h	/^  Jakes = 0, J = 0, Classic = 0, C = 0,$/;"	e	enum:itpp::DOPPLER_SPECTRUM
itpp::L3_Packet_Info	/usr/include/itpp/protocol/packet.h	/^class L3_Packet_Info$/;"	c	namespace:itpp
itpp::L3_Packet_Info::L3_Packet_Info	/usr/include/itpp/protocol/packet.h	/^  L3_Packet_Info(Packet *packet) { timestamp = 0; pkt_pointer = packet; }$/;"	f	class:itpp::L3_Packet_Info	access:public	signature:(Packet *packet)
itpp::L3_Packet_Info::pkt_pointer	/usr/include/itpp/protocol/packet.h	/^  Packet *pkt_pointer;$/;"	m	class:itpp::L3_Packet_Info	access:public
itpp::L3_Packet_Info::timestamp	/usr/include/itpp/protocol/packet.h	/^  Ttype timestamp;$/;"	m	class:itpp::L3_Packet_Info	access:public
itpp::L3_Packet_Info::~L3_Packet_Info	/usr/include/itpp/protocol/packet.h	/^  ~L3_Packet_Info() {}$/;"	f	class:itpp::L3_Packet_Info	access:public	signature:()
itpp::LDPC_Code	/usr/include/itpp/comm/ldpc.h	/^class LDPC_Code : public Channel_Code$/;"	c	namespace:itpp	inherits:Channel_Code
itpp::LDPC_Code::C	/usr/include/itpp/comm/ldpc.h	/^  ivec C, V, sumX1, sumX2, iind, jind;$/;"	m	class:itpp::LDPC_Code	access:private
itpp::LDPC_Code::G	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Generator *G;  \/\/!< Generator object pointer$/;"	m	class:itpp::LDPC_Code	access:protected
itpp::LDPC_Code::G_defined	/usr/include/itpp/comm/ldpc.h	/^  bool G_defined;  \/\/!< true if generator is defined$/;"	m	class:itpp::LDPC_Code	access:protected
itpp::LDPC_Code::H_defined	/usr/include/itpp/comm/ldpc.h	/^  bool H_defined;  \/\/!< true if parity check matrix is defined$/;"	m	class:itpp::LDPC_Code	access:protected
itpp::LDPC_Code::LDPC_Code	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Code();$/;"	p	class:itpp::LDPC_Code	access:public	signature:()
itpp::LDPC_Code::LDPC_Code	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Code(const LDPC_Parity* const H, LDPC_Generator* const G = 0);$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const LDPC_Parity* const H, LDPC_Generator* const G = 0)
itpp::LDPC_Code::LDPC_Code	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Code(const std::string& filename, LDPC_Generator* const G = 0);$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const std::string& filename, LDPC_Generator* const G = 0)
itpp::LDPC_Code::V	/usr/include/itpp/comm/ldpc.h	/^  ivec C, V, sumX1, sumX2, iind, jind;$/;"	m	class:itpp::LDPC_Code	access:private
itpp::LDPC_Code::bp_decode	/usr/include/itpp/comm/ldpc.h	/^  int bp_decode(const QLLRvec &LLRin, QLLRvec &LLRout);$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const QLLRvec &LLRin, QLLRvec &LLRout)
itpp::LDPC_Code::dec_method	/usr/include/itpp/comm/ldpc.h	/^  std::string dec_method; \/\/!< Decoding method$/;"	m	class:itpp::LDPC_Code	access:protected
itpp::LDPC_Code::decode	/usr/include/itpp/comm/ldpc.h	/^  virtual bvec decode(const bvec &) {$/;"	f	class:itpp::LDPC_Code	access:public	signature:(const bvec &)
itpp::LDPC_Code::decode	/usr/include/itpp/comm/ldpc.h	/^  virtual bvec decode(const vec &llr_in);$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const vec &llr_in)
itpp::LDPC_Code::decode	/usr/include/itpp/comm/ldpc.h	/^  virtual void decode(const bvec &, bvec &) {$/;"	f	class:itpp::LDPC_Code	access:public	signature:(const bvec &, bvec &)
itpp::LDPC_Code::decode	/usr/include/itpp/comm/ldpc.h	/^  virtual void decode(const vec &llr_in, bvec &syst_bits);$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const vec &llr_in, bvec &syst_bits)
itpp::LDPC_Code::decode_soft_out	/usr/include/itpp/comm/ldpc.h	/^  vec decode_soft_out(const vec &llr_in);$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const vec &llr_in)
itpp::LDPC_Code::decode_soft_out	/usr/include/itpp/comm/ldpc.h	/^  void decode_soft_out(const vec &llr_in, vec &llr_out);$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const vec &llr_in, vec &llr_out)
itpp::LDPC_Code::decoder_parameterization	/usr/include/itpp/comm/ldpc.h	/^  void decoder_parameterization(const LDPC_Parity* const H);$/;"	p	class:itpp::LDPC_Code	access:protected	signature:(const LDPC_Parity* const H)
itpp::LDPC_Code::encode	/usr/include/itpp/comm/ldpc.h	/^  virtual bvec encode(const bvec &input);$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const bvec &input)
itpp::LDPC_Code::encode	/usr/include/itpp/comm/ldpc.h	/^  virtual void encode(const bvec &input, bvec &output);$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const bvec &input, bvec &output)
itpp::LDPC_Code::get_decoding_method	/usr/include/itpp/comm/ldpc.h	/^  std::string get_decoding_method() const { return dec_method; }$/;"	f	class:itpp::LDPC_Code	access:public	signature:() const
itpp::LDPC_Code::get_llrcalc	/usr/include/itpp/comm/ldpc.h	/^  LLR_calc_unit get_llrcalc() const { return llrcalc; }$/;"	f	class:itpp::LDPC_Code	access:public	signature:() const
itpp::LDPC_Code::get_ncheck	/usr/include/itpp/comm/ldpc.h	/^  int get_ncheck() const { return ncheck; }$/;"	f	class:itpp::LDPC_Code	access:public	signature:() const
itpp::LDPC_Code::get_nrof_iterations	/usr/include/itpp/comm/ldpc.h	/^  int get_nrof_iterations() const { return max_iters; }$/;"	f	class:itpp::LDPC_Code	access:public	signature:() const
itpp::LDPC_Code::get_nvar	/usr/include/itpp/comm/ldpc.h	/^  int get_nvar() const { return nvar; }$/;"	f	class:itpp::LDPC_Code	access:public	signature:() const
itpp::LDPC_Code::get_rate	/usr/include/itpp/comm/ldpc.h	/^  double get_rate() const {$/;"	f	class:itpp::LDPC_Code	access:public	signature:() const
itpp::LDPC_Code::iind	/usr/include/itpp/comm/ldpc.h	/^  ivec C, V, sumX1, sumX2, iind, jind;$/;"	m	class:itpp::LDPC_Code	access:private
itpp::LDPC_Code::integrity_check	/usr/include/itpp/comm/ldpc.h	/^  void integrity_check();$/;"	p	class:itpp::LDPC_Code	access:protected	signature:()
itpp::LDPC_Code::jind	/usr/include/itpp/comm/ldpc.h	/^  ivec C, V, sumX1, sumX2, iind, jind;$/;"	m	class:itpp::LDPC_Code	access:private
itpp::LDPC_Code::llrcalc	/usr/include/itpp/comm/ldpc.h	/^  LLR_calc_unit llrcalc; \/\/!< LLR calculation unit$/;"	m	class:itpp::LDPC_Code	access:protected
itpp::LDPC_Code::load_code	/usr/include/itpp/comm/ldpc.h	/^  void load_code(const std::string& filename, LDPC_Generator* const G = 0);$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const std::string& filename, LDPC_Generator* const G = 0)
itpp::LDPC_Code::max_iters	/usr/include/itpp/comm/ldpc.h	/^  int max_iters;  \/\/!< Maximum number of iterations$/;"	m	class:itpp::LDPC_Code	access:protected
itpp::LDPC_Code::mcv	/usr/include/itpp/comm/ldpc.h	/^  QLLRvec mvc, mcv;$/;"	m	class:itpp::LDPC_Code	access:private
itpp::LDPC_Code::mvc	/usr/include/itpp/comm/ldpc.h	/^  QLLRvec mvc, mcv;$/;"	m	class:itpp::LDPC_Code	access:private
itpp::LDPC_Code::ncheck	/usr/include/itpp/comm/ldpc.h	/^  int ncheck;   \/\/!< Number of check nodes$/;"	m	class:itpp::LDPC_Code	access:protected
itpp::LDPC_Code::nvar	/usr/include/itpp/comm/ldpc.h	/^  int nvar;   \/\/!< Number of variable nodes$/;"	m	class:itpp::LDPC_Code	access:protected
itpp::LDPC_Code::operator <<	/usr/include/itpp/comm/ldpc.h	/^  friend std::ostream &operator<<(std::ostream &os, const LDPC_Code &C);$/;"	p	class:itpp::LDPC_Code	access:friend	signature:(std::ostream &os, const LDPC_Code &C)
itpp::LDPC_Code::pisc	/usr/include/itpp/comm/ldpc.h	/^  bool pisc;   \/\/!< check syndrom before first iteration$/;"	m	class:itpp::LDPC_Code	access:protected
itpp::LDPC_Code::psc	/usr/include/itpp/comm/ldpc.h	/^  bool psc;   \/\/!< check syndrom after each iteration$/;"	m	class:itpp::LDPC_Code	access:protected
itpp::LDPC_Code::save_code	/usr/include/itpp/comm/ldpc.h	/^  void save_code(const std::string& filename) const;$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const std::string& filename) const
itpp::LDPC_Code::set_code	/usr/include/itpp/comm/ldpc.h	/^  void set_code(const LDPC_Parity* const H, LDPC_Generator* const G = 0);$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const LDPC_Parity* const H, LDPC_Generator* const G = 0)
itpp::LDPC_Code::set_decoding_method	/usr/include/itpp/comm/ldpc.h	/^  void set_decoding_method(const std::string& method);$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const std::string& method)
itpp::LDPC_Code::set_exit_conditions	/usr/include/itpp/comm/ldpc.h	/^  void set_exit_conditions(int max_iters,$/;"	p	class:itpp::LDPC_Code	access:public	signature:(int max_iters, bool syndr_check_each_iter = true, bool syndr_check_at_start = false)
itpp::LDPC_Code::set_llrcalc	/usr/include/itpp/comm/ldpc.h	/^  void set_llrcalc(const LLR_calc_unit& llrcalc);$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const LLR_calc_unit& llrcalc)
itpp::LDPC_Code::setup_decoder	/usr/include/itpp/comm/ldpc.h	/^  void setup_decoder();$/;"	p	class:itpp::LDPC_Code	access:protected	signature:()
itpp::LDPC_Code::sumX1	/usr/include/itpp/comm/ldpc.h	/^  ivec C, V, sumX1, sumX2, iind, jind;$/;"	m	class:itpp::LDPC_Code	access:private
itpp::LDPC_Code::sumX2	/usr/include/itpp/comm/ldpc.h	/^  ivec C, V, sumX1, sumX2, iind, jind;$/;"	m	class:itpp::LDPC_Code	access:private
itpp::LDPC_Code::syndrome_check	/usr/include/itpp/comm/ldpc.h	/^  bool syndrome_check(const QLLRvec &LLR) const;$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const QLLRvec &LLR) const
itpp::LDPC_Code::syndrome_check	/usr/include/itpp/comm/ldpc.h	/^  bool syndrome_check(const bvec &b) const;$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const bvec &b) const
itpp::LDPC_Code::~LDPC_Code	/usr/include/itpp/comm/ldpc.h	/^  virtual ~LDPC_Code() {}$/;"	f	class:itpp::LDPC_Code	access:public	signature:()
itpp::LDPC_Generator	/usr/include/itpp/comm/ldpc.h	/^class LDPC_Generator$/;"	c	namespace:itpp
itpp::LDPC_Generator::LDPC_Generator	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Generator(const std::string& type_in = ""): init_flag(false),$/;"	f	class:itpp::LDPC_Generator	access:public	signature:(const std::string& type_in = Ó)
itpp::LDPC_Generator::encode	/usr/include/itpp/comm/ldpc.h	/^  virtual void encode(const bvec &input, bvec &output) = 0;$/;"	p	class:itpp::LDPC_Generator	access:public	signature:(const bvec &input, bvec &output)
itpp::LDPC_Generator::get_type	/usr/include/itpp/comm/ldpc.h	/^  std::string get_type() const { return type; }$/;"	f	class:itpp::LDPC_Generator	access:public	signature:() const
itpp::LDPC_Generator::init_flag	/usr/include/itpp/comm/ldpc.h	/^  bool init_flag;  \/\/!< True if generator is initialized$/;"	m	class:itpp::LDPC_Generator	access:protected
itpp::LDPC_Generator::load	/usr/include/itpp/comm/ldpc.h	/^  virtual void load(const std::string& filename) = 0;$/;"	p	class:itpp::LDPC_Generator	access:protected	signature:(const std::string& filename)
itpp::LDPC_Generator::save	/usr/include/itpp/comm/ldpc.h	/^  virtual void save(const std::string& filename) const = 0;$/;"	p	class:itpp::LDPC_Generator	access:protected	signature:(const std::string& filename) const
itpp::LDPC_Generator::type	/usr/include/itpp/comm/ldpc.h	/^  std::string type;  \/\/!< Generator type$/;"	m	class:itpp::LDPC_Generator	access:protected
itpp::LDPC_Generator::~LDPC_Generator	/usr/include/itpp/comm/ldpc.h	/^  virtual ~LDPC_Generator() {}$/;"	f	class:itpp::LDPC_Generator	access:public	signature:()
itpp::LDPC_Generator_Systematic	/usr/include/itpp/comm/ldpc.h	/^class LDPC_Generator_Systematic : public LDPC_Generator$/;"	c	namespace:itpp	inherits:LDPC_Generator
itpp::LDPC_Generator_Systematic::G	/usr/include/itpp/comm/ldpc.h	/^  GF2mat G; \/\/ the matrix is stored in transposed form$/;"	m	class:itpp::LDPC_Generator_Systematic	access:private
itpp::LDPC_Generator_Systematic::LDPC_Generator_Systematic	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Generator_Systematic(): LDPC_Generator("systematic"), G() {}$/;"	f	class:itpp::LDPC_Generator_Systematic	access:public	signature:()
itpp::LDPC_Generator_Systematic::LDPC_Generator_Systematic	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Generator_Systematic(LDPC_Parity* const H,$/;"	p	class:itpp::LDPC_Generator_Systematic	access:public	signature:(LDPC_Parity* const H, bool natural_ordering = false, const ivec& ind = Ó)
itpp::LDPC_Generator_Systematic::construct	/usr/include/itpp/comm/ldpc.h	/^  ivec construct(LDPC_Parity* const H, bool natural_ordering = false,$/;"	p	class:itpp::LDPC_Generator_Systematic	access:public	signature:(LDPC_Parity* const H, bool natural_ordering = false, const ivec& ind = Ó)
itpp::LDPC_Generator_Systematic::encode	/usr/include/itpp/comm/ldpc.h	/^  virtual void encode(const bvec &input, bvec &output);$/;"	p	class:itpp::LDPC_Generator_Systematic	access:public	signature:(const bvec &input, bvec &output)
itpp::LDPC_Generator_Systematic::load	/usr/include/itpp/comm/ldpc.h	/^  virtual void load(const std::string& filename);$/;"	p	class:itpp::LDPC_Generator_Systematic	access:protected	signature:(const std::string& filename)
itpp::LDPC_Generator_Systematic::save	/usr/include/itpp/comm/ldpc.h	/^  virtual void save(const std::string& filename) const;$/;"	p	class:itpp::LDPC_Generator_Systematic	access:protected	signature:(const std::string& filename) const
itpp::LDPC_Generator_Systematic::~LDPC_Generator_Systematic	/usr/include/itpp/comm/ldpc.h	/^  virtual ~LDPC_Generator_Systematic() {}$/;"	f	class:itpp::LDPC_Generator_Systematic	access:public	signature:()
itpp::LDPC_Parity	/usr/include/itpp/comm/ldpc.h	/^class LDPC_Parity$/;"	c	namespace:itpp
itpp::LDPC_Parity::H	/usr/include/itpp/comm/ldpc.h	/^  GF2mat_sparse H;$/;"	m	class:itpp::LDPC_Parity	access:protected
itpp::LDPC_Parity::Ht	/usr/include/itpp/comm/ldpc.h	/^  GF2mat_sparse Ht;$/;"	m	class:itpp::LDPC_Parity	access:protected
itpp::LDPC_Parity::LDPC_Parity	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Parity(): init_flag(false) {}$/;"	f	class:itpp::LDPC_Parity	access:public	signature:()
itpp::LDPC_Parity::LDPC_Parity	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Parity(const GF2mat_sparse_alist& alist);$/;"	p	class:itpp::LDPC_Parity	access:public	signature:(const GF2mat_sparse_alist& alist)
itpp::LDPC_Parity::LDPC_Parity	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Parity(const std::string& filename, const std::string& format);$/;"	p	class:itpp::LDPC_Parity	access:public	signature:(const std::string& filename, const std::string& format)
itpp::LDPC_Parity::LDPC_Parity	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Parity(int ncheck, int nvar);$/;"	p	class:itpp::LDPC_Parity	access:public	signature:(int ncheck, int nvar)
itpp::LDPC_Parity::Nmax	/usr/include/itpp/comm/ldpc.h	/^  static const int Nmax = 200;$/;"	m	class:itpp::LDPC_Parity	access:protected
itpp::LDPC_Parity::check_connectivity	/usr/include/itpp/comm/ldpc.h	/^  int check_connectivity(int from_m, int from_n, int to_m, int to_n,$/;"	p	class:itpp::LDPC_Parity	access:protected	signature:(int from_m, int from_n, int to_m, int to_n, int g, int L) const
itpp::LDPC_Parity::check_for_cycles	/usr/include/itpp/comm/ldpc.h	/^  int check_for_cycles(int L) const;$/;"	p	class:itpp::LDPC_Parity	access:protected	signature:(int L) const
itpp::LDPC_Parity::display_stats	/usr/include/itpp/comm/ldpc.h	/^  virtual void display_stats() const;$/;"	p	class:itpp::LDPC_Parity	access:public	signature:() const
itpp::LDPC_Parity::export_alist	/usr/include/itpp/comm/ldpc.h	/^  GF2mat_sparse_alist export_alist() const;$/;"	p	class:itpp::LDPC_Parity	access:public	signature:() const
itpp::LDPC_Parity::get	/usr/include/itpp/comm/ldpc.h	/^  bin get(int i, int j) const {$/;"	f	class:itpp::LDPC_Parity	access:public	signature:(int i, int j) const
itpp::LDPC_Parity::get_H	/usr/include/itpp/comm/ldpc.h	/^  GF2mat_sparse get_H(bool transpose = false) const {$/;"	f	class:itpp::LDPC_Parity	access:public	signature:(bool transpose = false) const
itpp::LDPC_Parity::get_col	/usr/include/itpp/comm/ldpc.h	/^  Sparse_Vec<bin> get_col(int c) const { return H.get_col(c); }$/;"	f	class:itpp::LDPC_Parity	access:public	signature:(int c) const
itpp::LDPC_Parity::get_ncheck	/usr/include/itpp/comm/ldpc.h	/^  int get_ncheck() const {$/;"	f	class:itpp::LDPC_Parity	access:public	signature:() const
itpp::LDPC_Parity::get_nvar	/usr/include/itpp/comm/ldpc.h	/^  int get_nvar() const {$/;"	f	class:itpp::LDPC_Parity	access:public	signature:() const
itpp::LDPC_Parity::get_rate	/usr/include/itpp/comm/ldpc.h	/^  double get_rate() const {$/;"	f	class:itpp::LDPC_Parity	access:public	signature:() const
itpp::LDPC_Parity::get_row	/usr/include/itpp/comm/ldpc.h	/^  Sparse_Vec<bin> get_row(int r) const { return Ht.get_col(r); }$/;"	f	class:itpp::LDPC_Parity	access:public	signature:(int r) const
itpp::LDPC_Parity::import_alist	/usr/include/itpp/comm/ldpc.h	/^  void import_alist(const GF2mat_sparse_alist& H_alist);$/;"	p	class:itpp::LDPC_Parity	access:public	signature:(const GF2mat_sparse_alist& H_alist)
itpp::LDPC_Parity::init_flag	/usr/include/itpp/comm/ldpc.h	/^  bool init_flag;$/;"	m	class:itpp::LDPC_Parity	access:protected
itpp::LDPC_Parity::initialize	/usr/include/itpp/comm/ldpc.h	/^  void initialize(int ncheck, int nvar);$/;"	p	class:itpp::LDPC_Parity	access:public	signature:(int ncheck, int nvar)
itpp::LDPC_Parity::load_alist	/usr/include/itpp/comm/ldpc.h	/^  void load_alist(const std::string& alist_file);$/;"	p	class:itpp::LDPC_Parity	access:public	signature:(const std::string& alist_file)
itpp::LDPC_Parity::ncheck	/usr/include/itpp/comm/ldpc.h	/^  int ncheck;$/;"	m	class:itpp::LDPC_Parity	access:protected
itpp::LDPC_Parity::nvar	/usr/include/itpp/comm/ldpc.h	/^  int nvar;$/;"	m	class:itpp::LDPC_Parity	access:protected
itpp::LDPC_Parity::operator ()	/usr/include/itpp/comm/ldpc.h	/^  bin operator()(int i, int j) const {$/;"	f	class:itpp::LDPC_Parity	access:public	signature:(int i, int j) const
itpp::LDPC_Parity::save_alist	/usr/include/itpp/comm/ldpc.h	/^  void save_alist(const std::string& alist_file) const;$/;"	p	class:itpp::LDPC_Parity	access:public	signature:(const std::string& alist_file) const
itpp::LDPC_Parity::set	/usr/include/itpp/comm/ldpc.h	/^  void set(int i, int j, bin value);$/;"	p	class:itpp::LDPC_Parity	access:public	signature:(int i, int j, bin value)
itpp::LDPC_Parity::sumX1	/usr/include/itpp/comm/ldpc.h	/^  ivec sumX1;$/;"	m	class:itpp::LDPC_Parity	access:protected
itpp::LDPC_Parity::sumX2	/usr/include/itpp/comm/ldpc.h	/^  ivec sumX2;$/;"	m	class:itpp::LDPC_Parity	access:protected
itpp::LDPC_Parity::~LDPC_Parity	/usr/include/itpp/comm/ldpc.h	/^  virtual ~LDPC_Parity() {}$/;"	f	class:itpp::LDPC_Parity	access:public	signature:()
itpp::LDPC_Parity_Irregular	/usr/include/itpp/comm/ldpc.h	/^class LDPC_Parity_Irregular : public LDPC_Parity_Unstructured$/;"	c	namespace:itpp	inherits:LDPC_Parity_Unstructured
itpp::LDPC_Parity_Irregular::LDPC_Parity_Irregular	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Parity_Irregular() {}$/;"	f	class:itpp::LDPC_Parity_Irregular	access:public	signature:()
itpp::LDPC_Parity_Irregular::LDPC_Parity_Irregular	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Parity_Irregular(int Nvar, const vec& var_deg, const vec& chk_deg,$/;"	p	class:itpp::LDPC_Parity_Irregular	access:public	signature:(int Nvar, const vec& var_deg, const vec& chk_deg, const std::string& method = Ó, const ivec& options = Ó)
itpp::LDPC_Parity_Irregular::display_stats	/usr/include/itpp/comm/ldpc.h	/^  void display_stats() const { LDPC_Parity::display_stats(); }$/;"	f	class:itpp::LDPC_Parity_Irregular	access:public	signature:() const
itpp::LDPC_Parity_Irregular::generate	/usr/include/itpp/comm/ldpc.h	/^  void generate(int Nvar, const vec& var_deg, const vec& chk_deg,$/;"	p	class:itpp::LDPC_Parity_Irregular	access:public	signature:(int Nvar, const vec& var_deg, const vec& chk_deg, const std::string& method = Ó, const ivec& options = Ó)
itpp::LDPC_Parity_Regular	/usr/include/itpp/comm/ldpc.h	/^class LDPC_Parity_Regular : public LDPC_Parity_Unstructured$/;"	c	namespace:itpp	inherits:LDPC_Parity_Unstructured
itpp::LDPC_Parity_Regular::LDPC_Parity_Regular	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Parity_Regular() {}$/;"	f	class:itpp::LDPC_Parity_Regular	access:public	signature:()
itpp::LDPC_Parity_Regular::LDPC_Parity_Regular	/usr/include/itpp/comm/ldpc.h	/^  LDPC_Parity_Regular(int Nvar, int k, int l,$/;"	p	class:itpp::LDPC_Parity_Regular	access:public	signature:(int Nvar, int k, int l, const std::string& method = Ó, const ivec& options = Ó)
itpp::LDPC_Parity_Regular::display_stats	/usr/include/itpp/comm/ldpc.h	/^  void display_stats() const { LDPC_Parity::display_stats(); }$/;"	f	class:itpp::LDPC_Parity_Regular	access:public	signature:() const
itpp::LDPC_Parity_Regular::generate	/usr/include/itpp/comm/ldpc.h	/^  void generate(int Nvar, int k, int l,$/;"	p	class:itpp::LDPC_Parity_Regular	access:public	signature:(int Nvar, int k, int l, const std::string& method = Ó, const ivec& options = Ó)
itpp::LDPC_Parity_Unstructured	/usr/include/itpp/comm/ldpc.h	/^class LDPC_Parity_Unstructured : public LDPC_Parity$/;"	c	namespace:itpp	inherits:LDPC_Parity
itpp::LDPC_Parity_Unstructured::compute_CR	/usr/include/itpp/comm/ldpc.h	/^  void compute_CR(const vec& var_deg, const vec& chk_deg, const int Nvar,$/;"	p	class:itpp::LDPC_Parity_Unstructured	access:protected	signature:(const vec& var_deg, const vec& chk_deg, const int Nvar, ivec &C, ivec &R)
itpp::LDPC_Parity_Unstructured::cycle_removal_MGW	/usr/include/itpp/comm/ldpc.h	/^  int cycle_removal_MGW(int L);$/;"	p	class:itpp::LDPC_Parity_Unstructured	access:public	signature:(int L)
itpp::LDPC_Parity_Unstructured::display_stats	/usr/include/itpp/comm/ldpc.h	/^  virtual void display_stats() const = 0;$/;"	p	class:itpp::LDPC_Parity_Unstructured	access:public	signature:() const
itpp::LDPC_Parity_Unstructured::generate_random_H	/usr/include/itpp/comm/ldpc.h	/^  void generate_random_H(const ivec& C, const ivec& R, const ivec& cycopt);$/;"	p	class:itpp::LDPC_Parity_Unstructured	access:protected	signature:(const ivec& C, const ivec& R, const ivec& cycopt)
itpp::LFSR	/usr/include/itpp/comm/sequence.h	/^class LFSR$/;"	c	namespace:itpp
itpp::LFSR::Connections	/usr/include/itpp/comm/sequence.h	/^  bvec memory, Connections;$/;"	m	class:itpp::LFSR	access:private
itpp::LFSR::LFSR	/usr/include/itpp/comm/sequence.h	/^  LFSR(const bvec &connections);$/;"	p	class:itpp::LFSR	access:public	signature:(const bvec &connections)
itpp::LFSR::LFSR	/usr/include/itpp/comm/sequence.h	/^  LFSR(const ivec &connections);$/;"	p	class:itpp::LFSR	access:public	signature:(const ivec &connections)
itpp::LFSR::LFSR	/usr/include/itpp/comm/sequence.h	/^  LFSR(void) {};$/;"	f	class:itpp::LFSR	access:public	signature:(void)
itpp::LFSR::get_length	/usr/include/itpp/comm/sequence.h	/^  int get_length(void);$/;"	p	class:itpp::LFSR	access:public	signature:(void)
itpp::LFSR::get_length	/usr/include/itpp/comm/sequence.h	/^inline int LFSR::get_length(void) {return memory.size();}$/;"	f	class:itpp::LFSR	signature:(void)
itpp::LFSR::get_state	/usr/include/itpp/comm/sequence.h	/^  bvec get_state(void);$/;"	p	class:itpp::LFSR	access:public	signature:(void)
itpp::LFSR::get_state	/usr/include/itpp/comm/sequence.h	/^inline bvec LFSR::get_state(void) {return memory;}$/;"	f	class:itpp::LFSR	signature:(void)
itpp::LFSR::memory	/usr/include/itpp/comm/sequence.h	/^  bvec memory, Connections;$/;"	m	class:itpp::LFSR	access:private
itpp::LFSR::set_connections	/usr/include/itpp/comm/sequence.h	/^  void set_connections(const bvec &connections);$/;"	p	class:itpp::LFSR	access:public	signature:(const bvec &connections)
itpp::LFSR::set_connections	/usr/include/itpp/comm/sequence.h	/^  void set_connections(const ivec &connections);$/;"	p	class:itpp::LFSR	access:public	signature:(const ivec &connections)
itpp::LFSR::set_state	/usr/include/itpp/comm/sequence.h	/^  void set_state(const bvec &state);$/;"	p	class:itpp::LFSR	access:public	signature:(const bvec &state)
itpp::LFSR::set_state	/usr/include/itpp/comm/sequence.h	/^  void set_state(const ivec &state);$/;"	p	class:itpp::LFSR	access:public	signature:(const ivec &state)
itpp::LFSR::shift	/usr/include/itpp/comm/sequence.h	/^  bin shift(void);$/;"	p	class:itpp::LFSR	access:public	signature:(void)
itpp::LFSR::shift	/usr/include/itpp/comm/sequence.h	/^  bvec shift(int no_shifts);$/;"	p	class:itpp::LFSR	access:public	signature:(int no_shifts)
itpp::LFSR::shift	/usr/include/itpp/comm/sequence.h	/^inline bin LFSR::shift(void) {bin temp = memory * Connections;memory.shift_right(temp);return temp;}$/;"	f	class:itpp::LFSR	signature:(void)
itpp::LLR_calc_unit	/usr/include/itpp/comm/llr.h	/^class LLR_calc_unit$/;"	c	namespace:itpp
itpp::LLR_calc_unit::Boxplus	/usr/include/itpp/comm/llr.h	/^  QLLR Boxplus(QLLR a, QLLR b) const;$/;"	p	class:itpp::LLR_calc_unit	access:public	signature:(QLLR a, QLLR b) const
itpp::LLR_calc_unit::Dint1	/usr/include/itpp/comm/llr.h	/^  short int Dint1, Dint2, Dint3;$/;"	m	class:itpp::LLR_calc_unit	access:private
itpp::LLR_calc_unit::Dint2	/usr/include/itpp/comm/llr.h	/^  short int Dint1, Dint2, Dint3;$/;"	m	class:itpp::LLR_calc_unit	access:private
itpp::LLR_calc_unit::Dint3	/usr/include/itpp/comm/llr.h	/^  short int Dint1, Dint2, Dint3;$/;"	m	class:itpp::LLR_calc_unit	access:private
itpp::LLR_calc_unit::LLR_calc_unit	/usr/include/itpp/comm/llr.h	/^  LLR_calc_unit();$/;"	p	class:itpp::LLR_calc_unit	access:public	signature:()
itpp::LLR_calc_unit::LLR_calc_unit	/usr/include/itpp/comm/llr.h	/^  LLR_calc_unit(short int Dint1, short int Dint2, short int Dint3);$/;"	p	class:itpp::LLR_calc_unit	access:public	signature:(short int Dint1, short int Dint2, short int Dint3)
itpp::LLR_calc_unit::construct_logexp_table	/usr/include/itpp/comm/llr.h	/^  ivec construct_logexp_table();$/;"	p	class:itpp::LLR_calc_unit	access:private	signature:()
itpp::LLR_calc_unit::get_Dint	/usr/include/itpp/comm/llr.h	/^  ivec get_Dint();$/;"	p	class:itpp::LLR_calc_unit	access:public	signature:()
itpp::LLR_calc_unit::init_llr_tables	/usr/include/itpp/comm/llr.h	/^  void init_llr_tables(short int Dint1 = 12, short int Dint2 = 300,$/;"	p	class:itpp::LLR_calc_unit	access:public	signature:(short int Dint1 = 12, short int Dint2 = 300, short int Dint3 = 7)
itpp::LLR_calc_unit::jaclog	/usr/include/itpp/comm/llr.h	/^  inline QLLR jaclog(QLLR a, QLLR b) const;$/;"	p	class:itpp::LLR_calc_unit	access:public	signature:(QLLR a, QLLR b) const
itpp::LLR_calc_unit::jaclog	/usr/include/itpp/comm/llr.h	/^inline QLLR LLR_calc_unit::jaclog(QLLR a, QLLR b) const$/;"	f	class:itpp::LLR_calc_unit	signature:(QLLR a, QLLR b) const
itpp::LLR_calc_unit::logexp	/usr/include/itpp/comm/llr.h	/^  inline QLLR logexp(QLLR x) const;$/;"	p	class:itpp::LLR_calc_unit	access:public	signature:(QLLR x) const
itpp::LLR_calc_unit::logexp	/usr/include/itpp/comm/llr.h	/^inline QLLR LLR_calc_unit::logexp(QLLR x) const$/;"	f	class:itpp::LLR_calc_unit	signature:(QLLR x) const
itpp::LLR_calc_unit::logexp_table	/usr/include/itpp/comm/llr.h	/^  ivec logexp_table;$/;"	m	class:itpp::LLR_calc_unit	access:private
itpp::LLR_calc_unit::operator <<	/usr/include/itpp/comm/llr.h	/^  friend std::ostream &operator<<(std::ostream &os, const LLR_calc_unit &l);$/;"	p	class:itpp::LLR_calc_unit	access:friend	signature:(std::ostream &os, const LLR_calc_unit &l)
itpp::LLR_calc_unit::to_double	/usr/include/itpp/comm/llr.h	/^  double to_double(QLLR l) const;$/;"	p	class:itpp::LLR_calc_unit	access:public	signature:(QLLR l) const
itpp::LLR_calc_unit::to_double	/usr/include/itpp/comm/llr.h	/^  mat to_double(const QLLRmat &l) const;$/;"	p	class:itpp::LLR_calc_unit	access:public	signature:(const QLLRmat &l) const
itpp::LLR_calc_unit::to_double	/usr/include/itpp/comm/llr.h	/^  vec to_double(const QLLRvec &l) const;$/;"	p	class:itpp::LLR_calc_unit	access:public	signature:(const QLLRvec &l) const
itpp::LLR_calc_unit::to_double	/usr/include/itpp/comm/llr.h	/^inline double LLR_calc_unit::to_double(QLLR l) const$/;"	f	class:itpp::LLR_calc_unit	signature:(QLLR l) const
itpp::LLR_calc_unit::to_qllr	/usr/include/itpp/comm/llr.h	/^  QLLR to_qllr(double l) const;$/;"	p	class:itpp::LLR_calc_unit	access:public	signature:(double l) const
itpp::LLR_calc_unit::to_qllr	/usr/include/itpp/comm/llr.h	/^  QLLRmat to_qllr(const mat &l) const;$/;"	p	class:itpp::LLR_calc_unit	access:public	signature:(const mat &l) const
itpp::LLR_calc_unit::to_qllr	/usr/include/itpp/comm/llr.h	/^  QLLRvec to_qllr(const vec &l) const;$/;"	p	class:itpp::LLR_calc_unit	access:public	signature:(const vec &l) const
itpp::LLR_calc_unit::to_qllr	/usr/include/itpp/comm/llr.h	/^inline QLLR LLR_calc_unit::to_qllr(double l) const$/;"	f	class:itpp::LLR_calc_unit	signature:(double l) const
itpp::LOGMAP	/usr/include/itpp/comm/modulator.h	/^  LOGMAP,   \/\/!< Log-MAP full calculation$/;"	e	enum:itpp::Soft_Method
itpp::Laplace_RNG	/usr/include/itpp/base/random.h	/^class Laplace_RNG$/;"	c	namespace:itpp
itpp::Laplace_RNG::Laplace_RNG	/usr/include/itpp/base/random.h	/^  Laplace_RNG(double meanval = 0.0, double variance = 1.0);$/;"	p	class:itpp::Laplace_RNG	access:public	signature:(double meanval = 0.0, double variance = 1.0)
itpp::Laplace_RNG::RNG	/usr/include/itpp/base/random.h	/^  Random_Generator RNG;$/;"	m	class:itpp::Laplace_RNG	access:private
itpp::Laplace_RNG::get_setup	/usr/include/itpp/base/random.h	/^  void get_setup(double &meanval, double &variance) const;$/;"	p	class:itpp::Laplace_RNG	access:public	signature:(double &meanval, double &variance) const
itpp::Laplace_RNG::mean	/usr/include/itpp/base/random.h	/^  double mean, var, sqrt_12var;$/;"	m	class:itpp::Laplace_RNG	access:private
itpp::Laplace_RNG::operator ()	/usr/include/itpp/base/random.h	/^  double operator()() { return sample(); }$/;"	f	class:itpp::Laplace_RNG	access:public	signature:()
itpp::Laplace_RNG::operator ()	/usr/include/itpp/base/random.h	/^  mat operator()(int h, int w);$/;"	p	class:itpp::Laplace_RNG	access:public	signature:(int h, int w)
itpp::Laplace_RNG::operator ()	/usr/include/itpp/base/random.h	/^  vec operator()(int n);$/;"	p	class:itpp::Laplace_RNG	access:public	signature:(int n)
itpp::Laplace_RNG::sample	/usr/include/itpp/base/random.h	/^  double sample() {$/;"	f	class:itpp::Laplace_RNG	access:public	signature:()
itpp::Laplace_RNG::setup	/usr/include/itpp/base/random.h	/^  void setup(double meanval, double variance);$/;"	p	class:itpp::Laplace_RNG	access:public	signature:(double meanval, double variance)
itpp::Laplace_RNG::sqrt_12var	/usr/include/itpp/base/random.h	/^  double mean, var, sqrt_12var;$/;"	m	class:itpp::Laplace_RNG	access:private
itpp::Laplace_RNG::var	/usr/include/itpp/base/random.h	/^  double mean, var, sqrt_12var;$/;"	m	class:itpp::Laplace_RNG	access:private
itpp::Line_Search	/usr/include/itpp/optim/newton_search.h	/^class Line_Search$/;"	c	namespace:itpp
itpp::Line_Search::F_end	/usr/include/itpp/optim/newton_search.h	/^  double F_end;$/;"	m	class:itpp::Line_Search	access:private
itpp::Line_Search::F_start	/usr/include/itpp/optim/newton_search.h	/^  double F_start;$/;"	m	class:itpp::Line_Search	access:private
itpp::Line_Search::F_values	/usr/include/itpp/optim/newton_search.h	/^  vec alpha_values, F_values, dF_values;$/;"	m	class:itpp::Line_Search	access:private
itpp::Line_Search::Line_Search	/usr/include/itpp/optim/newton_search.h	/^  Line_Search();$/;"	p	class:itpp::Line_Search	access:public	signature:()
itpp::Line_Search::alpha	/usr/include/itpp/optim/newton_search.h	/^  double alpha; \/\/ end value of alpha, info(1)$/;"	m	class:itpp::Line_Search	access:private
itpp::Line_Search::alpha_values	/usr/include/itpp/optim/newton_search.h	/^  vec alpha_values, F_values, dF_values;$/;"	m	class:itpp::Line_Search	access:private
itpp::Line_Search::dF_values	/usr/include/itpp/optim/newton_search.h	/^  vec alpha_values, F_values, dF_values;$/;"	m	class:itpp::Line_Search	access:private
itpp::Line_Search::df_dx	/usr/include/itpp/optim/newton_search.h	/^  vec(*df_dx)(const vec&);  \/\/ df\/dx, gradient of f$/;"	m	class:itpp::Line_Search	access:private
itpp::Line_Search::disable_trace	/usr/include/itpp/optim/newton_search.h	/^  void disable_trace() { trace = false; }$/;"	f	class:itpp::Line_Search	access:public	signature:()
itpp::Line_Search::enable_trace	/usr/include/itpp/optim/newton_search.h	/^  void enable_trace() { trace = true; }$/;"	f	class:itpp::Line_Search	access:public	signature:()
itpp::Line_Search::f	/usr/include/itpp/optim/newton_search.h	/^  double(*f)(const vec&);  \/\/ function to minimize$/;"	m	class:itpp::Line_Search	access:private
itpp::Line_Search::finished	/usr/include/itpp/optim/newton_search.h	/^  bool finished; \/\/ true if functions and starting points are set$/;"	m	class:itpp::Line_Search	access:private
itpp::Line_Search::g_end	/usr/include/itpp/optim/newton_search.h	/^  vec x_end, g_end;$/;"	m	class:itpp::Line_Search	access:private
itpp::Line_Search::g_start	/usr/include/itpp/optim/newton_search.h	/^  vec x_start, g_start, h_start;$/;"	m	class:itpp::Line_Search	access:private
itpp::Line_Search::get_alpha	/usr/include/itpp/optim/newton_search.h	/^  double get_alpha();$/;"	p	class:itpp::Line_Search	access:public	signature:()
itpp::Line_Search::get_beta	/usr/include/itpp/optim/newton_search.h	/^  double get_beta() { return stop_beta; }$/;"	f	class:itpp::Line_Search	access:public	signature:()
itpp::Line_Search::get_max_iterations	/usr/include/itpp/optim/newton_search.h	/^  int get_max_iterations() { return max_iterations; }$/;"	f	class:itpp::Line_Search	access:public	signature:()
itpp::Line_Search::get_max_stepsize	/usr/include/itpp/optim/newton_search.h	/^  double get_max_stepsize() { return max_stepsize; }$/;"	f	class:itpp::Line_Search	access:public	signature:()
itpp::Line_Search::get_no_function_evaluations	/usr/include/itpp/optim/newton_search.h	/^  int get_no_function_evaluations();$/;"	p	class:itpp::Line_Search	access:public	signature:()
itpp::Line_Search::get_rho	/usr/include/itpp/optim/newton_search.h	/^  double get_rho() { return stop_rho; }$/;"	f	class:itpp::Line_Search	access:public	signature:()
itpp::Line_Search::get_slope_ratio	/usr/include/itpp/optim/newton_search.h	/^  double get_slope_ratio();$/;"	p	class:itpp::Line_Search	access:public	signature:()
itpp::Line_Search::get_solution	/usr/include/itpp/optim/newton_search.h	/^  void get_solution(vec &xn, double &Fn, vec &gn);$/;"	p	class:itpp::Line_Search	access:public	signature:(vec &xn, double &Fn, vec &gn)
itpp::Line_Search::get_trace	/usr/include/itpp/optim/newton_search.h	/^  void get_trace(vec &alphavalues, vec &Fvalues, vec &dFvalues);$/;"	p	class:itpp::Line_Search	access:public	signature:(vec &alphavalues, vec &Fvalues, vec &dFvalues)
itpp::Line_Search::h_start	/usr/include/itpp/optim/newton_search.h	/^  vec x_start, g_start, h_start;$/;"	m	class:itpp::Line_Search	access:private
itpp::Line_Search::init	/usr/include/itpp/optim/newton_search.h	/^  bool init; \/\/ true if functions and starting points are set$/;"	m	class:itpp::Line_Search	access:private
itpp::Line_Search::max_iterations	/usr/include/itpp/optim/newton_search.h	/^  int max_iterations; \/\/ opts(4)$/;"	m	class:itpp::Line_Search	access:private
itpp::Line_Search::max_stepsize	/usr/include/itpp/optim/newton_search.h	/^  double max_stepsize; \/\/ opts(5)$/;"	m	class:itpp::Line_Search	access:private
itpp::Line_Search::method	/usr/include/itpp/optim/newton_search.h	/^  Line_Search_Method method;$/;"	m	class:itpp::Line_Search	access:private
itpp::Line_Search::n	/usr/include/itpp/optim/newton_search.h	/^  int n; \/\/ dimension of problem, size(x)$/;"	m	class:itpp::Line_Search	access:private
itpp::Line_Search::no_feval	/usr/include/itpp/optim/newton_search.h	/^  int no_feval; \/\/ info(3)$/;"	m	class:itpp::Line_Search	access:private
itpp::Line_Search::search	/usr/include/itpp/optim/newton_search.h	/^  bool search();$/;"	p	class:itpp::Line_Search	access:public	signature:()
itpp::Line_Search::search	/usr/include/itpp/optim/newton_search.h	/^  bool search(const vec &x, double F, const vec &g, const vec &h, vec &xn,$/;"	p	class:itpp::Line_Search	access:public	signature:(const vec &x, double F, const vec &g, const vec &h, vec &xn, double &Fn, vec &gn)
itpp::Line_Search::search	/usr/include/itpp/optim/newton_search.h	/^  bool search(vec &xn, double &Fn, vec &gn);$/;"	p	class:itpp::Line_Search	access:public	signature:(vec &xn, double &Fn, vec &gn)
itpp::Line_Search::set_function	/usr/include/itpp/optim/newton_search.h	/^  void set_function(double(*function)(const vec&));$/;"	p	class:itpp::Line_Search	access:public	signature:(double(*function)(const vec&))
itpp::Line_Search::set_functions	/usr/include/itpp/optim/newton_search.h	/^  void set_functions(double(*function)(const vec&), vec(*gradient)(const vec&)) { set_function(function); set_gradient(gradient); }$/;"	f	class:itpp::Line_Search	access:public	signature:(double(*function)(const vec&), vec(*gradient)(const vec&))
itpp::Line_Search::set_gradient	/usr/include/itpp/optim/newton_search.h	/^  void set_gradient(vec(*gradient)(const vec&));$/;"	p	class:itpp::Line_Search	access:public	signature:(vec(gradient)const vec&))
itpp::Line_Search::set_max_iterations	/usr/include/itpp/optim/newton_search.h	/^  void set_max_iterations(int value);$/;"	p	class:itpp::Line_Search	access:public	signature:(int value)
itpp::Line_Search::set_max_stepsize	/usr/include/itpp/optim/newton_search.h	/^  void set_max_stepsize(double value);$/;"	p	class:itpp::Line_Search	access:public	signature:(double value)
itpp::Line_Search::set_method	/usr/include/itpp/optim/newton_search.h	/^  void set_method(const Line_Search_Method &method);$/;"	p	class:itpp::Line_Search	access:public	signature:(const Line_Search_Method &method)
itpp::Line_Search::set_start_point	/usr/include/itpp/optim/newton_search.h	/^  void set_start_point(const vec &x, double F, const vec &g, const vec &h);$/;"	p	class:itpp::Line_Search	access:public	signature:(const vec &x, double F, const vec &g, const vec &h)
itpp::Line_Search::set_stop_values	/usr/include/itpp/optim/newton_search.h	/^  void set_stop_values(double rho, double beta);$/;"	p	class:itpp::Line_Search	access:public	signature:(double rho, double beta)
itpp::Line_Search::slope_ratio	/usr/include/itpp/optim/newton_search.h	/^  double slope_ratio; \/\/ slope ratio at xn, info(2)$/;"	m	class:itpp::Line_Search	access:private
itpp::Line_Search::stop_beta	/usr/include/itpp/optim/newton_search.h	/^  double stop_beta; \/\/ opts(3)$/;"	m	class:itpp::Line_Search	access:private
itpp::Line_Search::stop_rho	/usr/include/itpp/optim/newton_search.h	/^  double stop_rho; \/\/ opts(2)$/;"	m	class:itpp::Line_Search	access:private
itpp::Line_Search::trace	/usr/include/itpp/optim/newton_search.h	/^  bool trace; \/\/ true if trace is enabled$/;"	m	class:itpp::Line_Search	access:private
itpp::Line_Search::x_end	/usr/include/itpp/optim/newton_search.h	/^  vec x_end, g_end;$/;"	m	class:itpp::Line_Search	access:private
itpp::Line_Search::x_start	/usr/include/itpp/optim/newton_search.h	/^  vec x_start, g_start, h_start;$/;"	m	class:itpp::Line_Search	access:private
itpp::Line_Search::~Line_Search	/usr/include/itpp/optim/newton_search.h	/^  ~Line_Search() {};$/;"	f	class:itpp::Line_Search	access:public	signature:()
itpp::Line_Search_Method	/usr/include/itpp/optim/newton_search.h	/^enum Line_Search_Method {Soft, Exact};$/;"	g	namespace:itpp
itpp::Link_Packet	/usr/include/itpp/protocol/packet.h	/^class Link_Packet : public Packet$/;"	c	namespace:itpp	inherits:Packet
itpp::Link_Packet::Link_Packet	/usr/include/itpp/protocol/packet.h	/^  Link_Packet(const int Seq_no, const unsigned long int Link_packet_id, L3_Packet_Info *Cp) { seq_no = Seq_no; link_packet_id = Link_packet_id; l3_pkt_info_p = Cp; }$/;"	f	class:itpp::Link_Packet	access:public	signature:(const int Seq_no, const unsigned long int Link_packet_id, L3_Packet_Info *Cp)
itpp::Link_Packet::l3_pkt_info_p	/usr/include/itpp/protocol/packet.h	/^  L3_Packet_Info *l3_pkt_info_p;$/;"	m	class:itpp::Link_Packet	access:public
itpp::Link_Packet::link_packet_id	/usr/include/itpp/protocol/packet.h	/^  unsigned long int link_packet_id;$/;"	m	class:itpp::Link_Packet	access:public
itpp::Link_Packet::seq_no	/usr/include/itpp/protocol/packet.h	/^  int seq_no;$/;"	m	class:itpp::Link_Packet	access:public
itpp::Link_Packet::~Link_Packet	/usr/include/itpp/protocol/packet.h	/^  ~Link_Packet() {}$/;"	f	class:itpp::Link_Packet	access:public	signature:()
itpp::MAX_WORDLEN	/usr/include/itpp/fixed/fix_base.h	/^const int MAX_WORDLEN = 64;$/;"	m	namespace:itpp
itpp::MA_Filter	/usr/include/itpp/signal/filter.h	/^class MA_Filter : public Filter<T1, T2, T3>$/;"	c	namespace:itpp	inherits:Filter
itpp::MA_Filter::MA_Filter	/usr/include/itpp/signal/filter.h	/^  explicit MA_Filter();$/;"	p	class:itpp::MA_Filter	access:public	signature:()
itpp::MA_Filter::MA_Filter	/usr/include/itpp/signal/filter.h	/^  explicit MA_Filter(const Vec<T2> &b);$/;"	p	class:itpp::MA_Filter	access:public	signature:(const Vec<T2> &b)
itpp::MA_Filter::MA_Filter	/usr/include/itpp/signal/filter.h	/^MA_Filter<T1, T2, T3>::MA_Filter() : Filter<T1, T2, T3>()$/;"	f	class:itpp::MA_Filter	signature:()
itpp::MA_Filter::MA_Filter	/usr/include/itpp/signal/filter.h	/^MA_Filter<T1, T2, T3>::MA_Filter(const Vec<T2> &b) : Filter<T1, T2, T3>()$/;"	f	class:itpp::MA_Filter	signature:(const Vec<T2> &b)
itpp::MA_Filter::clear	/usr/include/itpp/signal/filter.h	/^  void clear() { mem.clear(); }$/;"	f	class:itpp::MA_Filter	access:public	signature:()
itpp::MA_Filter::coeffs	/usr/include/itpp/signal/filter.h	/^  Vec<T2> coeffs;$/;"	m	class:itpp::MA_Filter	access:private
itpp::MA_Filter::filter	/usr/include/itpp/signal/filter.h	/^  virtual T3 filter(const T1 Sample);$/;"	p	class:itpp::MA_Filter	access:private	signature:(const T1 Sample)
itpp::MA_Filter::filter	/usr/include/itpp/signal/filter.h	/^T3 MA_Filter<T1, T2, T3>::filter(const T1 Sample)$/;"	f	class:itpp::MA_Filter	signature:(const T1 Sample)
itpp::MA_Filter::get_coeffs	/usr/include/itpp/signal/filter.h	/^  Vec<T2> get_coeffs() const { return coeffs; }$/;"	f	class:itpp::MA_Filter	access:public	signature:() const
itpp::MA_Filter::get_state	/usr/include/itpp/signal/filter.h	/^  Vec<T3> get_state() const;$/;"	p	class:itpp::MA_Filter	access:public	signature:() const
itpp::MA_Filter::get_state	/usr/include/itpp/signal/filter.h	/^Vec<T3> MA_Filter<T1, T2, T3>::get_state() const$/;"	f	class:itpp::MA_Filter	signature:() const
itpp::MA_Filter::init	/usr/include/itpp/signal/filter.h	/^  bool init;$/;"	m	class:itpp::MA_Filter	access:private
itpp::MA_Filter::inptr	/usr/include/itpp/signal/filter.h	/^  int inptr;$/;"	m	class:itpp::MA_Filter	access:private
itpp::MA_Filter::mem	/usr/include/itpp/signal/filter.h	/^  Vec<T3> mem;$/;"	m	class:itpp::MA_Filter	access:private
itpp::MA_Filter::set_coeffs	/usr/include/itpp/signal/filter.h	/^  void set_coeffs(const Vec<T2> &b);$/;"	p	class:itpp::MA_Filter	access:public	signature:(const Vec<T2> &b)
itpp::MA_Filter::set_coeffs	/usr/include/itpp/signal/filter.h	/^void MA_Filter<T1, T2, T3>::set_coeffs(const Vec<T2> &b)$/;"	f	class:itpp::MA_Filter	signature:(const Vec<T2> &b)
itpp::MA_Filter::set_state	/usr/include/itpp/signal/filter.h	/^  void set_state(const Vec<T3> &state);$/;"	p	class:itpp::MA_Filter	access:public	signature:(const Vec<T3> &state)
itpp::MA_Filter::set_state	/usr/include/itpp/signal/filter.h	/^void MA_Filter<T1, T2, T3>::set_state(const Vec<T3> &state)$/;"	f	class:itpp::MA_Filter	signature:(const Vec<T3> &state)
itpp::MA_Filter::~MA_Filter	/usr/include/itpp/signal/filter.h	/^  virtual ~MA_Filter() { }$/;"	f	class:itpp::MA_Filter	access:public	signature:()
itpp::MEDS	/usr/include/itpp/comm/channel.h	/^enum RICE_METHOD { MEDS };$/;"	e	enum:itpp::RICE_METHOD
itpp::MFD	/usr/include/itpp/comm/convcode.h	/^enum CONVOLUTIONAL_CODE_TYPE {MFD, ODS};$/;"	e	enum:itpp::CONVOLUTIONAL_CODE_TYPE
itpp::MOG_diag	/usr/include/itpp/stat/mog_diag.h	/^class MOG_diag : public MOG_generic$/;"	c	namespace:itpp	inherits:MOG_generic
itpp::MOG_diag::MOG_diag	/usr/include/itpp/stat/mog_diag.h	/^  MOG_diag() { zero_all_ptrs(); init(); }$/;"	f	class:itpp::MOG_diag	access:public	signature:()
itpp::MOG_diag::MOG_diag	/usr/include/itpp/stat/mog_diag.h	/^  MOG_diag(Array<vec> &means_in, Array<mat> &full_covs_in, vec &weights_in) { zero_all_ptrs(); init(means_in, full_covs_in, weights_in); convert_to_diag(); }$/;"	f	class:itpp::MOG_diag	access:public	signature:(Array<vec> &means_in, Array<mat> &full_covs_in, vec &weights_in)
itpp::MOG_diag::MOG_diag	/usr/include/itpp/stat/mog_diag.h	/^  MOG_diag(Array<vec> &means_in, Array<vec> &diag_covs_in, vec &weights_in) { zero_all_ptrs(); init(means_in, diag_covs_in, weights_in); }$/;"	f	class:itpp::MOG_diag	access:public	signature:(Array<vec> &means_in, Array<vec> &diag_covs_in, vec &weights_in)
itpp::MOG_diag::MOG_diag	/usr/include/itpp/stat/mog_diag.h	/^  MOG_diag(Array<vec> &means_in, bool) { zero_all_ptrs(); init(means_in, false);  }$/;"	f	class:itpp::MOG_diag	access:public	signature:(Array<vec> &means_in, bool)
itpp::MOG_diag::MOG_diag	/usr/include/itpp/stat/mog_diag.h	/^  MOG_diag(const int &K_in, const int &D_in, bool full_in = false) { zero_all_ptrs(); init(K_in, D_in, full_in); }$/;"	f	class:itpp::MOG_diag	access:public	signature:(const int &K_in, const int &D_in, bool full_in = false)
itpp::MOG_diag::MOG_diag	/usr/include/itpp/stat/mog_diag.h	/^  MOG_diag(const std::string &name) { zero_all_ptrs(); load(name); }$/;"	f	class:itpp::MOG_diag	access:public	signature:(const std::string &name)
itpp::MOG_diag::avg_log_lhood	/usr/include/itpp/stat/mog_diag.h	/^  double avg_log_lhood(const Array<vec> & X_in);$/;"	p	class:itpp::MOG_diag	access:public	signature:(const Array<vec> & X_in)
itpp::MOG_diag::avg_log_lhood	/usr/include/itpp/stat/mog_diag.h	/^  double avg_log_lhood(const double ** c_x_in, int N);$/;"	p	class:itpp::MOG_diag	access:public	signature:(const double ** c_x_in, int N)
itpp::MOG_diag::c_diag_covs	/usr/include/itpp/stat/mog_diag.h	/^  double ** c_diag_covs;$/;"	m	class:itpp::MOG_diag	access:protected
itpp::MOG_diag::c_diag_covs_inv_etc	/usr/include/itpp/stat/mog_diag.h	/^  double ** c_diag_covs_inv_etc;$/;"	m	class:itpp::MOG_diag	access:protected
itpp::MOG_diag::c_log_det_etc	/usr/include/itpp/stat/mog_diag.h	/^  double * c_log_det_etc;$/;"	m	class:itpp::MOG_diag	access:protected
itpp::MOG_diag::c_log_weights	/usr/include/itpp/stat/mog_diag.h	/^  double * c_log_weights;$/;"	m	class:itpp::MOG_diag	access:protected
itpp::MOG_diag::c_means	/usr/include/itpp/stat/mog_diag.h	/^  double ** c_means;$/;"	m	class:itpp::MOG_diag	access:protected
itpp::MOG_diag::c_tmpvecK	/usr/include/itpp/stat/mog_diag.h	/^  double * c_tmpvecK;$/;"	m	class:itpp::MOG_diag	access:private
itpp::MOG_diag::c_weights	/usr/include/itpp/stat/mog_diag.h	/^  double * c_weights;$/;"	m	class:itpp::MOG_diag	access:protected
itpp::MOG_diag::cleanup	/usr/include/itpp/stat/mog_diag.h	/^  void cleanup() { free_all_ptrs(); MOG_generic::cleanup(); }$/;"	f	class:itpp::MOG_diag	access:public	signature:()
itpp::MOG_diag::convert_to_full	/usr/include/itpp/stat/mog_diag.h	/^  void convert_to_full() {};$/;"	f	class:itpp::MOG_diag	access:public	signature:()
itpp::MOG_diag::disable_c_access	/usr/include/itpp/stat/mog_diag.h	/^  double * disable_c_access(double * v_in);$/;"	p	class:itpp::MOG_diag	access:protected	signature:(double * v_in)
itpp::MOG_diag::disable_c_access	/usr/include/itpp/stat/mog_diag.h	/^  double ** disable_c_access(double ** A_in);$/;"	p	class:itpp::MOG_diag	access:protected	signature:(double ** A_in)
itpp::MOG_diag::disable_c_access	/usr/include/itpp/stat/mog_diag.h	/^  int * disable_c_access(int * v_in);$/;"	p	class:itpp::MOG_diag	access:protected	signature:(int * v_in)
itpp::MOG_diag::disable_c_access	/usr/include/itpp/stat/mog_diag.h	/^  int ** disable_c_access(int ** A_in);$/;"	p	class:itpp::MOG_diag	access:protected	signature:(int ** A_in)
itpp::MOG_diag::enable_c_access	/usr/include/itpp/stat/mog_diag.h	/^  double * enable_c_access(vec & v_in);$/;"	p	class:itpp::MOG_diag	access:protected	signature:(vec & v_in)
itpp::MOG_diag::enable_c_access	/usr/include/itpp/stat/mog_diag.h	/^  double ** enable_c_access(Array<vec> & A_in);$/;"	p	class:itpp::MOG_diag	access:protected	signature:(Array<vec> & A_in)
itpp::MOG_diag::enable_c_access	/usr/include/itpp/stat/mog_diag.h	/^  int * enable_c_access(ivec & v_in);$/;"	p	class:itpp::MOG_diag	access:protected	signature:(ivec & v_in)
itpp::MOG_diag::enable_c_access	/usr/include/itpp/stat/mog_diag.h	/^  int ** enable_c_access(Array<ivec> & A_in);$/;"	p	class:itpp::MOG_diag	access:protected	signature:(Array<ivec> & A_in)
itpp::MOG_diag::free_all_ptrs	/usr/include/itpp/stat/mog_diag.h	/^  void free_all_ptrs();$/;"	p	class:itpp::MOG_diag	access:protected	signature:()
itpp::MOG_diag::lhood	/usr/include/itpp/stat/mog_diag.h	/^  double lhood(const double * c_x_in);$/;"	p	class:itpp::MOG_diag	access:public	signature:(const double * c_x_in)
itpp::MOG_diag::lhood	/usr/include/itpp/stat/mog_diag.h	/^  double lhood(const vec &x_in);$/;"	p	class:itpp::MOG_diag	access:public	signature:(const vec &x_in)
itpp::MOG_diag::lhood_internal	/usr/include/itpp/stat/mog_diag.h	/^  double lhood_internal(const double * c_x_in);$/;"	p	class:itpp::MOG_diag	access:protected	signature:(const double * c_x_in)
itpp::MOG_diag::lhood_internal	/usr/include/itpp/stat/mog_diag.h	/^  double lhood_internal(const vec &x_in);$/;"	p	class:itpp::MOG_diag	access:protected	signature:(const vec &x_in)
itpp::MOG_diag::load	/usr/include/itpp/stat/mog_diag.h	/^  void load(const std::string &name_in);$/;"	p	class:itpp::MOG_diag	access:public	signature:(const std::string &name_in)
itpp::MOG_diag::log_lhood	/usr/include/itpp/stat/mog_diag.h	/^  double log_lhood(const double * c_x_in);$/;"	p	class:itpp::MOG_diag	access:public	signature:(const double * c_x_in)
itpp::MOG_diag::log_lhood	/usr/include/itpp/stat/mog_diag.h	/^  double log_lhood(const vec &x_in);$/;"	p	class:itpp::MOG_diag	access:public	signature:(const vec &x_in)
itpp::MOG_diag::log_lhood_internal	/usr/include/itpp/stat/mog_diag.h	/^  double log_lhood_internal(const double * c_x_in);$/;"	p	class:itpp::MOG_diag	access:protected	signature:(const double * c_x_in)
itpp::MOG_diag::log_lhood_internal	/usr/include/itpp/stat/mog_diag.h	/^  double log_lhood_internal(const vec &x_in);$/;"	p	class:itpp::MOG_diag	access:protected	signature:(const vec &x_in)
itpp::MOG_diag::log_lhood_single_gaus	/usr/include/itpp/stat/mog_diag.h	/^  double log_lhood_single_gaus(const double * c_x_in, const int k) const;$/;"	p	class:itpp::MOG_diag	access:public	signature:(const double * c_x_in, const int k) const
itpp::MOG_diag::log_lhood_single_gaus	/usr/include/itpp/stat/mog_diag.h	/^  double log_lhood_single_gaus(const vec &x_in, const int k) const;$/;"	p	class:itpp::MOG_diag	access:public	signature:(const vec &x_in, const int k) const
itpp::MOG_diag::log_lhood_single_gaus_internal	/usr/include/itpp/stat/mog_diag.h	/^  double log_lhood_single_gaus_internal(const double * c_x_in, const int k) const;$/;"	p	class:itpp::MOG_diag	access:protected	signature:(const double * c_x_in, const int k) const
itpp::MOG_diag::log_lhood_single_gaus_internal	/usr/include/itpp/stat/mog_diag.h	/^  double log_lhood_single_gaus_internal(const vec &x_in, const int k) const;$/;"	p	class:itpp::MOG_diag	access:protected	signature:(const vec &x_in, const int k) const
itpp::MOG_diag::setup_covs	/usr/include/itpp/stat/mog_diag.h	/^  void setup_covs();$/;"	p	class:itpp::MOG_diag	access:protected	signature:()
itpp::MOG_diag::setup_means	/usr/include/itpp/stat/mog_diag.h	/^  void setup_means();$/;"	p	class:itpp::MOG_diag	access:protected	signature:()
itpp::MOG_diag::setup_misc	/usr/include/itpp/stat/mog_diag.h	/^  void setup_misc();$/;"	p	class:itpp::MOG_diag	access:protected	signature:()
itpp::MOG_diag::setup_weights	/usr/include/itpp/stat/mog_diag.h	/^  void setup_weights();$/;"	p	class:itpp::MOG_diag	access:protected	signature:()
itpp::MOG_diag::tmpvecK	/usr/include/itpp/stat/mog_diag.h	/^  vec tmpvecK;$/;"	m	class:itpp::MOG_diag	access:private
itpp::MOG_diag::zero_all_ptrs	/usr/include/itpp/stat/mog_diag.h	/^  void zero_all_ptrs();$/;"	p	class:itpp::MOG_diag	access:protected	signature:()
itpp::MOG_diag::~MOG_diag	/usr/include/itpp/stat/mog_diag.h	/^  ~MOG_diag() { cleanup(); }$/;"	f	class:itpp::MOG_diag	access:public	signature:()
itpp::MOG_diag_EM_sup	/usr/include/itpp/stat/mog_diag_em.h	/^class MOG_diag_EM_sup : public MOG_diag$/;"	c	namespace:itpp	inherits:MOG_diag
itpp::MOG_diag_EM_sup::MOG_diag_EM_sup	/usr/include/itpp/stat/mog_diag_em.h	/^  MOG_diag_EM_sup() { verbose = false; }$/;"	f	class:itpp::MOG_diag_EM_sup	access:public	signature:()
itpp::MOG_diag_EM_sup::N	/usr/include/itpp/stat/mog_diag_em.h	/^  int N;$/;"	m	class:itpp::MOG_diag_EM_sup	access:protected
itpp::MOG_diag_EM_sup::acc_covs	/usr/include/itpp/stat/mog_diag_em.h	/^  Array<vec> acc_covs;$/;"	m	class:itpp::MOG_diag_EM_sup	access:private
itpp::MOG_diag_EM_sup::acc_loglhood_K	/usr/include/itpp/stat/mog_diag_em.h	/^  vec acc_loglhood_K;$/;"	m	class:itpp::MOG_diag_EM_sup	access:private
itpp::MOG_diag_EM_sup::acc_means	/usr/include/itpp/stat/mog_diag_em.h	/^  Array<vec> acc_means;$/;"	m	class:itpp::MOG_diag_EM_sup	access:private
itpp::MOG_diag_EM_sup::c_X	/usr/include/itpp/stat/mog_diag_em.h	/^  double ** c_X;$/;"	m	class:itpp::MOG_diag_EM_sup	access:protected
itpp::MOG_diag_EM_sup::c_acc_covs	/usr/include/itpp/stat/mog_diag_em.h	/^  double ** c_acc_covs;$/;"	m	class:itpp::MOG_diag_EM_sup	access:private
itpp::MOG_diag_EM_sup::c_acc_loglhood_K	/usr/include/itpp/stat/mog_diag_em.h	/^  double * c_acc_loglhood_K;$/;"	m	class:itpp::MOG_diag_EM_sup	access:private
itpp::MOG_diag_EM_sup::c_acc_means	/usr/include/itpp/stat/mog_diag_em.h	/^  double ** c_acc_means;$/;"	m	class:itpp::MOG_diag_EM_sup	access:private
itpp::MOG_diag_EM_sup::c_tmpvecD	/usr/include/itpp/stat/mog_diag_em.h	/^  double * c_tmpvecD;$/;"	m	class:itpp::MOG_diag_EM_sup	access:private
itpp::MOG_diag_EM_sup::c_tmpvecK	/usr/include/itpp/stat/mog_diag_em.h	/^  double * c_tmpvecK;$/;"	m	class:itpp::MOG_diag_EM_sup	access:private
itpp::MOG_diag_EM_sup::map	/usr/include/itpp/stat/mog_diag_em.h	/^  void map(MOG_diag &model_in, MOG_diag &prior_model, Array<vec> &X_in, int max_iter_in = 10, double alpha_in = 0.5, double var_floor_in = 0.0, double weight_floor_in = 0.0, bool verbose_in = false);$/;"	p	class:itpp::MOG_diag_EM_sup	access:public	signature:(MOG_diag &model_in, MOG_diag &prior_model, Array<vec> &X_in, int max_iter_in = 10, double alpha_in = 0.5, double var_floor_in = 0.0, double weight_floor_in = 0.0, bool verbose_in = false)
itpp::MOG_diag_EM_sup::max_iter	/usr/include/itpp/stat/mog_diag_em.h	/^  int max_iter;$/;"	m	class:itpp::MOG_diag_EM_sup	access:protected
itpp::MOG_diag_EM_sup::ml	/usr/include/itpp/stat/mog_diag_em.h	/^  void ml(MOG_diag &model_in, Array<vec> &X_in, int max_iter_in = 10, double var_floor_in = 0.0, double weight_floor_in = 0.0, bool verbose_in = false);$/;"	p	class:itpp::MOG_diag_EM_sup	access:public	signature:(MOG_diag &model_in, Array<vec> &X_in, int max_iter_in = 10, double var_floor_in = 0.0, double weight_floor_in = 0.0, bool verbose_in = false)
itpp::MOG_diag_EM_sup::ml_iterate	/usr/include/itpp/stat/mog_diag_em.h	/^  void ml_iterate();$/;"	p	class:itpp::MOG_diag_EM_sup	access:protected	signature:()
itpp::MOG_diag_EM_sup::ml_update_params	/usr/include/itpp/stat/mog_diag_em.h	/^  double ml_update_params();$/;"	p	class:itpp::MOG_diag_EM_sup	access:protected	signature:()
itpp::MOG_diag_EM_sup::sanitise_params	/usr/include/itpp/stat/mog_diag_em.h	/^  void inline sanitise_params();$/;"	p	class:itpp::MOG_diag_EM_sup	access:protected	signature:()
itpp::MOG_diag_EM_sup::tmpvecD	/usr/include/itpp/stat/mog_diag_em.h	/^  vec tmpvecD;$/;"	m	class:itpp::MOG_diag_EM_sup	access:private
itpp::MOG_diag_EM_sup::tmpvecK	/usr/include/itpp/stat/mog_diag_em.h	/^  vec tmpvecK;$/;"	m	class:itpp::MOG_diag_EM_sup	access:private
itpp::MOG_diag_EM_sup::update_internals	/usr/include/itpp/stat/mog_diag_em.h	/^  void inline update_internals();$/;"	p	class:itpp::MOG_diag_EM_sup	access:protected	signature:()
itpp::MOG_diag_EM_sup::var_floor	/usr/include/itpp/stat/mog_diag_em.h	/^  double var_floor;$/;"	m	class:itpp::MOG_diag_EM_sup	access:protected
itpp::MOG_diag_EM_sup::verbose	/usr/include/itpp/stat/mog_diag_em.h	/^  bool verbose;$/;"	m	class:itpp::MOG_diag_EM_sup	access:protected
itpp::MOG_diag_EM_sup::weight_floor	/usr/include/itpp/stat/mog_diag_em.h	/^  double weight_floor;$/;"	m	class:itpp::MOG_diag_EM_sup	access:protected
itpp::MOG_diag_EM_sup::~MOG_diag_EM_sup	/usr/include/itpp/stat/mog_diag_em.h	/^  ~MOG_diag_EM_sup() { }$/;"	f	class:itpp::MOG_diag_EM_sup	access:public	signature:()
itpp::MOG_diag_MAP	/usr/include/itpp/stat/mog_diag_em.h	/^void MOG_diag_MAP(MOG_diag &model_in, MOG_diag &prior_model_in, Array<vec> &X_in, int max_iter_in = 10, double alpha_in = 0.5, double var_floor_in = 0.0, double weight_floor_in = 0.0, bool verbose_in = false);$/;"	p	namespace:itpp	signature:(MOG_diag &model_in, MOG_diag &prior_model_in, Array<vec> &X_in, int max_iter_in = 10, double alpha_in = 0.5, double var_floor_in = 0.0, double weight_floor_in = 0.0, bool verbose_in = false)
itpp::MOG_diag_ML	/usr/include/itpp/stat/mog_diag_em.h	/^void MOG_diag_ML(MOG_diag &model_in, Array<vec> &X_in, int max_iter_in = 10, double var_floor_in = 0.0, double weight_floor_in = 0.0, bool verbose_in = false);$/;"	p	namespace:itpp	signature:(MOG_diag &model_in, Array<vec> &X_in, int max_iter_in = 10, double var_floor_in = 0.0, double weight_floor_in = 0.0, bool verbose_in = false)
itpp::MOG_diag_kmeans	/usr/include/itpp/stat/mog_diag_kmeans.h	/^void MOG_diag_kmeans(MOG_diag &model_in, Array<vec> &X_in, int max_iter_in = 10, double trust_in = 0.5, bool normalise_in = true, bool verbose_in = false);$/;"	p	namespace:itpp	signature:(MOG_diag &model_in, Array<vec> &X_in, int max_iter_in = 10, double trust_in = 0.5, bool normalise_in = true, bool verbose_in = false)
itpp::MOG_diag_kmeans_sup	/usr/include/itpp/stat/mog_diag_kmeans.h	/^class MOG_diag_kmeans_sup : public MOG_diag$/;"	c	namespace:itpp	inherits:MOG_diag
itpp::MOG_diag_kmeans_sup::MOG_diag_kmeans_sup	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  MOG_diag_kmeans_sup() { verbose = false; }$/;"	f	class:itpp::MOG_diag_kmeans_sup	access:public	signature:()
itpp::MOG_diag_kmeans_sup::N	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  int N;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:protected
itpp::MOG_diag_kmeans_sup::assign_to_means	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  void assign_to_means();$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:protected	signature:()
itpp::MOG_diag_kmeans_sup::c_X	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  double ** c_X;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:protected
itpp::MOG_diag_kmeans_sup::c_count	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  int * c_count;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:protected
itpp::MOG_diag_kmeans_sup::c_means_old	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  double ** c_means_old;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:protected
itpp::MOG_diag_kmeans_sup::c_norm_mu	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  double * c_norm_mu;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:private
itpp::MOG_diag_kmeans_sup::c_norm_sd	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  double * c_norm_sd;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:private
itpp::MOG_diag_kmeans_sup::c_partitions	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  int ** c_partitions;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:protected
itpp::MOG_diag_kmeans_sup::c_tmpvec	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  double * c_tmpvec;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:private
itpp::MOG_diag_kmeans_sup::calc_covs	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  void calc_covs();$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:protected	signature:()
itpp::MOG_diag_kmeans_sup::calc_means	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  void calc_means();$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:protected	signature:()
itpp::MOG_diag_kmeans_sup::calc_weights	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  void calc_weights();$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:protected	signature:()
itpp::MOG_diag_kmeans_sup::count	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  ivec count;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:protected
itpp::MOG_diag_kmeans_sup::dezombify_means	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  bool dezombify_means();$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:protected	signature:()
itpp::MOG_diag_kmeans_sup::dist	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  inline double dist(const double * x, const double * y) const;$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:protected	signature:(const double * x, const double * y) const
itpp::MOG_diag_kmeans_sup::initial_means	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  void initial_means();$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:protected	signature:()
itpp::MOG_diag_kmeans_sup::iterate	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  void iterate();$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:protected	signature:()
itpp::MOG_diag_kmeans_sup::max_iter	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  int max_iter;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:protected
itpp::MOG_diag_kmeans_sup::means_old	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  Array<vec> means_old;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:protected
itpp::MOG_diag_kmeans_sup::measure_change	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  double measure_change() const;$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:protected	signature:() const
itpp::MOG_diag_kmeans_sup::norm_mu	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  vec norm_mu;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:private
itpp::MOG_diag_kmeans_sup::norm_sd	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  vec norm_sd;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:private
itpp::MOG_diag_kmeans_sup::normalise_vectors	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  void normalise_vectors();$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:protected	signature:()
itpp::MOG_diag_kmeans_sup::partitions	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  Array<ivec> partitions;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:protected
itpp::MOG_diag_kmeans_sup::recalculate_means	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  void recalculate_means();$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:protected	signature:()
itpp::MOG_diag_kmeans_sup::run	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  void run(MOG_diag &model_in, Array<vec> &X_in, int max_iter_in = 10, double trust_in = 0.5, bool normalise_in = true, bool verbose_in = false);$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:public	signature:(MOG_diag &model_in, Array<vec> &X_in, int max_iter_in = 10, double trust_in = 0.5, bool normalise_in = true, bool verbose_in = false)
itpp::MOG_diag_kmeans_sup::tmpvec	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  vec tmpvec;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:private
itpp::MOG_diag_kmeans_sup::trust	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  double trust;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:protected
itpp::MOG_diag_kmeans_sup::unnormalise_means	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  void unnormalise_means();$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:protected	signature:()
itpp::MOG_diag_kmeans_sup::unnormalise_vectors	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  void unnormalise_vectors();$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:protected	signature:()
itpp::MOG_diag_kmeans_sup::verbose	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  bool verbose;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:protected
itpp::MOG_diag_kmeans_sup::~MOG_diag_kmeans_sup	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  ~MOG_diag_kmeans_sup() { }$/;"	f	class:itpp::MOG_diag_kmeans_sup	access:public	signature:()
itpp::MOG_generic	/usr/include/itpp/stat/mog_generic.h	/^class MOG_generic$/;"	c	namespace:itpp
itpp::MOG_generic::D	/usr/include/itpp/stat/mog_generic.h	/^  int D;$/;"	m	class:itpp::MOG_generic	access:protected
itpp::MOG_generic::K	/usr/include/itpp/stat/mog_generic.h	/^  int K;$/;"	m	class:itpp::MOG_generic	access:protected
itpp::MOG_generic::MOG_generic	/usr/include/itpp/stat/mog_generic.h	/^  MOG_generic() { init(); }$/;"	f	class:itpp::MOG_generic	access:public	signature:()
itpp::MOG_generic::MOG_generic	/usr/include/itpp/stat/mog_generic.h	/^  MOG_generic(Array<vec> &means_in, Array<mat> &full_covs_in, vec &weights_in) { init(means_in, full_covs_in, weights_in); }$/;"	f	class:itpp::MOG_generic	access:public	signature:(Array<vec> &means_in, Array<mat> &full_covs_in, vec &weights_in)
itpp::MOG_generic::MOG_generic	/usr/include/itpp/stat/mog_generic.h	/^  MOG_generic(Array<vec> &means_in, Array<vec> &diag_covs_in, vec &weights_in) { init(means_in, diag_covs_in, weights_in); }$/;"	f	class:itpp::MOG_generic	access:public	signature:(Array<vec> &means_in, Array<vec> &diag_covs_in, vec &weights_in)
itpp::MOG_generic::MOG_generic	/usr/include/itpp/stat/mog_generic.h	/^  MOG_generic(Array<vec> &means_in, bool full_in = false) { init(means_in, full_in); }$/;"	f	class:itpp::MOG_generic	access:public	signature:(Array<vec> &means_in, bool full_in = false)
itpp::MOG_generic::MOG_generic	/usr/include/itpp/stat/mog_generic.h	/^  MOG_generic(const int &K_in, const int &D_in, bool full_in = false) { init(K_in, D_in, full_in); }$/;"	f	class:itpp::MOG_generic	access:public	signature:(const int &K_in, const int &D_in, bool full_in = false)
itpp::MOG_generic::MOG_generic	/usr/include/itpp/stat/mog_generic.h	/^  MOG_generic(const std::string &name_in) { load(name_in); }$/;"	f	class:itpp::MOG_generic	access:public	signature:(const std::string &name_in)
itpp::MOG_generic::avg_log_lhood	/usr/include/itpp/stat/mog_generic.h	/^  virtual double avg_log_lhood(const Array<vec> &X_in);$/;"	p	class:itpp::MOG_generic	access:public	signature:(const Array<vec> &X_in)
itpp::MOG_generic::check_array_uniformity	/usr/include/itpp/stat/mog_generic.h	/^  bool check_array_uniformity(const Array<vec> & A) const;$/;"	p	class:itpp::MOG_generic	access:protected	signature:(const Array<vec> & A) const
itpp::MOG_generic::check_size	/usr/include/itpp/stat/mog_generic.h	/^  bool check_size(const Array<vec> &X_in) const;$/;"	p	class:itpp::MOG_generic	access:protected	signature:(const Array<vec> &X_in) const
itpp::MOG_generic::check_size	/usr/include/itpp/stat/mog_generic.h	/^  bool check_size(const vec &x_in) const;$/;"	p	class:itpp::MOG_generic	access:protected	signature:(const vec &x_in) const
itpp::MOG_generic::cleanup	/usr/include/itpp/stat/mog_generic.h	/^  virtual void cleanup();$/;"	p	class:itpp::MOG_generic	access:public	signature:()
itpp::MOG_generic::convert_to_diag	/usr/include/itpp/stat/mog_generic.h	/^  virtual void convert_to_diag();$/;"	p	class:itpp::MOG_generic	access:public	signature:()
itpp::MOG_generic::convert_to_diag_internal	/usr/include/itpp/stat/mog_generic.h	/^  void convert_to_diag_internal();$/;"	p	class:itpp::MOG_generic	access:protected	signature:()
itpp::MOG_generic::convert_to_full	/usr/include/itpp/stat/mog_generic.h	/^  virtual void convert_to_full();$/;"	p	class:itpp::MOG_generic	access:public	signature:()
itpp::MOG_generic::convert_to_full_internal	/usr/include/itpp/stat/mog_generic.h	/^  void convert_to_full_internal();$/;"	p	class:itpp::MOG_generic	access:protected	signature:()
itpp::MOG_generic::diag_covs	/usr/include/itpp/stat/mog_generic.h	/^  Array<vec> diag_covs;$/;"	m	class:itpp::MOG_generic	access:protected
itpp::MOG_generic::diag_covs_inv_etc	/usr/include/itpp/stat/mog_generic.h	/^  Array<vec> diag_covs_inv_etc;$/;"	m	class:itpp::MOG_generic	access:protected
itpp::MOG_generic::do_checks	/usr/include/itpp/stat/mog_generic.h	/^  bool do_checks;$/;"	m	class:itpp::MOG_generic	access:protected
itpp::MOG_generic::full	/usr/include/itpp/stat/mog_generic.h	/^  bool full;$/;"	m	class:itpp::MOG_generic	access:protected
itpp::MOG_generic::full_covs	/usr/include/itpp/stat/mog_generic.h	/^  Array<mat> full_covs;$/;"	m	class:itpp::MOG_generic	access:protected
itpp::MOG_generic::full_covs_inv	/usr/include/itpp/stat/mog_generic.h	/^  Array<mat> full_covs_inv;$/;"	m	class:itpp::MOG_generic	access:protected
itpp::MOG_generic::get_D	/usr/include/itpp/stat/mog_generic.h	/^  int get_D() const { if (valid) return(D); else return(0); }$/;"	f	class:itpp::MOG_generic	access:public	signature:() const
itpp::MOG_generic::get_K	/usr/include/itpp/stat/mog_generic.h	/^  int get_K() const { if (valid) return(K); else return(0); }$/;"	f	class:itpp::MOG_generic	access:public	signature:() const
itpp::MOG_generic::get_diag_covs	/usr/include/itpp/stat/mog_generic.h	/^  Array<vec> get_diag_covs() const { Array<vec> tmp; if (valid && !full) { tmp = diag_covs; } return tmp; }$/;"	f	class:itpp::MOG_generic	access:public	signature:() const
itpp::MOG_generic::get_full_covs	/usr/include/itpp/stat/mog_generic.h	/^  Array<mat> get_full_covs() const { Array<mat> tmp; if (valid && full) { tmp = full_covs; } return tmp; }$/;"	f	class:itpp::MOG_generic	access:public	signature:() const
itpp::MOG_generic::get_means	/usr/include/itpp/stat/mog_generic.h	/^  Array<vec> get_means() const { Array<vec> tmp; if (valid) { tmp = means; } return tmp; }$/;"	f	class:itpp::MOG_generic	access:public	signature:() const
itpp::MOG_generic::get_weights	/usr/include/itpp/stat/mog_generic.h	/^  vec get_weights() const { vec tmp;  if (valid) { tmp = weights; } return tmp; }$/;"	f	class:itpp::MOG_generic	access:public	signature:() const
itpp::MOG_generic::init	/usr/include/itpp/stat/mog_generic.h	/^  void init();$/;"	p	class:itpp::MOG_generic	access:public	signature:()
itpp::MOG_generic::init	/usr/include/itpp/stat/mog_generic.h	/^  void init(Array<vec> &means_in, Array<mat> &full_covs_in, vec &weights_in);$/;"	p	class:itpp::MOG_generic	access:public	signature:(Array<vec> &means_in, Array<mat> &full_covs_in, vec &weights_in)
itpp::MOG_generic::init	/usr/include/itpp/stat/mog_generic.h	/^  void init(Array<vec> &means_in, Array<vec> &diag_covs_in, vec &weights_in);$/;"	p	class:itpp::MOG_generic	access:public	signature:(Array<vec> &means_in, Array<vec> &diag_covs_in, vec &weights_in)
itpp::MOG_generic::init	/usr/include/itpp/stat/mog_generic.h	/^  void init(Array<vec> &means_in, bool full_in = false);$/;"	p	class:itpp::MOG_generic	access:public	signature:(Array<vec> &means_in, bool full_in = false)
itpp::MOG_generic::init	/usr/include/itpp/stat/mog_generic.h	/^  void init(const int &K_in, const int &D_in, bool full_in = false);$/;"	p	class:itpp::MOG_generic	access:public	signature:(const int &K_in, const int &D_in, bool full_in = false)
itpp::MOG_generic::is_full	/usr/include/itpp/stat/mog_generic.h	/^  bool is_full() const { return full; }$/;"	f	class:itpp::MOG_generic	access:public	signature:() const
itpp::MOG_generic::is_valid	/usr/include/itpp/stat/mog_generic.h	/^  bool is_valid() const { return valid; }$/;"	f	class:itpp::MOG_generic	access:public	signature:() const
itpp::MOG_generic::join	/usr/include/itpp/stat/mog_generic.h	/^  virtual void join(const MOG_generic &B_in);$/;"	p	class:itpp::MOG_generic	access:public	signature:(const MOG_generic &B_in)
itpp::MOG_generic::lhood	/usr/include/itpp/stat/mog_generic.h	/^  virtual double lhood(const vec &x_in);$/;"	p	class:itpp::MOG_generic	access:public	signature:(const vec &x_in)
itpp::MOG_generic::lhood_internal	/usr/include/itpp/stat/mog_generic.h	/^  virtual double lhood_internal(const vec &x_in);$/;"	p	class:itpp::MOG_generic	access:protected	signature:(const vec &x_in)
itpp::MOG_generic::load	/usr/include/itpp/stat/mog_generic.h	/^  virtual void load(const std::string &name_in);$/;"	p	class:itpp::MOG_generic	access:public	signature:(const std::string &name_in)
itpp::MOG_generic::log_det_etc	/usr/include/itpp/stat/mog_generic.h	/^  vec log_det_etc;$/;"	m	class:itpp::MOG_generic	access:protected
itpp::MOG_generic::log_lhood	/usr/include/itpp/stat/mog_generic.h	/^  virtual double log_lhood(const vec &x_in);$/;"	p	class:itpp::MOG_generic	access:public	signature:(const vec &x_in)
itpp::MOG_generic::log_lhood_internal	/usr/include/itpp/stat/mog_generic.h	/^  virtual double log_lhood_internal(const vec &x_in);$/;"	p	class:itpp::MOG_generic	access:protected	signature:(const vec &x_in)
itpp::MOG_generic::log_lhood_single_gaus	/usr/include/itpp/stat/mog_generic.h	/^  virtual double log_lhood_single_gaus(const vec &x_in, const int k);$/;"	p	class:itpp::MOG_generic	access:public	signature:(const vec &x_in, const int k)
itpp::MOG_generic::log_lhood_single_gaus_internal	/usr/include/itpp/stat/mog_generic.h	/^  virtual double log_lhood_single_gaus_internal(const vec &x_in, const int k);$/;"	p	class:itpp::MOG_generic	access:protected	signature:(const vec &x_in, const int k)
itpp::MOG_generic::log_max_K	/usr/include/itpp/stat/mog_generic.h	/^  double log_max_K;$/;"	m	class:itpp::MOG_generic	access:protected
itpp::MOG_generic::log_weights	/usr/include/itpp/stat/mog_generic.h	/^  vec log_weights;$/;"	m	class:itpp::MOG_generic	access:protected
itpp::MOG_generic::means	/usr/include/itpp/stat/mog_generic.h	/^  Array<vec> means;$/;"	m	class:itpp::MOG_generic	access:protected
itpp::MOG_generic::paranoid	/usr/include/itpp/stat/mog_generic.h	/^  bool paranoid;$/;"	m	class:itpp::MOG_generic	access:protected
itpp::MOG_generic::save	/usr/include/itpp/stat/mog_generic.h	/^  virtual void save(const std::string &name_in) const;$/;"	p	class:itpp::MOG_generic	access:public	signature:(const std::string &name_in) const
itpp::MOG_generic::set_checks	/usr/include/itpp/stat/mog_generic.h	/^  void set_checks(bool do_checks_in) { do_checks = do_checks_in; }$/;"	f	class:itpp::MOG_generic	access:public	signature:(bool do_checks_in)
itpp::MOG_generic::set_diag_covs	/usr/include/itpp/stat/mog_generic.h	/^  void set_diag_covs(Array<vec> &diag_covs_in);$/;"	p	class:itpp::MOG_generic	access:public	signature:(Array<vec> &diag_covs_in)
itpp::MOG_generic::set_diag_covs_internal	/usr/include/itpp/stat/mog_generic.h	/^  void set_diag_covs_internal(Array<vec> &diag_covs_in);$/;"	p	class:itpp::MOG_generic	access:protected	signature:(Array<vec> &diag_covs_in)
itpp::MOG_generic::set_diag_covs_unity	/usr/include/itpp/stat/mog_generic.h	/^  void set_diag_covs_unity();$/;"	p	class:itpp::MOG_generic	access:public	signature:()
itpp::MOG_generic::set_diag_covs_unity_internal	/usr/include/itpp/stat/mog_generic.h	/^  void set_diag_covs_unity_internal();$/;"	p	class:itpp::MOG_generic	access:protected	signature:()
itpp::MOG_generic::set_full_covs	/usr/include/itpp/stat/mog_generic.h	/^  void set_full_covs(Array<mat> &full_covs_in);$/;"	p	class:itpp::MOG_generic	access:public	signature:(Array<mat> &full_covs_in)
itpp::MOG_generic::set_full_covs_internal	/usr/include/itpp/stat/mog_generic.h	/^  void set_full_covs_internal(Array<mat> &full_covs_in);$/;"	p	class:itpp::MOG_generic	access:protected	signature:(Array<mat> &full_covs_in)
itpp::MOG_generic::set_full_covs_unity	/usr/include/itpp/stat/mog_generic.h	/^  void set_full_covs_unity();$/;"	p	class:itpp::MOG_generic	access:public	signature:()
itpp::MOG_generic::set_full_covs_unity_internal	/usr/include/itpp/stat/mog_generic.h	/^  void set_full_covs_unity_internal();$/;"	p	class:itpp::MOG_generic	access:protected	signature:()
itpp::MOG_generic::set_means	/usr/include/itpp/stat/mog_generic.h	/^  void set_means(Array<vec> &means_in);$/;"	p	class:itpp::MOG_generic	access:public	signature:(Array<vec> &means_in)
itpp::MOG_generic::set_means_internal	/usr/include/itpp/stat/mog_generic.h	/^  void set_means_internal(Array<vec> &means_in);$/;"	p	class:itpp::MOG_generic	access:protected	signature:(Array<vec> &means_in)
itpp::MOG_generic::set_means_zero	/usr/include/itpp/stat/mog_generic.h	/^  void set_means_zero();$/;"	p	class:itpp::MOG_generic	access:public	signature:()
itpp::MOG_generic::set_means_zero_internal	/usr/include/itpp/stat/mog_generic.h	/^  void set_means_zero_internal();$/;"	p	class:itpp::MOG_generic	access:protected	signature:()
itpp::MOG_generic::set_paranoid	/usr/include/itpp/stat/mog_generic.h	/^  void set_paranoid(bool paranoid_in) { paranoid = paranoid_in; }$/;"	f	class:itpp::MOG_generic	access:public	signature:(bool paranoid_in)
itpp::MOG_generic::set_weights	/usr/include/itpp/stat/mog_generic.h	/^  void set_weights(vec &weights_in);$/;"	p	class:itpp::MOG_generic	access:public	signature:(vec &weights_in)
itpp::MOG_generic::set_weights_internal	/usr/include/itpp/stat/mog_generic.h	/^  void set_weights_internal(vec &_weigths);$/;"	p	class:itpp::MOG_generic	access:protected	signature:(vec &_weigths)
itpp::MOG_generic::set_weights_uniform	/usr/include/itpp/stat/mog_generic.h	/^  void set_weights_uniform();$/;"	p	class:itpp::MOG_generic	access:public	signature:()
itpp::MOG_generic::set_weights_uniform_internal	/usr/include/itpp/stat/mog_generic.h	/^  void set_weights_uniform_internal();$/;"	p	class:itpp::MOG_generic	access:protected	signature:()
itpp::MOG_generic::setup_covs	/usr/include/itpp/stat/mog_generic.h	/^  virtual void setup_covs();$/;"	p	class:itpp::MOG_generic	access:protected	signature:()
itpp::MOG_generic::setup_means	/usr/include/itpp/stat/mog_generic.h	/^  virtual void setup_means();$/;"	p	class:itpp::MOG_generic	access:protected	signature:()
itpp::MOG_generic::setup_misc	/usr/include/itpp/stat/mog_generic.h	/^  virtual void setup_misc();$/;"	p	class:itpp::MOG_generic	access:protected	signature:()
itpp::MOG_generic::setup_weights	/usr/include/itpp/stat/mog_generic.h	/^  virtual void setup_weights();$/;"	p	class:itpp::MOG_generic	access:protected	signature:()
itpp::MOG_generic::tmpvecD	/usr/include/itpp/stat/mog_generic.h	/^  vec tmpvecD;$/;"	m	class:itpp::MOG_generic	access:private
itpp::MOG_generic::tmpvecK	/usr/include/itpp/stat/mog_generic.h	/^  vec tmpvecK;$/;"	m	class:itpp::MOG_generic	access:private
itpp::MOG_generic::valid	/usr/include/itpp/stat/mog_generic.h	/^  bool valid;$/;"	m	class:itpp::MOG_generic	access:protected
itpp::MOG_generic::weights	/usr/include/itpp/stat/mog_generic.h	/^  vec weights;$/;"	m	class:itpp::MOG_generic	access:protected
itpp::MOG_generic::~MOG_generic	/usr/include/itpp/stat/mog_generic.h	/^  virtual ~MOG_generic() { cleanup(); }$/;"	f	class:itpp::MOG_generic	access:public	signature:()
itpp::Mat	/usr/include/itpp/base/mat.h	/^class Mat$/;"	c	namespace:itpp
itpp::Mat::H	/usr/include/itpp/base/mat.h	/^  Mat<Num_T> H() const { return this->hermitian_transpose(); }$/;"	f	class:itpp::Mat	access:public	signature:() const
itpp::Mat::Mat	/usr/include/itpp/base/mat.h	/^  Mat(const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:public	signature:(const Mat<Num_T> &m)
itpp::Mat::Mat	/usr/include/itpp/base/mat.h	/^  Mat(const Mat<Num_T> &m, const Factory &f);$/;"	p	class:itpp::Mat	access:public	signature:(const Mat<Num_T> &m, const Factory &f)
itpp::Mat::Mat	/usr/include/itpp/base/mat.h	/^  Mat(const Num_T *c_array, int rows, int cols, bool row_major = true,$/;"	p	class:itpp::Mat	access:public	signature:(const Num_T *c_array, int rows, int cols, bool row_major = true, const Factory &f = DEFAULT_FACTORY)
itpp::Mat::Mat	/usr/include/itpp/base/mat.h	/^  Mat(const Vec<Num_T> &v, const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Mat	access:public	signature:(const Vec<Num_T> &v, const Factory &f = DEFAULT_FACTORY)
itpp::Mat::Mat	/usr/include/itpp/base/mat.h	/^  Mat(const char *str, const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Mat	access:public	signature:(const char *str, const Factory &f = DEFAULT_FACTORY)
itpp::Mat::Mat	/usr/include/itpp/base/mat.h	/^  Mat(const std::string &str, const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Mat	access:public	signature:(const std::string &str, const Factory &f = DEFAULT_FACTORY)
itpp::Mat::Mat	/usr/include/itpp/base/mat.h	/^  Mat(int rows, int cols, const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Mat	access:public	signature:(int rows, int cols, const Factory &f = DEFAULT_FACTORY)
itpp::Mat::Mat	/usr/include/itpp/base/mat.h	/^  explicit Mat(const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Mat	access:public	signature:(const Factory &f = DEFAULT_FACTORY)
itpp::Mat::Mat	/usr/include/itpp/base/mat.h	/^Mat<Num_T>::Mat(const Factory &f) :$/;"	f	class:itpp::Mat	signature:(const Factory &f)
itpp::Mat::Mat	/usr/include/itpp/base/mat.h	/^Mat<Num_T>::Mat(const Mat<Num_T> &m) :$/;"	f	class:itpp::Mat	signature:(const Mat<Num_T> &m)
itpp::Mat::Mat	/usr/include/itpp/base/mat.h	/^Mat<Num_T>::Mat(const Mat<Num_T> &m, const Factory &f) :$/;"	f	class:itpp::Mat	signature:(const Mat<Num_T> &m, const Factory &f)
itpp::Mat::Mat	/usr/include/itpp/base/mat.h	/^Mat<Num_T>::Mat(const Num_T *c_array, int rows, int cols, bool row_major,$/;"	f	class:itpp::Mat	signature:(const Num_T *c_array, int rows, int cols, bool row_major, const Factory &f)
itpp::Mat::Mat	/usr/include/itpp/base/mat.h	/^Mat<Num_T>::Mat(const Vec<Num_T> &v, const Factory &f) :$/;"	f	class:itpp::Mat	signature:(const Vec<Num_T> &v, const Factory &f)
itpp::Mat::Mat	/usr/include/itpp/base/mat.h	/^Mat<Num_T>::Mat(const char *str, const Factory &f) :$/;"	f	class:itpp::Mat	signature:(const char *str, const Factory &f)
itpp::Mat::Mat	/usr/include/itpp/base/mat.h	/^Mat<Num_T>::Mat(const std::string &str, const Factory &f) :$/;"	f	class:itpp::Mat	signature:(const std::string &str, const Factory &f)
itpp::Mat::Mat	/usr/include/itpp/base/mat.h	/^Mat<Num_T>::Mat(int rows, int cols, const Factory &f) :$/;"	f	class:itpp::Mat	signature:(int rows, int cols, const Factory &f)
itpp::Mat::T	/usr/include/itpp/base/mat.h	/^  Mat<Num_T> T() const { return this->transpose(); }$/;"	f	class:itpp::Mat	access:public	signature:() const
itpp::Mat::_data	/usr/include/itpp/base/mat.h	/^  Num_T *_data() { return data; }$/;"	f	class:itpp::Mat	access:public	signature:()
itpp::Mat::_data	/usr/include/itpp/base/mat.h	/^  const Num_T *_data() const { return data; }$/;"	f	class:itpp::Mat	access:public	signature:() const
itpp::Mat::_datasize	/usr/include/itpp/base/mat.h	/^  int _datasize() const { return datasize; }$/;"	f	class:itpp::Mat	access:public	signature:() const
itpp::Mat::_elem	/usr/include/itpp/base/mat.h	/^  Num_T &_elem(int i) { return data[i]; }$/;"	f	class:itpp::Mat	access:public	signature:(int i)
itpp::Mat::_elem	/usr/include/itpp/base/mat.h	/^  Num_T &_elem(int r, int c) { return data[r+c*no_rows]; }$/;"	f	class:itpp::Mat	access:public	signature:(int r, int c)
itpp::Mat::_elem	/usr/include/itpp/base/mat.h	/^  const Num_T &_elem(int i) const { return data[i]; }$/;"	f	class:itpp::Mat	access:public	signature:(int i) const
itpp::Mat::_elem	/usr/include/itpp/base/mat.h	/^  const Num_T &_elem(int r, int c) const { return data[r+c*no_rows]; }$/;"	f	class:itpp::Mat	access:public	signature:(int r, int c) const
itpp::Mat::alloc	/usr/include/itpp/base/mat.h	/^  void alloc(int rows, int cols);$/;"	p	class:itpp::Mat	access:protected	signature:(int rows, int cols)
itpp::Mat::alloc	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::alloc(int rows, int cols)$/;"	f	class:itpp::Mat	signature:(int rows, int cols)
itpp::Mat::append_col	/usr/include/itpp/base/mat.h	/^  void append_col(const Vec<Num_T> &v);$/;"	p	class:itpp::Mat	access:public	signature:(const Vec<Num_T> &v)
itpp::Mat::append_col	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::append_col(const Vec<Num_T> &v)$/;"	f	class:itpp::Mat	signature:(const Vec<Num_T> &v)
itpp::Mat::append_row	/usr/include/itpp/base/mat.h	/^  void append_row(const Vec<Num_T> &v);$/;"	p	class:itpp::Mat	access:public	signature:(const Vec<Num_T> &v)
itpp::Mat::append_row	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::append_row(const Vec<Num_T> &v)$/;"	f	class:itpp::Mat	signature:(const Vec<Num_T> &v)
itpp::Mat::clear	/usr/include/itpp/base/mat.h	/^  void clear() { zeros(); }$/;"	f	class:itpp::Mat	access:public	signature:()
itpp::Mat::col_in_range	/usr/include/itpp/base/mat.h	/^  bool col_in_range(int c) const { return ((c >= 0) && (c < no_cols)); }$/;"	f	class:itpp::Mat	access:private	signature:(int c) const
itpp::Mat::cols	/usr/include/itpp/base/mat.h	/^  int cols() const { return no_cols; }$/;"	f	class:itpp::Mat	access:public	signature:() const
itpp::Mat::concat_horizontal	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> concat_horizontal<>(const Mat<Num_T> &m1,$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::Mat::concat_vertical	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> concat_vertical<>(const Mat<Num_T> &m1,$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::Mat::copy_col	/usr/include/itpp/base/mat.h	/^  void copy_col(int to, int from);$/;"	p	class:itpp::Mat	access:public	signature:(int to, int from)
itpp::Mat::copy_col	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::copy_col(int to, int from)$/;"	f	class:itpp::Mat	signature:(int to, int from)
itpp::Mat::copy_row	/usr/include/itpp/base/mat.h	/^  void copy_row(int to, int from);$/;"	p	class:itpp::Mat	access:public	signature:(int to, int from)
itpp::Mat::copy_row	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::copy_row(int to, int from)$/;"	f	class:itpp::Mat	signature:(int to, int from)
itpp::Mat::data	/usr/include/itpp/base/mat.h	/^  Num_T *data;$/;"	m	class:itpp::Mat	access:protected
itpp::Mat::datasize	/usr/include/itpp/base/mat.h	/^  int datasize, no_rows, no_cols;$/;"	m	class:itpp::Mat	access:protected
itpp::Mat::del_col	/usr/include/itpp/base/mat.h	/^  void del_col(int c);$/;"	p	class:itpp::Mat	access:public	signature:(int c)
itpp::Mat::del_col	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::del_col(int c)$/;"	f	class:itpp::Mat	signature:(int c)
itpp::Mat::del_cols	/usr/include/itpp/base/mat.h	/^  void del_cols(int c1, int c2);$/;"	p	class:itpp::Mat	access:public	signature:(int c1, int c2)
itpp::Mat::del_cols	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::del_cols(int c1, int c2)$/;"	f	class:itpp::Mat	signature:(int c1, int c2)
itpp::Mat::del_row	/usr/include/itpp/base/mat.h	/^  void del_row(int r);$/;"	p	class:itpp::Mat	access:public	signature:(int r)
itpp::Mat::del_row	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::del_row(int r)$/;"	f	class:itpp::Mat	signature:(int r)
itpp::Mat::del_rows	/usr/include/itpp/base/mat.h	/^  void del_rows(int r1, int r2);$/;"	p	class:itpp::Mat	access:public	signature:(int r1, int r2)
itpp::Mat::del_rows	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::del_rows(int r1, int r2)$/;"	f	class:itpp::Mat	signature:(int r1, int r2)
itpp::Mat::elem_div	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> elem_div<>(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::Mat::elem_div_out	/usr/include/itpp/base/mat.h	/^  friend void elem_div_out<>(const Mat<Num_T> &m1, const Mat<Num_T> &m2,$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2, Mat<Num_T> &out)
itpp::Mat::elem_div_sum	/usr/include/itpp/base/mat.h	/^  friend Num_T elem_div_sum<>(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::Mat::elem_mult	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> elem_mult<>(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::Mat::elem_mult_inplace	/usr/include/itpp/base/mat.h	/^  friend void elem_mult_inplace<>(const Mat<Num_T> &m1, Mat<Num_T> &m2);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, Mat<Num_T> &m2)
itpp::Mat::elem_mult_out	/usr/include/itpp/base/mat.h	/^  friend void elem_mult_out<>(const Mat<Num_T> &m1, const Mat<Num_T> &m2,$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2, Mat<Num_T> &out)
itpp::Mat::elem_mult_out	/usr/include/itpp/base/mat.h	/^  friend void elem_mult_out<>(const Mat<Num_T> &m1, const Mat<Num_T> &m2,$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2, const Mat<Num_T> &m3, Mat<Num_T> &out)
itpp::Mat::elem_mult_out	/usr/include/itpp/base/mat.h	/^  friend void elem_mult_out<>(const Mat<Num_T> &m1, const Mat<Num_T> &m2,$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2, const Mat<Num_T> &m3, const Mat<Num_T> &m4, Mat<Num_T> &out)
itpp::Mat::elem_mult_sum	/usr/include/itpp/base/mat.h	/^  friend Num_T elem_mult_sum<>(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::Mat::factory	/usr/include/itpp/base/mat.h	/^  const Factory &factory;$/;"	m	class:itpp::Mat	access:protected
itpp::Mat::free	/usr/include/itpp/base/mat.h	/^  void free();$/;"	p	class:itpp::Mat	access:protected	signature:()
itpp::Mat::free	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::free()$/;"	f	class:itpp::Mat	signature:()
itpp::Mat::get	/usr/include/itpp/base/mat.h	/^  Mat<Num_T> get(int r1, int r2, int c1, int c2) const;$/;"	p	class:itpp::Mat	access:public	signature:(int r1, int r2, int c1, int c2) const
itpp::Mat::get	/usr/include/itpp/base/mat.h	/^  const Num_T &get(int r, int c) const;$/;"	p	class:itpp::Mat	access:public	signature:(int r, int c) const
itpp::Mat::get	/usr/include/itpp/base/mat.h	/^Mat<Num_T> Mat<Num_T>::get(int r1, int r2, int c1, int c2) const$/;"	f	class:itpp::Mat	signature:(int r1, int r2, int c1, int c2) const
itpp::Mat::get	/usr/include/itpp/base/mat.h	/^const Num_T& Mat<Num_T>::get(int r, int c) const$/;"	f	class:itpp::Mat	signature:(int r, int c) const
itpp::Mat::get_col	/usr/include/itpp/base/mat.h	/^  Vec<Num_T> get_col(int c) const;$/;"	p	class:itpp::Mat	access:public	signature:(int c) const
itpp::Mat::get_col	/usr/include/itpp/base/mat.h	/^Vec<Num_T> Mat<Num_T>::get_col(int c) const$/;"	f	class:itpp::Mat	signature:(int c) const
itpp::Mat::get_cols	/usr/include/itpp/base/mat.h	/^  Mat<Num_T> get_cols(const Vec<int> &indexlist) const;$/;"	p	class:itpp::Mat	access:public	signature:(const Vec<int> &indexlist) const
itpp::Mat::get_cols	/usr/include/itpp/base/mat.h	/^  Mat<Num_T> get_cols(int c1, int c2) const;$/;"	p	class:itpp::Mat	access:public	signature:(int c1, int c2) const
itpp::Mat::get_cols	/usr/include/itpp/base/mat.h	/^Mat<Num_T> Mat<Num_T>::get_cols(const Vec<int> &indexlist) const$/;"	f	class:itpp::Mat	signature:(const Vec<int> &indexlist) const
itpp::Mat::get_cols	/usr/include/itpp/base/mat.h	/^Mat<Num_T> Mat<Num_T>::get_cols(int c1, int c2) const$/;"	f	class:itpp::Mat	signature:(int c1, int c2) const
itpp::Mat::get_row	/usr/include/itpp/base/mat.h	/^  Vec<Num_T> get_row(int r) const;$/;"	p	class:itpp::Mat	access:public	signature:(int r) const
itpp::Mat::get_row	/usr/include/itpp/base/mat.h	/^Vec<Num_T> Mat<Num_T>::get_row(int r) const$/;"	f	class:itpp::Mat	signature:(int r) const
itpp::Mat::get_rows	/usr/include/itpp/base/mat.h	/^  Mat<Num_T> get_rows(const Vec<int> &indexlist) const;$/;"	p	class:itpp::Mat	access:public	signature:(const Vec<int> &indexlist) const
itpp::Mat::get_rows	/usr/include/itpp/base/mat.h	/^  Mat<Num_T> get_rows(int r1, int r2) const;$/;"	p	class:itpp::Mat	access:public	signature:(int r1, int r2) const
itpp::Mat::get_rows	/usr/include/itpp/base/mat.h	/^Mat<Num_T> Mat<Num_T>::get_rows(const Vec<int> &indexlist) const$/;"	f	class:itpp::Mat	signature:(const Vec<int> &indexlist) const
itpp::Mat::get_rows	/usr/include/itpp/base/mat.h	/^Mat<Num_T> Mat<Num_T>::get_rows(int r1, int r2) const$/;"	f	class:itpp::Mat	signature:(int r1, int r2) const
itpp::Mat::hermitian_transpose	/usr/include/itpp/base/mat.h	/^  Mat<Num_T> hermitian_transpose() const;$/;"	p	class:itpp::Mat	access:public	signature:() const
itpp::Mat::hermitian_transpose	/usr/include/itpp/base/mat.h	/^Mat<Num_T> Mat<Num_T>::hermitian_transpose() const$/;"	f	class:itpp::Mat	signature:() const
itpp::Mat::in_range	/usr/include/itpp/base/mat.h	/^  bool in_range(int i) const { return ((i >= 0) && (i < datasize)); }$/;"	f	class:itpp::Mat	access:private	signature:(int i) const
itpp::Mat::in_range	/usr/include/itpp/base/mat.h	/^  bool in_range(int r, int c) const {$/;"	f	class:itpp::Mat	access:private	signature:(int r, int c) const
itpp::Mat::ins_col	/usr/include/itpp/base/mat.h	/^  void ins_col(int c, const Vec<Num_T> &v);$/;"	p	class:itpp::Mat	access:public	signature:(int c, const Vec<Num_T> &v)
itpp::Mat::ins_col	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::ins_col(int c, const Vec<Num_T> &v)$/;"	f	class:itpp::Mat	signature:(int c, const Vec<Num_T> &v)
itpp::Mat::ins_row	/usr/include/itpp/base/mat.h	/^  void ins_row(int r, const Vec<Num_T> &v);$/;"	p	class:itpp::Mat	access:public	signature:(int r, const Vec<Num_T> &v)
itpp::Mat::ins_row	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::ins_row(int r, const Vec<Num_T> &v)$/;"	f	class:itpp::Mat	signature:(int r, const Vec<Num_T> &v)
itpp::Mat::no_cols	/usr/include/itpp/base/mat.h	/^  int datasize, no_rows, no_cols;$/;"	m	class:itpp::Mat	access:protected
itpp::Mat::no_rows	/usr/include/itpp/base/mat.h	/^  int datasize, no_rows, no_cols;$/;"	m	class:itpp::Mat	access:protected
itpp::Mat::ones	/usr/include/itpp/base/mat.h	/^  void ones();$/;"	p	class:itpp::Mat	access:public	signature:()
itpp::Mat::ones	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::ones()$/;"	f	class:itpp::Mat	signature:()
itpp::Mat::operator !=	/usr/include/itpp/base/mat.h	/^  bool operator!=(const Mat<Num_T> &m) const;$/;"	p	class:itpp::Mat	access:public	signature:(const Mat<Num_T> &m) const
itpp::Mat::operator !=	/usr/include/itpp/base/mat.h	/^bool Mat<Num_T>::operator!=(const Mat<Num_T> &m) const$/;"	f	class:itpp::Mat	signature:(const Mat<Num_T> &m) const
itpp::Mat::operator ()	/usr/include/itpp/base/mat.h	/^  Mat<Num_T> operator()(int r1, int r2, int c1, int c2) const;$/;"	p	class:itpp::Mat	access:public	signature:(int r1, int r2, int c1, int c2) const
itpp::Mat::operator ()	/usr/include/itpp/base/mat.h	/^  Num_T &operator()(int i);$/;"	p	class:itpp::Mat	access:public	signature:(int i)
itpp::Mat::operator ()	/usr/include/itpp/base/mat.h	/^  Num_T &operator()(int r, int c);$/;"	p	class:itpp::Mat	access:public	signature:(int r, int c)
itpp::Mat::operator ()	/usr/include/itpp/base/mat.h	/^  const Num_T &operator()(int i) const;$/;"	p	class:itpp::Mat	access:public	signature:(int i) const
itpp::Mat::operator ()	/usr/include/itpp/base/mat.h	/^  const Num_T &operator()(int r, int c) const;$/;"	p	class:itpp::Mat	access:public	signature:(int r, int c) const
itpp::Mat::operator ()	/usr/include/itpp/base/mat.h	/^Mat<Num_T> Mat<Num_T>::operator()(int r1, int r2, int c1, int c2) const$/;"	f	class:itpp::Mat	signature:(int r1, int r2, int c1, int c2) const
itpp::Mat::operator ()	/usr/include/itpp/base/mat.h	/^Num_T& Mat<Num_T>::operator()(int i)$/;"	f	class:itpp::Mat	signature:(int i)
itpp::Mat::operator ()	/usr/include/itpp/base/mat.h	/^Num_T& Mat<Num_T>::operator()(int r, int c)$/;"	f	class:itpp::Mat	signature:(int r, int c)
itpp::Mat::operator ()	/usr/include/itpp/base/mat.h	/^const Num_T& Mat<Num_T>::operator()(int i) const$/;"	f	class:itpp::Mat	signature:(int i) const
itpp::Mat::operator ()	/usr/include/itpp/base/mat.h	/^const Num_T& Mat<Num_T>::operator()(int r, int c) const$/;"	f	class:itpp::Mat	signature:(int r, int c) const
itpp::Mat::operator *<>	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> operator*<>(Num_T t, const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:friend	signature:(Num_T t, const Mat<Num_T> &m)
itpp::Mat::operator *<>	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> operator*<>(const Mat<Num_T> &m, Num_T t);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m, Num_T t)
itpp::Mat::operator *<>	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> operator*<>(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::Mat::operator *<>	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> operator*<>(const Vec<Num_T> &v, const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:friend	signature:(const Vec<Num_T> &v, const Mat<Num_T> &m)
itpp::Mat::operator *<>	/usr/include/itpp/base/mat.h	/^  friend Vec<Num_T> operator*<>(const Mat<Num_T> &m, const Vec<Num_T> &v);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m, const Vec<Num_T> &v)
itpp::Mat::operator *=	/usr/include/itpp/base/mat.h	/^  Mat<Num_T>& operator*=(Num_T t);$/;"	p	class:itpp::Mat	access:public	signature:(Num_T t)
itpp::Mat::operator *=	/usr/include/itpp/base/mat.h	/^  Mat<Num_T>& operator*=(const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:public	signature:(const Mat<Num_T> &m)
itpp::Mat::operator *=	/usr/include/itpp/base/mat.h	/^Mat<Num_T>& Mat<Num_T>::operator*=(Num_T t)$/;"	f	class:itpp::Mat	signature:(Num_T t)
itpp::Mat::operator *=	/usr/include/itpp/base/mat.h	/^Mat<Num_T>& Mat<Num_T>::operator*=(const Mat<Num_T> &m)$/;"	f	class:itpp::Mat	signature:(const Mat<Num_T> &m)
itpp::Mat::operator +<>	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> operator+<>(Num_T t, const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:friend	signature:(Num_T t, const Mat<Num_T> &m)
itpp::Mat::operator +<>	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> operator+<>(const Mat<Num_T> &m, Num_T t);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m, Num_T t)
itpp::Mat::operator +<>	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> operator+<>(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::Mat::operator +=	/usr/include/itpp/base/mat.h	/^  Mat<Num_T>& operator+=(Num_T t);$/;"	p	class:itpp::Mat	access:public	signature:(Num_T t)
itpp::Mat::operator +=	/usr/include/itpp/base/mat.h	/^  Mat<Num_T>& operator+=(const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:public	signature:(const Mat<Num_T> &m)
itpp::Mat::operator +=	/usr/include/itpp/base/mat.h	/^Mat<Num_T>& Mat<Num_T>::operator+=(Num_T t)$/;"	f	class:itpp::Mat	signature:(Num_T t)
itpp::Mat::operator +=	/usr/include/itpp/base/mat.h	/^Mat<Num_T>& Mat<Num_T>::operator+=(const Mat<Num_T> &m)$/;"	f	class:itpp::Mat	signature:(const Mat<Num_T> &m)
itpp::Mat::operator -<>	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> operator-<>(Num_T t, const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:friend	signature:(Num_T t, const Mat<Num_T> &m)
itpp::Mat::operator -<>	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> operator-<>(const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m)
itpp::Mat::operator -<>	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> operator-<>(const Mat<Num_T> &m, Num_T t);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m, Num_T t)
itpp::Mat::operator -<>	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> operator-<>(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::Mat::operator -=	/usr/include/itpp/base/mat.h	/^  Mat<Num_T>& operator-=(Num_T t);$/;"	p	class:itpp::Mat	access:public	signature:(Num_T t)
itpp::Mat::operator -=	/usr/include/itpp/base/mat.h	/^  Mat<Num_T>& operator-=(const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:public	signature:(const Mat<Num_T> &m)
itpp::Mat::operator -=	/usr/include/itpp/base/mat.h	/^Mat<Num_T>& Mat<Num_T>::operator-=(Num_T t)$/;"	f	class:itpp::Mat	signature:(Num_T t)
itpp::Mat::operator -=	/usr/include/itpp/base/mat.h	/^Mat<Num_T>& Mat<Num_T>::operator-=(const Mat<Num_T> &m)$/;"	f	class:itpp::Mat	signature:(const Mat<Num_T> &m)
itpp::Mat::operator /<>	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> operator\/<>(const Mat<Num_T> &m, Num_T t);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m, Num_T t)
itpp::Mat::operator /=	/usr/include/itpp/base/mat.h	/^  Mat<Num_T>& operator\/=(Num_T t);$/;"	p	class:itpp::Mat	access:public	signature:(Num_T t)
itpp::Mat::operator /=	/usr/include/itpp/base/mat.h	/^  Mat<Num_T>& operator\/=(const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:public	signature:(const Mat<Num_T> &m)
itpp::Mat::operator /=	/usr/include/itpp/base/mat.h	/^Mat<Num_T>& Mat<Num_T>::operator\/=(Num_T t)$/;"	f	class:itpp::Mat	signature:(Num_T t)
itpp::Mat::operator /=	/usr/include/itpp/base/mat.h	/^Mat<Num_T>& Mat<Num_T>::operator\/=(const Mat<Num_T> &m)$/;"	f	class:itpp::Mat	signature:(const Mat<Num_T> &m)
itpp::Mat::operator =	/usr/include/itpp/base/mat.h	/^  Mat<Num_T>& operator=(Num_T t);$/;"	p	class:itpp::Mat	access:public	signature:(Num_T t)
itpp::Mat::operator =	/usr/include/itpp/base/mat.h	/^  Mat<Num_T>& operator=(const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:public	signature:(const Mat<Num_T> &m)
itpp::Mat::operator =	/usr/include/itpp/base/mat.h	/^  Mat<Num_T>& operator=(const Vec<Num_T> &v);$/;"	p	class:itpp::Mat	access:public	signature:(const Vec<Num_T> &v)
itpp::Mat::operator =	/usr/include/itpp/base/mat.h	/^  Mat<Num_T>& operator=(const char *str);$/;"	p	class:itpp::Mat	access:public	signature:(const char *str)
itpp::Mat::operator =	/usr/include/itpp/base/mat.h	/^Mat<Num_T>& Mat<Num_T>::operator=(Num_T t)$/;"	f	class:itpp::Mat	signature:(Num_T t)
itpp::Mat::operator =	/usr/include/itpp/base/mat.h	/^Mat<Num_T>& Mat<Num_T>::operator=(const Mat<Num_T> &m)$/;"	f	class:itpp::Mat	signature:(const Mat<Num_T> &m)
itpp::Mat::operator =	/usr/include/itpp/base/mat.h	/^Mat<Num_T>& Mat<Num_T>::operator=(const Vec<Num_T> &v)$/;"	f	class:itpp::Mat	signature:(const Vec<Num_T> &v)
itpp::Mat::operator =	/usr/include/itpp/base/mat.h	/^Mat<Num_T>& Mat<Num_T>::operator=(const char *str)$/;"	f	class:itpp::Mat	signature:(const char *str)
itpp::Mat::operator ==	/usr/include/itpp/base/mat.h	/^  bool operator==(const Mat<Num_T> &m) const;$/;"	p	class:itpp::Mat	access:public	signature:(const Mat<Num_T> &m) const
itpp::Mat::operator ==	/usr/include/itpp/base/mat.h	/^bool Mat<Num_T>::operator==(const Mat<Num_T> &m) const$/;"	f	class:itpp::Mat	signature:(const Mat<Num_T> &m) const
itpp::Mat::row_in_range	/usr/include/itpp/base/mat.h	/^  bool row_in_range(int r) const { return ((r >= 0) && (r < no_rows)); }$/;"	f	class:itpp::Mat	access:private	signature:(int r) const
itpp::Mat::rows	/usr/include/itpp/base/mat.h	/^  int rows() const { return no_rows; }$/;"	f	class:itpp::Mat	access:public	signature:() const
itpp::Mat::set	/usr/include/itpp/base/mat.h	/^  void set(const char *str);$/;"	p	class:itpp::Mat	access:public	signature:(const char *str)
itpp::Mat::set	/usr/include/itpp/base/mat.h	/^  void set(const std::string &str);$/;"	p	class:itpp::Mat	access:public	signature:(const std::string &str)
itpp::Mat::set	/usr/include/itpp/base/mat.h	/^  void set(int r, int c, Num_T t);$/;"	p	class:itpp::Mat	access:public	signature:(int r, int c, Num_T t)
itpp::Mat::set	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::set(const char *str)$/;"	f	class:itpp::Mat	signature:(const char *str)
itpp::Mat::set	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::set(const std::string &str)$/;"	f	class:itpp::Mat	signature:(const std::string &str)
itpp::Mat::set	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::set(int r, int c, Num_T t)$/;"	f	class:itpp::Mat	signature:(int r, int c, Num_T t)
itpp::Mat::set_col	/usr/include/itpp/base/mat.h	/^  void set_col(int c, const Vec<Num_T> &v);$/;"	p	class:itpp::Mat	access:public	signature:(int c, const Vec<Num_T> &v)
itpp::Mat::set_col	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::set_col(int c, const Vec<Num_T> &v)$/;"	f	class:itpp::Mat	signature:(int c, const Vec<Num_T> &v)
itpp::Mat::set_cols	/usr/include/itpp/base/mat.h	/^  void set_cols(int c, const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:public	signature:(int c, const Mat<Num_T> &m)
itpp::Mat::set_cols	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::set_cols(int c, const Mat<Num_T> &m)$/;"	f	class:itpp::Mat	signature:(int c, const Mat<Num_T> &m)
itpp::Mat::set_row	/usr/include/itpp/base/mat.h	/^  void set_row(int r, const Vec<Num_T> &v);$/;"	p	class:itpp::Mat	access:public	signature:(int r, const Vec<Num_T> &v)
itpp::Mat::set_row	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::set_row(int r, const Vec<Num_T> &v)$/;"	f	class:itpp::Mat	signature:(int r, const Vec<Num_T> &v)
itpp::Mat::set_rows	/usr/include/itpp/base/mat.h	/^  void set_rows(int r, const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:public	signature:(int r, const Mat<Num_T> &m)
itpp::Mat::set_rows	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::set_rows(int r, const Mat<Num_T> &m)$/;"	f	class:itpp::Mat	signature:(int r, const Mat<Num_T> &m)
itpp::Mat::set_size	/usr/include/itpp/base/mat.h	/^  void set_size(int rows, int cols, bool copy = false);$/;"	p	class:itpp::Mat	access:public	signature:(int rows, int cols, bool copy = false)
itpp::Mat::set_size	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::set_size(int rows, int cols, bool copy)$/;"	f	class:itpp::Mat	signature:(int rows, int cols, bool copy)
itpp::Mat::set_submatrix	/usr/include/itpp/base/mat.h	/^  void set_submatrix(int r, int c, const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:public	signature:(int r, int c, const Mat<Num_T> &m)
itpp::Mat::set_submatrix	/usr/include/itpp/base/mat.h	/^  void set_submatrix(int r1, int r2, int c1, int c2, Num_T t);$/;"	p	class:itpp::Mat	access:public	signature:(int r1, int r2, int c1, int c2, Num_T t)
itpp::Mat::set_submatrix	/usr/include/itpp/base/mat.h	/^  void set_submatrix(int r1, int r2, int c1, int c2, const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:public	signature:(int r1, int r2, int c1, int c2, const Mat<Num_T> &m)
itpp::Mat::set_submatrix	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::set_submatrix(int r, int c, const Mat<Num_T> &m)$/;"	f	class:itpp::Mat	signature:(int r, int c, const Mat<Num_T> &m)
itpp::Mat::set_submatrix	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::set_submatrix(int r1, int r2, int c1, int c2, Num_T t)$/;"	f	class:itpp::Mat	signature:(int r1, int r2, int c1, int c2, Num_T t)
itpp::Mat::set_submatrix	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::set_submatrix(int r1, int r2, int c1, int c2,$/;"	f	class:itpp::Mat	signature:(int r1, int r2, int c1, int c2, const Mat<Num_T> &m)
itpp::Mat::size	/usr/include/itpp/base/mat.h	/^  int size() const { return datasize; }$/;"	f	class:itpp::Mat	access:public	signature:() const
itpp::Mat::swap_cols	/usr/include/itpp/base/mat.h	/^  void swap_cols(int c1, int c2);$/;"	p	class:itpp::Mat	access:public	signature:(int c1, int c2)
itpp::Mat::swap_cols	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::swap_cols(int c1, int c2)$/;"	f	class:itpp::Mat	signature:(int c1, int c2)
itpp::Mat::swap_rows	/usr/include/itpp/base/mat.h	/^  void swap_rows(int r1, int r2);$/;"	p	class:itpp::Mat	access:public	signature:(int r1, int r2)
itpp::Mat::swap_rows	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::swap_rows(int r1, int r2)$/;"	f	class:itpp::Mat	signature:(int r1, int r2)
itpp::Mat::transpose	/usr/include/itpp/base/mat.h	/^  Mat<Num_T> transpose() const;$/;"	p	class:itpp::Mat	access:public	signature:() const
itpp::Mat::transpose	/usr/include/itpp/base/mat.h	/^Mat<Num_T> Mat<Num_T>::transpose() const$/;"	f	class:itpp::Mat	signature:() const
itpp::Mat::value_type	/usr/include/itpp/base/mat.h	/^  typedef Num_T value_type;$/;"	t	class:itpp::Mat	access:public
itpp::Mat::zeros	/usr/include/itpp/base/mat.h	/^  void zeros();$/;"	p	class:itpp::Mat	access:public	signature:()
itpp::Mat::zeros	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::zeros()$/;"	f	class:itpp::Mat	signature:()
itpp::Mat::~Mat	/usr/include/itpp/base/mat.h	/^  ~Mat();$/;"	p	class:itpp::Mat	access:public	signature:()
itpp::Mat::~Mat	/usr/include/itpp/base/mat.h	/^Mat<Num_T>::~Mat()$/;"	f	class:itpp::Mat	signature:()
itpp::Minimum	/usr/include/itpp/base/itassert.h	/^enum error_msg_style { Full, Minimum };$/;"	e	enum:itpp::error_msg_style
itpp::Modulator	/usr/include/itpp/comm/modulator.h	/^class Modulator$/;"	c	namespace:itpp
itpp::Modulator::M	/usr/include/itpp/comm/modulator.h	/^  int M;$/;"	m	class:itpp::Modulator	access:protected
itpp::Modulator::Modulator	/usr/include/itpp/comm/modulator.h	/^  Modulator();$/;"	p	class:itpp::Modulator	access:public	signature:()
itpp::Modulator::Modulator	/usr/include/itpp/comm/modulator.h	/^  Modulator(const Vec<T>& symbols, const ivec& bits2symbols);$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& symbols, const ivec& bits2symbols)
itpp::Modulator::Modulator	/usr/include/itpp/comm/modulator.h	/^Modulator<T>::Modulator() :$/;"	f	class:itpp::Modulator	signature:()
itpp::Modulator::Modulator	/usr/include/itpp/comm/modulator.h	/^Modulator<T>::Modulator(const Vec<T> &symbols, const ivec &bits2symbols)$/;"	f	class:itpp::Modulator	signature:(const Vec<T> &symbols, const ivec &bits2symbols)
itpp::Modulator::S0	/usr/include/itpp/comm/modulator.h	/^  imat S0;$/;"	m	class:itpp::Modulator	access:protected
itpp::Modulator::S1	/usr/include/itpp/comm/modulator.h	/^  imat S1;$/;"	m	class:itpp::Modulator	access:protected
itpp::Modulator::bitmap	/usr/include/itpp/comm/modulator.h	/^  bmat bitmap;$/;"	m	class:itpp::Modulator	access:protected
itpp::Modulator::bits2symbols	/usr/include/itpp/comm/modulator.h	/^  ivec bits2symbols;$/;"	m	class:itpp::Modulator	access:protected
itpp::Modulator::bits_per_symbol	/usr/include/itpp/comm/modulator.h	/^  virtual int bits_per_symbol() const { return k; }$/;"	f	class:itpp::Modulator	access:public	signature:() const
itpp::Modulator::calculate_softbit_matrices	/usr/include/itpp/comm/modulator.h	/^  void calculate_softbit_matrices();$/;"	p	class:itpp::Modulator	access:protected	signature:()
itpp::Modulator::calculate_softbit_matrices	/usr/include/itpp/comm/modulator.h	/^void Modulator<T>::calculate_softbit_matrices()$/;"	f	class:itpp::Modulator	signature:()
itpp::Modulator::demodulate	/usr/include/itpp/comm/modulator.h	/^  virtual ivec demodulate(const Vec<T>& signal) const;$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& signal) const
itpp::Modulator::demodulate	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate(const Vec<T>& signal, ivec& output) const;$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& signal, ivec& output) const
itpp::Modulator::demodulate	/usr/include/itpp/comm/modulator.h	/^ivec Modulator<T>::demodulate(const Vec<T>& signal) const$/;"	f	class:itpp::Modulator	signature:(const Vec<T>& signal) const
itpp::Modulator::demodulate	/usr/include/itpp/comm/modulator.h	/^void Modulator<T>::demodulate(const Vec<T> &signal, ivec& output) const$/;"	f	class:itpp::Modulator	signature:(const Vec<T> &signal, ivec& output) const
itpp::Modulator::demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  virtual bvec demodulate_bits(const Vec<T>& signal) const;$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& signal) const
itpp::Modulator::demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate_bits(const Vec<T>& signal, bvec& bits) const;$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& signal, bvec& bits) const
itpp::Modulator::demodulate_bits	/usr/include/itpp/comm/modulator.h	/^bvec Modulator<T>::demodulate_bits(const Vec<T> &signal) const$/;"	f	class:itpp::Modulator	signature:(const Vec<T> &signal) const
itpp::Modulator::demodulate_bits	/usr/include/itpp/comm/modulator.h	/^void Modulator<T>::demodulate_bits(const Vec<T> &signal, bvec &bits) const$/;"	f	class:itpp::Modulator	signature:(const Vec<T> &signal, bvec &bits) const
itpp::Modulator::demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual vec demodulate_soft_bits(const Vec<T>& rx_symbols, double N0,$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& rx_symbols, double N0, Soft_Method method = LOGMAP) const
itpp::Modulator::demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual vec demodulate_soft_bits(const Vec<T>& rx_symbols,$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& rx_symbols, const Vec<T>& channel, double N0, Soft_Method method = LOGMAP) const
itpp::Modulator::demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate_soft_bits(const Vec<T>& rx_symbols, double N0,$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& rx_symbols, double N0, vec& soft_bits, Soft_Method method = LOGMAP) const
itpp::Modulator::demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate_soft_bits(const Vec<T>& rx_symbols,$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& rx_symbols, const Vec<T>& channel, double N0, vec& soft_bits, Soft_Method method = LOGMAP) const
itpp::Modulator::demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^vec Modulator<T>::demodulate_soft_bits(const Vec<T> &rx_symbols,$/;"	f	class:itpp::Modulator	signature:(const Vec<T> &rx_symbols, const Vec<T> &channel, double N0, Soft_Method method) const
itpp::Modulator::demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^vec Modulator<T>::demodulate_soft_bits(const Vec<T> &rx_symbols,$/;"	f	class:itpp::Modulator	signature:(const Vec<T> &rx_symbols, double N0, Soft_Method method) const
itpp::Modulator::demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^void Modulator<T>::demodulate_soft_bits(const Vec<T> &rx_symbols, double N0,$/;"	f	class:itpp::Modulator	signature:(const Vec<T> &rx_symbols, double N0, vec &soft_bits, Soft_Method method) const
itpp::Modulator::demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^void Modulator<T>::demodulate_soft_bits(const Vec<T> &rx_symbols,$/;"	f	class:itpp::Modulator	signature:(const Vec<T> &rx_symbols, const Vec<T> &channel, double N0, vec &soft_bits, Soft_Method method) const
itpp::Modulator::demodulate_soft_bits_approx	/usr/include/itpp/comm/modulator.h	/^  virtual vec demodulate_soft_bits_approx(const Vec<T>& rx_symbols,$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& rx_symbols, const Vec<T>& channel, double N0) const
itpp::Modulator::demodulate_soft_bits_approx	/usr/include/itpp/comm/modulator.h	/^  virtual vec demodulate_soft_bits_approx(const Vec<T>& rx_symbols,$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& rx_symbols, double N0) const
itpp::Modulator::demodulate_soft_bits_approx	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate_soft_bits_approx(const Vec<T>& rx_symbols,$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& rx_symbols, const Vec<T>& channel, double N0, vec& soft_bits) const
itpp::Modulator::demodulate_soft_bits_approx	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate_soft_bits_approx(const Vec<T>& rx_symbols,$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& rx_symbols, double N0, vec& soft_bits) const
itpp::Modulator::demodulate_soft_bits_approx	/usr/include/itpp/comm/modulator.h	/^vec Modulator<T>::demodulate_soft_bits_approx(const Vec<T> &rx_symbols,$/;"	f	class:itpp::Modulator	signature:(const Vec<T> &rx_symbols, const Vec<T> &channel, double N0) const
itpp::Modulator::demodulate_soft_bits_approx	/usr/include/itpp/comm/modulator.h	/^vec Modulator<T>::demodulate_soft_bits_approx(const Vec<T> &rx_symbols,$/;"	f	class:itpp::Modulator	signature:(const Vec<T> &rx_symbols, double N0) const
itpp::Modulator::demodulate_soft_bits_approx	/usr/include/itpp/comm/modulator.h	/^void Modulator<T>::demodulate_soft_bits_approx(const Vec<T> &rx_symbols,$/;"	f	class:itpp::Modulator	signature:(const Vec<T> &rx_symbols, const Vec<T> &channel, double N0, vec &soft_bits) const
itpp::Modulator::demodulate_soft_bits_approx	/usr/include/itpp/comm/modulator.h	/^void Modulator<T>::demodulate_soft_bits_approx(const Vec<T> &rx_symbols,$/;"	f	class:itpp::Modulator	signature:(const Vec<T> &rx_symbols, double N0, vec &soft_bits) const
itpp::Modulator::get_bits2symbols	/usr/include/itpp/comm/modulator.h	/^  virtual ivec get_bits2symbols() const { return bits2symbols; }$/;"	f	class:itpp::Modulator	access:public	signature:() const
itpp::Modulator::get_symbols	/usr/include/itpp/comm/modulator.h	/^  virtual Vec<T> get_symbols() const { return symbols; }$/;"	f	class:itpp::Modulator	access:public	signature:() const
itpp::Modulator::k	/usr/include/itpp/comm/modulator.h	/^  int k;$/;"	m	class:itpp::Modulator	access:protected
itpp::Modulator::modulate	/usr/include/itpp/comm/modulator.h	/^  virtual Vec<T> modulate(const ivec& symbolnumbers) const;$/;"	p	class:itpp::Modulator	access:public	signature:(const ivec& symbolnumbers) const
itpp::Modulator::modulate	/usr/include/itpp/comm/modulator.h	/^  virtual void modulate(const ivec& symbolnumbers, Vec<T>& output) const;$/;"	p	class:itpp::Modulator	access:public	signature:(const ivec& symbolnumbers, Vec<T>& output) const
itpp::Modulator::modulate	/usr/include/itpp/comm/modulator.h	/^Vec<T> Modulator<T>::modulate(const ivec &symbolnumbers) const$/;"	f	class:itpp::Modulator	signature:(const ivec &symbolnumbers) const
itpp::Modulator::modulate	/usr/include/itpp/comm/modulator.h	/^void Modulator<T>::modulate(const ivec &symbolnumbers, Vec<T>& output) const$/;"	f	class:itpp::Modulator	signature:(const ivec &symbolnumbers, Vec<T>& output) const
itpp::Modulator::modulate_bits	/usr/include/itpp/comm/modulator.h	/^  virtual Vec<T> modulate_bits(const bvec& bits) const;$/;"	p	class:itpp::Modulator	access:public	signature:(const bvec& bits) const
itpp::Modulator::modulate_bits	/usr/include/itpp/comm/modulator.h	/^  virtual void modulate_bits(const bvec& bits, Vec<T>& output) const;$/;"	p	class:itpp::Modulator	access:public	signature:(const bvec& bits, Vec<T>& output) const
itpp::Modulator::modulate_bits	/usr/include/itpp/comm/modulator.h	/^Vec<T> Modulator<T>::modulate_bits(const bvec &bits) const$/;"	f	class:itpp::Modulator	signature:(const bvec &bits) const
itpp::Modulator::modulate_bits	/usr/include/itpp/comm/modulator.h	/^void Modulator<T>::modulate_bits(const bvec &bits, Vec<T> &output) const$/;"	f	class:itpp::Modulator	signature:(const bvec &bits, Vec<T> &output) const
itpp::Modulator::set	/usr/include/itpp/comm/modulator.h	/^  virtual void set(const Vec<T>& symbols, const ivec& bits2symbols);$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& symbols, const ivec& bits2symbols)
itpp::Modulator::set	/usr/include/itpp/comm/modulator.h	/^void Modulator<T>::set(const Vec<T> &in_symbols, const ivec &in_bits2symbols)$/;"	f	class:itpp::Modulator	signature:(const Vec<T> &in_symbols, const ivec &in_bits2symbols)
itpp::Modulator::setup_done	/usr/include/itpp/comm/modulator.h	/^  bool setup_done;$/;"	m	class:itpp::Modulator	access:protected
itpp::Modulator::symbols	/usr/include/itpp/comm/modulator.h	/^  Vec<T> symbols;$/;"	m	class:itpp::Modulator	access:protected
itpp::Modulator::~Modulator	/usr/include/itpp/comm/modulator.h	/^  virtual ~Modulator() {}$/;"	f	class:itpp::Modulator	access:public	signature:()
itpp::Modulator_1D	/usr/include/itpp/comm/modulator.h	/^typedef Modulator<double> Modulator_1D;$/;"	t	namespace:itpp
itpp::Modulator_2D	/usr/include/itpp/comm/modulator.h	/^typedef Modulator<std::complex<double> > Modulator_2D;$/;"	t	namespace:itpp
itpp::Modulator_NCD	/usr/include/itpp/comm/modulator_nd.h	/^class Modulator_NCD : public Modulator_ND$/;"	c	namespace:itpp	inherits:Modulator_ND
itpp::Modulator_NCD::Modulator_NCD	/usr/include/itpp/comm/modulator_nd.h	/^  Modulator_NCD() {}$/;"	f	class:itpp::Modulator_NCD	access:public	signature:()
itpp::Modulator_NCD::demodulate_soft_bits	/usr/include/itpp/comm/modulator_nd.h	/^  QLLRvec demodulate_soft_bits(const cvec &y, const cmat &H, double sigma2,$/;"	p	class:itpp::Modulator_NCD	access:public	signature:(const cvec &y, const cmat &H, double sigma2, const QLLRvec &LLR_apriori, Soft_Demod_Method method)
itpp::Modulator_NCD::demodulate_soft_bits	/usr/include/itpp/comm/modulator_nd.h	/^  void demodulate_soft_bits(const cvec &y, const cmat &H, double sigma2,$/;"	p	class:itpp::Modulator_NCD	access:public	signature:(const cvec &y, const cmat &H, double sigma2, const QLLRvec &LLR_apriori, QLLRvec &LLR_aposteriori)
itpp::Modulator_NCD::demodulate_soft_bits	/usr/include/itpp/comm/modulator_nd.h	/^  void demodulate_soft_bits(const cvec &y, const cmat &H, double sigma2,$/;"	p	class:itpp::Modulator_NCD	access:public	signature:(const cvec &y, const cmat &H, double sigma2, const QLLRvec &LLR_apriori, QLLRvec &LLR_aposteriori, Soft_Demod_Method method)
itpp::Modulator_NCD::demodulate_soft_bits	/usr/include/itpp/comm/modulator_nd.h	/^  void demodulate_soft_bits(const cvec &y, const cvec &H, double sigma2,$/;"	p	class:itpp::Modulator_NCD	access:public	signature:(const cvec &y, const cvec &H, double sigma2, const QLLRvec &LLR_apriori, QLLRvec &LLR_aposteriori)
itpp::Modulator_NCD::get_symbols	/usr/include/itpp/comm/modulator_nd.h	/^  Array<cvec> get_symbols() const { return symbols; }$/;"	f	class:itpp::Modulator_NCD	access:public	signature:() const
itpp::Modulator_NCD::modulate_bits	/usr/include/itpp/comm/modulator_nd.h	/^  cvec modulate_bits(const bvec &bits) const;$/;"	p	class:itpp::Modulator_NCD	access:public	signature:(const bvec &bits) const
itpp::Modulator_NCD::modulate_bits	/usr/include/itpp/comm/modulator_nd.h	/^  void modulate_bits(const bvec &bits, cvec &symbols) const;$/;"	p	class:itpp::Modulator_NCD	access:public	signature:(const bvec &bits, cvec &symbols) const
itpp::Modulator_NCD::operator <<	/usr/include/itpp/comm/modulator_nd.h	/^  friend std::ostream &operator<<(std::ostream &os, const Modulator_NCD &m);$/;"	p	class:itpp::Modulator_NCD	access:friend	signature:(std::ostream &os, const Modulator_NCD &m)
itpp::Modulator_NCD::symbols	/usr/include/itpp/comm/modulator_nd.h	/^  Array<cvec> symbols;$/;"	m	class:itpp::Modulator_NCD	access:protected
itpp::Modulator_NCD::update_norm	/usr/include/itpp/comm/modulator_nd.h	/^  void update_norm(double &norm, int k, int sold, int snew, const cvec &ytH,$/;"	p	class:itpp::Modulator_NCD	access:protected	signature:(double &norm, int k, int sold, int snew, const cvec &ytH, const cmat &HtH, const ivec &s)
itpp::Modulator_NCD::~Modulator_NCD	/usr/include/itpp/comm/modulator_nd.h	/^  ~Modulator_NCD() {}$/;"	f	class:itpp::Modulator_NCD	access:public	signature:()
itpp::Modulator_ND	/usr/include/itpp/comm/modulator_nd.h	/^class Modulator_ND$/;"	c	namespace:itpp
itpp::Modulator_ND::FULL_ENUM_LOGMAP	/usr/include/itpp/comm/modulator_nd.h	/^    FULL_ENUM_LOGMAP,$/;"	e	enum:itpp::Modulator_ND::Soft_Demod_Method
itpp::Modulator_ND::M	/usr/include/itpp/comm/modulator_nd.h	/^  ivec M;$/;"	m	class:itpp::Modulator_ND	access:protected
itpp::Modulator_ND::Modulator_ND	/usr/include/itpp/comm/modulator_nd.h	/^  Modulator_ND(LLR_calc_unit llrcalc_in = LLR_calc_unit()):$/;"	f	class:itpp::Modulator_ND	access:public	signature:(LLR_calc_unit llrcalc_in = LLR_calc_unit())
itpp::Modulator_ND::Soft_Demod_Method	/usr/include/itpp/comm/modulator_nd.h	/^  enum Soft_Demod_Method {$/;"	g	class:itpp::Modulator_ND	access:public
itpp::Modulator_ND::ZF_LOGMAP	/usr/include/itpp/comm/modulator_nd.h	/^    ZF_LOGMAP$/;"	e	enum:itpp::Modulator_ND::Soft_Demod_Method
itpp::Modulator_ND::bitmap	/usr/include/itpp/comm/modulator_nd.h	/^  Array<bmat> bitmap;$/;"	m	class:itpp::Modulator_ND	access:protected
itpp::Modulator_ND::bits2symbols	/usr/include/itpp/comm/modulator_nd.h	/^  Array<ivec> bits2symbols;$/;"	m	class:itpp::Modulator_ND	access:protected
itpp::Modulator_ND::get_M	/usr/include/itpp/comm/modulator_nd.h	/^  ivec get_M() const { return M; }$/;"	f	class:itpp::Modulator_ND	access:public	signature:() const
itpp::Modulator_ND::get_dim	/usr/include/itpp/comm/modulator_nd.h	/^  int get_dim() const { return nt; }$/;"	f	class:itpp::Modulator_ND	access:public	signature:() const
itpp::Modulator_ND::get_k	/usr/include/itpp/comm/modulator_nd.h	/^  ivec get_k() const { return k; }$/;"	f	class:itpp::Modulator_ND	access:public	signature:() const
itpp::Modulator_ND::get_llrcalc	/usr/include/itpp/comm/modulator_nd.h	/^  LLR_calc_unit get_llrcalc() const { return llrcalc; }$/;"	f	class:itpp::Modulator_ND	access:public	signature:() const
itpp::Modulator_ND::k	/usr/include/itpp/comm/modulator_nd.h	/^  ivec k;$/;"	m	class:itpp::Modulator_ND	access:protected
itpp::Modulator_ND::llrcalc	/usr/include/itpp/comm/modulator_nd.h	/^  LLR_calc_unit llrcalc;$/;"	m	class:itpp::Modulator_ND	access:protected
itpp::Modulator_ND::nt	/usr/include/itpp/comm/modulator_nd.h	/^  int nt;$/;"	m	class:itpp::Modulator_ND	access:protected
itpp::Modulator_ND::probabilities	/usr/include/itpp/comm/modulator_nd.h	/^  Array<QLLRvec> probabilities(const QLLRvec &l);$/;"	p	class:itpp::Modulator_ND	access:protected	signature:(const QLLRvec &l)
itpp::Modulator_ND::probabilities	/usr/include/itpp/comm/modulator_nd.h	/^  QLLRvec probabilities(QLLR l); \/\/ some abuse of what QLLR stands for...$/;"	p	class:itpp::Modulator_ND	access:protected	signature:(QLLR l)
itpp::Modulator_ND::set_llrcalc	/usr/include/itpp/comm/modulator_nd.h	/^  void set_llrcalc(LLR_calc_unit llrcalc_in) { llrcalc = llrcalc_in; };$/;"	f	class:itpp::Modulator_ND	access:public	signature:(LLR_calc_unit llrcalc_in)
itpp::Modulator_ND::update_LLR	/usr/include/itpp/comm/modulator_nd.h	/^  void update_LLR(const Array<QLLRvec> &logP_apriori, const ivec &s,$/;"	p	class:itpp::Modulator_ND	access:protected	signature:(const Array<QLLRvec> &logP_apriori, const ivec &s, QLLR scaled_norm, QLLRvec &num, QLLRvec &denom)
itpp::Modulator_ND::update_LLR	/usr/include/itpp/comm/modulator_nd.h	/^  void update_LLR(const Array<QLLRvec> &logP_apriori, int s,$/;"	p	class:itpp::Modulator_ND	access:protected	signature:(const Array<QLLRvec> &logP_apriori, int s, QLLR scaled_norm, int j, QLLRvec &num, QLLRvec &denom)
itpp::Modulator_ND::~Modulator_ND	/usr/include/itpp/comm/modulator_nd.h	/^  ~Modulator_ND() {}$/;"	f	class:itpp::Modulator_ND	access:public	signature:()
itpp::Modulator_NRD	/usr/include/itpp/comm/modulator_nd.h	/^class Modulator_NRD : public Modulator_ND$/;"	c	namespace:itpp	inherits:Modulator_ND
itpp::Modulator_NRD::Modulator_NRD	/usr/include/itpp/comm/modulator_nd.h	/^  Modulator_NRD() {}$/;"	f	class:itpp::Modulator_NRD	access:public	signature:()
itpp::Modulator_NRD::demodulate_soft_bits	/usr/include/itpp/comm/modulator_nd.h	/^  QLLRvec demodulate_soft_bits(const vec &y, const mat &H, double sigma2,$/;"	p	class:itpp::Modulator_NRD	access:public	signature:(const vec &y, const mat &H, double sigma2, const QLLRvec &LLR_apriori, Soft_Demod_Method method)
itpp::Modulator_NRD::demodulate_soft_bits	/usr/include/itpp/comm/modulator_nd.h	/^  void demodulate_soft_bits(const vec &y, const mat &H, double sigma2,$/;"	p	class:itpp::Modulator_NRD	access:public	signature:(const vec &y, const mat &H, double sigma2, const QLLRvec &LLR_apriori, QLLRvec &LLR_aposteriori)
itpp::Modulator_NRD::demodulate_soft_bits	/usr/include/itpp/comm/modulator_nd.h	/^  void demodulate_soft_bits(const vec &y, const mat &H, double sigma2,$/;"	p	class:itpp::Modulator_NRD	access:public	signature:(const vec &y, const mat &H, double sigma2, const QLLRvec &LLR_apriori, QLLRvec &LLR_aposteriori, Soft_Demod_Method method)
itpp::Modulator_NRD::demodulate_soft_bits	/usr/include/itpp/comm/modulator_nd.h	/^  void demodulate_soft_bits(const vec &y, const vec &h, double sigma2,$/;"	p	class:itpp::Modulator_NRD	access:public	signature:(const vec &y, const vec &h, double sigma2, const QLLRvec &LLR_apriori, QLLRvec &LLR_aposteriori)
itpp::Modulator_NRD::get_symbols	/usr/include/itpp/comm/modulator_nd.h	/^  Array<vec> get_symbols() const { return symbols; }$/;"	f	class:itpp::Modulator_NRD	access:public	signature:() const
itpp::Modulator_NRD::modulate_bits	/usr/include/itpp/comm/modulator_nd.h	/^  vec modulate_bits(const bvec &bits) const;$/;"	p	class:itpp::Modulator_NRD	access:public	signature:(const bvec &bits) const
itpp::Modulator_NRD::modulate_bits	/usr/include/itpp/comm/modulator_nd.h	/^  void modulate_bits(const bvec &bits, vec &symbols) const;$/;"	p	class:itpp::Modulator_NRD	access:public	signature:(const bvec &bits, vec &symbols) const
itpp::Modulator_NRD::operator <<	/usr/include/itpp/comm/modulator_nd.h	/^  friend std::ostream &operator<<(std::ostream &os, const Modulator_NRD &m);$/;"	p	class:itpp::Modulator_NRD	access:friend	signature:(std::ostream &os, const Modulator_NRD &m)
itpp::Modulator_NRD::symbols	/usr/include/itpp/comm/modulator_nd.h	/^  Array<vec> symbols;$/;"	m	class:itpp::Modulator_NRD	access:protected
itpp::Modulator_NRD::update_norm	/usr/include/itpp/comm/modulator_nd.h	/^  void update_norm(double &norm, int k, int sold, int snew, const vec &ytH,$/;"	p	class:itpp::Modulator_NRD	access:protected	signature:(double &norm, int k, int sold, int snew, const vec &ytH, const mat &HtH, const ivec &s)
itpp::Modulator_NRD::~Modulator_NRD	/usr/include/itpp/comm/modulator_nd.h	/^  ~Modulator_NRD() {}$/;"	f	class:itpp::Modulator_NRD	access:public	signature:()
itpp::Multicode_Spread_1d	/usr/include/itpp/comm/spread.h	/^class Multicode_Spread_1d$/;"	c	namespace:itpp
itpp::Multicode_Spread_1d::L	/usr/include/itpp/comm/spread.h	/^  short L;$/;"	m	class:itpp::Multicode_Spread_1d	access:protected
itpp::Multicode_Spread_1d::Multicode_Spread_1d	/usr/include/itpp/comm/spread.h	/^  Multicode_Spread_1d() { }$/;"	f	class:itpp::Multicode_Spread_1d	access:public	signature:()
itpp::Multicode_Spread_1d::Multicode_Spread_1d	/usr/include/itpp/comm/spread.h	/^  Multicode_Spread_1d(const mat &incodes);$/;"	p	class:itpp::Multicode_Spread_1d	access:public	signature:(const mat &incodes)
itpp::Multicode_Spread_1d::N	/usr/include/itpp/comm/spread.h	/^  short N;$/;"	m	class:itpp::Multicode_Spread_1d	access:protected
itpp::Multicode_Spread_1d::codes	/usr/include/itpp/comm/spread.h	/^  mat codes;$/;"	m	class:itpp::Multicode_Spread_1d	access:protected
itpp::Multicode_Spread_1d::despread	/usr/include/itpp/comm/spread.h	/^  vec despread(const vec &receivedsignal, int timing);$/;"	p	class:itpp::Multicode_Spread_1d	access:public	signature:(const vec &receivedsignal, int timing)
itpp::Multicode_Spread_1d::get_codes	/usr/include/itpp/comm/spread.h	/^  mat get_codes();$/;"	p	class:itpp::Multicode_Spread_1d	access:public	signature:()
itpp::Multicode_Spread_1d::get_nocodes	/usr/include/itpp/comm/spread.h	/^  short get_nocodes() { return L; }$/;"	f	class:itpp::Multicode_Spread_1d	access:public	signature:()
itpp::Multicode_Spread_1d::get_period	/usr/include/itpp/comm/spread.h	/^  short get_period() { return N; }$/;"	f	class:itpp::Multicode_Spread_1d	access:public	signature:()
itpp::Multicode_Spread_1d::set_codes	/usr/include/itpp/comm/spread.h	/^  void set_codes(const mat &incodes);$/;"	p	class:itpp::Multicode_Spread_1d	access:public	signature:(const mat &incodes)
itpp::Multicode_Spread_1d::spread	/usr/include/itpp/comm/spread.h	/^  vec spread(const vec &symbols);$/;"	p	class:itpp::Multicode_Spread_1d	access:public	signature:(const vec &symbols)
itpp::Multicode_Spread_2d	/usr/include/itpp/comm/spread.h	/^class Multicode_Spread_2d$/;"	c	namespace:itpp
itpp::Multicode_Spread_2d::Multicode_Spread_2d	/usr/include/itpp/comm/spread.h	/^  Multicode_Spread_2d() { }$/;"	f	class:itpp::Multicode_Spread_2d	access:public	signature:()
itpp::Multicode_Spread_2d::Multicode_Spread_2d	/usr/include/itpp/comm/spread.h	/^  Multicode_Spread_2d(const mat &incodesI, const mat &incodesQ);$/;"	p	class:itpp::Multicode_Spread_2d	access:public	signature:(const mat &incodesI, const mat &incodesQ)
itpp::Multicode_Spread_2d::despread	/usr/include/itpp/comm/spread.h	/^  cvec despread(const cvec &receivedsignal, int timing);$/;"	p	class:itpp::Multicode_Spread_2d	access:public	signature:(const cvec &receivedsignal, int timing)
itpp::Multicode_Spread_2d::get_codesI	/usr/include/itpp/comm/spread.h	/^  mat get_codesI();$/;"	p	class:itpp::Multicode_Spread_2d	access:public	signature:()
itpp::Multicode_Spread_2d::get_codesQ	/usr/include/itpp/comm/spread.h	/^  mat get_codesQ();$/;"	p	class:itpp::Multicode_Spread_2d	access:public	signature:()
itpp::Multicode_Spread_2d::get_period	/usr/include/itpp/comm/spread.h	/^  short get_period() { return mcspreadI.get_period(); }$/;"	f	class:itpp::Multicode_Spread_2d	access:public	signature:()
itpp::Multicode_Spread_2d::mcspreadI	/usr/include/itpp/comm/spread.h	/^  Multicode_Spread_1d mcspreadI, mcspreadQ;$/;"	m	class:itpp::Multicode_Spread_2d	access:protected
itpp::Multicode_Spread_2d::mcspreadQ	/usr/include/itpp/comm/spread.h	/^  Multicode_Spread_1d mcspreadI, mcspreadQ;$/;"	m	class:itpp::Multicode_Spread_2d	access:protected
itpp::Multicode_Spread_2d::set_codes	/usr/include/itpp/comm/spread.h	/^  void set_codes(const mat &incodesI, const mat &incodesQ);$/;"	p	class:itpp::Multicode_Spread_2d	access:public	signature:(const mat &incodesI, const mat &incodesQ)
itpp::Multicode_Spread_2d::spread	/usr/include/itpp/comm/spread.h	/^  cvec spread(const cvec &symbols);$/;"	p	class:itpp::Multicode_Spread_2d	access:public	signature:(const cvec &symbols)
itpp::ND_UPAM	/usr/include/itpp/comm/modulator_nd.h	/^class ND_UPAM : public Modulator_NRD$/;"	c	namespace:itpp	inherits:Modulator_NRD
itpp::ND_UPAM::ND_UPAM	/usr/include/itpp/comm/modulator_nd.h	/^  ND_UPAM(int nt = 1, int Mary = 2);$/;"	p	class:itpp::ND_UPAM	access:public	signature:(int nt = 1, int Mary = 2)
itpp::ND_UPAM::set_M	/usr/include/itpp/comm/modulator_nd.h	/^  void set_M(int nt = 1, int Mary = 2);$/;"	p	class:itpp::ND_UPAM	access:public	signature:(int nt = 1, int Mary = 2)
itpp::ND_UPAM::set_M	/usr/include/itpp/comm/modulator_nd.h	/^  void set_M(int nt = 1, ivec Mary = "2");$/;"	p	class:itpp::ND_UPAM	access:public	signature:(int nt = 1, ivec Mary = Ó)
itpp::ND_UPAM::sign_nozero_i	/usr/include/itpp/comm/modulator_nd.h	/^  inline int sign_nozero_i(double a) { return (a > 0.0 ? 1 : -1); }$/;"	f	class:itpp::ND_UPAM	access:private	signature:(double a)
itpp::ND_UPAM::sign_nozero_i	/usr/include/itpp/comm/modulator_nd.h	/^  inline int sign_nozero_i(int a) { return (a > 0 ? 1 : -1); }$/;"	f	class:itpp::ND_UPAM	access:private	signature:(int a)
itpp::ND_UPAM::spacing	/usr/include/itpp/comm/modulator_nd.h	/^  vec spacing;  \/\/ spacing between the constellation points$/;"	m	class:itpp::ND_UPAM	access:private
itpp::ND_UPAM::sphere_decoding	/usr/include/itpp/comm/modulator_nd.h	/^  int sphere_decoding(const vec &y, const mat &H, double rmin, double rmax,$/;"	p	class:itpp::ND_UPAM	access:public	signature:(const vec &y, const mat &H, double rmin, double rmax, double stepup, QLLRvec &detected_bits)
itpp::ND_UPAM::sphere_search_SE	/usr/include/itpp/comm/modulator_nd.h	/^  int sphere_search_SE(const vec &y, const mat &H, const imat &zrange,$/;"	p	class:itpp::ND_UPAM	access:private	signature:(const vec &y, const mat &H, const imat &zrange, double r, ivec &zhat)
itpp::ND_UPAM::~ND_UPAM	/usr/include/itpp/comm/modulator_nd.h	/^  ~ND_UPAM() {}$/;"	f	class:itpp::ND_UPAM	access:public	signature:()
itpp::ND_UPSK	/usr/include/itpp/comm/modulator_nd.h	/^class ND_UPSK : public Modulator_NCD$/;"	c	namespace:itpp	inherits:Modulator_NCD
itpp::ND_UPSK::ND_UPSK	/usr/include/itpp/comm/modulator_nd.h	/^  ND_UPSK(int nt = 1, int Mary = 4);$/;"	p	class:itpp::ND_UPSK	access:public	signature:(int nt = 1, int Mary = 4)
itpp::ND_UPSK::set_M	/usr/include/itpp/comm/modulator_nd.h	/^  void set_M(int nt = 1, int Mary = 4);$/;"	p	class:itpp::ND_UPSK	access:public	signature:(int nt = 1, int Mary = 4)
itpp::ND_UPSK::set_M	/usr/include/itpp/comm/modulator_nd.h	/^  void set_M(int nt = 1, ivec Mary = "4");$/;"	p	class:itpp::ND_UPSK	access:public	signature:(int nt = 1, ivec Mary = Ó)
itpp::ND_UPSK::~ND_UPSK	/usr/include/itpp/comm/modulator_nd.h	/^  ~ND_UPSK() {}$/;"	f	class:itpp::ND_UPSK	access:public	signature:()
itpp::ND_UQAM	/usr/include/itpp/comm/modulator_nd.h	/^class ND_UQAM : public Modulator_NCD$/;"	c	namespace:itpp	inherits:Modulator_NCD
itpp::ND_UQAM::L	/usr/include/itpp/comm/modulator_nd.h	/^  ivec L;  \/\/!< the square root of M$/;"	m	class:itpp::ND_UQAM	access:protected
itpp::ND_UQAM::ND_UQAM	/usr/include/itpp/comm/modulator_nd.h	/^  ND_UQAM(int nt = 1, int Mary = 4);$/;"	p	class:itpp::ND_UQAM	access:public	signature:(int nt = 1, int Mary = 4)
itpp::ND_UQAM::set_M	/usr/include/itpp/comm/modulator_nd.h	/^  void set_M(int nt = 1, int Mary = 4);$/;"	p	class:itpp::ND_UQAM	access:public	signature:(int nt = 1, int Mary = 4)
itpp::ND_UQAM::set_M	/usr/include/itpp/comm/modulator_nd.h	/^  void set_M(int nt = 1, ivec Mary = "4");$/;"	p	class:itpp::ND_UQAM	access:public	signature:(int nt = 1, ivec Mary = Ó)
itpp::ND_UQAM::~ND_UQAM	/usr/include/itpp/comm/modulator_nd.h	/^  ~ND_UQAM() {}$/;"	f	class:itpp::ND_UQAM	access:public	signature:()
itpp::Name	/usr/include/itpp/base/itfile.h	/^class Name$/;"	c	namespace:itpp
itpp::Name::Name	/usr/include/itpp/base/itfile.h	/^  Name(const std::string& n, const std::string& d = ""): name(n), desc(d) {}$/;"	f	class:itpp::Name	access:public	signature:(const std::string& n, const std::string& d = Ó)
itpp::Name::desc	/usr/include/itpp/base/itfile.h	/^  const std::string& desc;$/;"	m	class:itpp::Name	access:public
itpp::Name::name	/usr/include/itpp/base/itfile.h	/^  const std::string& name;$/;"	m	class:itpp::Name	access:public
itpp::Name::operator =	/usr/include/itpp/base/itfile.h	/^  Name &operator=(const Name&) { return *this; }$/;"	f	class:itpp::Name	access:public	signature:(const Name&)
itpp::Newton_Search	/usr/include/itpp/optim/newton_search.h	/^class Newton_Search$/;"	c	namespace:itpp
itpp::Newton_Search::D_start	/usr/include/itpp/optim/newton_search.h	/^  mat D_start;$/;"	m	class:itpp::Newton_Search	access:private
itpp::Newton_Search::Delta_values	/usr/include/itpp/optim/newton_search.h	/^  vec F_values, ng_values, Delta_values;$/;"	m	class:itpp::Newton_Search	access:private
itpp::Newton_Search::F	/usr/include/itpp/optim/newton_search.h	/^  double F, ng, nh; \/\/ function value, stop_1, stop_2 values at solution point$/;"	m	class:itpp::Newton_Search	access:private
itpp::Newton_Search::F_values	/usr/include/itpp/optim/newton_search.h	/^  vec F_values, ng_values, Delta_values;$/;"	m	class:itpp::Newton_Search	access:private
itpp::Newton_Search::Newton_Search	/usr/include/itpp/optim/newton_search.h	/^  Newton_Search();$/;"	p	class:itpp::Newton_Search	access:public	signature:()
itpp::Newton_Search::df_dx	/usr/include/itpp/optim/newton_search.h	/^  vec(*df_dx)(const vec&);  \/\/ df\/dx, gradient of f$/;"	m	class:itpp::Newton_Search	access:private
itpp::Newton_Search::disable_trace	/usr/include/itpp/optim/newton_search.h	/^  void disable_trace() { trace = false; }$/;"	f	class:itpp::Newton_Search	access:public	signature:()
itpp::Newton_Search::enable_trace	/usr/include/itpp/optim/newton_search.h	/^  void enable_trace() { trace = true; }$/;"	f	class:itpp::Newton_Search	access:public	signature:()
itpp::Newton_Search::f	/usr/include/itpp/optim/newton_search.h	/^  double(*f)(const vec&);  \/\/ function to minimize$/;"	m	class:itpp::Newton_Search	access:private
itpp::Newton_Search::finished	/usr/include/itpp/optim/newton_search.h	/^  bool init, finished, trace;$/;"	m	class:itpp::Newton_Search	access:private
itpp::Newton_Search::get_epsilon_1	/usr/include/itpp/optim/newton_search.h	/^  double get_epsilon_1() { return stop_epsilon_1; }$/;"	f	class:itpp::Newton_Search	access:public	signature:()
itpp::Newton_Search::get_epsilon_2	/usr/include/itpp/optim/newton_search.h	/^  double get_epsilon_2() { return stop_epsilon_2; }$/;"	f	class:itpp::Newton_Search	access:public	signature:()
itpp::Newton_Search::get_function_value	/usr/include/itpp/optim/newton_search.h	/^  double get_function_value();$/;"	p	class:itpp::Newton_Search	access:public	signature:()
itpp::Newton_Search::get_initial_stepsize	/usr/include/itpp/optim/newton_search.h	/^  double get_initial_stepsize() { return initial_stepsize; }$/;"	f	class:itpp::Newton_Search	access:public	signature:()
itpp::Newton_Search::get_max_evaluations	/usr/include/itpp/optim/newton_search.h	/^  int get_max_evaluations() { return max_evaluations; }$/;"	f	class:itpp::Newton_Search	access:public	signature:()
itpp::Newton_Search::get_no_function_evaluations	/usr/include/itpp/optim/newton_search.h	/^  int get_no_function_evaluations();$/;"	p	class:itpp::Newton_Search	access:public	signature:()
itpp::Newton_Search::get_no_iterations	/usr/include/itpp/optim/newton_search.h	/^  int get_no_iterations();$/;"	p	class:itpp::Newton_Search	access:public	signature:()
itpp::Newton_Search::get_solution	/usr/include/itpp/optim/newton_search.h	/^  vec get_solution();$/;"	p	class:itpp::Newton_Search	access:public	signature:()
itpp::Newton_Search::get_stop_1	/usr/include/itpp/optim/newton_search.h	/^  double get_stop_1();$/;"	p	class:itpp::Newton_Search	access:public	signature:()
itpp::Newton_Search::get_stop_2	/usr/include/itpp/optim/newton_search.h	/^  double get_stop_2();$/;"	p	class:itpp::Newton_Search	access:public	signature:()
itpp::Newton_Search::get_trace	/usr/include/itpp/optim/newton_search.h	/^  void get_trace(Array<vec> & xvalues, vec &Fvalues, vec &ngvalues, vec &dvalues);$/;"	p	class:itpp::Newton_Search	access:public	signature:(Array<vec> & xvalues, vec &Fvalues, vec &ngvalues, vec &dvalues)
itpp::Newton_Search::init	/usr/include/itpp/optim/newton_search.h	/^  bool init, finished, trace;$/;"	m	class:itpp::Newton_Search	access:private
itpp::Newton_Search::initial_stepsize	/usr/include/itpp/optim/newton_search.h	/^  double initial_stepsize; \/\/ opts(1)$/;"	m	class:itpp::Newton_Search	access:private
itpp::Newton_Search::max_evaluations	/usr/include/itpp/optim/newton_search.h	/^  int max_evaluations; \/\/ opts(4)$/;"	m	class:itpp::Newton_Search	access:private
itpp::Newton_Search::method	/usr/include/itpp/optim/newton_search.h	/^  Newton_Search_Method method;$/;"	m	class:itpp::Newton_Search	access:private
itpp::Newton_Search::n	/usr/include/itpp/optim/newton_search.h	/^  int n; \/\/ dimension of problem, size(x)$/;"	m	class:itpp::Newton_Search	access:private
itpp::Newton_Search::ng	/usr/include/itpp/optim/newton_search.h	/^  double F, ng, nh; \/\/ function value, stop_1, stop_2 values at solution point$/;"	m	class:itpp::Newton_Search	access:private
itpp::Newton_Search::ng_values	/usr/include/itpp/optim/newton_search.h	/^  vec F_values, ng_values, Delta_values;$/;"	m	class:itpp::Newton_Search	access:private
itpp::Newton_Search::nh	/usr/include/itpp/optim/newton_search.h	/^  double F, ng, nh; \/\/ function value, stop_1, stop_2 values at solution point$/;"	m	class:itpp::Newton_Search	access:private
itpp::Newton_Search::no_feval	/usr/include/itpp/optim/newton_search.h	/^  int no_feval; \/\/ number of function evaluations$/;"	m	class:itpp::Newton_Search	access:private
itpp::Newton_Search::no_iter	/usr/include/itpp/optim/newton_search.h	/^  int no_iter; \/\/ number of iterations$/;"	m	class:itpp::Newton_Search	access:private
itpp::Newton_Search::search	/usr/include/itpp/optim/newton_search.h	/^  bool search();$/;"	p	class:itpp::Newton_Search	access:public	signature:()
itpp::Newton_Search::search	/usr/include/itpp/optim/newton_search.h	/^  bool search(const vec &x0, vec &xn);$/;"	p	class:itpp::Newton_Search	access:public	signature:(const vec &x0, vec &xn)
itpp::Newton_Search::search	/usr/include/itpp/optim/newton_search.h	/^  bool search(vec &xn);$/;"	p	class:itpp::Newton_Search	access:public	signature:(vec &xn)
itpp::Newton_Search::set_function	/usr/include/itpp/optim/newton_search.h	/^  void set_function(double(*function)(const vec&));$/;"	p	class:itpp::Newton_Search	access:public	signature:(double(*function)(const vec&))
itpp::Newton_Search::set_functions	/usr/include/itpp/optim/newton_search.h	/^  void set_functions(double(*function)(const vec&), vec(*gradient)(const vec&)) { set_function(function); set_gradient(gradient); }$/;"	f	class:itpp::Newton_Search	access:public	signature:(double(*function)(const vec&), vec(*gradient)(const vec&))
itpp::Newton_Search::set_gradient	/usr/include/itpp/optim/newton_search.h	/^  void set_gradient(vec(*gradient)(const vec&));$/;"	p	class:itpp::Newton_Search	access:public	signature:(vec(gradient)const vec&))
itpp::Newton_Search::set_initial_stepsize	/usr/include/itpp/optim/newton_search.h	/^  void set_initial_stepsize(double value);$/;"	p	class:itpp::Newton_Search	access:public	signature:(double value)
itpp::Newton_Search::set_max_evaluations	/usr/include/itpp/optim/newton_search.h	/^  void set_max_evaluations(int value);$/;"	p	class:itpp::Newton_Search	access:public	signature:(int value)
itpp::Newton_Search::set_method	/usr/include/itpp/optim/newton_search.h	/^  void set_method(const Newton_Search_Method &method);$/;"	p	class:itpp::Newton_Search	access:public	signature:(const Newton_Search_Method &method)
itpp::Newton_Search::set_start_point	/usr/include/itpp/optim/newton_search.h	/^  void set_start_point(const vec &x);$/;"	p	class:itpp::Newton_Search	access:public	signature:(const vec &x)
itpp::Newton_Search::set_start_point	/usr/include/itpp/optim/newton_search.h	/^  void set_start_point(const vec &x, const mat &D);$/;"	p	class:itpp::Newton_Search	access:public	signature:(const vec &x, const mat &D)
itpp::Newton_Search::set_stop_values	/usr/include/itpp/optim/newton_search.h	/^  void set_stop_values(double epsilon_1, double epsilon_2);$/;"	p	class:itpp::Newton_Search	access:public	signature:(double epsilon_1, double epsilon_2)
itpp::Newton_Search::stop_epsilon_1	/usr/include/itpp/optim/newton_search.h	/^  double stop_epsilon_1; \/\/ opts(2)$/;"	m	class:itpp::Newton_Search	access:private
itpp::Newton_Search::stop_epsilon_2	/usr/include/itpp/optim/newton_search.h	/^  double stop_epsilon_2; \/\/ opt(3)$/;"	m	class:itpp::Newton_Search	access:private
itpp::Newton_Search::trace	/usr/include/itpp/optim/newton_search.h	/^  bool init, finished, trace;$/;"	m	class:itpp::Newton_Search	access:private
itpp::Newton_Search::x_end	/usr/include/itpp/optim/newton_search.h	/^  vec x_end;$/;"	m	class:itpp::Newton_Search	access:private
itpp::Newton_Search::x_start	/usr/include/itpp/optim/newton_search.h	/^  vec x_start;$/;"	m	class:itpp::Newton_Search	access:private
itpp::Newton_Search::x_values	/usr/include/itpp/optim/newton_search.h	/^  Array<vec> x_values;$/;"	m	class:itpp::Newton_Search	access:private
itpp::Newton_Search::~Newton_Search	/usr/include/itpp/optim/newton_search.h	/^  ~Newton_Search() {};$/;"	f	class:itpp::Newton_Search	access:public	signature:()
itpp::Newton_Search_Method	/usr/include/itpp/optim/newton_search.h	/^enum Newton_Search_Method {BFGS};$/;"	g	namespace:itpp
itpp::Normal_RNG	/usr/include/itpp/base/random.h	/^class Normal_RNG$/;"	c	namespace:itpp
itpp::Normal_RNG::Normal_RNG	/usr/include/itpp/base/random.h	/^  Normal_RNG(): mean(0.0), sigma(1.0) {}$/;"	f	class:itpp::Normal_RNG	access:public	signature:()
itpp::Normal_RNG::Normal_RNG	/usr/include/itpp/base/random.h	/^  Normal_RNG(double meanval, double variance):$/;"	f	class:itpp::Normal_RNG	access:public	signature:(double meanval, double variance)
itpp::Normal_RNG::PARAM_R	/usr/include/itpp/base/random.h	/^  static const double PARAM_R;$/;"	m	class:itpp::Normal_RNG	access:private
itpp::Normal_RNG::RNG	/usr/include/itpp/base/random.h	/^  Random_Generator RNG;$/;"	m	class:itpp::Normal_RNG	access:private
itpp::Normal_RNG::get_setup	/usr/include/itpp/base/random.h	/^  void get_setup(double &meanval, double &variance) const;$/;"	p	class:itpp::Normal_RNG	access:public	signature:(double &meanval, double &variance) const
itpp::Normal_RNG::ktab	/usr/include/itpp/base/random.h	/^  static const unsigned int ktab[128];$/;"	m	class:itpp::Normal_RNG	access:private
itpp::Normal_RNG::mean	/usr/include/itpp/base/random.h	/^  double mean, sigma;$/;"	m	class:itpp::Normal_RNG	access:private
itpp::Normal_RNG::operator ()	/usr/include/itpp/base/random.h	/^  double operator()() { return (sigma*sample() + mean); }$/;"	f	class:itpp::Normal_RNG	access:public	signature:()
itpp::Normal_RNG::operator ()	/usr/include/itpp/base/random.h	/^  mat operator()(int h, int w) {$/;"	f	class:itpp::Normal_RNG	access:public	signature:(int h, int w)
itpp::Normal_RNG::operator ()	/usr/include/itpp/base/random.h	/^  vec operator()(int n) {$/;"	f	class:itpp::Normal_RNG	access:public	signature:(int n)
itpp::Normal_RNG::sample	/usr/include/itpp/base/random.h	/^  double sample();$/;"	p	class:itpp::Normal_RNG	access:public	signature:()
itpp::Normal_RNG::sample_matrix	/usr/include/itpp/base/random.h	/^  void sample_matrix(int rows, int cols, mat &out) {$/;"	f	class:itpp::Normal_RNG	access:public	signature:(int rows, int cols, mat &out)
itpp::Normal_RNG::sample_vector	/usr/include/itpp/base/random.h	/^  void sample_vector(int size, vec &out) {$/;"	f	class:itpp::Normal_RNG	access:public	signature:(int size, vec &out)
itpp::Normal_RNG::setup	/usr/include/itpp/base/random.h	/^  void setup(double meanval, double variance)$/;"	f	class:itpp::Normal_RNG	access:public	signature:(double meanval, double variance)
itpp::Normal_RNG::sigma	/usr/include/itpp/base/random.h	/^  double mean, sigma;$/;"	m	class:itpp::Normal_RNG	access:private
itpp::Normal_RNG::wtab	/usr/include/itpp/base/random.h	/^  static const double wtab[128];$/;"	m	class:itpp::Normal_RNG	access:private
itpp::Normal_RNG::ytab	/usr/include/itpp/base/random.h	/^  static const double ytab[128];$/;"	m	class:itpp::Normal_RNG	access:private
itpp::ODS	/usr/include/itpp/comm/convcode.h	/^enum CONVOLUTIONAL_CODE_TYPE {MFD, ODS};$/;"	e	enum:itpp::CONVOLUTIONAL_CODE_TYPE
itpp::OFDM	/usr/include/itpp/comm/ofdm.h	/^class OFDM$/;"	c	namespace:itpp
itpp::OFDM::Ncp	/usr/include/itpp/comm/ofdm.h	/^  int Nfft, Ncp, Nupsample;$/;"	m	class:itpp::OFDM	access:private
itpp::OFDM::Nfft	/usr/include/itpp/comm/ofdm.h	/^  int Nfft, Ncp, Nupsample;$/;"	m	class:itpp::OFDM	access:private
itpp::OFDM::Nupsample	/usr/include/itpp/comm/ofdm.h	/^  int Nfft, Ncp, Nupsample;$/;"	m	class:itpp::OFDM	access:private
itpp::OFDM::OFDM	/usr/include/itpp/comm/ofdm.h	/^  OFDM(int inNfft, int inNcp, int inNupsample = 1);$/;"	p	class:itpp::OFDM	access:public	signature:(int inNfft, int inNcp, int inNupsample = 1)
itpp::OFDM::OFDM	/usr/include/itpp/comm/ofdm.h	/^  OFDM(void) { setup_done = false; }$/;"	f	class:itpp::OFDM	access:public	signature:(void)
itpp::OFDM::demodulate	/usr/include/itpp/comm/ofdm.h	/^  cvec demodulate(const cvec &input);$/;"	p	class:itpp::OFDM	access:public	signature:(const cvec &input)
itpp::OFDM::demodulate	/usr/include/itpp/comm/ofdm.h	/^  void demodulate(const cvec &input, cvec &output);$/;"	p	class:itpp::OFDM	access:public	signature:(const cvec &input, cvec &output)
itpp::OFDM::modulate	/usr/include/itpp/comm/ofdm.h	/^  cvec modulate(const cvec &input);$/;"	p	class:itpp::OFDM	access:public	signature:(const cvec &input)
itpp::OFDM::modulate	/usr/include/itpp/comm/ofdm.h	/^  void modulate(const cvec &input, cvec &output);$/;"	p	class:itpp::OFDM	access:public	signature:(const cvec &input, cvec &output)
itpp::OFDM::no_carriers	/usr/include/itpp/comm/ofdm.h	/^  int no_carriers() {return Nfft;}$/;"	f	class:itpp::OFDM	access:public	signature:()
itpp::OFDM::norm_factor	/usr/include/itpp/comm/ofdm.h	/^  double norm_factor;$/;"	m	class:itpp::OFDM	access:private
itpp::OFDM::set_parameters	/usr/include/itpp/comm/ofdm.h	/^  void set_parameters(const int Nfft, const int Ncp, const int inNupsample = 1);$/;"	p	class:itpp::OFDM	access:public	signature:(const int Nfft, const int Ncp, const int inNupsample = 1)
itpp::OFDM::setup_done	/usr/include/itpp/comm/ofdm.h	/^  bool setup_done;$/;"	m	class:itpp::OFDM	access:private
itpp::OUTPUT_FIX	/usr/include/itpp/fixed/fix_base.h	/^  OUTPUT_FIX,         \/\/!< Output fixed-point representation only$/;"	e	enum:itpp::output_mode
itpp::OUTPUT_FIX_SHIFT	/usr/include/itpp/fixed/fix_base.h	/^  OUTPUT_FIX_SHIFT,   \/\/!< Output fixed-point representation followed by \\<shift\\> (default)$/;"	e	enum:itpp::output_mode
itpp::OUTPUT_FLOAT	/usr/include/itpp/fixed/fix_base.h	/^  OUTPUT_FLOAT,       \/\/!< Output floating-point value$/;"	e	enum:itpp::output_mode
itpp::OUTPUT_FLOAT_SHIFT	/usr/include/itpp/fixed/fix_base.h	/^  OUTPUT_FLOAT_SHIFT  \/\/!< Output floating-point value followed by \\<\\<shift$/;"	e	enum:itpp::output_mode
itpp::PAM	/usr/include/itpp/comm/modulator.h	/^class PAM : public Modulator<double>$/;"	c	namespace:itpp	inherits:Modulator
itpp::PAM::PAM	/usr/include/itpp/comm/modulator.h	/^  PAM() {}$/;"	f	class:itpp::PAM	access:public	signature:()
itpp::PAM::PAM	/usr/include/itpp/comm/modulator.h	/^  PAM(int M) { set_M(M); }$/;"	f	class:itpp::PAM	access:public	signature:(int M)
itpp::PAM::demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  bvec demodulate_bits(const vec& signal) const;$/;"	p	class:itpp::PAM	access:public	signature:(const vec& signal) const
itpp::PAM::demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  void demodulate_bits(const vec& signal, bvec& output) const;$/;"	p	class:itpp::PAM	access:public	signature:(const vec& signal, bvec& output) const
itpp::PAM::scaling_factor	/usr/include/itpp/comm/modulator.h	/^  double scaling_factor;$/;"	m	class:itpp::PAM	access:protected
itpp::PAM::set_M	/usr/include/itpp/comm/modulator.h	/^  void set_M(int M);$/;"	p	class:itpp::PAM	access:public	signature:(int M)
itpp::PAM::~PAM	/usr/include/itpp/comm/modulator.h	/^  virtual ~PAM() {}$/;"	f	class:itpp::PAM	access:public	signature:()
itpp::PAM_c	/usr/include/itpp/comm/modulator.h	/^class PAM_c : public Modulator<std::complex<double> >$/;"	c	namespace:itpp	inherits:Modulator
itpp::PAM_c::PAM_c	/usr/include/itpp/comm/modulator.h	/^  PAM_c() {}$/;"	f	class:itpp::PAM_c	access:public	signature:()
itpp::PAM_c::PAM_c	/usr/include/itpp/comm/modulator.h	/^  PAM_c(int M) { set_M(M); }$/;"	f	class:itpp::PAM_c	access:public	signature:(int M)
itpp::PAM_c::demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  bvec demodulate_bits(const cvec& signal) const;$/;"	p	class:itpp::PAM_c	access:public	signature:(const cvec& signal) const
itpp::PAM_c::demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  void demodulate_bits(const cvec& signal, bvec& output) const;$/;"	p	class:itpp::PAM_c	access:public	signature:(const cvec& signal, bvec& output) const
itpp::PAM_c::demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual vec demodulate_soft_bits(const cvec& rx_symbols, double N0,$/;"	p	class:itpp::PAM_c	access:public	signature:(const cvec& rx_symbols, double N0, Soft_Method method = LOGMAP) const
itpp::PAM_c::demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual vec demodulate_soft_bits(const cvec& rx_symbols,$/;"	p	class:itpp::PAM_c	access:public	signature:(const cvec& rx_symbols, const cvec& channel, double N0, Soft_Method method = LOGMAP) const
itpp::PAM_c::demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate_soft_bits(const cvec& rx_symbols, double N0,$/;"	p	class:itpp::PAM_c	access:public	signature:(const cvec& rx_symbols, double N0, vec& soft_bits, Soft_Method method = LOGMAP) const
itpp::PAM_c::demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate_soft_bits(const cvec& rx_symbols,$/;"	p	class:itpp::PAM_c	access:public	signature:(const cvec& rx_symbols, const cvec& channel, double N0, vec& soft_bits, Soft_Method method = LOGMAP) const
itpp::PAM_c::scaling_factor	/usr/include/itpp/comm/modulator.h	/^  double scaling_factor;$/;"	m	class:itpp::PAM_c	access:protected
itpp::PAM_c::set_M	/usr/include/itpp/comm/modulator.h	/^  void set_M(int M);$/;"	p	class:itpp::PAM_c	access:public	signature:(int M)
itpp::PAM_c::~PAM_c	/usr/include/itpp/comm/modulator.h	/^  virtual ~PAM_c() {}$/;"	f	class:itpp::PAM_c	access:public	signature:()
itpp::PSK	/usr/include/itpp/comm/modulator.h	/^class PSK : public Modulator<std::complex<double> >$/;"	c	namespace:itpp	inherits:Modulator
itpp::PSK::PSK	/usr/include/itpp/comm/modulator.h	/^  PSK() {}$/;"	f	class:itpp::PSK	access:public	signature:()
itpp::PSK::PSK	/usr/include/itpp/comm/modulator.h	/^  PSK(int M) { set_M(M); }$/;"	f	class:itpp::PSK	access:public	signature:(int M)
itpp::PSK::demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  bvec demodulate_bits(const cvec& signal) const;$/;"	p	class:itpp::PSK	access:public	signature:(const cvec& signal) const
itpp::PSK::demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  void demodulate_bits(const cvec& signal, bvec& bits) const;$/;"	p	class:itpp::PSK	access:public	signature:(const cvec& signal, bvec& bits) const
itpp::PSK::set_M	/usr/include/itpp/comm/modulator.h	/^  void set_M(int M);$/;"	p	class:itpp::PSK	access:public	signature:(int M)
itpp::PSK::~PSK	/usr/include/itpp/comm/modulator.h	/^  virtual ~PSK() { }$/;"	f	class:itpp::PSK	access:public	signature:()
itpp::Packet	/usr/include/itpp/protocol/packet.h	/^class Packet$/;"	c	namespace:itpp
itpp::Packet::Packet	/usr/include/itpp/protocol/packet.h	/^  Packet(const int packet_size = 0) { set_bit_size(packet_size); }$/;"	f	class:itpp::Packet	access:public	signature:(const int packet_size = 0)
itpp::Packet::bit_size	/usr/include/itpp/protocol/packet.h	/^  int bit_size() { return size_bits; }$/;"	f	class:itpp::Packet	access:public	signature:()
itpp::Packet::set_bit_size	/usr/include/itpp/protocol/packet.h	/^  void set_bit_size(int packet_size) { it_assert(packet_size >= 0, "Packet size must be positive"); size_bits = packet_size; }$/;"	f	class:itpp::Packet	access:public	signature:(int packet_size)
itpp::Packet::size_bits	/usr/include/itpp/protocol/packet.h	/^  int size_bits; \/\/ size of packet in bits$/;"	m	class:itpp::Packet	access:private
itpp::Packet::~Packet	/usr/include/itpp/protocol/packet.h	/^  virtual ~Packet() {}$/;"	f	class:itpp::Packet	access:public	signature:()
itpp::Packet_Channel	/usr/include/itpp/protocol/packet_channel.h	/^class Packet_Channel$/;"	c	namespace:itpp
itpp::Packet_Channel::K	/usr/include/itpp/protocol/packet_channel.h	/^  int k, K, L;$/;"	m	class:itpp::Packet_Channel	access:private
itpp::Packet_Channel::L	/usr/include/itpp/protocol/packet_channel.h	/^  int k, K, L;$/;"	m	class:itpp::Packet_Channel	access:private
itpp::Packet_Channel::Packet_Channel	/usr/include/itpp/protocol/packet_channel.h	/^  Packet_Channel();$/;"	p	class:itpp::Packet_Channel	access:public	signature:()
itpp::Packet_Channel::Packet_Channel	/usr/include/itpp/protocol/packet_channel.h	/^  Packet_Channel(const double Pr, const Ttype Delay, const double Block_rate, const int Max_slots = 0);$/;"	p	class:itpp::Packet_Channel	access:public	signature:(const double Pr, const Ttype Delay, const double Block_rate, const int Max_slots = 0)
itpp::Packet_Channel::block_rate_loop	/usr/include/itpp/protocol/packet_channel.h	/^  void block_rate_loop();$/;"	p	class:itpp::Packet_Channel	access:private	signature:()
itpp::Packet_Channel::block_time	/usr/include/itpp/protocol/packet_channel.h	/^  double block_time;$/;"	m	class:itpp::Packet_Channel	access:private
itpp::Packet_Channel::delay	/usr/include/itpp/protocol/packet_channel.h	/^  Ttype delay;$/;"	m	class:itpp::Packet_Channel	access:private
itpp::Packet_Channel::explicit_errors	/usr/include/itpp/protocol/packet_channel.h	/^  bool explicit_errors;$/;"	m	class:itpp::Packet_Channel	access:private
itpp::Packet_Channel::get_nof_inputs	/usr/include/itpp/protocol/packet_channel.h	/^  Signal<void*> get_nof_inputs;$/;"	m	class:itpp::Packet_Channel	access:public
itpp::Packet_Channel::handle_input	/usr/include/itpp/protocol/packet_channel.h	/^  void handle_input(Link_Packet* M);$/;"	p	class:itpp::Packet_Channel	access:private	signature:(Link_Packet* M)
itpp::Packet_Channel::handle_nof_inputs	/usr/include/itpp/protocol/packet_channel.h	/^  void handle_nof_inputs(const int N);$/;"	p	class:itpp::Packet_Channel	access:private	signature:(const int N)
itpp::Packet_Channel::handle_start	/usr/include/itpp/protocol/packet_channel.h	/^  void handle_start(const bool start);$/;"	p	class:itpp::Packet_Channel	access:private	signature:(const bool start)
itpp::Packet_Channel::input	/usr/include/itpp/protocol/packet_channel.h	/^  Slot<Packet_Channel, Link_Packet*> input;$/;"	m	class:itpp::Packet_Channel	access:public
itpp::Packet_Channel::input_request	/usr/include/itpp/protocol/packet_channel.h	/^  Signal<int> input_request;$/;"	m	class:itpp::Packet_Channel	access:public
itpp::Packet_Channel::k	/usr/include/itpp/protocol/packet_channel.h	/^  int k, K, L;$/;"	m	class:itpp::Packet_Channel	access:private
itpp::Packet_Channel::keep_running	/usr/include/itpp/protocol/packet_channel.h	/^  bool keep_running;$/;"	m	class:itpp::Packet_Channel	access:private
itpp::Packet_Channel::lose	/usr/include/itpp/protocol/packet_channel.h	/^  bool lose;$/;"	m	class:itpp::Packet_Channel	access:private
itpp::Packet_Channel::lost	/usr/include/itpp/protocol/packet_channel.h	/^  ivec lost;$/;"	m	class:itpp::Packet_Channel	access:private
itpp::Packet_Channel::max_slots	/usr/include/itpp/protocol/packet_channel.h	/^  int max_slots;$/;"	m	class:itpp::Packet_Channel	access:private
itpp::Packet_Channel::nof_inputs	/usr/include/itpp/protocol/packet_channel.h	/^  Slot<Packet_Channel, int> nof_inputs;$/;"	m	class:itpp::Packet_Channel	access:public
itpp::Packet_Channel::output	/usr/include/itpp/protocol/packet_channel.h	/^  Signal<Link_Packet*> output;$/;"	m	class:itpp::Packet_Channel	access:public
itpp::Packet_Channel::parameters_ok	/usr/include/itpp/protocol/packet_channel.h	/^  bool parameters_ok;$/;"	m	class:itpp::Packet_Channel	access:private
itpp::Packet_Channel::pr	/usr/include/itpp/protocol/packet_channel.h	/^  double pr;$/;"	m	class:itpp::Packet_Channel	access:private
itpp::Packet_Channel::set_errors	/usr/include/itpp/protocol/packet_channel.h	/^  void set_errors(const ivec &Lost);$/;"	p	class:itpp::Packet_Channel	access:public	signature:(const ivec &Lost)
itpp::Packet_Channel::set_parameters	/usr/include/itpp/protocol/packet_channel.h	/^  void set_parameters(const double Pr, const Ttype Delay, const double Block_rate, const int Max_slots);$/;"	p	class:itpp::Packet_Channel	access:public	signature:(const double Pr, const Ttype Delay, const double Block_rate, const int Max_slots)
itpp::Packet_Channel::start	/usr/include/itpp/protocol/packet_channel.h	/^  Slot<Packet_Channel, bool> start;$/;"	m	class:itpp::Packet_Channel	access:public
itpp::Packet_Channel::~Packet_Channel	/usr/include/itpp/protocol/packet_channel.h	/^  ~Packet_Channel();$/;"	p	class:itpp::Packet_Channel	access:public	signature:()
itpp::Packet_Generator	/usr/include/itpp/protocol/packet_generator.h	/^class Packet_Generator$/;"	c	namespace:itpp
itpp::Packet_Generator::Packet_Generator	/usr/include/itpp/protocol/packet_generator.h	/^  Packet_Generator(const int Packet_size = 150, const unsigned long int Max_packets = 0);$/;"	p	class:itpp::Packet_Generator	access:public	signature:(const int Packet_size = 150, const unsigned long int Max_packets = 0)
itpp::Packet_Generator::delta_t	/usr/include/itpp/protocol/packet_generator.h	/^  virtual Ttype delta_t() = 0;$/;"	p	class:itpp::Packet_Generator	access:protected	signature:()
itpp::Packet_Generator::get_max_packets	/usr/include/itpp/protocol/packet_generator.h	/^  int get_max_packets();$/;"	p	class:itpp::Packet_Generator	access:public	signature:()
itpp::Packet_Generator::get_packet_size	/usr/include/itpp/protocol/packet_generator.h	/^  int get_packet_size();$/;"	p	class:itpp::Packet_Generator	access:public	signature:()
itpp::Packet_Generator::handle_next	/usr/include/itpp/protocol/packet_generator.h	/^  void handle_next(Packet*);$/;"	p	class:itpp::Packet_Generator	access:private	signature:(Packet*)
itpp::Packet_Generator::handle_start	/usr/include/itpp/protocol/packet_generator.h	/^  void handle_start(const bool run);$/;"	p	class:itpp::Packet_Generator	access:private	signature:(const bool run)
itpp::Packet_Generator::id	/usr/include/itpp/protocol/packet_generator.h	/^  unsigned long int id;$/;"	m	class:itpp::Packet_Generator	access:private
itpp::Packet_Generator::keep_running	/usr/include/itpp/protocol/packet_generator.h	/^  bool keep_running;$/;"	m	class:itpp::Packet_Generator	access:private
itpp::Packet_Generator::max_packets	/usr/include/itpp/protocol/packet_generator.h	/^  unsigned long int max_packets;$/;"	m	class:itpp::Packet_Generator	access:private
itpp::Packet_Generator::next	/usr/include/itpp/protocol/packet_generator.h	/^  Slot<Packet_Generator, Packet*> next;$/;"	m	class:itpp::Packet_Generator	access:private
itpp::Packet_Generator::output	/usr/include/itpp/protocol/packet_generator.h	/^  Signal<Packet*> output;$/;"	m	class:itpp::Packet_Generator	access:public
itpp::Packet_Generator::packet_size	/usr/include/itpp/protocol/packet_generator.h	/^  int packet_size;$/;"	m	class:itpp::Packet_Generator	access:private
itpp::Packet_Generator::set_parameters	/usr/include/itpp/protocol/packet_generator.h	/^  void set_parameters(const int Packet_size, const unsigned long int Max_packets);$/;"	p	class:itpp::Packet_Generator	access:public	signature:(const int Packet_size, const unsigned long int Max_packets)
itpp::Packet_Generator::start	/usr/include/itpp/protocol/packet_generator.h	/^  Slot<Packet_Generator, bool> start;$/;"	m	class:itpp::Packet_Generator	access:public
itpp::Packet_Generator::~Packet_Generator	/usr/include/itpp/protocol/packet_generator.h	/^  virtual ~Packet_Generator();$/;"	p	class:itpp::Packet_Generator	access:public	signature:()
itpp::Parser	/usr/include/itpp/base/parser.h	/^class Parser$/;"	c	namespace:itpp
itpp::Parser::Parser	/usr/include/itpp/base/parser.h	/^  Parser();$/;"	p	class:itpp::Parser	access:public	signature:()
itpp::Parser::Parser	/usr/include/itpp/base/parser.h	/^  Parser(const Array<std::string> &setup);$/;"	p	class:itpp::Parser	access:public	signature:(const Array<std::string> &setup)
itpp::Parser::Parser	/usr/include/itpp/base/parser.h	/^  Parser(const std::string &filename);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &filename)
itpp::Parser::Parser	/usr/include/itpp/base/parser.h	/^  Parser(const std::string &filename, int argc, char *argv[]);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &filename, int argc, char *argv[])
itpp::Parser::Parser	/usr/include/itpp/base/parser.h	/^  Parser(int argc, char *argv[]);$/;"	p	class:itpp::Parser	access:public	signature:(int argc, char *argv[])
itpp::Parser::SetupStrings	/usr/include/itpp/base/parser.h	/^  Array<std::string> SetupStrings;$/;"	m	class:itpp::Parser	access:private
itpp::Parser::VERBOSE	/usr/include/itpp/base/parser.h	/^  bool VERBOSE;$/;"	m	class:itpp::Parser	access:private
itpp::Parser::exist	/usr/include/itpp/base/parser.h	/^  bool exist(const std::string &name);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &name)
itpp::Parser::findname	/usr/include/itpp/base/parser.h	/^  std::string findname(const std::string &name,$/;"	p	class:itpp::Parser	access:private	signature:(const std::string &name, bool &error_flag, bool &print_flag, int num = 0, bool keep_brackets = false)
itpp::Parser::get	/usr/include/itpp/base/parser.h	/^  bool get(T &var, const std::string &name, int num = -1);$/;"	p	class:itpp::Parser	access:public	signature:(T &var, const std::string &name, int num = -1)
itpp::Parser::get	/usr/include/itpp/base/parser.h	/^bool Parser::get(T &var, const std::string &name, int num)$/;"	f	class:itpp::Parser	signature:(T &var, const std::string &name, int num)
itpp::Parser::get	/usr/include/itpp/base/parser.h	/^bool Parser::get(bool &var, const std::string &name, int num);$/;"	p	class:itpp::Parser	signature:(bool &var, const std::string &name, int num)
itpp::Parser::get	/usr/include/itpp/base/parser.h	/^bool Parser::get(int &var, const std::string &name, int num);$/;"	p	class:itpp::Parser	signature:(int &var, const std::string &name, int num)
itpp::Parser::get	/usr/include/itpp/base/parser.h	/^bool Parser::get(std::string &var, const std::string &name, int num);$/;"	p	class:itpp::Parser	signature:(std::string &var, const std::string &name, int num)
itpp::Parser::get_bmat	/usr/include/itpp/base/parser.h	/^  bmat get_bmat(const std::string &name, int num = -1);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &name, int num = -1)
itpp::Parser::get_bool	/usr/include/itpp/base/parser.h	/^  bool get_bool(const std::string &name,  int num = -1);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &name, int num = -1)
itpp::Parser::get_bvec	/usr/include/itpp/base/parser.h	/^  bvec get_bvec(const std::string &name, int num = -1);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &name, int num = -1)
itpp::Parser::get_double	/usr/include/itpp/base/parser.h	/^  double get_double(const std::string &name, int num = -1);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &name, int num = -1)
itpp::Parser::get_imat	/usr/include/itpp/base/parser.h	/^  imat get_imat(const std::string &name, int num = -1);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &name, int num = -1)
itpp::Parser::get_int	/usr/include/itpp/base/parser.h	/^  int get_int(const std::string &name,  int num = -1);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &name, int num = -1)
itpp::Parser::get_ivec	/usr/include/itpp/base/parser.h	/^  ivec get_ivec(const std::string &name, int num = -1);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &name, int num = -1)
itpp::Parser::get_mat	/usr/include/itpp/base/parser.h	/^  mat get_mat(const std::string &name, int num = -1);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &name, int num = -1)
itpp::Parser::get_smat	/usr/include/itpp/base/parser.h	/^  smat get_smat(const std::string &name, int num = -1);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &name, int num = -1)
itpp::Parser::get_string	/usr/include/itpp/base/parser.h	/^  std::string get_string(const std::string &name, int num = -1);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &name, int num = -1)
itpp::Parser::get_svec	/usr/include/itpp/base/parser.h	/^  svec get_svec(const std::string &name, int num = -1);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &name, int num = -1)
itpp::Parser::get_vec	/usr/include/itpp/base/parser.h	/^  vec get_vec(const std::string &name, int num = -1);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &name, int num = -1)
itpp::Parser::init	/usr/include/itpp/base/parser.h	/^  void init(const Array<std::string> &setup);$/;"	p	class:itpp::Parser	access:public	signature:(const Array<std::string> &setup)
itpp::Parser::init	/usr/include/itpp/base/parser.h	/^  void init(const std::string &filename);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &filename)
itpp::Parser::init	/usr/include/itpp/base/parser.h	/^  void init(const std::string &filename, int argc, char *argv[]);$/;"	p	class:itpp::Parser	access:public	signature:(const std::string &filename, int argc, char *argv[])
itpp::Parser::init	/usr/include/itpp/base/parser.h	/^  void init(int argc, char *argv[]);$/;"	p	class:itpp::Parser	access:public	signature:(int argc, char *argv[])
itpp::Parser::pre_parsing	/usr/include/itpp/base/parser.h	/^  void pre_parsing(void);$/;"	p	class:itpp::Parser	access:private	signature:(void)
itpp::Parser::set_silentmode	/usr/include/itpp/base/parser.h	/^  void set_silentmode(bool v = true);$/;"	p	class:itpp::Parser	access:public	signature:(bool v = true)
itpp::Pattern_Source	/usr/include/itpp/signal/source.h	/^class Pattern_Source$/;"	c	namespace:itpp
itpp::Pattern_Source::Pattern_Source	/usr/include/itpp/signal/source.h	/^  Pattern_Source(const vec &pattern, int start_pos = 0);$/;"	p	class:itpp::Pattern_Source	access:public	signature:(const vec &pattern, int start_pos = 0)
itpp::Pattern_Source::mean	/usr/include/itpp/signal/source.h	/^  double mean, var;$/;"	m	class:itpp::Pattern_Source	access:private
itpp::Pattern_Source::operator ()	/usr/include/itpp/signal/source.h	/^  double operator()() { return sample(); }$/;"	f	class:itpp::Pattern_Source	access:public	signature:()
itpp::Pattern_Source::operator ()	/usr/include/itpp/signal/source.h	/^  mat operator()(int h, int w);$/;"	p	class:itpp::Pattern_Source	access:public	signature:(int h, int w)
itpp::Pattern_Source::operator ()	/usr/include/itpp/signal/source.h	/^  vec operator()(int n);$/;"	p	class:itpp::Pattern_Source	access:public	signature:(int n)
itpp::Pattern_Source::pat	/usr/include/itpp/signal/source.h	/^  vec pat;$/;"	m	class:itpp::Pattern_Source	access:private
itpp::Pattern_Source::pos	/usr/include/itpp/signal/source.h	/^  int pos;$/;"	m	class:itpp::Pattern_Source	access:private
itpp::Pattern_Source::sample	/usr/include/itpp/signal/source.h	/^  double sample();$/;"	p	class:itpp::Pattern_Source	access:private	signature:()
itpp::Pattern_Source::var	/usr/include/itpp/signal/source.h	/^  double mean, var;$/;"	m	class:itpp::Pattern_Source	access:private
itpp::Pattern_Source::~Pattern_Source	/usr/include/itpp/signal/source.h	/^  virtual ~Pattern_Source() { }$/;"	f	class:itpp::Pattern_Source	access:public	signature:()
itpp::Poisson_Packet_Generator	/usr/include/itpp/protocol/packet_generator.h	/^class Poisson_Packet_Generator : public Packet_Generator$/;"	c	namespace:itpp	inherits:Packet_Generator
itpp::Poisson_Packet_Generator::Poisson_Packet_Generator	/usr/include/itpp/protocol/packet_generator.h	/^  Poisson_Packet_Generator(const double Avg_bit_rate = 1.0, const int Packet_size = 150, const unsigned long int Max_packets = 0);$/;"	p	class:itpp::Poisson_Packet_Generator	access:public	signature:(const double Avg_bit_rate = 1.0, const int Packet_size = 150, const unsigned long int Max_packets = 0)
itpp::Poisson_Packet_Generator::avg_bit_rate	/usr/include/itpp/protocol/packet_generator.h	/^  double avg_bit_rate;$/;"	m	class:itpp::Poisson_Packet_Generator	access:protected
itpp::Poisson_Packet_Generator::avg_delta_t	/usr/include/itpp/protocol/packet_generator.h	/^  double avg_delta_t;$/;"	m	class:itpp::Poisson_Packet_Generator	access:protected
itpp::Poisson_Packet_Generator::delta_t	/usr/include/itpp/protocol/packet_generator.h	/^  virtual Ttype delta_t();$/;"	p	class:itpp::Poisson_Packet_Generator	access:protected	signature:()
itpp::Poisson_Packet_Generator::ee	/usr/include/itpp/protocol/packet_generator.h	/^  Exponential_RNG ee;$/;"	m	class:itpp::Poisson_Packet_Generator	access:protected
itpp::Poisson_Packet_Generator::get_avg_bit_rate	/usr/include/itpp/protocol/packet_generator.h	/^  double get_avg_bit_rate();$/;"	p	class:itpp::Poisson_Packet_Generator	access:public	signature:()
itpp::Poisson_Packet_Generator::set_parameters	/usr/include/itpp/protocol/packet_generator.h	/^  void set_parameters(const double Avg_bit_rate, const int Packet_size, const unsigned long int Max_packets);$/;"	p	class:itpp::Poisson_Packet_Generator	access:public	signature:(const double Avg_bit_rate, const int Packet_size, const unsigned long int Max_packets)
itpp::Poisson_Packet_Generator::~Poisson_Packet_Generator	/usr/include/itpp/protocol/packet_generator.h	/^  virtual ~Poisson_Packet_Generator();$/;"	p	class:itpp::Poisson_Packet_Generator	access:public	signature:()
itpp::Pulse_Shape	/usr/include/itpp/comm/pulse_shape.h	/^class Pulse_Shape$/;"	c	namespace:itpp
itpp::Pulse_Shape::Pulse_Shape	/usr/include/itpp/comm/pulse_shape.h	/^  Pulse_Shape();$/;"	p	class:itpp::Pulse_Shape	access:public	signature:()
itpp::Pulse_Shape::Pulse_Shape	/usr/include/itpp/comm/pulse_shape.h	/^  Pulse_Shape(const Vec<T2> &impulse_response, int upsampling_factor);$/;"	p	class:itpp::Pulse_Shape	access:public	signature:(const Vec<T2> &impulse_response, int upsampling_factor)
itpp::Pulse_Shape::Pulse_Shape	/usr/include/itpp/comm/pulse_shape.h	/^Pulse_Shape<T1, T2, T3>::Pulse_Shape()$/;"	f	class:itpp::Pulse_Shape	signature:()
itpp::Pulse_Shape::Pulse_Shape	/usr/include/itpp/comm/pulse_shape.h	/^Pulse_Shape<T1, T2, T3>::Pulse_Shape(const Vec<T2> &impulse_response, int upsampling_factor)$/;"	f	class:itpp::Pulse_Shape	signature:(const Vec<T2> &impulse_response, int upsampling_factor)
itpp::Pulse_Shape::clear	/usr/include/itpp/comm/pulse_shape.h	/^  void clear(void);$/;"	p	class:itpp::Pulse_Shape	access:public	signature:(void)
itpp::Pulse_Shape::clear	/usr/include/itpp/comm/pulse_shape.h	/^void Pulse_Shape<T1, T2, T3>::clear(void)$/;"	f	class:itpp::Pulse_Shape	signature:(void)
itpp::Pulse_Shape::get_filter_length	/usr/include/itpp/comm/pulse_shape.h	/^  int get_filter_length() const;$/;"	p	class:itpp::Pulse_Shape	access:public	signature:() const
itpp::Pulse_Shape::get_filter_length	/usr/include/itpp/comm/pulse_shape.h	/^int Pulse_Shape<T1, T2, T3>::get_filter_length(void) const$/;"	f	class:itpp::Pulse_Shape	signature:(void) const
itpp::Pulse_Shape::get_pulse_length	/usr/include/itpp/comm/pulse_shape.h	/^  int get_pulse_length() const;$/;"	p	class:itpp::Pulse_Shape	access:public	signature:() const
itpp::Pulse_Shape::get_pulse_length	/usr/include/itpp/comm/pulse_shape.h	/^int Pulse_Shape<T1, T2, T3>::get_pulse_length(void) const$/;"	f	class:itpp::Pulse_Shape	signature:(void) const
itpp::Pulse_Shape::get_pulse_shape	/usr/include/itpp/comm/pulse_shape.h	/^  Vec<T2> get_pulse_shape(void) const;$/;"	p	class:itpp::Pulse_Shape	access:public	signature:(void) const
itpp::Pulse_Shape::get_pulse_shape	/usr/include/itpp/comm/pulse_shape.h	/^Vec<T2> Pulse_Shape<T1, T2, T3>::get_pulse_shape(void) const$/;"	f	class:itpp::Pulse_Shape	signature:(void) const
itpp::Pulse_Shape::get_upsampling_factor	/usr/include/itpp/comm/pulse_shape.h	/^  int get_upsampling_factor() const;$/;"	p	class:itpp::Pulse_Shape	access:public	signature:() const
itpp::Pulse_Shape::get_upsampling_factor	/usr/include/itpp/comm/pulse_shape.h	/^int Pulse_Shape<T1, T2, T3>::get_upsampling_factor(void) const$/;"	f	class:itpp::Pulse_Shape	signature:(void) const
itpp::Pulse_Shape::impulse_response	/usr/include/itpp/comm/pulse_shape.h	/^  Vec<T2> impulse_response;$/;"	m	class:itpp::Pulse_Shape	access:protected
itpp::Pulse_Shape::pulse_length	/usr/include/itpp/comm/pulse_shape.h	/^  int pulse_length;$/;"	m	class:itpp::Pulse_Shape	access:protected
itpp::Pulse_Shape::set_pulse_shape	/usr/include/itpp/comm/pulse_shape.h	/^  void set_pulse_shape(const Vec<T2> &impulse_response, int upsampling_factor);$/;"	p	class:itpp::Pulse_Shape	access:public	signature:(const Vec<T2> &impulse_response, int upsampling_factor)
itpp::Pulse_Shape::set_pulse_shape	/usr/include/itpp/comm/pulse_shape.h	/^void Pulse_Shape<T1, T2, T3>::set_pulse_shape(const Vec<T2> &impulse_response_in, int upsampling_factor_in)$/;"	f	class:itpp::Pulse_Shape	signature:(const Vec<T2> &impulse_response_in, int upsampling_factor_in)
itpp::Pulse_Shape::setup_done	/usr/include/itpp/comm/pulse_shape.h	/^  bool setup_done;$/;"	m	class:itpp::Pulse_Shape	access:protected
itpp::Pulse_Shape::shape_samples	/usr/include/itpp/comm/pulse_shape.h	/^  Vec<T3> shape_samples(const Vec<T1> &input);$/;"	p	class:itpp::Pulse_Shape	access:public	signature:(const Vec<T1> &input)
itpp::Pulse_Shape::shape_samples	/usr/include/itpp/comm/pulse_shape.h	/^  void shape_samples(const Vec<T1> &input, Vec<T3> &output);$/;"	p	class:itpp::Pulse_Shape	access:public	signature:(const Vec<T1> &input, Vec<T3> &output)
itpp::Pulse_Shape::shape_samples	/usr/include/itpp/comm/pulse_shape.h	/^Vec<T3> Pulse_Shape<T1, T2, T3>::shape_samples(const Vec<T1>& input)$/;"	f	class:itpp::Pulse_Shape	signature:(const Vec<T1>& input)
itpp::Pulse_Shape::shape_samples	/usr/include/itpp/comm/pulse_shape.h	/^void Pulse_Shape<T1, T2, T3>::shape_samples(const Vec<T1>& input, Vec<T3> &output)$/;"	f	class:itpp::Pulse_Shape	signature:(const Vec<T1>& input, Vec<T3> &output)
itpp::Pulse_Shape::shape_symbols	/usr/include/itpp/comm/pulse_shape.h	/^  Vec<T3> shape_symbols(const Vec<T1> &input);$/;"	p	class:itpp::Pulse_Shape	access:public	signature:(const Vec<T1> &input)
itpp::Pulse_Shape::shape_symbols	/usr/include/itpp/comm/pulse_shape.h	/^  void shape_symbols(const Vec<T1> &input, Vec<T3> &output);$/;"	p	class:itpp::Pulse_Shape	access:public	signature:(const Vec<T1> &input, Vec<T3> &output)
itpp::Pulse_Shape::shape_symbols	/usr/include/itpp/comm/pulse_shape.h	/^Vec<T3> Pulse_Shape<T1, T2, T3>::shape_symbols(const Vec<T1>& input)$/;"	f	class:itpp::Pulse_Shape	signature:(const Vec<T1>& input)
itpp::Pulse_Shape::shape_symbols	/usr/include/itpp/comm/pulse_shape.h	/^void Pulse_Shape<T1, T2, T3>::shape_symbols(const Vec<T1>& input, Vec<T3> &output)$/;"	f	class:itpp::Pulse_Shape	signature:(const Vec<T1>& input, Vec<T3> &output)
itpp::Pulse_Shape::shaping_filter	/usr/include/itpp/comm/pulse_shape.h	/^  MA_Filter<T1, T2, T3> shaping_filter;$/;"	m	class:itpp::Pulse_Shape	access:protected
itpp::Pulse_Shape::upsampling_factor	/usr/include/itpp/comm/pulse_shape.h	/^  int upsampling_factor;$/;"	m	class:itpp::Pulse_Shape	access:protected
itpp::Pulse_Shape::~Pulse_Shape	/usr/include/itpp/comm/pulse_shape.h	/^  virtual ~Pulse_Shape() {}$/;"	f	class:itpp::Pulse_Shape	access:public	signature:()
itpp::Punctured_Convolutional_Code	/usr/include/itpp/comm/punct_convcode.h	/^class Punctured_Convolutional_Code : public Convolutional_Code$/;"	c	namespace:itpp	inherits:Convolutional_Code
itpp::Punctured_Convolutional_Code::Period	/usr/include/itpp/comm/punct_convcode.h	/^  int Period;$/;"	m	class:itpp::Punctured_Convolutional_Code	access:protected
itpp::Punctured_Convolutional_Code::Punctured_Convolutional_Code	/usr/include/itpp/comm/punct_convcode.h	/^  Punctured_Convolutional_Code(void) : Convolutional_Code() {}$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:(void)
itpp::Punctured_Convolutional_Code::calculate_spectrum	/usr/include/itpp/comm/punct_convcode.h	/^  void calculate_spectrum(Array<ivec> &spectrum, int dmax, int no_terms);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(Array<ivec> &spectrum, int dmax, int no_terms)
itpp::Punctured_Convolutional_Code::calculate_spectrum	/usr/include/itpp/comm/punct_convcode.h	/^  void calculate_spectrum(Array<ivec> &spectrum, int time, int dmax, int no_terms, int block_length = 0);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(Array<ivec> &spectrum, int time, int dmax, int no_terms, int block_length = 0)
itpp::Punctured_Convolutional_Code::catastrophic	/usr/include/itpp/comm/punct_convcode.h	/^  bool catastrophic(void);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(void)
itpp::Punctured_Convolutional_Code::decode	/usr/include/itpp/comm/punct_convcode.h	/^  virtual bvec decode(const bvec &coded_bits);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const bvec &coded_bits)
itpp::Punctured_Convolutional_Code::decode	/usr/include/itpp/comm/punct_convcode.h	/^  virtual bvec decode(const vec &received_signal) { bvec output; decode(received_signal, output); return output; }$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const vec &received_signal)
itpp::Punctured_Convolutional_Code::decode	/usr/include/itpp/comm/punct_convcode.h	/^  virtual void decode(const bvec &coded_bits, bvec &decoded_bits);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const bvec &coded_bits, bvec &decoded_bits)
itpp::Punctured_Convolutional_Code::decode	/usr/include/itpp/comm/punct_convcode.h	/^  virtual void decode(const vec &received_signal, bvec &output);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const vec &received_signal, bvec &output)
itpp::Punctured_Convolutional_Code::decode_tail	/usr/include/itpp/comm/punct_convcode.h	/^  bvec decode_tail(const vec &received_signal) { bvec output; decode_tail(received_signal, output); return output; }$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const vec &received_signal)
itpp::Punctured_Convolutional_Code::decode_tail	/usr/include/itpp/comm/punct_convcode.h	/^  void decode_tail(const vec &received_signal, bvec &output);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const vec &received_signal, bvec &output)
itpp::Punctured_Convolutional_Code::decode_tailbite	/usr/include/itpp/comm/punct_convcode.h	/^  bvec decode_tailbite(const vec &received_signal)$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const vec &received_signal)
itpp::Punctured_Convolutional_Code::decode_tailbite	/usr/include/itpp/comm/punct_convcode.h	/^  void decode_tailbite(const vec &received_signal, bvec &output);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const vec &received_signal, bvec &output)
itpp::Punctured_Convolutional_Code::decode_trunc	/usr/include/itpp/comm/punct_convcode.h	/^  bvec decode_trunc(const vec &received_signal) { bvec output; decode_trunc(received_signal, output); return output; }$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const vec &received_signal)
itpp::Punctured_Convolutional_Code::decode_trunc	/usr/include/itpp/comm/punct_convcode.h	/^  void decode_trunc(const vec &received_signal, bvec &output);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const vec &received_signal, bvec &output)
itpp::Punctured_Convolutional_Code::distance_profile	/usr/include/itpp/comm/punct_convcode.h	/^  void distance_profile(ivec &dist_prof, int time, int dmax = 100000, bool reverse = false);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(ivec &dist_prof, int time, int dmax = 100000, bool reverse = false)
itpp::Punctured_Convolutional_Code::encode	/usr/include/itpp/comm/punct_convcode.h	/^  bvec encode(const bvec &input) { bvec output; encode(input, output); return output; }$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const bvec &input)
itpp::Punctured_Convolutional_Code::encode	/usr/include/itpp/comm/punct_convcode.h	/^  void encode(const bvec &input, bvec &output);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const bvec &input, bvec &output)
itpp::Punctured_Convolutional_Code::encode_tail	/usr/include/itpp/comm/punct_convcode.h	/^  bvec encode_tail(const bvec &input) { bvec output; encode_tail(input, output); return output; }$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const bvec &input)
itpp::Punctured_Convolutional_Code::encode_tail	/usr/include/itpp/comm/punct_convcode.h	/^  void encode_tail(const bvec &input, bvec &output);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const bvec &input, bvec &output)
itpp::Punctured_Convolutional_Code::encode_tailbite	/usr/include/itpp/comm/punct_convcode.h	/^  bvec encode_tailbite(const bvec &input)$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const bvec &input)
itpp::Punctured_Convolutional_Code::encode_tailbite	/usr/include/itpp/comm/punct_convcode.h	/^  void encode_tailbite(const bvec &input, bvec &output);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const bvec &input, bvec &output)
itpp::Punctured_Convolutional_Code::encode_trunc	/usr/include/itpp/comm/punct_convcode.h	/^  bvec encode_trunc(const bvec &input) { bvec output; encode_trunc(input, output); return output; }$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const bvec &input)
itpp::Punctured_Convolutional_Code::encode_trunc	/usr/include/itpp/comm/punct_convcode.h	/^  void encode_trunc(const bvec &input, bvec &output);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const bvec &input, bvec &output)
itpp::Punctured_Convolutional_Code::fast	/usr/include/itpp/comm/punct_convcode.h	/^  int fast(Array<ivec> &spectrum, int time, int dfree, int no_terms, int d_best_so_far = 0, bool test_catastrophic = false);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(Array<ivec> &spectrum, int time, int dfree, int no_terms, int d_best_so_far = 0, bool test_catastrophic = false)
itpp::Punctured_Convolutional_Code::get_generator_polynomials	/usr/include/itpp/comm/punct_convcode.h	/^  ivec get_generator_polynomials() const { return gen_pol; }$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:() const
itpp::Punctured_Convolutional_Code::get_puncture_matrix	/usr/include/itpp/comm/punct_convcode.h	/^  bmat get_puncture_matrix() const { return puncture_matrix; }$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:() const
itpp::Punctured_Convolutional_Code::get_puncture_period	/usr/include/itpp/comm/punct_convcode.h	/^  int get_puncture_period() const { return Period; }$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:() const
itpp::Punctured_Convolutional_Code::get_rate	/usr/include/itpp/comm/punct_convcode.h	/^  virtual double get_rate() const { return rate; }$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:() const
itpp::Punctured_Convolutional_Code::init_encoder	/usr/include/itpp/comm/punct_convcode.h	/^  void init_encoder() { encoder_state = start_state; }$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:()
itpp::Punctured_Convolutional_Code::inverse_tail	/usr/include/itpp/comm/punct_convcode.h	/^  bool inverse_tail(const bvec coded_sequence, bvec &input);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const bvec coded_sequence, bvec &input)
itpp::Punctured_Convolutional_Code::puncture_matrix	/usr/include/itpp/comm/punct_convcode.h	/^  bmat puncture_matrix;$/;"	m	class:itpp::Punctured_Convolutional_Code	access:protected
itpp::Punctured_Convolutional_Code::set_code	/usr/include/itpp/comm/punct_convcode.h	/^  void set_code(const CONVOLUTIONAL_CODE_TYPE type_of_code, int inverse_rate, int constraint_length)$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const CONVOLUTIONAL_CODE_TYPE type_of_code, int inverse_rate, int constraint_length)
itpp::Punctured_Convolutional_Code::set_generator_polynomials	/usr/include/itpp/comm/punct_convcode.h	/^  void set_generator_polynomials(const ivec &gen, int constraint_length)$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const ivec &gen, int constraint_length)
itpp::Punctured_Convolutional_Code::set_method	/usr/include/itpp/comm/punct_convcode.h	/^  void set_method(const CONVOLUTIONAL_CODE_METHOD method) { Convolutional_Code::set_method(method); }$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const CONVOLUTIONAL_CODE_METHOD method)
itpp::Punctured_Convolutional_Code::set_puncture_matrix	/usr/include/itpp/comm/punct_convcode.h	/^  void set_puncture_matrix(const bmat &pmatrix); \/\/ add test of matrix size$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const bmat &pmatrix)
itpp::Punctured_Convolutional_Code::total	/usr/include/itpp/comm/punct_convcode.h	/^  int total;$/;"	m	class:itpp::Punctured_Convolutional_Code	access:protected
itpp::Punctured_Convolutional_Code::weight	/usr/include/itpp/comm/punct_convcode.h	/^  int weight(const int state, const int input, int time);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:protected	signature:(const int state, const int input, int time)
itpp::Punctured_Convolutional_Code::weight	/usr/include/itpp/comm/punct_convcode.h	/^  void weight(const int state, int &w0, int &w1, int time);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:protected	signature:(const int state, int &w0, int &w1, int time)
itpp::Punctured_Convolutional_Code::weight_reverse	/usr/include/itpp/comm/punct_convcode.h	/^  int weight_reverse(const int state, const int input, int time);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:protected	signature:(const int state, const int input, int time)
itpp::Punctured_Convolutional_Code::weight_reverse	/usr/include/itpp/comm/punct_convcode.h	/^  void weight_reverse(const int state, int &w0, int &w1, int time);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:protected	signature:(const int state, int &w0, int &w1, int time)
itpp::Punctured_Convolutional_Code::~Punctured_Convolutional_Code	/usr/include/itpp/comm/punct_convcode.h	/^  virtual ~Punctured_Convolutional_Code(void) {}$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:(void)
itpp::QAM	/usr/include/itpp/comm/modulator.h	/^class QAM : public Modulator<std::complex<double> >$/;"	c	namespace:itpp	inherits:Modulator
itpp::QAM::L	/usr/include/itpp/comm/modulator.h	/^  int L;$/;"	m	class:itpp::QAM	access:protected
itpp::QAM::QAM	/usr/include/itpp/comm/modulator.h	/^  QAM() {}$/;"	f	class:itpp::QAM	access:public	signature:()
itpp::QAM::QAM	/usr/include/itpp/comm/modulator.h	/^  QAM(int M) { set_M(M); }$/;"	f	class:itpp::QAM	access:public	signature:(int M)
itpp::QAM::demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  bvec demodulate_bits(const cvec& signal) const;$/;"	p	class:itpp::QAM	access:public	signature:(const cvec& signal) const
itpp::QAM::demodulate_bits	/usr/include/itpp/comm/modulator.h	/^  void demodulate_bits(const cvec& signal, bvec& bits) const;$/;"	p	class:itpp::QAM	access:public	signature:(const cvec& signal, bvec& bits) const
itpp::QAM::scaling_factor	/usr/include/itpp/comm/modulator.h	/^  double scaling_factor;$/;"	m	class:itpp::QAM	access:protected
itpp::QAM::set_M	/usr/include/itpp/comm/modulator.h	/^  void set_M(int M);$/;"	p	class:itpp::QAM	access:public	signature:(int M)
itpp::QAM::~QAM	/usr/include/itpp/comm/modulator.h	/^  virtual ~QAM() { }$/;"	f	class:itpp::QAM	access:public	signature:()
itpp::QLLR	/usr/include/itpp/comm/llr.h	/^typedef signed int QLLR;$/;"	t	namespace:itpp
itpp::QLLR_MAX	/usr/include/itpp/comm/llr.h	/^const QLLR QLLR_MAX = (std::numeric_limits<QLLR>::max() >> 4);$/;"	m	namespace:itpp
itpp::QLLRmat	/usr/include/itpp/comm/llr.h	/^typedef Mat<QLLR> QLLRmat;$/;"	t	namespace:itpp
itpp::QLLRvec	/usr/include/itpp/comm/llr.h	/^typedef Vec<QLLR> QLLRvec;$/;"	t	namespace:itpp
itpp::QPSK	/usr/include/itpp/comm/modulator.h	/^class QPSK : public PSK$/;"	c	namespace:itpp	inherits:PSK
itpp::QPSK::QPSK	/usr/include/itpp/comm/modulator.h	/^  QPSK(): PSK(4) {}$/;"	f	class:itpp::QPSK	access:public	signature:()
itpp::QPSK::demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  vec demodulate_soft_bits(const cvec& rx_symbols, const cvec& channel,$/;"	p	class:itpp::QPSK	access:public	signature:(const cvec& rx_symbols, const cvec& channel, double N0, Soft_Method method = LOGMAP) const
itpp::QPSK::demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  vec demodulate_soft_bits(const cvec& rx_symbols, double N0,$/;"	p	class:itpp::QPSK	access:public	signature:(const cvec& rx_symbols, double N0, Soft_Method method = LOGMAP) const
itpp::QPSK::demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate_soft_bits(const cvec& rx_symbols, double N0,$/;"	p	class:itpp::QPSK	access:public	signature:(const cvec& rx_symbols, double N0, vec& soft_bits, Soft_Method method = LOGMAP) const
itpp::QPSK::demodulate_soft_bits	/usr/include/itpp/comm/modulator.h	/^  virtual void demodulate_soft_bits(const cvec& rx_symbols,$/;"	p	class:itpp::QPSK	access:public	signature:(const cvec& rx_symbols, const cvec& channel, double N0, vec& soft_bits, Soft_Method method = LOGMAP) const
itpp::QPSK::~QPSK	/usr/include/itpp/comm/modulator.h	/^  virtual ~QPSK() {}$/;"	f	class:itpp::QPSK	access:public	signature:()
itpp::QUICKSORT	/usr/include/itpp/base/sort.h	/^enum SORTING_METHOD { INTROSORT = 0, QUICKSORT = 1, HEAPSORT = 2,$/;"	e	enum:itpp::SORTING_METHOD
itpp::Qfunc	/usr/include/itpp/base/math/error.h	/^double Qfunc(double x);$/;"	p	namespace:itpp	signature:(double x)
itpp::Qfunc	/usr/include/itpp/base/math/error.h	/^inline mat Qfunc(const mat &x)$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::Qfunc	/usr/include/itpp/base/math/error.h	/^inline vec Qfunc(const vec &x)$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::RICE_METHOD	/usr/include/itpp/comm/channel.h	/^enum RICE_METHOD { MEDS };$/;"	g	namespace:itpp
itpp::RND	/usr/include/itpp/fixed/fix_base.h	/^  RND,                \/\/!< Rounding to plus infinity$/;"	e	enum:itpp::q_mode
itpp::RND_CONV	/usr/include/itpp/fixed/fix_base.h	/^  RND_CONV,           \/\/!< Convergent rounding with half-way value rounded to even value$/;"	e	enum:itpp::q_mode
itpp::RND_CONV_ODD	/usr/include/itpp/fixed/fix_base.h	/^  RND_CONV_ODD,       \/\/!< Convergent rounding with half-way value rounded to odd value (not defined in SystemC)$/;"	e	enum:itpp::q_mode
itpp::RND_INF	/usr/include/itpp/fixed/fix_base.h	/^  RND_INF,            \/\/!< Rounding to infinity$/;"	e	enum:itpp::q_mode
itpp::RND_MIN_INF	/usr/include/itpp/fixed/fix_base.h	/^  RND_MIN_INF,        \/\/!< Rounding to minus infinity$/;"	e	enum:itpp::q_mode
itpp::RND_ZERO	/usr/include/itpp/fixed/fix_base.h	/^  RND_ZERO,           \/\/!< Rounding to zero$/;"	e	enum:itpp::q_mode
itpp::RNG_get_state	/usr/include/itpp/base/random.h	/^void RNG_get_state(ivec &state);$/;"	p	namespace:itpp	signature:(ivec &state)
itpp::RNG_randomize	/usr/include/itpp/base/random.h	/^void RNG_randomize();$/;"	p	namespace:itpp	signature:()
itpp::RNG_reset	/usr/include/itpp/base/random.h	/^void RNG_reset();$/;"	p	namespace:itpp	signature:()
itpp::RNG_reset	/usr/include/itpp/base/random.h	/^void RNG_reset(unsigned int seed);$/;"	p	namespace:itpp	signature:(unsigned int seed)
itpp::RNG_set_state	/usr/include/itpp/base/random.h	/^void RNG_set_state(ivec &state);$/;"	p	namespace:itpp	signature:(ivec &state)
itpp::Raised_Cosine	/usr/include/itpp/comm/pulse_shape.h	/^class Raised_Cosine : public Pulse_Shape<T1, double, T1>$/;"	c	namespace:itpp	inherits:Pulse_Shape
itpp::Raised_Cosine::Raised_Cosine	/usr/include/itpp/comm/pulse_shape.h	/^  Raised_Cosine() {}$/;"	f	class:itpp::Raised_Cosine	access:public	signature:()
itpp::Raised_Cosine::Raised_Cosine	/usr/include/itpp/comm/pulse_shape.h	/^  Raised_Cosine(double roll_off, int filter_length = 6, int upsampling_factor = 8);$/;"	p	class:itpp::Raised_Cosine	access:public	signature:(double roll_off, int filter_length = 6, int upsampling_factor = 8)
itpp::Raised_Cosine::Raised_Cosine	/usr/include/itpp/comm/pulse_shape.h	/^Raised_Cosine<T1>::Raised_Cosine(double roll_off_factor, int filter_length, int upsampling_factor)$/;"	f	class:itpp::Raised_Cosine	signature:(double roll_off_factor, int filter_length, int upsampling_factor)
itpp::Raised_Cosine::get_roll_off	/usr/include/itpp/comm/pulse_shape.h	/^  double get_roll_off(void) const;$/;"	p	class:itpp::Raised_Cosine	access:public	signature:(void) const
itpp::Raised_Cosine::get_roll_off	/usr/include/itpp/comm/pulse_shape.h	/^double Raised_Cosine<T1>::get_roll_off(void) const$/;"	f	class:itpp::Raised_Cosine	signature:(void) const
itpp::Raised_Cosine::roll_off_factor	/usr/include/itpp/comm/pulse_shape.h	/^  double roll_off_factor;$/;"	m	class:itpp::Raised_Cosine	access:protected
itpp::Raised_Cosine::set_pulse_shape	/usr/include/itpp/comm/pulse_shape.h	/^  void set_pulse_shape(double roll_off_factor, int filter_length = 6, int upsampling_factor = 8);$/;"	p	class:itpp::Raised_Cosine	access:public	signature:(double roll_off_factor, int filter_length = 6, int upsampling_factor = 8)
itpp::Raised_Cosine::set_pulse_shape	/usr/include/itpp/comm/pulse_shape.h	/^void Raised_Cosine<T1>::set_pulse_shape(double roll_off_factor_in, int filter_length, int upsampling_factor_in)$/;"	f	class:itpp::Raised_Cosine	signature:(double roll_off_factor_in, int filter_length, int upsampling_factor_in)
itpp::Raised_Cosine::~Raised_Cosine	/usr/include/itpp/comm/pulse_shape.h	/^  virtual ~Raised_Cosine() {}$/;"	f	class:itpp::Raised_Cosine	access:public	signature:()
itpp::Random_Generator	/usr/include/itpp/base/random.h	/^class Random_Generator$/;"	c	namespace:itpp
itpp::Random_Generator::Random_Generator	/usr/include/itpp/base/random.h	/^  Random_Generator() { if (!initialized) reset(4357U); }$/;"	f	class:itpp::Random_Generator	access:public	signature:()
itpp::Random_Generator::Random_Generator	/usr/include/itpp/base/random.h	/^  Random_Generator(unsigned int seed) { reset(seed); }$/;"	f	class:itpp::Random_Generator	access:public	signature:(unsigned int seed)
itpp::Random_Generator::get_state	/usr/include/itpp/base/random.h	/^  void get_state(ivec &out_state);$/;"	p	class:itpp::Random_Generator	access:public	signature:(ivec &out_state)
itpp::Random_Generator::hash	/usr/include/itpp/base/random.h	/^  unsigned int hash(time_t t, clock_t c);$/;"	p	class:itpp::Random_Generator	access:private	signature:(time_t t, clock_t c)
itpp::Random_Generator::hiBit	/usr/include/itpp/base/random.h	/^  unsigned int hiBit(const unsigned int& u) const { return u & 0x80000000U; }$/;"	f	class:itpp::Random_Generator	access:private	signature:(const unsigned int& u) const
itpp::Random_Generator::initialize	/usr/include/itpp/base/random.h	/^  void initialize(unsigned int seed) {$/;"	f	class:itpp::Random_Generator	access:private	signature:(unsigned int seed)
itpp::Random_Generator::initialized	/usr/include/itpp/base/random.h	/^  static bool initialized;$/;"	m	class:itpp::Random_Generator	access:private
itpp::Random_Generator::last_seed	/usr/include/itpp/base/random.h	/^  unsigned int last_seed;$/;"	m	class:itpp::Random_Generator	access:private
itpp::Random_Generator::left	/usr/include/itpp/base/random.h	/^  static int left;$/;"	m	class:itpp::Random_Generator	access:private
itpp::Random_Generator::loBit	/usr/include/itpp/base/random.h	/^  unsigned int loBit(const unsigned int& u) const { return u & 0x00000001U; }$/;"	f	class:itpp::Random_Generator	access:private	signature:(const unsigned int& u) const
itpp::Random_Generator::loBits	/usr/include/itpp/base/random.h	/^  unsigned int loBits(const unsigned int& u) const { return u & 0x7fffffffU; }$/;"	f	class:itpp::Random_Generator	access:private	signature:(const unsigned int& u) const
itpp::Random_Generator::mixBits	/usr/include/itpp/base/random.h	/^  unsigned int mixBits(const unsigned int& u, const unsigned int& v) const$/;"	f	class:itpp::Random_Generator	access:private	signature:(const unsigned int& u, const unsigned int& v) const
itpp::Random_Generator::pNext	/usr/include/itpp/base/random.h	/^  static unsigned int *pNext;$/;"	m	class:itpp::Random_Generator	access:private
itpp::Random_Generator::random53_01_lclosed	/usr/include/itpp/base/random.h	/^  double random53_01_lclosed() {$/;"	f	class:itpp::Random_Generator	access:public	signature:()
itpp::Random_Generator::random_01	/usr/include/itpp/base/random.h	/^  double random_01() { return (random_int() + 0.5) * (1.0 \/ 4294967296.0); }$/;"	f	class:itpp::Random_Generator	access:public	signature:()
itpp::Random_Generator::random_01_closed	/usr/include/itpp/base/random.h	/^  double random_01_closed() { return random_int() * (1.0 \/ 4294967295.0); }$/;"	f	class:itpp::Random_Generator	access:public	signature:()
itpp::Random_Generator::random_01_lclosed	/usr/include/itpp/base/random.h	/^  double random_01_lclosed() { return random_int() * (1.0 \/ 4294967296.0); }$/;"	f	class:itpp::Random_Generator	access:public	signature:()
itpp::Random_Generator::random_int	/usr/include/itpp/base/random.h	/^  unsigned int random_int() {$/;"	f	class:itpp::Random_Generator	access:public	signature:()
itpp::Random_Generator::randomize	/usr/include/itpp/base/random.h	/^  void randomize() { reset(hash(time(0), clock())); }$/;"	f	class:itpp::Random_Generator	access:public	signature:()
itpp::Random_Generator::reload	/usr/include/itpp/base/random.h	/^  void reload() {$/;"	f	class:itpp::Random_Generator	access:private	signature:()
itpp::Random_Generator::reset	/usr/include/itpp/base/random.h	/^  void reset() { initialize(last_seed); reload(); initialized = true; }$/;"	f	class:itpp::Random_Generator	access:public	signature:()
itpp::Random_Generator::reset	/usr/include/itpp/base/random.h	/^  void reset(unsigned int seed) { last_seed = seed; reset(); }$/;"	f	class:itpp::Random_Generator	access:public	signature:(unsigned int seed)
itpp::Random_Generator::set_state	/usr/include/itpp/base/random.h	/^  void set_state(ivec &new_state);$/;"	p	class:itpp::Random_Generator	access:public	signature:(ivec &new_state)
itpp::Random_Generator::state	/usr/include/itpp/base/random.h	/^  static unsigned int state[624];$/;"	m	class:itpp::Random_Generator	access:private
itpp::Random_Generator::twist	/usr/include/itpp/base/random.h	/^  unsigned int twist(const unsigned int& m, const unsigned int& s0,$/;"	f	class:itpp::Random_Generator	access:private	signature:(const unsigned int& m, const unsigned int& s0, const unsigned int& s1) const
itpp::Rayleigh_RNG	/usr/include/itpp/base/random.h	/^class Rayleigh_RNG$/;"	c	namespace:itpp
itpp::Rayleigh_RNG::Rayleigh_RNG	/usr/include/itpp/base/random.h	/^  Rayleigh_RNG(double sigma = 1.0);$/;"	p	class:itpp::Rayleigh_RNG	access:public	signature:(double sigma = 1.0)
itpp::Rayleigh_RNG::get_setup	/usr/include/itpp/base/random.h	/^  double get_setup() { return sig; }$/;"	f	class:itpp::Rayleigh_RNG	access:public	signature:()
itpp::Rayleigh_RNG::nRNG	/usr/include/itpp/base/random.h	/^  Normal_RNG nRNG;$/;"	m	class:itpp::Rayleigh_RNG	access:private
itpp::Rayleigh_RNG::operator ()	/usr/include/itpp/base/random.h	/^  double operator()() { return sample(); }$/;"	f	class:itpp::Rayleigh_RNG	access:public	signature:()
itpp::Rayleigh_RNG::operator ()	/usr/include/itpp/base/random.h	/^  mat operator()(int h, int w);$/;"	p	class:itpp::Rayleigh_RNG	access:public	signature:(int h, int w)
itpp::Rayleigh_RNG::operator ()	/usr/include/itpp/base/random.h	/^  vec operator()(int n);$/;"	p	class:itpp::Rayleigh_RNG	access:public	signature:(int n)
itpp::Rayleigh_RNG::sample	/usr/include/itpp/base/random.h	/^  double sample() {$/;"	f	class:itpp::Rayleigh_RNG	access:private	signature:()
itpp::Rayleigh_RNG::setup	/usr/include/itpp/base/random.h	/^  void setup(double sigma) { sig = sigma; }$/;"	f	class:itpp::Rayleigh_RNG	access:public	signature:(double sigma)
itpp::Rayleigh_RNG::sig	/usr/include/itpp/base/random.h	/^  double sig;$/;"	m	class:itpp::Rayleigh_RNG	access:private
itpp::Real_Timer	/usr/include/itpp/base/timing.h	/^class Real_Timer : public Timer$/;"	c	namespace:itpp	inherits:Timer
itpp::Real_Timer::Real_Timer	/usr/include/itpp/base/timing.h	/^  Real_Timer() { }$/;"	f	class:itpp::Real_Timer	access:public	signature:()
itpp::Real_Timer::get_current_time	/usr/include/itpp/base/timing.h	/^  double get_current_time() const;$/;"	p	class:itpp::Real_Timer	access:protected	signature:() const
itpp::Rec_Syst_Conv_Code	/usr/include/itpp/comm/rec_syst_conv_code.h	/^class Rec_Syst_Conv_Code$/;"	c	namespace:itpp
itpp::Rec_Syst_Conv_Code::K	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  int n, K, m;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
itpp::Rec_Syst_Conv_Code::Lc	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  double rate, Lc;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
itpp::Rec_Syst_Conv_Code::Nstates	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  int encoder_state, Nstates;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
itpp::Rec_Syst_Conv_Code::Rec_Syst_Conv_Code	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  Rec_Syst_Conv_Code(): infinity(1e30) {}$/;"	f	class:itpp::Rec_Syst_Conv_Code	access:public	signature:()
itpp::Rec_Syst_Conv_Code::alpha	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  mat gamma, alpha, beta;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
itpp::Rec_Syst_Conv_Code::alpha_q	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  QLLRmat gamma_q, alpha_q, beta_q;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
itpp::Rec_Syst_Conv_Code::beta	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  mat gamma, alpha, beta;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
itpp::Rec_Syst_Conv_Code::beta_q	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  QLLRmat gamma_q, alpha_q, beta_q;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
itpp::Rec_Syst_Conv_Code::calc_state_transition	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  int calc_state_transition(const int instate, const int input, ivec &parity);$/;"	p	class:itpp::Rec_Syst_Conv_Code	access:private	signature:(const int instate, const int input, ivec &parity)
itpp::Rec_Syst_Conv_Code::denom	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  vec denom;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
itpp::Rec_Syst_Conv_Code::denom_q	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  QLLRvec denom_q;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
itpp::Rec_Syst_Conv_Code::encode	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  void encode(const bvec &input, bmat &parity_bits);$/;"	p	class:itpp::Rec_Syst_Conv_Code	access:public	signature:(const bvec &input, bmat &parity_bits)
itpp::Rec_Syst_Conv_Code::encode_tail	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  void encode_tail(const bvec &input, bvec &tail, bmat &parity_bits);$/;"	p	class:itpp::Rec_Syst_Conv_Code	access:public	signature:(const bvec &input, bvec &tail, bmat &parity_bits)
itpp::Rec_Syst_Conv_Code::encoder_state	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  int encoder_state, Nstates;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
itpp::Rec_Syst_Conv_Code::gamma	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  mat gamma, alpha, beta;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
itpp::Rec_Syst_Conv_Code::gamma_q	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  QLLRmat gamma_q, alpha_q, beta_q;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
itpp::Rec_Syst_Conv_Code::gen_pol	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  ivec gen_pol, gen_pol_rev;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
itpp::Rec_Syst_Conv_Code::gen_pol_rev	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  ivec gen_pol, gen_pol_rev;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
itpp::Rec_Syst_Conv_Code::infinity	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  const double infinity;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
itpp::Rec_Syst_Conv_Code::llrcalc	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  LLR_calc_unit llrcalc;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
itpp::Rec_Syst_Conv_Code::ln2	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  double ln2;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
itpp::Rec_Syst_Conv_Code::log_decode	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  virtual void log_decode(const QLLRvec &rec_systematic,$/;"	p	class:itpp::Rec_Syst_Conv_Code	access:public	signature:(const QLLRvec &rec_systematic, const QLLRmat &rec_parity, const QLLRvec &extrinsic_input, QLLRvec &extrinsic_output, bool set_terminated = false)
itpp::Rec_Syst_Conv_Code::log_decode	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  virtual void log_decode(const vec &rec_systematic, const mat &rec_parity, const vec &extrinsic_input,$/;"	p	class:itpp::Rec_Syst_Conv_Code	access:public	signature:(const vec &rec_systematic, const mat &rec_parity, const vec &extrinsic_input, vec &extrinsic_output, bool set_terminated = false, std::string metric = Ó)
itpp::Rec_Syst_Conv_Code::log_decode_n2	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  virtual void log_decode_n2(const QLLRvec &rec_systematic,$/;"	p	class:itpp::Rec_Syst_Conv_Code	access:public	signature:(const QLLRvec &rec_systematic, const QLLRvec &rec_parity, const QLLRvec &extrinsic_input, QLLRvec &extrinsic_output, bool set_terminated = false)
itpp::Rec_Syst_Conv_Code::log_decode_n2	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  virtual void log_decode_n2(const vec &rec_systematic,$/;"	p	class:itpp::Rec_Syst_Conv_Code	access:public	signature:(const vec &rec_systematic, const vec &rec_parity, const vec &extrinsic_input, vec &extrinsic_output, bool set_terminated = false, std::string metric = Ó)
itpp::Rec_Syst_Conv_Code::m	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  int n, K, m;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
itpp::Rec_Syst_Conv_Code::map_decode	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  virtual void map_decode(const vec &rec_systematic, const mat &rec_parity, const vec &extrinsic_input, vec &extrinsic_output,$/;"	p	class:itpp::Rec_Syst_Conv_Code	access:public	signature:(const vec &rec_systematic, const mat &rec_parity, const vec &extrinsic_input, vec &extrinsic_output, bool set_terminated = false)
itpp::Rec_Syst_Conv_Code::n	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  int n, K, m;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
itpp::Rec_Syst_Conv_Code::operator =	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  Rec_Syst_Conv_Code & operator=(const Rec_Syst_Conv_Code &) { return *this; }$/;"	f	class:itpp::Rec_Syst_Conv_Code	access:public	signature:(const Rec_Syst_Conv_Code &)
itpp::Rec_Syst_Conv_Code::output_parity	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  imat state_trans, output_parity, rev_state_trans, rev_output_parity;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
itpp::Rec_Syst_Conv_Code::rate	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  double rate, Lc;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
itpp::Rec_Syst_Conv_Code::rev_output_parity	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  imat state_trans, output_parity, rev_state_trans, rev_output_parity;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
itpp::Rec_Syst_Conv_Code::rev_state_trans	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  imat state_trans, output_parity, rev_state_trans, rev_output_parity;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
itpp::Rec_Syst_Conv_Code::set_awgn_channel_parameters	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  void set_awgn_channel_parameters(double Ec, double N0);$/;"	p	class:itpp::Rec_Syst_Conv_Code	access:public	signature:(double Ec, double N0)
itpp::Rec_Syst_Conv_Code::set_generator_polynomials	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  void set_generator_polynomials(const ivec &gen, int constraint_length);$/;"	p	class:itpp::Rec_Syst_Conv_Code	access:public	signature:(const ivec &gen, int constraint_length)
itpp::Rec_Syst_Conv_Code::set_llrcalc	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  void set_llrcalc(LLR_calc_unit in_llrcalc);$/;"	p	class:itpp::Rec_Syst_Conv_Code	access:public	signature:(LLR_calc_unit in_llrcalc)
itpp::Rec_Syst_Conv_Code::set_scaling_factor	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  void set_scaling_factor(double in_Lc);$/;"	p	class:itpp::Rec_Syst_Conv_Code	access:public	signature:(double in_Lc)
itpp::Rec_Syst_Conv_Code::state_trans	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  imat state_trans, output_parity, rev_state_trans, rev_output_parity;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
itpp::Rec_Syst_Conv_Code::terminated	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  bool terminated;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
itpp::Rec_Syst_Conv_Code::~Rec_Syst_Conv_Code	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  virtual ~Rec_Syst_Conv_Code() {}$/;"	f	class:itpp::Rec_Syst_Conv_Code	access:public	signature:()
itpp::Reed_Solomon	/usr/include/itpp/comm/reedsolomon.h	/^class Reed_Solomon : public Channel_Code$/;"	c	namespace:itpp	inherits:Channel_Code
itpp::Reed_Solomon::Reed_Solomon	/usr/include/itpp/comm/reedsolomon.h	/^  Reed_Solomon(int in_m, int in_t, bool sys = false);$/;"	p	class:itpp::Reed_Solomon	access:public	signature:(int in_m, int in_t, bool sys = false)
itpp::Reed_Solomon::decode	/usr/include/itpp/comm/reedsolomon.h	/^  virtual bvec decode(const bvec &coded_bits);$/;"	p	class:itpp::Reed_Solomon	access:public	signature:(const bvec &coded_bits)
itpp::Reed_Solomon::decode	/usr/include/itpp/comm/reedsolomon.h	/^  virtual bvec decode(const vec &received_signal);$/;"	p	class:itpp::Reed_Solomon	access:public	signature:(const vec &received_signal)
itpp::Reed_Solomon::decode	/usr/include/itpp/comm/reedsolomon.h	/^  virtual void decode(const bvec &coded_bits, bvec &decoded_bits);$/;"	p	class:itpp::Reed_Solomon	access:public	signature:(const bvec &coded_bits, bvec &decoded_bits)
itpp::Reed_Solomon::decode	/usr/include/itpp/comm/reedsolomon.h	/^  virtual void decode(const vec &received_signal, bvec &output);$/;"	p	class:itpp::Reed_Solomon	access:public	signature:(const vec &received_signal, bvec &output)
itpp::Reed_Solomon::encode	/usr/include/itpp/comm/reedsolomon.h	/^  virtual bvec encode(const bvec &uncoded_bits);$/;"	p	class:itpp::Reed_Solomon	access:public	signature:(const bvec &uncoded_bits)
itpp::Reed_Solomon::encode	/usr/include/itpp/comm/reedsolomon.h	/^  virtual void encode(const bvec &uncoded_bits, bvec &coded_bits);$/;"	p	class:itpp::Reed_Solomon	access:public	signature:(const bvec &uncoded_bits, bvec &coded_bits)
itpp::Reed_Solomon::g	/usr/include/itpp/comm/reedsolomon.h	/^  GFX g;$/;"	m	class:itpp::Reed_Solomon	access:protected
itpp::Reed_Solomon::get_rate	/usr/include/itpp/comm/reedsolomon.h	/^  virtual double get_rate() const { return static_cast<double>(k) \/ n; }$/;"	f	class:itpp::Reed_Solomon	access:public	signature:() const
itpp::Reed_Solomon::k	/usr/include/itpp/comm/reedsolomon.h	/^  int m, t, k, n, q;$/;"	m	class:itpp::Reed_Solomon	access:protected
itpp::Reed_Solomon::m	/usr/include/itpp/comm/reedsolomon.h	/^  int m, t, k, n, q;$/;"	m	class:itpp::Reed_Solomon	access:protected
itpp::Reed_Solomon::n	/usr/include/itpp/comm/reedsolomon.h	/^  int m, t, k, n, q;$/;"	m	class:itpp::Reed_Solomon	access:protected
itpp::Reed_Solomon::operator =	/usr/include/itpp/comm/reedsolomon.h	/^  Reed_Solomon & operator=(const Reed_Solomon &) { return *this; }$/;"	f	class:itpp::Reed_Solomon	access:public	signature:(const Reed_Solomon &)
itpp::Reed_Solomon::q	/usr/include/itpp/comm/reedsolomon.h	/^  int m, t, k, n, q;$/;"	m	class:itpp::Reed_Solomon	access:protected
itpp::Reed_Solomon::systematic	/usr/include/itpp/comm/reedsolomon.h	/^  const bool systematic;$/;"	m	class:itpp::Reed_Solomon	access:protected
itpp::Reed_Solomon::t	/usr/include/itpp/comm/reedsolomon.h	/^  int m, t, k, n, q;$/;"	m	class:itpp::Reed_Solomon	access:protected
itpp::Reed_Solomon::~Reed_Solomon	/usr/include/itpp/comm/reedsolomon.h	/^  virtual ~Reed_Solomon() { }$/;"	f	class:itpp::Reed_Solomon	access:public	signature:()
itpp::Rice_Fading_Generator	/usr/include/itpp/comm/channel.h	/^class Rice_Fading_Generator : public Correlated_Fading_Generator$/;"	c	namespace:itpp	inherits:Correlated_Fading_Generator
itpp::Rice_Fading_Generator::Ni	/usr/include/itpp/comm/channel.h	/^  int Ni;$/;"	m	class:itpp::Rice_Fading_Generator	access:protected
itpp::Rice_Fading_Generator::Rice_Fading_Generator	/usr/include/itpp/comm/channel.h	/^  Rice_Fading_Generator(double norm_doppler, DOPPLER_SPECTRUM spectrum = Jakes,$/;"	p	class:itpp::Rice_Fading_Generator	access:public	signature:(double norm_doppler, DOPPLER_SPECTRUM spectrum = Jakes, int no_freq = 16, RICE_METHOD method = MEDS)
itpp::Rice_Fading_Generator::c1	/usr/include/itpp/comm/channel.h	/^  vec f1, f2, c1, c2, th1, th2;$/;"	m	class:itpp::Rice_Fading_Generator	access:protected
itpp::Rice_Fading_Generator::c2	/usr/include/itpp/comm/channel.h	/^  vec f1, f2, c1, c2, th1, th2;$/;"	m	class:itpp::Rice_Fading_Generator	access:protected
itpp::Rice_Fading_Generator::dopp_spectrum	/usr/include/itpp/comm/channel.h	/^  DOPPLER_SPECTRUM dopp_spectrum; \/\/!< Doppler spectrum type (Jakes by default)$/;"	m	class:itpp::Rice_Fading_Generator	access:protected
itpp::Rice_Fading_Generator::f01	/usr/include/itpp/comm/channel.h	/^  double f01, f02;$/;"	m	class:itpp::Rice_Fading_Generator	access:protected
itpp::Rice_Fading_Generator::f02	/usr/include/itpp/comm/channel.h	/^  double f01, f02;$/;"	m	class:itpp::Rice_Fading_Generator	access:protected
itpp::Rice_Fading_Generator::f1	/usr/include/itpp/comm/channel.h	/^  vec f1, f2, c1, c2, th1, th2;$/;"	m	class:itpp::Rice_Fading_Generator	access:protected
itpp::Rice_Fading_Generator::f2	/usr/include/itpp/comm/channel.h	/^  vec f1, f2, c1, c2, th1, th2;$/;"	m	class:itpp::Rice_Fading_Generator	access:protected
itpp::Rice_Fading_Generator::generate	/usr/include/itpp/comm/channel.h	/^  virtual void generate(int no_samples, cvec &output);$/;"	p	class:itpp::Rice_Fading_Generator	access:public	signature:(int no_samples, cvec &output)
itpp::Rice_Fading_Generator::get_doppler_spectrum	/usr/include/itpp/comm/channel.h	/^  virtual DOPPLER_SPECTRUM get_doppler_spectrum() const { return dopp_spectrum; }$/;"	f	class:itpp::Rice_Fading_Generator	access:public	signature:() const
itpp::Rice_Fading_Generator::get_no_frequencies	/usr/include/itpp/comm/channel.h	/^  virtual int get_no_frequencies() const { return Ni; }$/;"	f	class:itpp::Rice_Fading_Generator	access:public	signature:() const
itpp::Rice_Fading_Generator::get_rice_method	/usr/include/itpp/comm/channel.h	/^  virtual RICE_METHOD get_rice_method() const { return rice_method; }$/;"	f	class:itpp::Rice_Fading_Generator	access:public	signature:() const
itpp::Rice_Fading_Generator::init	/usr/include/itpp/comm/channel.h	/^  virtual void init();$/;"	p	class:itpp::Rice_Fading_Generator	access:public	signature:()
itpp::Rice_Fading_Generator::init_MEDS	/usr/include/itpp/comm/channel.h	/^  void init_MEDS();$/;"	p	class:itpp::Rice_Fading_Generator	access:protected	signature:()
itpp::Rice_Fading_Generator::rice_method	/usr/include/itpp/comm/channel.h	/^  RICE_METHOD rice_method;$/;"	m	class:itpp::Rice_Fading_Generator	access:protected
itpp::Rice_Fading_Generator::set_doppler_spectrum	/usr/include/itpp/comm/channel.h	/^  virtual void set_doppler_spectrum(DOPPLER_SPECTRUM spectrum);$/;"	p	class:itpp::Rice_Fading_Generator	access:public	signature:(DOPPLER_SPECTRUM spectrum)
itpp::Rice_Fading_Generator::set_no_frequencies	/usr/include/itpp/comm/channel.h	/^  virtual void set_no_frequencies(int no_freq);$/;"	p	class:itpp::Rice_Fading_Generator	access:public	signature:(int no_freq)
itpp::Rice_Fading_Generator::set_rice_method	/usr/include/itpp/comm/channel.h	/^  virtual void set_rice_method(RICE_METHOD method);$/;"	p	class:itpp::Rice_Fading_Generator	access:public	signature:(RICE_METHOD method)
itpp::Rice_Fading_Generator::th1	/usr/include/itpp/comm/channel.h	/^  vec f1, f2, c1, c2, th1, th2;$/;"	m	class:itpp::Rice_Fading_Generator	access:protected
itpp::Rice_Fading_Generator::th2	/usr/include/itpp/comm/channel.h	/^  vec f1, f2, c1, c2, th1, th2;$/;"	m	class:itpp::Rice_Fading_Generator	access:protected
itpp::Rice_Fading_Generator::~Rice_Fading_Generator	/usr/include/itpp/comm/channel.h	/^  virtual ~Rice_Fading_Generator() {}$/;"	f	class:itpp::Rice_Fading_Generator	access:public	signature:()
itpp::Rice_MEDS	/usr/include/itpp/comm/channel.h	/^enum CORRELATED_METHOD { Rice_MEDS, IFFT, FIR };$/;"	e	enum:itpp::CORRELATED_METHOD
itpp::Rice_RNG	/usr/include/itpp/base/random.h	/^class Rice_RNG$/;"	c	namespace:itpp
itpp::Rice_RNG::Rice_RNG	/usr/include/itpp/base/random.h	/^  Rice_RNG(double sigma = 1.0, double v = 1.0);$/;"	p	class:itpp::Rice_RNG	access:public	signature:(double sigma = 1.0, double v = 1.0)
itpp::Rice_RNG::get_setup	/usr/include/itpp/base/random.h	/^  void get_setup(double &sigma, double &v) { sigma = sig; v = s; }$/;"	f	class:itpp::Rice_RNG	access:public	signature:(double &sigma, double &v)
itpp::Rice_RNG::nRNG	/usr/include/itpp/base/random.h	/^  Normal_RNG nRNG;$/;"	m	class:itpp::Rice_RNG	access:private
itpp::Rice_RNG::operator ()	/usr/include/itpp/base/random.h	/^  double operator()() { return sample(); }$/;"	f	class:itpp::Rice_RNG	access:public	signature:()
itpp::Rice_RNG::operator ()	/usr/include/itpp/base/random.h	/^  mat operator()(int h, int w);$/;"	p	class:itpp::Rice_RNG	access:public	signature:(int h, int w)
itpp::Rice_RNG::operator ()	/usr/include/itpp/base/random.h	/^  vec operator()(int n);$/;"	p	class:itpp::Rice_RNG	access:public	signature:(int n)
itpp::Rice_RNG::s	/usr/include/itpp/base/random.h	/^  double sig, s;$/;"	m	class:itpp::Rice_RNG	access:private
itpp::Rice_RNG::sample	/usr/include/itpp/base/random.h	/^  double sample() {$/;"	f	class:itpp::Rice_RNG	access:private	signature:()
itpp::Rice_RNG::setup	/usr/include/itpp/base/random.h	/^  void setup(double sigma, double v) { sig = sigma; s = v; }$/;"	f	class:itpp::Rice_RNG	access:public	signature:(double sigma, double v)
itpp::Rice_RNG::sig	/usr/include/itpp/base/random.h	/^  double sig, s;$/;"	m	class:itpp::Rice_RNG	access:private
itpp::Root_Raised_Cosine	/usr/include/itpp/comm/pulse_shape.h	/^class Root_Raised_Cosine : public Pulse_Shape<T1, double, T1>$/;"	c	namespace:itpp	inherits:Pulse_Shape
itpp::Root_Raised_Cosine::Root_Raised_Cosine	/usr/include/itpp/comm/pulse_shape.h	/^  Root_Raised_Cosine() {}$/;"	f	class:itpp::Root_Raised_Cosine	access:public	signature:()
itpp::Root_Raised_Cosine::Root_Raised_Cosine	/usr/include/itpp/comm/pulse_shape.h	/^  Root_Raised_Cosine(double roll_off_factor, int filter_length = 6, int upsampling_factor = 8);$/;"	p	class:itpp::Root_Raised_Cosine	access:public	signature:(double roll_off_factor, int filter_length = 6, int upsampling_factor = 8)
itpp::Root_Raised_Cosine::Root_Raised_Cosine	/usr/include/itpp/comm/pulse_shape.h	/^Root_Raised_Cosine<T1>::Root_Raised_Cosine(double roll_off_factor, int filter_length, int upsampling_factor)$/;"	f	class:itpp::Root_Raised_Cosine	signature:(double roll_off_factor, int filter_length, int upsampling_factor)
itpp::Root_Raised_Cosine::get_roll_off	/usr/include/itpp/comm/pulse_shape.h	/^  double get_roll_off(void) const;$/;"	p	class:itpp::Root_Raised_Cosine	access:public	signature:(void) const
itpp::Root_Raised_Cosine::get_roll_off	/usr/include/itpp/comm/pulse_shape.h	/^double Root_Raised_Cosine<T1>::get_roll_off(void) const$/;"	f	class:itpp::Root_Raised_Cosine	signature:(void) const
itpp::Root_Raised_Cosine::roll_off_factor	/usr/include/itpp/comm/pulse_shape.h	/^  double roll_off_factor;$/;"	m	class:itpp::Root_Raised_Cosine	access:protected
itpp::Root_Raised_Cosine::set_pulse_shape	/usr/include/itpp/comm/pulse_shape.h	/^  void set_pulse_shape(double roll_off_factor, int filter_length = 6, int upsampling_factor = 8);$/;"	p	class:itpp::Root_Raised_Cosine	access:public	signature:(double roll_off_factor, int filter_length = 6, int upsampling_factor = 8)
itpp::Root_Raised_Cosine::set_pulse_shape	/usr/include/itpp/comm/pulse_shape.h	/^void Root_Raised_Cosine<T1>::set_pulse_shape(double roll_off_factor_in, int filter_length, int upsampling_factor_in)$/;"	f	class:itpp::Root_Raised_Cosine	signature:(double roll_off_factor_in, int filter_length, int upsampling_factor_in)
itpp::Root_Raised_Cosine::~Root_Raised_Cosine	/usr/include/itpp/comm/pulse_shape.h	/^  virtual ~Root_Raised_Cosine() {}$/;"	f	class:itpp::Root_Raised_Cosine	access:public	signature:()
itpp::SAT	/usr/include/itpp/fixed/fix_base.h	/^  SAT,                \/\/!< Saturation$/;"	e	enum:itpp::o_mode
itpp::SAT_SYM	/usr/include/itpp/fixed/fix_base.h	/^  SAT_SYM,            \/\/!< Symmetrical saturation (Not implemented)$/;"	e	enum:itpp::o_mode
itpp::SAT_ZERO	/usr/include/itpp/fixed/fix_base.h	/^  SAT_ZERO,           \/\/!< Saturation to zero (Not implemented)$/;"	e	enum:itpp::o_mode
itpp::SND_Format	/usr/include/itpp/srccode/audiofile.h	/^class SND_Format$/;"	c	namespace:itpp
itpp::SND_Format::__anon1::channels	/usr/include/itpp/srccode/audiofile.h	/^    unsigned channels;$/;"	m	struct:itpp::SND_Format::__anon1	access:public
itpp::SND_Format::__anon1::data_size	/usr/include/itpp/srccode/audiofile.h	/^    unsigned data_size;$/;"	m	struct:itpp::SND_Format::__anon1	access:public
itpp::SND_Format::__anon1::encoding	/usr/include/itpp/srccode/audiofile.h	/^    unsigned encoding;$/;"	m	struct:itpp::SND_Format::__anon1	access:public
itpp::SND_Format::__anon1::hdr_size	/usr/include/itpp/srccode/audiofile.h	/^    unsigned hdr_size;$/;"	m	struct:itpp::SND_Format::__anon1	access:public
itpp::SND_Format::__anon1::info	/usr/include/itpp/srccode/audiofile.h	/^    char info[SND_INFO_LEN];$/;"	m	struct:itpp::SND_Format::__anon1	access:public
itpp::SND_Format::__anon1::magic	/usr/include/itpp/srccode/audiofile.h	/^    unsigned magic;$/;"	m	struct:itpp::SND_Format::__anon1	access:public
itpp::SND_Format::__anon1::sample_rate	/usr/include/itpp/srccode/audiofile.h	/^    unsigned sample_rate;$/;"	m	struct:itpp::SND_Format::__anon1	access:public
itpp::SND_Format::channels	/usr/include/itpp/srccode/audiofile.h	/^  int channels() const { return header.channels; }$/;"	f	class:itpp::SND_Format	access:public	signature:() const
itpp::SND_Format::data_encoding	/usr/include/itpp/srccode/audiofile.h	/^  enum data_encoding { enc_unknown  =  0,$/;"	g	class:itpp::SND_Format	access:public
itpp::SND_Format::enc_alaw8	/usr/include/itpp/srccode/audiofile.h	/^                       enc_alaw8    = 27,$/;"	e	enum:itpp::SND_Format::data_encoding
itpp::SND_Format::enc_double	/usr/include/itpp/srccode/audiofile.h	/^                       enc_double   =  7$/;"	e	enum:itpp::SND_Format::data_encoding
itpp::SND_Format::enc_float	/usr/include/itpp/srccode/audiofile.h	/^                       enc_float    =  6,$/;"	e	enum:itpp::SND_Format::data_encoding
itpp::SND_Format::enc_linear16	/usr/include/itpp/srccode/audiofile.h	/^                       enc_linear16 =  3,$/;"	e	enum:itpp::SND_Format::data_encoding
itpp::SND_Format::enc_linear24	/usr/include/itpp/srccode/audiofile.h	/^                       enc_linear24 =  4,$/;"	e	enum:itpp::SND_Format::data_encoding
itpp::SND_Format::enc_linear32	/usr/include/itpp/srccode/audiofile.h	/^                       enc_linear32 =  5,$/;"	e	enum:itpp::SND_Format::data_encoding
itpp::SND_Format::enc_linear8	/usr/include/itpp/srccode/audiofile.h	/^                       enc_linear8  =  2,$/;"	e	enum:itpp::SND_Format::data_encoding
itpp::SND_Format::enc_mulaw8	/usr/include/itpp/srccode/audiofile.h	/^                       enc_mulaw8   =  1,$/;"	e	enum:itpp::SND_Format::data_encoding
itpp::SND_Format::enc_unknown	/usr/include/itpp/srccode/audiofile.h	/^  enum data_encoding { enc_unknown  =  0,$/;"	e	enum:itpp::SND_Format::data_encoding
itpp::SND_Format::encoding	/usr/include/itpp/srccode/audiofile.h	/^  data_encoding encoding() const { return (data_encoding)header.encoding; }$/;"	f	class:itpp::SND_Format	access:public	signature:() const
itpp::SND_Format::header	/usr/include/itpp/srccode/audiofile.h	/^  } header; \/\/!< Definition of the header structure$/;"	m	class:itpp::SND_Format	typeref:struct:itpp::SND_Format::__anon1	access:protected
itpp::SND_Format::rate	/usr/include/itpp/srccode/audiofile.h	/^  int rate() const { return header.sample_rate; }$/;"	f	class:itpp::SND_Format	access:public	signature:() const
itpp::SND_Format::read_header	/usr/include/itpp/srccode/audiofile.h	/^  bool read_header(std::istream &f);$/;"	p	class:itpp::SND_Format	access:protected	signature:(std::istream &f)
itpp::SND_Format::sample_size	/usr/include/itpp/srccode/audiofile.h	/^  int sample_size() const;$/;"	p	class:itpp::SND_Format	access:protected	signature:() const
itpp::SND_Format::samples	/usr/include/itpp/srccode/audiofile.h	/^  int samples() const { return header.data_size \/ sample_size(); }$/;"	f	class:itpp::SND_Format	access:public	signature:() const
itpp::SND_Format::set_rate	/usr/include/itpp/srccode/audiofile.h	/^  void set_rate(int r) { header.sample_rate = r; }$/;"	f	class:itpp::SND_Format	access:public	signature:(int r)
itpp::SND_Format::write_header	/usr/include/itpp/srccode/audiofile.h	/^  bool write_header(std::ostream &f);$/;"	p	class:itpp::SND_Format	access:protected	signature:(std::ostream &f)
itpp::SND_IO_File	/usr/include/itpp/srccode/audiofile.h	/^class SND_IO_File : public SND_In_File, public SND_Out_File$/;"	c	namespace:itpp	inherits:SND_In_File,SND_Out_File
itpp::SND_IO_File::SND_IO_File	/usr/include/itpp/srccode/audiofile.h	/^  SND_IO_File() { }$/;"	f	class:itpp::SND_IO_File	access:public	signature:()
itpp::SND_IO_File::SND_IO_File	/usr/include/itpp/srccode/audiofile.h	/^  SND_IO_File(const char *fname) { open(fname); }$/;"	f	class:itpp::SND_IO_File	access:public	signature:(const char *fname)
itpp::SND_IO_File::close	/usr/include/itpp/srccode/audiofile.h	/^  virtual void close();$/;"	p	class:itpp::SND_IO_File	access:public	signature:()
itpp::SND_IO_File::open	/usr/include/itpp/srccode/audiofile.h	/^  virtual bool open(const char *fname);$/;"	p	class:itpp::SND_IO_File	access:public	signature:(const char *fname)
itpp::SND_IO_File::~SND_IO_File	/usr/include/itpp/srccode/audiofile.h	/^  virtual ~SND_IO_File() { close(); }$/;"	f	class:itpp::SND_IO_File	access:public	signature:()
itpp::SND_In_File	/usr/include/itpp/srccode/audiofile.h	/^class SND_In_File : virtual public Audio_File, virtual public SND_Format$/;"	c	namespace:itpp	inherits:Audio_File,SND_Format
itpp::SND_In_File::SND_In_File	/usr/include/itpp/srccode/audiofile.h	/^  SND_In_File();$/;"	p	class:itpp::SND_In_File	access:public	signature:()
itpp::SND_In_File::SND_In_File	/usr/include/itpp/srccode/audiofile.h	/^  SND_In_File(const char *fname);$/;"	p	class:itpp::SND_In_File	access:public	signature:(const char *fname)
itpp::SND_In_File::close	/usr/include/itpp/srccode/audiofile.h	/^  virtual void close();$/;"	p	class:itpp::SND_In_File	access:public	signature:()
itpp::SND_In_File::open	/usr/include/itpp/srccode/audiofile.h	/^  virtual bool open(const char *fname);$/;"	p	class:itpp::SND_In_File	access:public	signature:(const char *fname)
itpp::SND_In_File::read	/usr/include/itpp/srccode/audiofile.h	/^  virtual bool read(vec &v);$/;"	p	class:itpp::SND_In_File	access:public	signature:(vec &v)
itpp::SND_In_File::read	/usr/include/itpp/srccode/audiofile.h	/^  virtual bool read(vec &v, int n);$/;"	p	class:itpp::SND_In_File	access:public	signature:(vec &v, int n)
itpp::SND_In_File::seek_read	/usr/include/itpp/srccode/audiofile.h	/^  bool seek_read(int pos);$/;"	p	class:itpp::SND_In_File	access:public	signature:(int pos)
itpp::SND_In_File::tell_read	/usr/include/itpp/srccode/audiofile.h	/^  int tell_read();$/;"	p	class:itpp::SND_In_File	access:public	signature:()
itpp::SND_In_File::~SND_In_File	/usr/include/itpp/srccode/audiofile.h	/^  virtual ~SND_In_File() { close(); }$/;"	f	class:itpp::SND_In_File	access:public	signature:()
itpp::SND_Out_File	/usr/include/itpp/srccode/audiofile.h	/^class SND_Out_File : virtual public Audio_File, virtual public SND_Format$/;"	c	namespace:itpp	inherits:Audio_File,SND_Format
itpp::SND_Out_File::SND_Out_File	/usr/include/itpp/srccode/audiofile.h	/^  SND_Out_File();$/;"	p	class:itpp::SND_Out_File	access:public	signature:()
itpp::SND_Out_File::SND_Out_File	/usr/include/itpp/srccode/audiofile.h	/^  SND_Out_File(const char *fname, int rate = 8000, data_encoding e = enc_linear16);$/;"	p	class:itpp::SND_Out_File	access:public	signature:(const char *fname, int rate = 8000, data_encoding e = enc_linear16)
itpp::SND_Out_File::close	/usr/include/itpp/srccode/audiofile.h	/^  virtual void close();$/;"	p	class:itpp::SND_Out_File	access:public	signature:()
itpp::SND_Out_File::open	/usr/include/itpp/srccode/audiofile.h	/^  bool open(const char *fname, int rate = 8000, data_encoding e = enc_linear16);$/;"	p	class:itpp::SND_Out_File	access:public	signature:(const char *fname, int rate = 8000, data_encoding e = enc_linear16)
itpp::SND_Out_File::seek_write	/usr/include/itpp/srccode/audiofile.h	/^  bool seek_write(int pos);$/;"	p	class:itpp::SND_Out_File	access:public	signature:(int pos)
itpp::SND_Out_File::tell_write	/usr/include/itpp/srccode/audiofile.h	/^  int tell_write();$/;"	p	class:itpp::SND_Out_File	access:public	signature:()
itpp::SND_Out_File::write	/usr/include/itpp/srccode/audiofile.h	/^  virtual bool write(const vec &v);$/;"	p	class:itpp::SND_Out_File	access:public	signature:(const vec &v)
itpp::SND_Out_File::~SND_Out_File	/usr/include/itpp/srccode/audiofile.h	/^  virtual ~SND_Out_File() { close(); }$/;"	f	class:itpp::SND_Out_File	access:public	signature:()
itpp::SORTING_METHOD	/usr/include/itpp/base/sort.h	/^enum SORTING_METHOD { INTROSORT = 0, QUICKSORT = 1, HEAPSORT = 2,$/;"	g	namespace:itpp
itpp::Sawtooth_Source	/usr/include/itpp/signal/source.h	/^class Sawtooth_Source$/;"	c	namespace:itpp
itpp::Sawtooth_Source::A	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Sawtooth_Source	access:private
itpp::Sawtooth_Source::Sawtooth_Source	/usr/include/itpp/signal/source.h	/^  Sawtooth_Source(double freq, double mean = 0.0, double ampl = 1.0, double inphase = 0.0);$/;"	p	class:itpp::Sawtooth_Source	access:public	signature:(double freq, double mean = 0.0, double ampl = 1.0, double inphase = 0.0)
itpp::Sawtooth_Source::dtheta	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Sawtooth_Source	access:private
itpp::Sawtooth_Source::m	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Sawtooth_Source	access:private
itpp::Sawtooth_Source::operator ()	/usr/include/itpp/signal/source.h	/^  double operator()() { return sample(); }$/;"	f	class:itpp::Sawtooth_Source	access:public	signature:()
itpp::Sawtooth_Source::operator ()	/usr/include/itpp/signal/source.h	/^  mat operator()(int h, int w);$/;"	p	class:itpp::Sawtooth_Source	access:public	signature:(int h, int w)
itpp::Sawtooth_Source::operator ()	/usr/include/itpp/signal/source.h	/^  vec operator()(int n);$/;"	p	class:itpp::Sawtooth_Source	access:public	signature:(int n)
itpp::Sawtooth_Source::sample	/usr/include/itpp/signal/source.h	/^  double sample();$/;"	p	class:itpp::Sawtooth_Source	access:private	signature:()
itpp::Sawtooth_Source::theta	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Sawtooth_Source	access:private
itpp::Scalar_Quantizer	/usr/include/itpp/srccode/vq.h	/^class Scalar_Quantizer$/;"	c	namespace:itpp
itpp::Scalar_Quantizer::LatestDist	/usr/include/itpp/srccode/vq.h	/^  double LatestDist;$/;"	m	class:itpp::Scalar_Quantizer	access:protected
itpp::Scalar_Quantizer::Levels	/usr/include/itpp/srccode/vq.h	/^  vec Levels;$/;"	m	class:itpp::Scalar_Quantizer	access:protected
itpp::Scalar_Quantizer::Q	/usr/include/itpp/srccode/vq.h	/^  double Q(double x) const;$/;"	p	class:itpp::Scalar_Quantizer	access:public	signature:(double x) const
itpp::Scalar_Quantizer::Q	/usr/include/itpp/srccode/vq.h	/^  vec Q(const vec &x) const;$/;"	p	class:itpp::Scalar_Quantizer	access:public	signature:(const vec &x) const
itpp::Scalar_Quantizer::Q	/usr/include/itpp/srccode/vq.h	/^inline double Scalar_Quantizer::Q(double x) const { return decode(encode(x)); }$/;"	f	class:itpp::Scalar_Quantizer	signature:(double x) const
itpp::Scalar_Quantizer::Scalar_Quantizer	/usr/include/itpp/srccode/vq.h	/^  Scalar_Quantizer();$/;"	p	class:itpp::Scalar_Quantizer	access:public	signature:()
itpp::Scalar_Quantizer::Scalar_Quantizer	/usr/include/itpp/srccode/vq.h	/^  Scalar_Quantizer(const char *Name);$/;"	p	class:itpp::Scalar_Quantizer	access:public	signature:(const char *Name)
itpp::Scalar_Quantizer::decode	/usr/include/itpp/srccode/vq.h	/^  double decode(int Index) const;$/;"	p	class:itpp::Scalar_Quantizer	access:public	signature:(int Index) const
itpp::Scalar_Quantizer::decode	/usr/include/itpp/srccode/vq.h	/^  vec decode(const ivec &Index) const;$/;"	p	class:itpp::Scalar_Quantizer	access:public	signature:(const ivec &Index) const
itpp::Scalar_Quantizer::decode	/usr/include/itpp/srccode/vq.h	/^inline double Scalar_Quantizer::decode(int Index) const { return Levels(Index); }$/;"	f	class:itpp::Scalar_Quantizer	signature:(int Index) const
itpp::Scalar_Quantizer::encode	/usr/include/itpp/srccode/vq.h	/^  int encode(double x) const;$/;"	p	class:itpp::Scalar_Quantizer	access:public	signature:(double x) const
itpp::Scalar_Quantizer::encode	/usr/include/itpp/srccode/vq.h	/^  ivec encode(const vec &x) const;$/;"	p	class:itpp::Scalar_Quantizer	access:public	signature:(const vec &x) const
itpp::Scalar_Quantizer::get_levels	/usr/include/itpp/srccode/vq.h	/^  vec get_levels() const;$/;"	p	class:itpp::Scalar_Quantizer	access:public	signature:() const
itpp::Scalar_Quantizer::get_levels	/usr/include/itpp/srccode/vq.h	/^inline vec Scalar_Quantizer::get_levels() const {return Levels; }$/;"	f	class:itpp::Scalar_Quantizer	signature:() const
itpp::Scalar_Quantizer::operator ()	/usr/include/itpp/srccode/vq.h	/^  double operator()(double x) const;$/;"	p	class:itpp::Scalar_Quantizer	access:public	signature:(double x) const
itpp::Scalar_Quantizer::operator ()	/usr/include/itpp/srccode/vq.h	/^  vec operator()(const vec &x) const;$/;"	p	class:itpp::Scalar_Quantizer	access:public	signature:(const vec &x) const
itpp::Scalar_Quantizer::operator ()	/usr/include/itpp/srccode/vq.h	/^inline double Scalar_Quantizer::operator()(double x) const { return Q(x); }$/;"	f	class:itpp::Scalar_Quantizer	signature:(double x) const
itpp::Scalar_Quantizer::operator ()	/usr/include/itpp/srccode/vq.h	/^inline vec Scalar_Quantizer::operator()(const vec &x)  const { return Q(x); }$/;"	f	class:itpp::Scalar_Quantizer	signature:(const vec &x) const
itpp::Scalar_Quantizer::set_levels	/usr/include/itpp/srccode/vq.h	/^  void set_levels(const vec &L);$/;"	p	class:itpp::Scalar_Quantizer	access:public	signature:(const vec &L)
itpp::Scalar_Quantizer::set_levels	/usr/include/itpp/srccode/vq.h	/^inline void Scalar_Quantizer::set_levels(const vec &L) {Levels = L;sort(Levels); }$/;"	f	class:itpp::Scalar_Quantizer	signature:(const vec &L)
itpp::Scalar_Quantizer::size	/usr/include/itpp/srccode/vq.h	/^  int size() const;$/;"	p	class:itpp::Scalar_Quantizer	access:public	signature:() const
itpp::Scalar_Quantizer::size	/usr/include/itpp/srccode/vq.h	/^inline int Scalar_Quantizer::size() const { return Levels.length(); }$/;"	f	class:itpp::Scalar_Quantizer	signature:() const
itpp::Selective_Repeat_ARQ_Receiver	/usr/include/itpp/protocol/selective_repeat.h	/^class Selective_Repeat_ARQ_Receiver$/;"	c	namespace:itpp
itpp::Selective_Repeat_ARQ_Receiver::Rnext	/usr/include/itpp/protocol/selective_repeat.h	/^  int Rnext;$/;"	m	class:itpp::Selective_Repeat_ARQ_Receiver	access:private
itpp::Selective_Repeat_ARQ_Receiver::Selective_Repeat_ARQ_Receiver	/usr/include/itpp/protocol/selective_repeat.h	/^  Selective_Repeat_ARQ_Receiver();$/;"	p	class:itpp::Selective_Repeat_ARQ_Receiver	access:public	signature:()
itpp::Selective_Repeat_ARQ_Receiver::Selective_Repeat_ARQ_Receiver	/usr/include/itpp/protocol/selective_repeat.h	/^  Selective_Repeat_ARQ_Receiver(const int Seq_no_size);$/;"	p	class:itpp::Selective_Repeat_ARQ_Receiver	access:public	signature:(const int Seq_no_size)
itpp::Selective_Repeat_ARQ_Receiver::ack_output	/usr/include/itpp/protocol/selective_repeat.h	/^  Signal<Array<Packet*> > ack_output; \/\/!< Delivers ack.$/;"	m	class:itpp::Selective_Repeat_ARQ_Receiver	access:public
itpp::Selective_Repeat_ARQ_Receiver::greater_modulo_L	/usr/include/itpp/protocol/selective_repeat.h	/^  bool greater_modulo_L(const int a, const int b);$/;"	p	class:itpp::Selective_Repeat_ARQ_Receiver	access:private	signature:(const int a, const int b)
itpp::Selective_Repeat_ARQ_Receiver::handle_packet_input	/usr/include/itpp/protocol/selective_repeat.h	/^  void handle_packet_input(Array<Packet*>); \/\/ Take care of incomming packets.$/;"	p	class:itpp::Selective_Repeat_ARQ_Receiver	access:private	signature:(Array<Packet*>)
itpp::Selective_Repeat_ARQ_Receiver::id	/usr/include/itpp/protocol/selective_repeat.h	/^  int id;$/;"	m	class:itpp::Selective_Repeat_ARQ_Receiver	access:private
itpp::Selective_Repeat_ARQ_Receiver::packet_input	/usr/include/itpp/protocol/selective_repeat.h	/^  Slot<Selective_Repeat_ARQ_Receiver, Array<Packet*> > packet_input; \/\/!< Receives incoming packets.$/;"	m	class:itpp::Selective_Repeat_ARQ_Receiver	access:public
itpp::Selective_Repeat_ARQ_Receiver::packet_output	/usr/include/itpp/protocol/selective_repeat.h	/^  Signal<Packet*> packet_output;      \/\/!< Delivers received packets.$/;"	m	class:itpp::Selective_Repeat_ARQ_Receiver	access:public
itpp::Selective_Repeat_ARQ_Receiver::parameters_ok	/usr/include/itpp/protocol/selective_repeat.h	/^  bool parameters_ok;$/;"	m	class:itpp::Selective_Repeat_ARQ_Receiver	access:private
itpp::Selective_Repeat_ARQ_Receiver::rx_buffer	/usr/include/itpp/protocol/selective_repeat.h	/^  Array<Link_Packet*> rx_buffer;$/;"	m	class:itpp::Selective_Repeat_ARQ_Receiver	access:private
itpp::Selective_Repeat_ARQ_Receiver::seq_no_max	/usr/include/itpp/protocol/selective_repeat.h	/^  int seq_no_max;$/;"	m	class:itpp::Selective_Repeat_ARQ_Receiver	access:private
itpp::Selective_Repeat_ARQ_Receiver::seq_no_size	/usr/include/itpp/protocol/selective_repeat.h	/^  int seq_no_size;$/;"	m	class:itpp::Selective_Repeat_ARQ_Receiver	access:private
itpp::Selective_Repeat_ARQ_Receiver::set_parameters	/usr/include/itpp/protocol/selective_repeat.h	/^  void set_parameters(const int Seq_no_size); \/\/ # bits in sequence no.$/;"	p	class:itpp::Selective_Repeat_ARQ_Receiver	access:public	signature:(const int Seq_no_size)
itpp::Selective_Repeat_ARQ_Receiver::~Selective_Repeat_ARQ_Receiver	/usr/include/itpp/protocol/selective_repeat.h	/^  ~Selective_Repeat_ARQ_Receiver();$/;"	p	class:itpp::Selective_Repeat_ARQ_Receiver	access:public	signature:()
itpp::Selective_Repeat_ARQ_Sender	/usr/include/itpp/protocol/selective_repeat.h	/^class Selective_Repeat_ARQ_Sender$/;"	c	namespace:itpp
itpp::Selective_Repeat_ARQ_Sender::Selective_Repeat_ARQ_Sender	/usr/include/itpp/protocol/selective_repeat.h	/^  Selective_Repeat_ARQ_Sender();$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:public	signature:()
itpp::Selective_Repeat_ARQ_Sender::Selective_Repeat_ARQ_Sender	/usr/include/itpp/protocol/selective_repeat.h	/^  Selective_Repeat_ARQ_Sender(const int Seq_no_size, const int Buffer_size_factor, const int Link_packet_size, const Ttype Time_out);$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:public	signature:(const int Seq_no_size, const int Buffer_size_factor, const int Link_packet_size, const Ttype Time_out)
itpp::Selective_Repeat_ARQ_Sender::ack_input	/usr/include/itpp/protocol/selective_repeat.h	/^  Slot<Selective_Repeat_ARQ_Sender, Array<Packet*> > ack_input; \/\/!< Receives incoming ack\/nacks.$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:public
itpp::Selective_Repeat_ARQ_Sender::buffer_overflow	/usr/include/itpp/protocol/selective_repeat.h	/^  Signal<int> buffer_overflow;           \/\/!< Signals buffer overflows.$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:public
itpp::Selective_Repeat_ARQ_Sender::buffer_size	/usr/include/itpp/protocol/selective_repeat.h	/^  int buffer_size();$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:public	signature:()
itpp::Selective_Repeat_ARQ_Sender::buffered_non_outstanding	/usr/include/itpp/protocol/selective_repeat.h	/^  int buffered_non_outstanding();$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:()
itpp::Selective_Repeat_ARQ_Sender::cancel_output	/usr/include/itpp/protocol/selective_repeat.h	/^  void cancel_output(const int Sequence_number);$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:(const int Sequence_number)
itpp::Selective_Repeat_ARQ_Sender::feasable_blocks	/usr/include/itpp/protocol/selective_repeat.h	/^  int feasable_blocks();$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:()
itpp::Selective_Repeat_ARQ_Sender::fill_output	/usr/include/itpp/protocol/selective_repeat.h	/^  void fill_output();$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:()
itpp::Selective_Repeat_ARQ_Sender::free_sequence_numbers	/usr/include/itpp/protocol/selective_repeat.h	/^  int free_sequence_numbers();$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:()
itpp::Selective_Repeat_ARQ_Sender::get_link_packets	/usr/include/itpp/protocol/selective_repeat.h	/^  void get_link_packets(const int K, Array<Packet*> &pa);$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:public	signature:(const int K, Array<Packet*> &pa)
itpp::Selective_Repeat_ARQ_Sender::handle_ack_input	/usr/include/itpp/protocol/selective_repeat.h	/^  void handle_ack_input(Array<Packet*> packet_array); \/\/ Take care of incomming ack\/nacks.$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:(Array<Packet*> packet_array)
itpp::Selective_Repeat_ARQ_Sender::handle_packet_input	/usr/include/itpp/protocol/selective_repeat.h	/^  void handle_packet_input(Packet *P);          \/\/ Take care of incomming packets.$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:(Packet *P)
itpp::Selective_Repeat_ARQ_Sender::handle_packet_output_request	/usr/include/itpp/protocol/selective_repeat.h	/^  void handle_packet_output_request(int K);     \/\/ Take care of incomming packet requests.$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:(int K)
itpp::Selective_Repeat_ARQ_Sender::handle_query_nof_ready_packets	/usr/include/itpp/protocol/selective_repeat.h	/^  void handle_query_nof_ready_packets(void*);   \/\/ Take care of incomming query for number of packets ready to transmit.$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:(void*)
itpp::Selective_Repeat_ARQ_Sender::id	/usr/include/itpp/protocol/selective_repeat.h	/^  int id;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
itpp::Selective_Repeat_ARQ_Sender::input_buffer	/usr/include/itpp/protocol/selective_repeat.h	/^  Array<Link_Packet*> input_buffer;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
itpp::Selective_Repeat_ARQ_Sender::input_buffer_size	/usr/include/itpp/protocol/selective_repeat.h	/^  int input_buffer_size;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
itpp::Selective_Repeat_ARQ_Sender::input_free_space	/usr/include/itpp/protocol/selective_repeat.h	/^  int input_free_space;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
itpp::Selective_Repeat_ARQ_Sender::input_next	/usr/include/itpp/protocol/selective_repeat.h	/^  int input_next;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
itpp::Selective_Repeat_ARQ_Sender::ip_pkt_queue	/usr/include/itpp/protocol/selective_repeat.h	/^  Front_Drop_Queue ip_pkt_queue;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
itpp::Selective_Repeat_ARQ_Sender::link_packet_size	/usr/include/itpp/protocol/selective_repeat.h	/^  int link_packet_size;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
itpp::Selective_Repeat_ARQ_Sender::link_packets_buffered	/usr/include/itpp/protocol/selective_repeat.h	/^  int link_packets_buffered();$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:public	signature:()
itpp::Selective_Repeat_ARQ_Sender::link_packets_max_queuing_time	/usr/include/itpp/protocol/selective_repeat.h	/^  Ttype link_packets_max_queuing_time();$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:public	signature:()
itpp::Selective_Repeat_ARQ_Sender::link_packets_queued_waiting_for_transmission	/usr/include/itpp/protocol/selective_repeat.h	/^  int link_packets_queued_waiting_for_transmission();$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:public	signature:()
itpp::Selective_Repeat_ARQ_Sender::no_retransmit	/usr/include/itpp/protocol/selective_repeat.h	/^  int no_retransmit;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
itpp::Selective_Repeat_ARQ_Sender::nof_ready_link_packets	/usr/include/itpp/protocol/selective_repeat.h	/^  int nof_ready_link_packets();$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:public	signature:()
itpp::Selective_Repeat_ARQ_Sender::nof_ready_packets	/usr/include/itpp/protocol/selective_repeat.h	/^  Signal<int> nof_ready_packets;         \/\/!< Delivers no ready packets.$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:public
itpp::Selective_Repeat_ARQ_Sender::output_indexes	/usr/include/itpp/protocol/selective_repeat.h	/^  ivec output_indexes;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
itpp::Selective_Repeat_ARQ_Sender::outstanding	/usr/include/itpp/protocol/selective_repeat.h	/^  int outstanding;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
itpp::Selective_Repeat_ARQ_Sender::packet_input	/usr/include/itpp/protocol/selective_repeat.h	/^  Slot<Selective_Repeat_ARQ_Sender, Packet*> packet_input; \/\/!< Receives incoming packets.$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:public
itpp::Selective_Repeat_ARQ_Sender::packet_output	/usr/include/itpp/protocol/selective_repeat.h	/^  Signal<Array<Packet*> > packet_output; \/\/!< Delivers transmitted packets.$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:public
itpp::Selective_Repeat_ARQ_Sender::packet_output_request	/usr/include/itpp/protocol/selective_repeat.h	/^  Slot<Selective_Repeat_ARQ_Sender, int> packet_output_request; \/\/!< Receives incoming packet output requests.$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:public
itpp::Selective_Repeat_ARQ_Sender::parameters_ok	/usr/include/itpp/protocol/selective_repeat.h	/^  bool parameters_ok;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
itpp::Selective_Repeat_ARQ_Sender::push_packet_on_tx_buffer	/usr/include/itpp/protocol/selective_repeat.h	/^  void push_packet_on_tx_buffer(Packet *packet);$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:(Packet *packet)
itpp::Selective_Repeat_ARQ_Sender::query_nof_ready_packets	/usr/include/itpp/protocol/selective_repeat.h	/^  Slot<Selective_Repeat_ARQ_Sender, void*> query_nof_ready_packets; \/\/!< Receives incoming query for number of packets ready to transmit.$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:public
itpp::Selective_Repeat_ARQ_Sender::rd_pos	/usr/include/itpp/protocol/selective_repeat.h	/^  int rd_pos;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
itpp::Selective_Repeat_ARQ_Sender::remove	/usr/include/itpp/protocol/selective_repeat.h	/^  void remove(const int Sequence_number);$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:(const int Sequence_number)
itpp::Selective_Repeat_ARQ_Sender::retransmission_indexes	/usr/include/itpp/protocol/selective_repeat.h	/^  ivec retransmission_indexes;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
itpp::Selective_Repeat_ARQ_Sender::retransmit	/usr/include/itpp/protocol/selective_repeat.h	/^  void retransmit(int Sequence_number);    \/\/ Take care of incomming query for number of packets ready to transmit.$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:(int Sequence_number)
itpp::Selective_Repeat_ARQ_Sender::rt_pos	/usr/include/itpp/protocol/selective_repeat.h	/^  int rt_pos;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
itpp::Selective_Repeat_ARQ_Sender::schedule_output	/usr/include/itpp/protocol/selective_repeat.h	/^  void schedule_output(const int Buffer_index, const int Sequence_number, const bool Retransmission);$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:(const int Buffer_index, const int Sequence_number, const bool Retransmission)
itpp::Selective_Repeat_ARQ_Sender::scheduled_retransmissions	/usr/include/itpp/protocol/selective_repeat.h	/^  int scheduled_retransmissions;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
itpp::Selective_Repeat_ARQ_Sender::scheduled_total	/usr/include/itpp/protocol/selective_repeat.h	/^  int scheduled_total;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
itpp::Selective_Repeat_ARQ_Sender::seq_no	/usr/include/itpp/protocol/selective_repeat.h	/^  int seq_no;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
itpp::Selective_Repeat_ARQ_Sender::seq_no_max	/usr/include/itpp/protocol/selective_repeat.h	/^  int seq_no_max;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
itpp::Selective_Repeat_ARQ_Sender::seq_no_size	/usr/include/itpp/protocol/selective_repeat.h	/^  int seq_no_size;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
itpp::Selective_Repeat_ARQ_Sender::sequence_number_2_buffer_index	/usr/include/itpp/protocol/selective_repeat.h	/^  int sequence_number_2_buffer_index(const int Sequence_number);$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:(const int Sequence_number)
itpp::Selective_Repeat_ARQ_Sender::set_parameters	/usr/include/itpp/protocol/selective_repeat.h	/^  void set_parameters(const int Seq_no_size,        \/\/ # bits in sequence no.$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:public	signature:(const int Seq_no_size, const int Buffer_size_factor, const int Link_packet_size, const Ttype Time_out)
itpp::Selective_Repeat_ARQ_Sender::time_out	/usr/include/itpp/protocol/selective_repeat.h	/^  Ttype time_out;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
itpp::Selective_Repeat_ARQ_Sender::timer	/usr/include/itpp/protocol/selective_repeat.h	/^  Array<ATimer<Selective_Repeat_ARQ_Sender, int> > timer;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
itpp::Selective_Repeat_ARQ_Sender::tx_last	/usr/include/itpp/protocol/selective_repeat.h	/^  int tx_last;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
itpp::Selective_Repeat_ARQ_Sender::tx_next	/usr/include/itpp/protocol/selective_repeat.h	/^  int tx_next;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
itpp::Selective_Repeat_ARQ_Sender::~Selective_Repeat_ARQ_Sender	/usr/include/itpp/protocol/selective_repeat.h	/^  ~Selective_Repeat_ARQ_Sender();$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:public	signature:()
itpp::Sequence_Interleaver	/usr/include/itpp/comm/interleave.h	/^class Sequence_Interleaver$/;"	c	namespace:itpp
itpp::Sequence_Interleaver::Sequence_Interleaver	/usr/include/itpp/comm/interleave.h	/^  Sequence_Interleaver(int in_interleaver_depth);$/;"	p	class:itpp::Sequence_Interleaver	access:public	signature:(int in_interleaver_depth)
itpp::Sequence_Interleaver::Sequence_Interleaver	/usr/include/itpp/comm/interleave.h	/^  Sequence_Interleaver(ivec in_interleaver_sequence);$/;"	p	class:itpp::Sequence_Interleaver	access:public	signature:(ivec in_interleaver_sequence)
itpp::Sequence_Interleaver::Sequence_Interleaver	/usr/include/itpp/comm/interleave.h	/^  Sequence_Interleaver(void) {interleaver_depth = 0;};$/;"	f	class:itpp::Sequence_Interleaver	access:public	signature:(void)
itpp::Sequence_Interleaver::Sequence_Interleaver	/usr/include/itpp/comm/interleave.h	/^Sequence_Interleaver<T>::Sequence_Interleaver(int in_interleaver_depth)$/;"	f	class:itpp::Sequence_Interleaver	signature:(int in_interleaver_depth)
itpp::Sequence_Interleaver::Sequence_Interleaver	/usr/include/itpp/comm/interleave.h	/^Sequence_Interleaver<T>::Sequence_Interleaver(ivec in_interleaver_sequence)$/;"	f	class:itpp::Sequence_Interleaver	signature:(ivec in_interleaver_sequence)
itpp::Sequence_Interleaver::deinterleave	/usr/include/itpp/comm/interleave.h	/^  Vec<T> deinterleave(const Vec<T> &input, short keepzeros = 0);$/;"	p	class:itpp::Sequence_Interleaver	access:public	signature:(const Vec<T> &input, short keepzeros = 0)
itpp::Sequence_Interleaver::deinterleave	/usr/include/itpp/comm/interleave.h	/^  void deinterleave(const Vec<T> &input, Vec<T> &output, short keepzeros = 0);$/;"	p	class:itpp::Sequence_Interleaver	access:public	signature:(const Vec<T> &input, Vec<T> &output, short keepzeros = 0)
itpp::Sequence_Interleaver::deinterleave	/usr/include/itpp/comm/interleave.h	/^Vec<T> Sequence_Interleaver<T>::deinterleave(const Vec<T> &input, short keepzeros)$/;"	f	class:itpp::Sequence_Interleaver	signature:(const Vec<T> &input, short keepzeros)
itpp::Sequence_Interleaver::deinterleave	/usr/include/itpp/comm/interleave.h	/^void Sequence_Interleaver<T>::deinterleave(const Vec<T> &input, Vec<T> &output, short keepzeros)$/;"	f	class:itpp::Sequence_Interleaver	signature:(const Vec<T> &input, Vec<T> &output, short keepzeros)
itpp::Sequence_Interleaver::get_interleaver_depth	/usr/include/itpp/comm/interleave.h	/^  int get_interleaver_depth(void) { return interleaver_depth; };$/;"	f	class:itpp::Sequence_Interleaver	access:public	signature:(void)
itpp::Sequence_Interleaver::get_interleaver_sequence	/usr/include/itpp/comm/interleave.h	/^  ivec get_interleaver_sequence();$/;"	p	class:itpp::Sequence_Interleaver	access:public	signature:()
itpp::Sequence_Interleaver::get_interleaver_sequence	/usr/include/itpp/comm/interleave.h	/^ivec Sequence_Interleaver<T>::get_interleaver_sequence()$/;"	f	class:itpp::Sequence_Interleaver	signature:()
itpp::Sequence_Interleaver::input_length	/usr/include/itpp/comm/interleave.h	/^  int interleaver_depth, input_length;$/;"	m	class:itpp::Sequence_Interleaver	access:private
itpp::Sequence_Interleaver::interleave	/usr/include/itpp/comm/interleave.h	/^  Vec<T> interleave(const Vec<T> &input);$/;"	p	class:itpp::Sequence_Interleaver	access:public	signature:(const Vec<T> &input)
itpp::Sequence_Interleaver::interleave	/usr/include/itpp/comm/interleave.h	/^  void interleave(const Vec<T> &input, Vec<T> &output);$/;"	p	class:itpp::Sequence_Interleaver	access:public	signature:(const Vec<T> &input, Vec<T> &output)
itpp::Sequence_Interleaver::interleave	/usr/include/itpp/comm/interleave.h	/^Vec<T> Sequence_Interleaver<T>::interleave(const Vec<T> &input)$/;"	f	class:itpp::Sequence_Interleaver	signature:(const Vec<T> &input)
itpp::Sequence_Interleaver::interleave	/usr/include/itpp/comm/interleave.h	/^void Sequence_Interleaver<T>::interleave(const Vec<T> &input, Vec<T> &output)$/;"	f	class:itpp::Sequence_Interleaver	signature:(const Vec<T> &input, Vec<T> &output)
itpp::Sequence_Interleaver::interleaver_depth	/usr/include/itpp/comm/interleave.h	/^  int interleaver_depth, input_length;$/;"	m	class:itpp::Sequence_Interleaver	access:private
itpp::Sequence_Interleaver::interleaver_sequence	/usr/include/itpp/comm/interleave.h	/^  ivec interleaver_sequence;$/;"	m	class:itpp::Sequence_Interleaver	access:private
itpp::Sequence_Interleaver::randomize_interleaver_sequence	/usr/include/itpp/comm/interleave.h	/^  void randomize_interleaver_sequence();$/;"	p	class:itpp::Sequence_Interleaver	access:public	signature:()
itpp::Sequence_Interleaver::randomize_interleaver_sequence	/usr/include/itpp/comm/interleave.h	/^void Sequence_Interleaver<T>::randomize_interleaver_sequence()$/;"	f	class:itpp::Sequence_Interleaver	signature:()
itpp::Sequence_Interleaver::set_interleaver_depth	/usr/include/itpp/comm/interleave.h	/^  void set_interleaver_depth(int in_interleaver_depth) { interleaver_depth = in_interleaver_depth; };$/;"	f	class:itpp::Sequence_Interleaver	access:public	signature:(int in_interleaver_depth)
itpp::Sequence_Interleaver::set_interleaver_sequence	/usr/include/itpp/comm/interleave.h	/^  void set_interleaver_sequence(ivec in_interleaver_sequence);$/;"	p	class:itpp::Sequence_Interleaver	access:public	signature:(ivec in_interleaver_sequence)
itpp::Sequence_Interleaver::set_interleaver_sequence	/usr/include/itpp/comm/interleave.h	/^void Sequence_Interleaver<T>::set_interleaver_sequence(ivec in_interleaver_sequence)$/;"	f	class:itpp::Sequence_Interleaver	signature:(ivec in_interleaver_sequence)
itpp::Sequence_Number	/usr/include/itpp/protocol/tcp.h	/^class Sequence_Number$/;"	c	namespace:itpp
itpp::Sequence_Number::Sequence_Number	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number() : seq(0) { }$/;"	f	class:itpp::Sequence_Number	access:public	signature:()
itpp::Sequence_Number::Sequence_Number	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number(const Sequence_Number &n) : seq(n.seq) { }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const Sequence_Number &n)
itpp::Sequence_Number::Sequence_Number	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number(int n) : seq(n) {}$/;"	f	class:itpp::Sequence_Number	access:protected	signature:(int n)
itpp::Sequence_Number::operator !=	/usr/include/itpp/protocol/tcp.h	/^  bool operator!=(const Sequence_Number &n) const { return seq != n.seq; }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const Sequence_Number &n) const
itpp::Sequence_Number::operator +	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number operator+(const int n) const { return Sequence_Number(seq + n); }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const int n) const
itpp::Sequence_Number::operator +	/usr/include/itpp/protocol/tcp.h	/^  friend Sequence_Number operator+(const int n1, const Sequence_Number &n2) { return Sequence_Number(n1 + n2.seq); }$/;"	f	class:itpp::Sequence_Number	access:friend	signature:(const int n1, const Sequence_Number &n2)
itpp::Sequence_Number::operator +=	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number &operator+=(const int n) { seq += n; return *this; }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const int n)
itpp::Sequence_Number::operator -	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number operator-(const int n) const { return Sequence_Number(seq - n); }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const int n) const
itpp::Sequence_Number::operator -	/usr/include/itpp/protocol/tcp.h	/^  int operator-(const Sequence_Number &n) const { return seq - n.seq; }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const Sequence_Number &n) const
itpp::Sequence_Number::operator -=	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number &operator-=(const int n) { seq -= n; return *this; }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const int n)
itpp::Sequence_Number::operator <	/usr/include/itpp/protocol/tcp.h	/^  bool operator<(const Sequence_Number &n) const { return (seq - n.seq) < 0; }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const Sequence_Number &n) const
itpp::Sequence_Number::operator <<	/usr/include/itpp/protocol/tcp.h	/^  friend std::ostream &operator<<(std::ostream &os, const Sequence_Number &n) { os << n.seq; return os; }$/;"	f	class:itpp::Sequence_Number	access:friend	signature:(std::ostream &os, const Sequence_Number &n)
itpp::Sequence_Number::operator <=	/usr/include/itpp/protocol/tcp.h	/^  bool operator<=(const Sequence_Number &n) const { return (seq - n.seq) <= 0; }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const Sequence_Number &n) const
itpp::Sequence_Number::operator =	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number &operator=(const Sequence_Number &n) { seq = n.seq; return *this; }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const Sequence_Number &n)
itpp::Sequence_Number::operator =	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number &operator=(const int &rep) { seq = rep; return *this; }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const int &rep)
itpp::Sequence_Number::operator ==	/usr/include/itpp/protocol/tcp.h	/^  bool operator==(const Sequence_Number &n) const { return seq == n.seq; }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const Sequence_Number &n) const
itpp::Sequence_Number::operator >	/usr/include/itpp/protocol/tcp.h	/^  bool operator>(const Sequence_Number &n) const { return (seq - n.seq) > 0; }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const Sequence_Number &n) const
itpp::Sequence_Number::operator >=	/usr/include/itpp/protocol/tcp.h	/^  bool operator>=(const Sequence_Number &n) const { return (seq - n.seq) >= 0; }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const Sequence_Number &n) const
itpp::Sequence_Number::seq	/usr/include/itpp/protocol/tcp.h	/^  int seq;$/;"	m	class:itpp::Sequence_Number	access:protected
itpp::Sequence_Number::value	/usr/include/itpp/protocol/tcp.h	/^  int value() const { return seq; }$/;"	f	class:itpp::Sequence_Number	access:public	signature:() const
itpp::Signal	/usr/include/itpp/protocol/signals_slots.h	/^class Signal$/;"	c	namespace:itpp
itpp::Signal::Base_Slot_Iterator	/usr/include/itpp/protocol/signals_slots.h	/^  typedef typename std::list<Base_Slot<DataType>*, std::allocator< Base_Slot<DataType>* > >::iterator Base_Slot_Iterator;$/;"	t	class:itpp::Signal	access:protected
itpp::Signal::Signal	/usr/include/itpp/protocol/signals_slots.h	/^  Signal(const std::string signal_name = "Unamed Signal", const bool single_shot = false, const bool enable_debug = false);$/;"	p	class:itpp::Signal	access:public	signature:(const std::string signal_name = Ó, const bool single_shot = false, const bool enable_debug = false)
itpp::Signal::Signal	/usr/include/itpp/protocol/signals_slots.h	/^Signal<DataType>::Signal(const std::string signal_name, const bool single_shot, const bool enable_debug)$/;"	f	class:itpp::Signal	signature:(const std::string signal_name, const bool single_shot, const bool enable_debug)
itpp::Signal::_disconnect	/usr/include/itpp/protocol/signals_slots.h	/^  void _disconnect(Base_Slot<DataType>* slot);$/;"	p	class:itpp::Signal	access:protected	signature:(Base_Slot<DataType>* slot)
itpp::Signal::_disconnect	/usr/include/itpp/protocol/signals_slots.h	/^void Signal<DataType>::_disconnect(Base_Slot<DataType>* slot)$/;"	f	class:itpp::Signal	signature:(Base_Slot<DataType>* slot)
itpp::Signal::armed	/usr/include/itpp/protocol/signals_slots.h	/^  bool armed;$/;"	m	class:itpp::Signal	access:private
itpp::Signal::cancel	/usr/include/itpp/protocol/signals_slots.h	/^  void cancel();$/;"	p	class:itpp::Signal	access:public	signature:()
itpp::Signal::cancel	/usr/include/itpp/protocol/signals_slots.h	/^void Signal<DataType>::cancel()$/;"	f	class:itpp::Signal	signature:()
itpp::Signal::connect	/usr/include/itpp/protocol/signals_slots.h	/^  void connect(Base_Slot<DataType>* slot);$/;"	p	class:itpp::Signal	access:public	signature:(Base_Slot<DataType>* slot)
itpp::Signal::connect	/usr/include/itpp/protocol/signals_slots.h	/^void Signal<DataType>::connect(Base_Slot<DataType>* slot)$/;"	f	class:itpp::Signal	signature:(Base_Slot<DataType>* slot)
itpp::Signal::connected_slots	/usr/include/itpp/protocol/signals_slots.h	/^  std::list<Base_Slot<DataType>*, std::allocator<Base_Slot<DataType>* > > connected_slots;$/;"	m	class:itpp::Signal	access:protected
itpp::Signal::debug	/usr/include/itpp/protocol/signals_slots.h	/^  bool debug;$/;"	m	class:itpp::Signal	access:private
itpp::Signal::disconnect	/usr/include/itpp/protocol/signals_slots.h	/^  void disconnect(Base_Slot<DataType>* slot = NULL);$/;"	p	class:itpp::Signal	access:public	signature:(Base_Slot<DataType>* slot = NULL)
itpp::Signal::disconnect	/usr/include/itpp/protocol/signals_slots.h	/^void Signal<DataType>::disconnect(Base_Slot<DataType>* slot)$/;"	f	class:itpp::Signal	signature:(Base_Slot<DataType>* slot)
itpp::Signal::e	/usr/include/itpp/protocol/signals_slots.h	/^  Data_Event<Signal, DataType> *e;$/;"	m	class:itpp::Signal	access:private
itpp::Signal::name	/usr/include/itpp/protocol/signals_slots.h	/^  std::string name;$/;"	m	class:itpp::Signal	access:protected
itpp::Signal::operator ()	/usr/include/itpp/protocol/signals_slots.h	/^  Base_Event* operator()(DataType signal, const Ttype delta_time = 0);$/;"	p	class:itpp::Signal	access:public	signature:(DataType signal, const Ttype delta_time = 0)
itpp::Signal::operator ()	/usr/include/itpp/protocol/signals_slots.h	/^Base_Event* Signal<DataType>::operator()(DataType signal, const Ttype delta_time)$/;"	f	class:itpp::Signal	signature:(DataType signal, const Ttype delta_time)
itpp::Signal::set_debug	/usr/include/itpp/protocol/signals_slots.h	/^  void set_debug(const bool enable_debug = true);$/;"	p	class:itpp::Signal	access:public	signature:(const bool enable_debug = true)
itpp::Signal::set_debug	/usr/include/itpp/protocol/signals_slots.h	/^void Signal<DataType>::set_debug(const bool enable_debug)$/;"	f	class:itpp::Signal	signature:(const bool enable_debug)
itpp::Signal::set_name	/usr/include/itpp/protocol/signals_slots.h	/^  void set_name(const std::string &signal_name);$/;"	p	class:itpp::Signal	access:public	signature:(const std::string &signal_name)
itpp::Signal::set_name	/usr/include/itpp/protocol/signals_slots.h	/^void Signal<DataType>::set_name(const std::string &signal_name)$/;"	f	class:itpp::Signal	signature:(const std::string &signal_name)
itpp::Signal::single	/usr/include/itpp/protocol/signals_slots.h	/^  bool single;$/;"	m	class:itpp::Signal	access:private
itpp::Signal::trigger	/usr/include/itpp/protocol/signals_slots.h	/^  void trigger(DataType u);$/;"	p	class:itpp::Signal	access:public	signature:(DataType u)
itpp::Signal::trigger	/usr/include/itpp/protocol/signals_slots.h	/^void Signal<DataType>::trigger(DataType u)$/;"	f	class:itpp::Signal	signature:(DataType u)
itpp::Signal::~Signal	/usr/include/itpp/protocol/signals_slots.h	/^  ~Signal();$/;"	p	class:itpp::Signal	access:public	signature:()
itpp::Signal::~Signal	/usr/include/itpp/protocol/signals_slots.h	/^Signal<DataType>::~Signal()$/;"	f	class:itpp::Signal	signature:()
itpp::Sine_Source	/usr/include/itpp/signal/source.h	/^class Sine_Source$/;"	c	namespace:itpp
itpp::Sine_Source::A	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Sine_Source	access:private
itpp::Sine_Source::Sine_Source	/usr/include/itpp/signal/source.h	/^  Sine_Source(double freq, double mean = 0.0, double ampl = 1.0, double inphase = 0.0);$/;"	p	class:itpp::Sine_Source	access:public	signature:(double freq, double mean = 0.0, double ampl = 1.0, double inphase = 0.0)
itpp::Sine_Source::dtheta	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Sine_Source	access:private
itpp::Sine_Source::m	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Sine_Source	access:private
itpp::Sine_Source::operator ()	/usr/include/itpp/signal/source.h	/^  double operator()() { return sample(); }$/;"	f	class:itpp::Sine_Source	access:public	signature:()
itpp::Sine_Source::operator ()	/usr/include/itpp/signal/source.h	/^  mat operator()(int h, int w);$/;"	p	class:itpp::Sine_Source	access:public	signature:(int h, int w)
itpp::Sine_Source::operator ()	/usr/include/itpp/signal/source.h	/^  vec operator()(int n);$/;"	p	class:itpp::Sine_Source	access:public	signature:(int n)
itpp::Sine_Source::sample	/usr/include/itpp/signal/source.h	/^  double sample();$/;"	p	class:itpp::Sine_Source	access:private	signature:()
itpp::Sine_Source::theta	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Sine_Source	access:private
itpp::Sink	/usr/include/itpp/protocol/packet_generator.h	/^class Sink$/;"	c	namespace:itpp
itpp::Sink::Nbytes	/usr/include/itpp/protocol/packet_generator.h	/^  unsigned long int Nbytes;$/;"	m	class:itpp::Sink	access:private
itpp::Sink::Ncp	/usr/include/itpp/protocol/packet_generator.h	/^  unsigned long int Ncp;$/;"	m	class:itpp::Sink	access:private
itpp::Sink::Sink	/usr/include/itpp/protocol/packet_generator.h	/^  Sink(const unsigned long int Max_packets = 1000);$/;"	p	class:itpp::Sink	access:public	signature:(const unsigned long int Max_packets = 1000)
itpp::Sink::handle_packet_input	/usr/include/itpp/protocol/packet_generator.h	/^  void handle_packet_input(Packet* packet);$/;"	p	class:itpp::Sink	access:private	signature:(Packet* packet)
itpp::Sink::max_packets	/usr/include/itpp/protocol/packet_generator.h	/^  unsigned long int max_packets;$/;"	m	class:itpp::Sink	access:private
itpp::Sink::packet_input	/usr/include/itpp/protocol/packet_generator.h	/^  Slot<Sink, Packet*> packet_input;$/;"	m	class:itpp::Sink	access:public
itpp::Sink::start_time	/usr/include/itpp/protocol/packet_generator.h	/^  Ttype start_time;$/;"	m	class:itpp::Sink	access:private
itpp::Sink::~Sink	/usr/include/itpp/protocol/packet_generator.h	/^  ~Sink();$/;"	p	class:itpp::Sink	access:public	signature:()
itpp::Slot	/usr/include/itpp/protocol/signals_slots.h	/^class Slot : public Base_Slot<DataType>$/;"	c	namespace:itpp	inherits:Base_Slot
itpp::Slot::Slot	/usr/include/itpp/protocol/signals_slots.h	/^  Slot(const std::string _name = "Unamed Slot");$/;"	p	class:itpp::Slot	access:public	signature:(const std::string _name = Ó)
itpp::Slot::Slot	/usr/include/itpp/protocol/signals_slots.h	/^Slot<ObjectType, DataType>::Slot(const std::string slot_name) : Base_Slot<DataType>(slot_name)$/;"	f	class:itpp::Slot	signature:(const std::string slot_name)
itpp::Slot::forward	/usr/include/itpp/protocol/signals_slots.h	/^  void forward(ObjectType *object_pointer, void(ObjectType::*object_function_pointer)(DataType u));$/;"	p	class:itpp::Slot	access:public	signature:(ObjectType *object_pointer, void(ObjectType::*object_function_pointer)(DataType u))
itpp::Slot::forward	/usr/include/itpp/protocol/signals_slots.h	/^void Slot<ObjectType, DataType>::forward(ObjectType *object_pointer, void(ObjectType::*object_function_pointer)(DataType u))$/;"	f	class:itpp::Slot	signature:(ObjectType *object_pointer, void(ObjectType::*object_function_pointer)(DataType u))
itpp::Slot::operator ()	/usr/include/itpp/protocol/signals_slots.h	/^  void operator()(DataType u);$/;"	p	class:itpp::Slot	access:public	signature:(DataType u)
itpp::Slot::operator ()	/usr/include/itpp/protocol/signals_slots.h	/^void Slot<ObjectType, DataType>::operator()(DataType signal)$/;"	f	class:itpp::Slot	signature:(DataType signal)
itpp::Slot::pm	/usr/include/itpp/protocol/signals_slots.h	/^  void(ObjectType::*pm)(DataType signal);$/;"	m	class:itpp::Slot	access:private
itpp::Slot::po	/usr/include/itpp/protocol/signals_slots.h	/^  ObjectType *po;$/;"	m	class:itpp::Slot	access:private
itpp::Slot::~Slot	/usr/include/itpp/protocol/signals_slots.h	/^  ~Slot();$/;"	p	class:itpp::Slot	access:public	signature:()
itpp::Slot::~Slot	/usr/include/itpp/protocol/signals_slots.h	/^Slot<ObjectType, DataType>::~Slot() {}$/;"	f	class:itpp::Slot	signature:()
itpp::Soft	/usr/include/itpp/optim/newton_search.h	/^enum Line_Search_Method {Soft, Exact};$/;"	e	enum:itpp::Line_Search_Method
itpp::Soft_Method	/usr/include/itpp/comm/modulator.h	/^enum Soft_Method {$/;"	g	namespace:itpp
itpp::Sort	/usr/include/itpp/base/sort.h	/^class Sort$/;"	c	namespace:itpp
itpp::Sort::HeapSort	/usr/include/itpp/base/sort.h	/^  void HeapSort(int low, int high, T data[]);$/;"	p	class:itpp::Sort	access:private	signature:(int low, int high, T data[])
itpp::Sort::HeapSort	/usr/include/itpp/base/sort.h	/^void Sort<T>::HeapSort(int low, int high, T data[])$/;"	f	class:itpp::Sort	signature:(int low, int high, T data[])
itpp::Sort::HeapSort_Index	/usr/include/itpp/base/sort.h	/^  void HeapSort_Index(int low, int high, int indexlist[], const T data[]);$/;"	p	class:itpp::Sort	access:private	signature:(int low, int high, int indexlist[], const T data[])
itpp::Sort::HeapSort_Index	/usr/include/itpp/base/sort.h	/^void Sort<T>::HeapSort_Index(int low, int high, int indexlist[],$/;"	f	class:itpp::Sort	signature:(int low, int high, int indexlist[], const T data[])
itpp::Sort::InsertSort	/usr/include/itpp/base/sort.h	/^  void InsertSort(int low, int high, T data[]);$/;"	p	class:itpp::Sort	access:private	signature:(int low, int high, T data[])
itpp::Sort::InsertSort	/usr/include/itpp/base/sort.h	/^void Sort<T>::InsertSort(int low, int high, T data[])$/;"	f	class:itpp::Sort	signature:(int low, int high, T data[])
itpp::Sort::InsertSort_Index	/usr/include/itpp/base/sort.h	/^  void InsertSort_Index(int low, int high, int indexlist[], const T data[]);$/;"	p	class:itpp::Sort	access:private	signature:(int low, int high, int indexlist[], const T data[])
itpp::Sort::InsertSort_Index	/usr/include/itpp/base/sort.h	/^void Sort<T>::InsertSort_Index(int low, int high, int indexlist[],$/;"	f	class:itpp::Sort	signature:(int low, int high, int indexlist[], const T data[])
itpp::Sort::IntroSort	/usr/include/itpp/base/sort.h	/^  void IntroSort(int low, int high, int max_depth, T data[]);$/;"	p	class:itpp::Sort	access:private	signature:(int low, int high, int max_depth, T data[])
itpp::Sort::IntroSort	/usr/include/itpp/base/sort.h	/^void Sort<T>::IntroSort(int low, int high, int max_depth, T data[])$/;"	f	class:itpp::Sort	signature:(int low, int high, int max_depth, T data[])
itpp::Sort::IntroSort_Index	/usr/include/itpp/base/sort.h	/^  void IntroSort_Index(int low, int high, int max_depth, int indexlist[],$/;"	p	class:itpp::Sort	access:private	signature:(int low, int high, int max_depth, int indexlist[], const T data[])
itpp::Sort::IntroSort_Index	/usr/include/itpp/base/sort.h	/^void Sort<T>::IntroSort_Index(int low, int high, int max_depth,$/;"	f	class:itpp::Sort	signature:(int low, int high, int max_depth, int indexlist[], const T data[])
itpp::Sort::QuickSort	/usr/include/itpp/base/sort.h	/^  void QuickSort(int low, int high, T data[]);$/;"	p	class:itpp::Sort	access:private	signature:(int low, int high, T data[])
itpp::Sort::QuickSort	/usr/include/itpp/base/sort.h	/^void Sort<T>::QuickSort(int low, int high, T data[])$/;"	f	class:itpp::Sort	signature:(int low, int high, T data[])
itpp::Sort::QuickSort_Index	/usr/include/itpp/base/sort.h	/^  void QuickSort_Index(int low, int high, int indexlist[], const T data[]);$/;"	p	class:itpp::Sort	access:private	signature:(int low, int high, int indexlist[], const T data[])
itpp::Sort::QuickSort_Index	/usr/include/itpp/base/sort.h	/^void Sort<T>::QuickSort_Index(int low, int high, int indexlist[],$/;"	f	class:itpp::Sort	signature:(int low, int high, int indexlist[], const T data[])
itpp::Sort::Sort	/usr/include/itpp/base/sort.h	/^  Sort(SORTING_METHOD method = INTROSORT): sort_method(method) {}$/;"	f	class:itpp::Sort	access:public	signature:(SORTING_METHOD method = INTROSORT)
itpp::Sort::get_method	/usr/include/itpp/base/sort.h	/^  SORTING_METHOD get_method() const { return sort_method; }$/;"	f	class:itpp::Sort	access:public	signature:() const
itpp::Sort::intro_sort	/usr/include/itpp/base/sort.h	/^  void intro_sort(int low, int high, int max_depth, Vec<T> &data);$/;"	p	class:itpp::Sort	access:public	signature:(int low, int high, int max_depth, Vec<T> &data)
itpp::Sort::intro_sort	/usr/include/itpp/base/sort.h	/^void Sort<T>::intro_sort(int low, int high, int max_depth, Vec<T> &data)$/;"	f	class:itpp::Sort	signature:(int low, int high, int max_depth, Vec<T> &data)
itpp::Sort::intro_sort_index	/usr/include/itpp/base/sort.h	/^  ivec intro_sort_index(int low, int high, int max_depth,$/;"	p	class:itpp::Sort	access:public	signature:(int low, int high, int max_depth, const Vec<T> &data)
itpp::Sort::intro_sort_index	/usr/include/itpp/base/sort.h	/^ivec Sort<T>::intro_sort_index(int low, int high, int max_depth,$/;"	f	class:itpp::Sort	signature:(int low, int high, int max_depth, const Vec<T> &data)
itpp::Sort::set_method	/usr/include/itpp/base/sort.h	/^  void set_method(SORTING_METHOD method) { sort_method = method; }$/;"	f	class:itpp::Sort	access:public	signature:(SORTING_METHOD method)
itpp::Sort::sort	/usr/include/itpp/base/sort.h	/^  void sort(int low, int high, Vec<T> &data);$/;"	p	class:itpp::Sort	access:public	signature:(int low, int high, Vec<T> &data)
itpp::Sort::sort	/usr/include/itpp/base/sort.h	/^void Sort<T>::sort(int low, int high, Vec<T> &data)$/;"	f	class:itpp::Sort	signature:(int low, int high, Vec<T> &data)
itpp::Sort::sort_index	/usr/include/itpp/base/sort.h	/^  ivec sort_index(int low, int high, const Vec<T> &data);$/;"	p	class:itpp::Sort	access:public	signature:(int low, int high, const Vec<T> &data)
itpp::Sort::sort_index	/usr/include/itpp/base/sort.h	/^ivec Sort<T>::sort_index(int low, int high, const Vec<T> &data)$/;"	f	class:itpp::Sort	signature:(int low, int high, const Vec<T> &data)
itpp::Sort::sort_method	/usr/include/itpp/base/sort.h	/^  SORTING_METHOD sort_method;$/;"	m	class:itpp::Sort	access:private
itpp::Sparse_Mat	/usr/include/itpp/base/smat.h	/^class Sparse_Mat$/;"	c	namespace:itpp
itpp::Sparse_Mat::Sparse_Mat	/usr/include/itpp/base/smat.h	/^  Sparse_Mat();$/;"	p	class:itpp::Sparse_Mat	access:public	signature:()
itpp::Sparse_Mat::Sparse_Mat	/usr/include/itpp/base/smat.h	/^  Sparse_Mat(const Mat<T> &m);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const Mat<T> &m)
itpp::Sparse_Mat::Sparse_Mat	/usr/include/itpp/base/smat.h	/^  Sparse_Mat(const Mat<T> &m, T epsilon);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const Mat<T> &m, T epsilon)
itpp::Sparse_Mat::Sparse_Mat	/usr/include/itpp/base/smat.h	/^  Sparse_Mat(const Sparse_Mat<T> &m);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const Sparse_Mat<T> &m)
itpp::Sparse_Mat::Sparse_Mat	/usr/include/itpp/base/smat.h	/^  Sparse_Mat(int rows, int cols, int row_data_init = 200);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(int rows, int cols, int row_data_init = 200)
itpp::Sparse_Mat::Sparse_Mat	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T>::Sparse_Mat()$/;"	f	class:itpp::Sparse_Mat	signature:()
itpp::Sparse_Mat::Sparse_Mat	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T>::Sparse_Mat(const Mat<T> &m)$/;"	f	class:itpp::Sparse_Mat	signature:(const Mat<T> &m)
itpp::Sparse_Mat::Sparse_Mat	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T>::Sparse_Mat(const Mat<T> &m, T epsilon)$/;"	f	class:itpp::Sparse_Mat	signature:(const Mat<T> &m, T epsilon)
itpp::Sparse_Mat::Sparse_Mat	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T>::Sparse_Mat(const Sparse_Mat<T> &m)$/;"	f	class:itpp::Sparse_Mat	signature:(const Sparse_Mat<T> &m)
itpp::Sparse_Mat::Sparse_Mat	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T>::Sparse_Mat(int rows, int cols, int row_data_init)$/;"	f	class:itpp::Sparse_Mat	signature:(int rows, int cols, int row_data_init)
itpp::Sparse_Mat::add_elem	/usr/include/itpp/base/smat.h	/^  void add_elem(const int r, const int c, const T v);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const int r, const int c, const T v)
itpp::Sparse_Mat::add_elem	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::add_elem(int r, int c, T v)$/;"	f	class:itpp::Sparse_Mat	signature:(int r, int c, T v)
itpp::Sparse_Mat::alloc	/usr/include/itpp/base/smat.h	/^  void alloc(int row_data_size = 200);$/;"	p	class:itpp::Sparse_Mat	access:private	signature:(int row_data_size = 200)
itpp::Sparse_Mat::alloc	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::alloc(int row_data_init)$/;"	f	class:itpp::Sparse_Mat	signature:(int row_data_init)
itpp::Sparse_Mat::alloc_empty	/usr/include/itpp/base/smat.h	/^  void alloc_empty();$/;"	p	class:itpp::Sparse_Mat	access:private	signature:()
itpp::Sparse_Mat::alloc_empty	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::alloc_empty()$/;"	f	class:itpp::Sparse_Mat	signature:()
itpp::Sparse_Mat::clear	/usr/include/itpp/base/smat.h	/^  void clear();$/;"	p	class:itpp::Sparse_Mat	access:public	signature:()
itpp::Sparse_Mat::clear	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::clear()$/;"	f	class:itpp::Sparse_Mat	signature:()
itpp::Sparse_Mat::clear_elem	/usr/include/itpp/base/smat.h	/^  void clear_elem(const int r, const int c);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const int r, const int c)
itpp::Sparse_Mat::clear_elem	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::clear_elem(const int r, const int c)$/;"	f	class:itpp::Sparse_Mat	signature:(const int r, const int c)
itpp::Sparse_Mat::col	/usr/include/itpp/base/smat.h	/^  Sparse_Vec<T> *col;$/;"	m	class:itpp::Sparse_Mat	access:private
itpp::Sparse_Mat::cols	/usr/include/itpp/base/smat.h	/^  int cols() const { return n_cols; }$/;"	f	class:itpp::Sparse_Mat	access:public	signature:() const
itpp::Sparse_Mat::compact	/usr/include/itpp/base/smat.h	/^  void compact();$/;"	p	class:itpp::Sparse_Mat	access:public	signature:()
itpp::Sparse_Mat::compact	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::compact()$/;"	f	class:itpp::Sparse_Mat	signature:()
itpp::Sparse_Mat::density	/usr/include/itpp/base/smat.h	/^  double density();$/;"	p	class:itpp::Sparse_Mat	access:public	signature:()
itpp::Sparse_Mat::density	/usr/include/itpp/base/smat.h	/^double Sparse_Mat<T>::density()$/;"	f	class:itpp::Sparse_Mat	signature:()
itpp::Sparse_Mat::free	/usr/include/itpp/base/smat.h	/^  void free();$/;"	p	class:itpp::Sparse_Mat	access:private	signature:()
itpp::Sparse_Mat::free	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::free()$/;"	f	class:itpp::Sparse_Mat	signature:()
itpp::Sparse_Mat::full	/usr/include/itpp/base/smat.h	/^  Mat<T> full() const;$/;"	p	class:itpp::Sparse_Mat	access:public	signature:() const
itpp::Sparse_Mat::full	/usr/include/itpp/base/smat.h	/^  void full(Mat<T> &m) const;$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(Mat<T> &m) const
itpp::Sparse_Mat::full	/usr/include/itpp/base/smat.h	/^Mat<T> Sparse_Mat<T>::full() const$/;"	f	class:itpp::Sparse_Mat	signature:() const
itpp::Sparse_Mat::full	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::full(Mat<T> &m) const$/;"	f	class:itpp::Sparse_Mat	signature:(Mat<T> &m) const
itpp::Sparse_Mat::get_col	/usr/include/itpp/base/smat.h	/^  Sparse_Vec<T> get_col(int c) const;$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(int c) const
itpp::Sparse_Mat::get_col	/usr/include/itpp/base/smat.h	/^  void get_col(int c, Sparse_Vec<T> &v) const;$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(int c, Sparse_Vec<T> &v) const
itpp::Sparse_Mat::get_col	/usr/include/itpp/base/smat.h	/^Sparse_Vec<T> Sparse_Mat<T>::get_col(int c) const$/;"	f	class:itpp::Sparse_Mat	signature:(int c) const
itpp::Sparse_Mat::get_col	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::get_col(int c, Sparse_Vec<T> &v) const$/;"	f	class:itpp::Sparse_Mat	signature:(int c, Sparse_Vec<T> &v) const
itpp::Sparse_Mat::get_submatrix	/usr/include/itpp/base/smat.h	/^  Sparse_Mat<T> get_submatrix(int r1, int r2, int c1, int c2) const;$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(int r1, int r2, int c1, int c2) const
itpp::Sparse_Mat::get_submatrix	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> Sparse_Mat<T>::get_submatrix(int r1, int r2, int c1, int c2) const$/;"	f	class:itpp::Sparse_Mat	signature:(int r1, int r2, int c1, int c2) const
itpp::Sparse_Mat::get_submatrix_cols	/usr/include/itpp/base/smat.h	/^  Sparse_Mat<T> get_submatrix_cols(int c1, int c2) const;$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(int c1, int c2) const
itpp::Sparse_Mat::get_submatrix_cols	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> Sparse_Mat<T>::get_submatrix_cols(int c1, int c2) const$/;"	f	class:itpp::Sparse_Mat	signature:(int c1, int c2) const
itpp::Sparse_Mat::init	/usr/include/itpp/base/smat.h	/^  void init();$/;"	p	class:itpp::Sparse_Mat	access:private	signature:()
itpp::Sparse_Mat::init	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::init()$/;"	f	class:itpp::Sparse_Mat	signature:()
itpp::Sparse_Mat::mult_trans	/usr/include/itpp/base/smat.h	/^  friend Sparse_Mat<T> mult_trans <>(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2);$/;"	p	class:itpp::Sparse_Mat	access:friend	signature:(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)
itpp::Sparse_Mat::n_cols	/usr/include/itpp/base/smat.h	/^  int n_rows, n_cols;$/;"	m	class:itpp::Sparse_Mat	access:private
itpp::Sparse_Mat::n_rows	/usr/include/itpp/base/smat.h	/^  int n_rows, n_cols;$/;"	m	class:itpp::Sparse_Mat	access:private
itpp::Sparse_Mat::nnz	/usr/include/itpp/base/smat.h	/^  int nnz();$/;"	p	class:itpp::Sparse_Mat	access:public	signature:()
itpp::Sparse_Mat::nnz	/usr/include/itpp/base/smat.h	/^int Sparse_Mat<T>::nnz()$/;"	f	class:itpp::Sparse_Mat	signature:()
itpp::Sparse_Mat::operator ()	/usr/include/itpp/base/smat.h	/^  T operator()(int r, int c) const;$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(int r, int c) const
itpp::Sparse_Mat::operator ()	/usr/include/itpp/base/smat.h	/^T Sparse_Mat<T>::operator()(int r, int c) const$/;"	f	class:itpp::Sparse_Mat	signature:(int r, int c) const
itpp::Sparse_Mat::operator *<>	/usr/include/itpp/base/smat.h	/^  friend Sparse_Mat<T> operator*<>(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2);$/;"	p	class:itpp::Sparse_Mat	access:friend	signature:(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)
itpp::Sparse_Mat::operator *<>	/usr/include/itpp/base/smat.h	/^  friend Sparse_Mat<T> operator*<>(const T &c, const Sparse_Mat<T> &m);$/;"	p	class:itpp::Sparse_Mat	access:friend	signature:(const T &c, const Sparse_Mat<T> &m)
itpp::Sparse_Mat::operator *<>	/usr/include/itpp/base/smat.h	/^  friend Sparse_Vec<T> operator*<>(const Sparse_Mat<T> &m, const Sparse_Vec<T> &v);$/;"	p	class:itpp::Sparse_Mat	access:friend	signature:(const Sparse_Mat<T> &m, const Sparse_Vec<T> &v)
itpp::Sparse_Mat::operator *<>	/usr/include/itpp/base/smat.h	/^  friend Vec<T> operator*<>(const Sparse_Mat<T> &m, const Vec<T> &v);$/;"	p	class:itpp::Sparse_Mat	access:friend	signature:(const Sparse_Mat<T> &m, const Vec<T> &v)
itpp::Sparse_Mat::operator *<>	/usr/include/itpp/base/smat.h	/^  friend Vec<T> operator*<>(const Vec<T> &v, const Sparse_Mat<T> &m);$/;"	p	class:itpp::Sparse_Mat	access:friend	signature:(const Vec<T> &v, const Sparse_Mat<T> &m)
itpp::Sparse_Mat::operator *=	/usr/include/itpp/base/smat.h	/^  void operator*=(const T &v);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const T &v)
itpp::Sparse_Mat::operator *=	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::operator*=(const T &m)$/;"	f	class:itpp::Sparse_Mat	signature:(const T &m)
itpp::Sparse_Mat::operator +<>	/usr/include/itpp/base/smat.h	/^  friend Sparse_Mat<T> operator+<>(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2);$/;"	p	class:itpp::Sparse_Mat	access:friend	signature:(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)
itpp::Sparse_Mat::operator +=	/usr/include/itpp/base/smat.h	/^  void operator+=(const Mat<T> &v);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const Mat<T> &v)
itpp::Sparse_Mat::operator +=	/usr/include/itpp/base/smat.h	/^  void operator+=(const Sparse_Mat<T> &v);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const Sparse_Mat<T> &v)
itpp::Sparse_Mat::operator +=	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::operator+=(const Mat<T> &m)$/;"	f	class:itpp::Sparse_Mat	signature:(const Mat<T> &m)
itpp::Sparse_Mat::operator +=	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::operator+=(const Sparse_Mat<T> &m)$/;"	f	class:itpp::Sparse_Mat	signature:(const Sparse_Mat<T> &m)
itpp::Sparse_Mat::operator -	/usr/include/itpp/base/smat.h	/^  Sparse_Mat<T> operator-() const;$/;"	p	class:itpp::Sparse_Mat	access:public	signature:() const
itpp::Sparse_Mat::operator -	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> Sparse_Mat<T>::operator-() const$/;"	f	class:itpp::Sparse_Mat	signature:() const
itpp::Sparse_Mat::operator -=	/usr/include/itpp/base/smat.h	/^  void operator-=(const Mat<T> &v);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const Mat<T> &v)
itpp::Sparse_Mat::operator -=	/usr/include/itpp/base/smat.h	/^  void operator-=(const Sparse_Mat<T> &v);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const Sparse_Mat<T> &v)
itpp::Sparse_Mat::operator -=	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::operator-=(const Mat<T> &m)$/;"	f	class:itpp::Sparse_Mat	signature:(const Mat<T> &m)
itpp::Sparse_Mat::operator -=	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::operator-=(const Sparse_Mat<T> &m)$/;"	f	class:itpp::Sparse_Mat	signature:(const Sparse_Mat<T> &m)
itpp::Sparse_Mat::operator /=	/usr/include/itpp/base/smat.h	/^  void operator\/=(const T &v);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const T &v)
itpp::Sparse_Mat::operator /=	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::operator\/=(const T &m)$/;"	f	class:itpp::Sparse_Mat	signature:(const T &m)
itpp::Sparse_Mat::operator =	/usr/include/itpp/base/smat.h	/^  void operator=(const Mat<T> &m);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const Mat<T> &m)
itpp::Sparse_Mat::operator =	/usr/include/itpp/base/smat.h	/^  void operator=(const Sparse_Mat<T> &m);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const Sparse_Mat<T> &m)
itpp::Sparse_Mat::operator =	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::operator=(const Mat<T> &m)$/;"	f	class:itpp::Sparse_Mat	signature:(const Mat<T> &m)
itpp::Sparse_Mat::operator =	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::operator=(const Sparse_Mat<T> &m)$/;"	f	class:itpp::Sparse_Mat	signature:(const Sparse_Mat<T> &m)
itpp::Sparse_Mat::operator ==	/usr/include/itpp/base/smat.h	/^  bool operator==(const Sparse_Mat<T> &m) const;$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const Sparse_Mat<T> &m) const
itpp::Sparse_Mat::operator ==	/usr/include/itpp/base/smat.h	/^bool Sparse_Mat<T>::operator==(const Sparse_Mat<T> &m) const$/;"	f	class:itpp::Sparse_Mat	signature:(const Sparse_Mat<T> &m) const
itpp::Sparse_Mat::rows	/usr/include/itpp/base/smat.h	/^  int rows() const { return n_rows; }$/;"	f	class:itpp::Sparse_Mat	access:public	signature:() const
itpp::Sparse_Mat::set	/usr/include/itpp/base/smat.h	/^  void set(int r, int c, T v);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(int r, int c, T v)
itpp::Sparse_Mat::set	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::set(int r, int c, T v)$/;"	f	class:itpp::Sparse_Mat	signature:(int r, int c, T v)
itpp::Sparse_Mat::set_col	/usr/include/itpp/base/smat.h	/^  void set_col(int c, const Sparse_Vec<T> &v);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(int c, const Sparse_Vec<T> &v)
itpp::Sparse_Mat::set_col	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::set_col(int c, const Sparse_Vec<T> &v)$/;"	f	class:itpp::Sparse_Mat	signature:(int c, const Sparse_Vec<T> &v)
itpp::Sparse_Mat::set_new	/usr/include/itpp/base/smat.h	/^  void set_new(int r, int c, T v);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(int r, int c, T v)
itpp::Sparse_Mat::set_new	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::set_new(int r, int c, T v)$/;"	f	class:itpp::Sparse_Mat	signature:(int r, int c, T v)
itpp::Sparse_Mat::set_size	/usr/include/itpp/base/smat.h	/^  void set_size(int rows, int cols, int row_data_init = -1);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(int rows, int cols, int row_data_init = -1)
itpp::Sparse_Mat::set_size	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::set_size(int rows, int cols, int row_data_init)$/;"	f	class:itpp::Sparse_Mat	signature:(int rows, int cols, int row_data_init)
itpp::Sparse_Mat::set_submatrix	/usr/include/itpp/base/smat.h	/^  void set_submatrix(int r, int c, const Mat<T>& m);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(int r, int c, const Mat<T>& m)
itpp::Sparse_Mat::set_submatrix	/usr/include/itpp/base/smat.h	/^  void set_submatrix(int r1, int r2, int c1, int c2, const Mat<T> &m);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(int r1, int r2, int c1, int c2, const Mat<T> &m)
itpp::Sparse_Mat::set_submatrix	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::set_submatrix(int r, int c, const Mat<T>& m)$/;"	f	class:itpp::Sparse_Mat	signature:(int r, int c, const Mat<T>& m)
itpp::Sparse_Mat::set_submatrix	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::set_submatrix(int r1, int r2, int c1, int c2, const Mat<T>& m)$/;"	f	class:itpp::Sparse_Mat	signature:(int r1, int r2, int c1, int c2, const Mat<T>& m)
itpp::Sparse_Mat::trans_mult	/usr/include/itpp/base/smat.h	/^  friend Mat<T> trans_mult <>(const Sparse_Mat<T> &m);$/;"	p	class:itpp::Sparse_Mat	access:friend	signature:(const Sparse_Mat<T> &m)
itpp::Sparse_Mat::trans_mult	/usr/include/itpp/base/smat.h	/^  friend Sparse_Mat<T> trans_mult <>(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2);$/;"	p	class:itpp::Sparse_Mat	access:friend	signature:(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)
itpp::Sparse_Mat::trans_mult	/usr/include/itpp/base/smat.h	/^  friend Vec<T> trans_mult <>(const Sparse_Mat<T> &m, const Vec<T> &v);$/;"	p	class:itpp::Sparse_Mat	access:friend	signature:(const Sparse_Mat<T> &m, const Vec<T> &v)
itpp::Sparse_Mat::trans_mult_s	/usr/include/itpp/base/smat.h	/^  friend Sparse_Mat<T> trans_mult_s <>(const Sparse_Mat<T> &m);$/;"	p	class:itpp::Sparse_Mat	access:friend	signature:(const Sparse_Mat<T> &m)
itpp::Sparse_Mat::transpose	/usr/include/itpp/base/smat.h	/^  Sparse_Mat<T> transpose() const;$/;"	p	class:itpp::Sparse_Mat	access:public	signature:() const
itpp::Sparse_Mat::transpose	/usr/include/itpp/base/smat.h	/^  void transpose(Sparse_Mat<T> &m) const;$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(Sparse_Mat<T> &m) const
itpp::Sparse_Mat::transpose	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> Sparse_Mat<T>::transpose() const$/;"	f	class:itpp::Sparse_Mat	signature:() const
itpp::Sparse_Mat::transpose	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::transpose(Sparse_Mat<T> &m) const$/;"	f	class:itpp::Sparse_Mat	signature:(Sparse_Mat<T> &m) const
itpp::Sparse_Mat::zero_elem	/usr/include/itpp/base/smat.h	/^  void zero_elem(const int r, const int c);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const int r, const int c)
itpp::Sparse_Mat::zero_elem	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::zero_elem(const int r, const int c)$/;"	f	class:itpp::Sparse_Mat	signature:(const int r, const int c)
itpp::Sparse_Mat::zeros	/usr/include/itpp/base/smat.h	/^  void zeros();$/;"	p	class:itpp::Sparse_Mat	access:public	signature:()
itpp::Sparse_Mat::zeros	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::zeros()$/;"	f	class:itpp::Sparse_Mat	signature:()
itpp::Sparse_Mat::~Sparse_Mat	/usr/include/itpp/base/smat.h	/^  ~Sparse_Mat();$/;"	p	class:itpp::Sparse_Mat	access:public	signature:()
itpp::Sparse_Mat::~Sparse_Mat	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T>::~Sparse_Mat()$/;"	f	class:itpp::Sparse_Mat	signature:()
itpp::Sparse_Vec	/usr/include/itpp/base/svec.h	/^class Sparse_Vec$/;"	c	namespace:itpp
itpp::Sparse_Vec::Sparse_Vec	/usr/include/itpp/base/svec.h	/^  Sparse_Vec();$/;"	p	class:itpp::Sparse_Vec	access:public	signature:()
itpp::Sparse_Vec::Sparse_Vec	/usr/include/itpp/base/svec.h	/^  Sparse_Vec(const Sparse_Vec<T> &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const Sparse_Vec<T> &v)
itpp::Sparse_Vec::Sparse_Vec	/usr/include/itpp/base/svec.h	/^  Sparse_Vec(const Vec<T> &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const Vec<T> &v)
itpp::Sparse_Vec::Sparse_Vec	/usr/include/itpp/base/svec.h	/^  Sparse_Vec(const Vec<T> &v, T epsilon);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const Vec<T> &v, T epsilon)
itpp::Sparse_Vec::Sparse_Vec	/usr/include/itpp/base/svec.h	/^  Sparse_Vec(int sz, int data_init = 200);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(int sz, int data_init = 200)
itpp::Sparse_Vec::Sparse_Vec	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T>::Sparse_Vec()$/;"	f	class:itpp::Sparse_Vec	signature:()
itpp::Sparse_Vec::Sparse_Vec	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T>::Sparse_Vec(const Sparse_Vec<T> &v)$/;"	f	class:itpp::Sparse_Vec	signature:(const Sparse_Vec<T> &v)
itpp::Sparse_Vec::Sparse_Vec	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T>::Sparse_Vec(const Vec<T> &v)$/;"	f	class:itpp::Sparse_Vec	signature:(const Vec<T> &v)
itpp::Sparse_Vec::Sparse_Vec	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T>::Sparse_Vec(const Vec<T> &v, T epsilon)$/;"	f	class:itpp::Sparse_Vec	signature:(const Vec<T> &v, T epsilon)
itpp::Sparse_Vec::Sparse_Vec	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T>::Sparse_Vec(int sz, int data_init)$/;"	f	class:itpp::Sparse_Vec	signature:(int sz, int data_init)
itpp::Sparse_Vec::add	/usr/include/itpp/base/svec.h	/^  void add(const ivec &index_vec, const Vec<T> &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const ivec &index_vec, const Vec<T> &v)
itpp::Sparse_Vec::add	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::add(const ivec& index_vec, const Vec<T>& v)$/;"	f	class:itpp::Sparse_Vec	signature:(const ivec& index_vec, const Vec<T>& v)
itpp::Sparse_Vec::add_elem	/usr/include/itpp/base/svec.h	/^  void add_elem(const int i, const T v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const int i, const T v)
itpp::Sparse_Vec::add_elem	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::add_elem(const int i, const T v)$/;"	f	class:itpp::Sparse_Vec	signature:(const int i, const T v)
itpp::Sparse_Vec::alloc	/usr/include/itpp/base/svec.h	/^  void alloc();$/;"	p	class:itpp::Sparse_Vec	access:private	signature:()
itpp::Sparse_Vec::alloc	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::alloc()$/;"	f	class:itpp::Sparse_Vec	signature:()
itpp::Sparse_Vec::check_small_elems_flag	/usr/include/itpp/base/svec.h	/^  bool check_small_elems_flag;$/;"	m	class:itpp::Sparse_Vec	access:private
itpp::Sparse_Vec::clear	/usr/include/itpp/base/svec.h	/^  void clear();$/;"	p	class:itpp::Sparse_Vec	access:public	signature:()
itpp::Sparse_Vec::clear	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::clear()$/;"	f	class:itpp::Sparse_Vec	signature:()
itpp::Sparse_Vec::clear_elem	/usr/include/itpp/base/svec.h	/^  void clear_elem(const int i);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const int i)
itpp::Sparse_Vec::clear_elem	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::clear_elem(const int i)$/;"	f	class:itpp::Sparse_Vec	signature:(const int i)
itpp::Sparse_Vec::compact	/usr/include/itpp/base/svec.h	/^  void compact();$/;"	p	class:itpp::Sparse_Vec	access:public	signature:()
itpp::Sparse_Vec::compact	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::compact()$/;"	f	class:itpp::Sparse_Vec	signature:()
itpp::Sparse_Vec::data	/usr/include/itpp/base/svec.h	/^  T *data;$/;"	m	class:itpp::Sparse_Vec	access:private
itpp::Sparse_Vec::data_size	/usr/include/itpp/base/svec.h	/^  int v_size, used_size, data_size;$/;"	m	class:itpp::Sparse_Vec	access:private
itpp::Sparse_Vec::density	/usr/include/itpp/base/svec.h	/^  double density();$/;"	p	class:itpp::Sparse_Vec	access:public	signature:()
itpp::Sparse_Vec::density	/usr/include/itpp/base/svec.h	/^double Sparse_Vec<T>::density()$/;"	f	class:itpp::Sparse_Vec	signature:()
itpp::Sparse_Vec::elem_mult	/usr/include/itpp/base/svec.h	/^  friend Sparse_Vec<T> elem_mult <>(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2);$/;"	p	class:itpp::Sparse_Vec	access:friend	signature:(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2)
itpp::Sparse_Vec::elem_mult	/usr/include/itpp/base/svec.h	/^  friend Vec<T> elem_mult <>(const Sparse_Vec<T> &v1, const Vec<T> &v2);$/;"	p	class:itpp::Sparse_Vec	access:friend	signature:(const Sparse_Vec<T> &v1, const Vec<T> &v2)
itpp::Sparse_Vec::elem_mult	/usr/include/itpp/base/svec.h	/^  friend Vec<T> elem_mult <>(const Vec<T> &v1, const Sparse_Vec<T> &v2);$/;"	p	class:itpp::Sparse_Vec	access:friend	signature:(const Vec<T> &v1, const Sparse_Vec<T> &v2)
itpp::Sparse_Vec::elem_mult_s	/usr/include/itpp/base/svec.h	/^  friend Sparse_Vec<T> elem_mult_s <>(const Sparse_Vec<T> &v1, const Vec<T> &v2);$/;"	p	class:itpp::Sparse_Vec	access:friend	signature:(const Sparse_Vec<T> &v1, const Vec<T> &v2)
itpp::Sparse_Vec::elem_mult_s	/usr/include/itpp/base/svec.h	/^  friend Sparse_Vec<T> elem_mult_s <>(const Vec<T> &v1, const Sparse_Vec<T> &v2);$/;"	p	class:itpp::Sparse_Vec	access:friend	signature:(const Vec<T> &v1, const Sparse_Vec<T> &v2)
itpp::Sparse_Vec::eps	/usr/include/itpp/base/svec.h	/^  T eps;$/;"	m	class:itpp::Sparse_Vec	access:private
itpp::Sparse_Vec::free	/usr/include/itpp/base/svec.h	/^  void free();$/;"	p	class:itpp::Sparse_Vec	access:private	signature:()
itpp::Sparse_Vec::free	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::free()$/;"	f	class:itpp::Sparse_Vec	signature:()
itpp::Sparse_Vec::full	/usr/include/itpp/base/svec.h	/^  Vec<T> full() const;$/;"	p	class:itpp::Sparse_Vec	access:public	signature:() const
itpp::Sparse_Vec::full	/usr/include/itpp/base/svec.h	/^  void full(Vec<T> &v) const;$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(Vec<T> &v) const
itpp::Sparse_Vec::full	/usr/include/itpp/base/svec.h	/^Vec<T> Sparse_Vec<T>::full() const$/;"	f	class:itpp::Sparse_Vec	signature:() const
itpp::Sparse_Vec::full	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::full(Vec<T> &v) const$/;"	f	class:itpp::Sparse_Vec	signature:(Vec<T> &v) const
itpp::Sparse_Vec::get_nz	/usr/include/itpp/base/svec.h	/^  inline void get_nz(int p, int &idx, T &dat) {$/;"	f	class:itpp::Sparse_Vec	access:public	signature:(int p, int &idx, T &dat)
itpp::Sparse_Vec::get_nz_data	/usr/include/itpp/base/svec.h	/^  inline T get_nz_data(int p) {$/;"	f	class:itpp::Sparse_Vec	access:public	signature:(int p)
itpp::Sparse_Vec::get_nz_data	/usr/include/itpp/base/svec.h	/^  inline void get_nz_data(int p, T& data_out) {$/;"	f	class:itpp::Sparse_Vec	access:public	signature:(int p, T& data_out)
itpp::Sparse_Vec::get_nz_index	/usr/include/itpp/base/svec.h	/^  inline int get_nz_index(int p) {$/;"	f	class:itpp::Sparse_Vec	access:public	signature:(int p)
itpp::Sparse_Vec::get_nz_indices	/usr/include/itpp/base/svec.h	/^  ivec get_nz_indices();$/;"	p	class:itpp::Sparse_Vec	access:public	signature:()
itpp::Sparse_Vec::get_nz_indices	/usr/include/itpp/base/svec.h	/^ivec Sparse_Vec<T>::get_nz_indices()$/;"	f	class:itpp::Sparse_Vec	signature:()
itpp::Sparse_Vec::get_subvector	/usr/include/itpp/base/svec.h	/^  Sparse_Vec<T> get_subvector(int i1, int i2) const;$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(int i1, int i2) const
itpp::Sparse_Vec::get_subvector	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T> Sparse_Vec<T>::get_subvector(int i1, int i2) const$/;"	f	class:itpp::Sparse_Vec	signature:(int i1, int i2) const
itpp::Sparse_Vec::index	/usr/include/itpp/base/svec.h	/^  int *index;$/;"	m	class:itpp::Sparse_Vec	access:private
itpp::Sparse_Vec::init	/usr/include/itpp/base/svec.h	/^  void init();$/;"	p	class:itpp::Sparse_Vec	access:private	signature:()
itpp::Sparse_Vec::init	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::init()$/;"	f	class:itpp::Sparse_Vec	signature:()
itpp::Sparse_Vec::nnz	/usr/include/itpp/base/svec.h	/^  inline int nnz() {$/;"	f	class:itpp::Sparse_Vec	access:public	signature:()
itpp::Sparse_Vec::operator ()	/usr/include/itpp/base/svec.h	/^  T operator()(int i) const;$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(int i) const
itpp::Sparse_Vec::operator ()	/usr/include/itpp/base/svec.h	/^T Sparse_Vec<T>::operator()(int i) const$/;"	f	class:itpp::Sparse_Vec	signature:(int i) const
itpp::Sparse_Vec::operator *<>	/usr/include/itpp/base/svec.h	/^  friend T operator*<>(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2);$/;"	p	class:itpp::Sparse_Vec	access:friend	signature:(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2)
itpp::Sparse_Vec::operator *<>	/usr/include/itpp/base/svec.h	/^  friend T operator*<>(const Sparse_Vec<T> &v1, const Vec<T> &v2);$/;"	p	class:itpp::Sparse_Vec	access:friend	signature:(const Sparse_Vec<T> &v1, const Vec<T> &v2)
itpp::Sparse_Vec::operator *<>	/usr/include/itpp/base/svec.h	/^  friend T operator*<>(const Vec<T> &v1, const Sparse_Vec<T> &v2);$/;"	p	class:itpp::Sparse_Vec	access:friend	signature:(const Vec<T> &v1, const Sparse_Vec<T> &v2)
itpp::Sparse_Vec::operator *=	/usr/include/itpp/base/svec.h	/^  void operator*=(const T &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const T &v)
itpp::Sparse_Vec::operator *=	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::operator*=(const T &v)$/;"	f	class:itpp::Sparse_Vec	signature:(const T &v)
itpp::Sparse_Vec::operator +<>	/usr/include/itpp/base/svec.h	/^  friend Sparse_Vec<T> operator+<>(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2);$/;"	p	class:itpp::Sparse_Vec	access:friend	signature:(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2)
itpp::Sparse_Vec::operator +=	/usr/include/itpp/base/svec.h	/^  void operator+=(const Sparse_Vec<T> &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const Sparse_Vec<T> &v)
itpp::Sparse_Vec::operator +=	/usr/include/itpp/base/svec.h	/^  void operator+=(const Vec<T> &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const Vec<T> &v)
itpp::Sparse_Vec::operator +=	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::operator+=(const Sparse_Vec<T> &v)$/;"	f	class:itpp::Sparse_Vec	signature:(const Sparse_Vec<T> &v)
itpp::Sparse_Vec::operator +=	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::operator+=(const Vec<T> &v)$/;"	f	class:itpp::Sparse_Vec	signature:(const Vec<T> &v)
itpp::Sparse_Vec::operator -	/usr/include/itpp/base/svec.h	/^  Sparse_Vec<T> operator-() const;$/;"	p	class:itpp::Sparse_Vec	access:public	signature:() const
itpp::Sparse_Vec::operator -	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T> Sparse_Vec<T>::operator-() const$/;"	f	class:itpp::Sparse_Vec	signature:() const
itpp::Sparse_Vec::operator -=	/usr/include/itpp/base/svec.h	/^  void operator-=(const Sparse_Vec<T> &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const Sparse_Vec<T> &v)
itpp::Sparse_Vec::operator -=	/usr/include/itpp/base/svec.h	/^  void operator-=(const Vec<T> &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const Vec<T> &v)
itpp::Sparse_Vec::operator -=	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::operator-=(const Sparse_Vec<T> &v)$/;"	f	class:itpp::Sparse_Vec	signature:(const Sparse_Vec<T> &v)
itpp::Sparse_Vec::operator -=	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::operator-=(const Vec<T> &v)$/;"	f	class:itpp::Sparse_Vec	signature:(const Vec<T> &v)
itpp::Sparse_Vec::operator /=	/usr/include/itpp/base/svec.h	/^  void operator\/=(const T &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const T &v)
itpp::Sparse_Vec::operator /=	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::operator\/=(const T &v)$/;"	f	class:itpp::Sparse_Vec	signature:(const T &v)
itpp::Sparse_Vec::operator =	/usr/include/itpp/base/svec.h	/^  void operator=(const Sparse_Vec<T> &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const Sparse_Vec<T> &v)
itpp::Sparse_Vec::operator =	/usr/include/itpp/base/svec.h	/^  void operator=(const Vec<T> &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const Vec<T> &v)
itpp::Sparse_Vec::operator =	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::operator=(const Sparse_Vec<T> &v)$/;"	f	class:itpp::Sparse_Vec	signature:(const Sparse_Vec<T> &v)
itpp::Sparse_Vec::operator =	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::operator=(const Vec<T> &v)$/;"	f	class:itpp::Sparse_Vec	signature:(const Vec<T> &v)
itpp::Sparse_Vec::operator ==	/usr/include/itpp/base/svec.h	/^  bool operator==(const Sparse_Vec<T> &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const Sparse_Vec<T> &v)
itpp::Sparse_Vec::operator ==	/usr/include/itpp/base/svec.h	/^bool Sparse_Vec<T>::operator==(const Sparse_Vec<T> &v)$/;"	f	class:itpp::Sparse_Vec	signature:(const Sparse_Vec<T> &v)
itpp::Sparse_Vec::remove_small_elements	/usr/include/itpp/base/svec.h	/^  void remove_small_elements();$/;"	p	class:itpp::Sparse_Vec	access:public	signature:()
itpp::Sparse_Vec::remove_small_elements	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::remove_small_elements()$/;"	f	class:itpp::Sparse_Vec	signature:()
itpp::Sparse_Vec::resize_data	/usr/include/itpp/base/svec.h	/^  void resize_data(int new_size);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(int new_size)
itpp::Sparse_Vec::resize_data	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::resize_data(int new_size)$/;"	f	class:itpp::Sparse_Vec	signature:(int new_size)
itpp::Sparse_Vec::set	/usr/include/itpp/base/svec.h	/^  void set(const ivec &index_vec, const Vec<T> &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const ivec &index_vec, const Vec<T> &v)
itpp::Sparse_Vec::set	/usr/include/itpp/base/svec.h	/^  void set(int i, T v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(int i, T v)
itpp::Sparse_Vec::set	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::set(const ivec& index_vec, const Vec<T>& v)$/;"	f	class:itpp::Sparse_Vec	signature:(const ivec& index_vec, const Vec<T>& v)
itpp::Sparse_Vec::set	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::set(int i, T v)$/;"	f	class:itpp::Sparse_Vec	signature:(int i, T v)
itpp::Sparse_Vec::set_new	/usr/include/itpp/base/svec.h	/^  void set_new(const ivec &index_vec, const Vec<T> &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const ivec &index_vec, const Vec<T> &v)
itpp::Sparse_Vec::set_new	/usr/include/itpp/base/svec.h	/^  void set_new(int i, T v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(int i, T v)
itpp::Sparse_Vec::set_new	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::set_new(const ivec& index_vec, const Vec<T>& v)$/;"	f	class:itpp::Sparse_Vec	signature:(const ivec& index_vec, const Vec<T>& v)
itpp::Sparse_Vec::set_new	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::set_new(int i, T v)$/;"	f	class:itpp::Sparse_Vec	signature:(int i, T v)
itpp::Sparse_Vec::set_size	/usr/include/itpp/base/svec.h	/^  void set_size(int sz, int data_init = -1);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(int sz, int data_init = -1)
itpp::Sparse_Vec::set_size	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::set_size(int new_size, int data_init)$/;"	f	class:itpp::Sparse_Vec	signature:(int new_size, int data_init)
itpp::Sparse_Vec::set_small_element	/usr/include/itpp/base/svec.h	/^  void set_small_element(const T& epsilon);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const T& epsilon)
itpp::Sparse_Vec::set_small_element	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::set_small_element(const T& epsilon)$/;"	f	class:itpp::Sparse_Vec	signature:(const T& epsilon)
itpp::Sparse_Vec::size	/usr/include/itpp/base/svec.h	/^  int size() const { return v_size; }$/;"	f	class:itpp::Sparse_Vec	access:public	signature:() const
itpp::Sparse_Vec::sqr	/usr/include/itpp/base/svec.h	/^  T sqr() const;$/;"	p	class:itpp::Sparse_Vec	access:public	signature:() const
itpp::Sparse_Vec::sqr	/usr/include/itpp/base/svec.h	/^T Sparse_Vec<T>::sqr() const$/;"	f	class:itpp::Sparse_Vec	signature:() const
itpp::Sparse_Vec::used_size	/usr/include/itpp/base/svec.h	/^  int v_size, used_size, data_size;$/;"	m	class:itpp::Sparse_Vec	access:private
itpp::Sparse_Vec::v_size	/usr/include/itpp/base/svec.h	/^  int v_size, used_size, data_size;$/;"	m	class:itpp::Sparse_Vec	access:private
itpp::Sparse_Vec::zero_elem	/usr/include/itpp/base/svec.h	/^  void zero_elem(const int i);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const int i)
itpp::Sparse_Vec::zero_elem	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::zero_elem(const int i)$/;"	f	class:itpp::Sparse_Vec	signature:(const int i)
itpp::Sparse_Vec::zeros	/usr/include/itpp/base/svec.h	/^  void zeros();$/;"	p	class:itpp::Sparse_Vec	access:public	signature:()
itpp::Sparse_Vec::zeros	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::zeros()$/;"	f	class:itpp::Sparse_Vec	signature:()
itpp::Sparse_Vec::~Sparse_Vec	/usr/include/itpp/base/svec.h	/^  ~Sparse_Vec();$/;"	p	class:itpp::Sparse_Vec	access:public	signature:()
itpp::Sparse_Vec::~Sparse_Vec	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T>::~Sparse_Vec()$/;"	f	class:itpp::Sparse_Vec	signature:()
itpp::Spread_1d	/usr/include/itpp/comm/spread.h	/^class Spread_1d$/;"	c	namespace:itpp
itpp::Spread_1d::N	/usr/include/itpp/comm/spread.h	/^  short N;$/;"	m	class:itpp::Spread_1d	access:protected
itpp::Spread_1d::Spread_1d	/usr/include/itpp/comm/spread.h	/^  Spread_1d() { }$/;"	f	class:itpp::Spread_1d	access:public	signature:()
itpp::Spread_1d::Spread_1d	/usr/include/itpp/comm/spread.h	/^  Spread_1d(const vec &incode);$/;"	p	class:itpp::Spread_1d	access:public	signature:(const vec &incode)
itpp::Spread_1d::code	/usr/include/itpp/comm/spread.h	/^  vec code;$/;"	m	class:itpp::Spread_1d	access:protected
itpp::Spread_1d::despread	/usr/include/itpp/comm/spread.h	/^  vec despread(const vec &rec_signal, int timing)$/;"	f	class:itpp::Spread_1d	access:public	signature:(const vec &rec_signal, int timing)
itpp::Spread_1d::despread	/usr/include/itpp/comm/spread.h	/^  void despread(const vec &rec_signal, vec &out, int timing);$/;"	p	class:itpp::Spread_1d	access:public	signature:(const vec &rec_signal, vec &out, int timing)
itpp::Spread_1d::get_code	/usr/include/itpp/comm/spread.h	/^  vec get_code();$/;"	p	class:itpp::Spread_1d	access:public	signature:()
itpp::Spread_1d::get_period	/usr/include/itpp/comm/spread.h	/^  short get_period() { return N; }$/;"	f	class:itpp::Spread_1d	access:public	signature:()
itpp::Spread_1d::set_code	/usr/include/itpp/comm/spread.h	/^  void set_code(const vec &incode);$/;"	p	class:itpp::Spread_1d	access:public	signature:(const vec &incode)
itpp::Spread_1d::spread	/usr/include/itpp/comm/spread.h	/^  vec spread(const vec &symbols) { vec out; spread(symbols, out); return out; }$/;"	f	class:itpp::Spread_1d	access:public	signature:(const vec &symbols)
itpp::Spread_1d::spread	/usr/include/itpp/comm/spread.h	/^  void spread(const vec &symbols, vec &out);$/;"	p	class:itpp::Spread_1d	access:public	signature:(const vec &symbols, vec &out)
itpp::Spread_2d	/usr/include/itpp/comm/spread.h	/^class Spread_2d$/;"	c	namespace:itpp
itpp::Spread_2d::Spread_2d	/usr/include/itpp/comm/spread.h	/^  Spread_2d() { }$/;"	f	class:itpp::Spread_2d	access:public	signature:()
itpp::Spread_2d::Spread_2d	/usr/include/itpp/comm/spread.h	/^  Spread_2d(const vec &incodeI, const vec &incodeQ);$/;"	p	class:itpp::Spread_2d	access:public	signature:(const vec &incodeI, const vec &incodeQ)
itpp::Spread_2d::despread	/usr/include/itpp/comm/spread.h	/^  cvec despread(const cvec &rec_signal, int timing)$/;"	f	class:itpp::Spread_2d	access:public	signature:(const cvec &rec_signal, int timing)
itpp::Spread_2d::despread	/usr/include/itpp/comm/spread.h	/^  void despread(const cvec &rec_signal, cvec &out, int timing);$/;"	p	class:itpp::Spread_2d	access:public	signature:(const cvec &rec_signal, cvec &out, int timing)
itpp::Spread_2d::get_codeI	/usr/include/itpp/comm/spread.h	/^  vec get_codeI();$/;"	p	class:itpp::Spread_2d	access:public	signature:()
itpp::Spread_2d::get_codeQ	/usr/include/itpp/comm/spread.h	/^  vec get_codeQ();$/;"	p	class:itpp::Spread_2d	access:public	signature:()
itpp::Spread_2d::get_period	/usr/include/itpp/comm/spread.h	/^  short get_period() { return spreadI.get_period(); }$/;"	f	class:itpp::Spread_2d	access:public	signature:()
itpp::Spread_2d::set_code	/usr/include/itpp/comm/spread.h	/^  void set_code(const vec &incodeI, const vec &incodeQ);$/;"	p	class:itpp::Spread_2d	access:public	signature:(const vec &incodeI, const vec &incodeQ)
itpp::Spread_2d::spread	/usr/include/itpp/comm/spread.h	/^  cvec spread(const cvec &symbols) { cvec out; spread(symbols, out); return out; }$/;"	f	class:itpp::Spread_2d	access:public	signature:(const cvec &symbols)
itpp::Spread_2d::spread	/usr/include/itpp/comm/spread.h	/^  void spread(const cvec &symbols, cvec &out);$/;"	p	class:itpp::Spread_2d	access:public	signature:(const cvec &symbols, cvec &out)
itpp::Spread_2d::spreadI	/usr/include/itpp/comm/spread.h	/^  Spread_1d spreadI, spreadQ;$/;"	m	class:itpp::Spread_2d	access:protected
itpp::Spread_2d::spreadQ	/usr/include/itpp/comm/spread.h	/^  Spread_1d spreadI, spreadQ;$/;"	m	class:itpp::Spread_2d	access:protected
itpp::Square_Source	/usr/include/itpp/signal/source.h	/^class Square_Source$/;"	c	namespace:itpp
itpp::Square_Source::A	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Square_Source	access:private
itpp::Square_Source::Square_Source	/usr/include/itpp/signal/source.h	/^  Square_Source(double freq, double mean = 0.0, double ampl = 1.0, double inphase = 0.0);$/;"	p	class:itpp::Square_Source	access:public	signature:(double freq, double mean = 0.0, double ampl = 1.0, double inphase = 0.0)
itpp::Square_Source::dtheta	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Square_Source	access:private
itpp::Square_Source::m	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Square_Source	access:private
itpp::Square_Source::operator ()	/usr/include/itpp/signal/source.h	/^  double operator()() { return sample(); }$/;"	f	class:itpp::Square_Source	access:public	signature:()
itpp::Square_Source::operator ()	/usr/include/itpp/signal/source.h	/^  mat operator()(int h, int w);$/;"	p	class:itpp::Square_Source	access:public	signature:(int h, int w)
itpp::Square_Source::operator ()	/usr/include/itpp/signal/source.h	/^  vec operator()(int n);$/;"	p	class:itpp::Square_Source	access:public	signature:(int n)
itpp::Square_Source::sample	/usr/include/itpp/signal/source.h	/^  double sample();$/;"	p	class:itpp::Square_Source	access:private	signature:()
itpp::Square_Source::theta	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Square_Source	access:private
itpp::Stack	/usr/include/itpp/base/stack.h	/^class Stack$/;"	c	namespace:itpp
itpp::Stack::Stack	/usr/include/itpp/base/stack.h	/^  Stack();$/;"	p	class:itpp::Stack	access:public	signature:()
itpp::Stack::Stack	/usr/include/itpp/base/stack.h	/^  Stack(const Stack<T> &s);$/;"	p	class:itpp::Stack	access:public	signature:(const Stack<T> &s)
itpp::Stack::Stack	/usr/include/itpp/base/stack.h	/^  Stack(int n);$/;"	p	class:itpp::Stack	access:public	signature:(int n)
itpp::Stack::Stack	/usr/include/itpp/base/stack.h	/^Stack<T>::Stack()$/;"	f	class:itpp::Stack	signature:()
itpp::Stack::Stack	/usr/include/itpp/base/stack.h	/^Stack<T>::Stack(const Stack<T> &s)$/;"	f	class:itpp::Stack	signature:(const Stack<T> &s)
itpp::Stack::Stack	/usr/include/itpp/base/stack.h	/^Stack<T>::Stack(int n)$/;"	f	class:itpp::Stack	signature:(int n)
itpp::Stack::alloc	/usr/include/itpp/base/stack.h	/^  void alloc(int n);$/;"	p	class:itpp::Stack	access:private	signature:(int n)
itpp::Stack::alloc	/usr/include/itpp/base/stack.h	/^void Stack<T>::alloc(int n)$/;"	f	class:itpp::Stack	signature:(int n)
itpp::Stack::clear	/usr/include/itpp/base/stack.h	/^  void clear();$/;"	p	class:itpp::Stack	access:public	signature:()
itpp::Stack::clear	/usr/include/itpp/base/stack.h	/^void Stack<T>::clear()$/;"	f	class:itpp::Stack	signature:()
itpp::Stack::data	/usr/include/itpp/base/stack.h	/^  T *data;$/;"	m	class:itpp::Stack	access:private
itpp::Stack::free	/usr/include/itpp/base/stack.h	/^  void free();$/;"	p	class:itpp::Stack	access:private	signature:()
itpp::Stack::free	/usr/include/itpp/base/stack.h	/^void Stack<T>::free()$/;"	f	class:itpp::Stack	signature:()
itpp::Stack::ndata	/usr/include/itpp/base/stack.h	/^  int ndata;$/;"	m	class:itpp::Stack	access:private
itpp::Stack::no_elements	/usr/include/itpp/base/stack.h	/^  int no_elements() const { return valptr; }$/;"	f	class:itpp::Stack	access:public	signature:() const
itpp::Stack::operator =	/usr/include/itpp/base/stack.h	/^  void operator=(const Stack<T> &s);$/;"	p	class:itpp::Stack	access:public	signature:(const Stack<T> &s)
itpp::Stack::operator =	/usr/include/itpp/base/stack.h	/^void Stack<T>::operator=(const Stack<T> &s)$/;"	f	class:itpp::Stack	signature:(const Stack<T> &s)
itpp::Stack::peek	/usr/include/itpp/base/stack.h	/^  T peek() const;$/;"	p	class:itpp::Stack	access:public	signature:() const
itpp::Stack::peek	/usr/include/itpp/base/stack.h	/^T Stack<T>::peek() const$/;"	f	class:itpp::Stack	signature:() const
itpp::Stack::pop	/usr/include/itpp/base/stack.h	/^  T pop();$/;"	p	class:itpp::Stack	access:public	signature:()
itpp::Stack::pop	/usr/include/itpp/base/stack.h	/^T Stack<T>::pop()$/;"	f	class:itpp::Stack	signature:()
itpp::Stack::push	/usr/include/itpp/base/stack.h	/^  void push(T v);$/;"	p	class:itpp::Stack	access:public	signature:(T v)
itpp::Stack::push	/usr/include/itpp/base/stack.h	/^void Stack<T>::push(T v)$/;"	f	class:itpp::Stack	signature:(T v)
itpp::Stack::set_size	/usr/include/itpp/base/stack.h	/^  void set_size(int n, bool copy = false);$/;"	p	class:itpp::Stack	access:public	signature:(int n, bool copy = false)
itpp::Stack::set_size	/usr/include/itpp/base/stack.h	/^void Stack<T>::set_size(int sz, bool copy)$/;"	f	class:itpp::Stack	signature:(int sz, bool copy)
itpp::Stack::size	/usr/include/itpp/base/stack.h	/^  int size() const { return ndata; }$/;"	f	class:itpp::Stack	access:public	signature:() const
itpp::Stack::valptr	/usr/include/itpp/base/stack.h	/^  int valptr;$/;"	m	class:itpp::Stack	access:private
itpp::Stack::~Stack	/usr/include/itpp/base/stack.h	/^  virtual ~Stack();$/;"	p	class:itpp::Stack	access:public	signature:()
itpp::Stack::~Stack	/usr/include/itpp/base/stack.h	/^Stack<T>::~Stack()$/;"	f	class:itpp::Stack	signature:()
itpp::Stat	/usr/include/itpp/stat/misc_stat.h	/^class Stat$/;"	c	namespace:itpp
itpp::Stat::Stat	/usr/include/itpp/stat/misc_stat.h	/^  Stat() {clear();}$/;"	f	class:itpp::Stat	access:public	signature:()
itpp::Stat::_max	/usr/include/itpp/stat/misc_stat.h	/^  double _max;$/;"	m	class:itpp::Stat	access:protected
itpp::Stat::_min	/usr/include/itpp/stat/misc_stat.h	/^  double _min;$/;"	m	class:itpp::Stat	access:protected
itpp::Stat::_n_overflows	/usr/include/itpp/stat/misc_stat.h	/^  int _n_overflows;$/;"	m	class:itpp::Stat	access:protected
itpp::Stat::_n_samples	/usr/include/itpp/stat/misc_stat.h	/^  int _n_samples;$/;"	m	class:itpp::Stat	access:protected
itpp::Stat::_n_zeros	/usr/include/itpp/stat/misc_stat.h	/^  int _n_zeros;$/;"	m	class:itpp::Stat	access:protected
itpp::Stat::_sqr_sum	/usr/include/itpp/stat/misc_stat.h	/^  double _sqr_sum;$/;"	m	class:itpp::Stat	access:protected
itpp::Stat::_sum	/usr/include/itpp/stat/misc_stat.h	/^  double _sum;$/;"	m	class:itpp::Stat	access:protected
itpp::Stat::avg	/usr/include/itpp/stat/misc_stat.h	/^  double avg() const {return _sum \/ _n_samples;}$/;"	f	class:itpp::Stat	access:public	signature:() const
itpp::Stat::clear	/usr/include/itpp/stat/misc_stat.h	/^  virtual void clear() {$/;"	f	class:itpp::Stat	access:public	signature:()
itpp::Stat::histogram	/usr/include/itpp/stat/misc_stat.h	/^  vec histogram() const {return vec(0);}$/;"	f	class:itpp::Stat	access:public	signature:() const
itpp::Stat::max	/usr/include/itpp/stat/misc_stat.h	/^  double max() const {return _max;}$/;"	f	class:itpp::Stat	access:public	signature:() const
itpp::Stat::min	/usr/include/itpp/stat/misc_stat.h	/^  double min() const {return _min;}$/;"	f	class:itpp::Stat	access:public	signature:() const
itpp::Stat::n_overflows	/usr/include/itpp/stat/misc_stat.h	/^  int n_overflows() const {return _n_overflows;}$/;"	f	class:itpp::Stat	access:public	signature:() const
itpp::Stat::n_samples	/usr/include/itpp/stat/misc_stat.h	/^  int n_samples() const {return _n_samples;}$/;"	f	class:itpp::Stat	access:public	signature:() const
itpp::Stat::n_zeros	/usr/include/itpp/stat/misc_stat.h	/^  int n_zeros() const {return _n_zeros;}$/;"	f	class:itpp::Stat	access:public	signature:() const
itpp::Stat::sample	/usr/include/itpp/stat/misc_stat.h	/^  virtual void sample(const double s, const bool overflow = false) {$/;"	f	class:itpp::Stat	access:public	signature:(const double s, const bool overflow = false)
itpp::Stat::sigma	/usr/include/itpp/stat/misc_stat.h	/^  double sigma() const {$/;"	f	class:itpp::Stat	access:public	signature:() const
itpp::Stat::sqr_sum	/usr/include/itpp/stat/misc_stat.h	/^  double sqr_sum() const {return _sqr_sum;}$/;"	f	class:itpp::Stat	access:public	signature:() const
itpp::Stat::sum	/usr/include/itpp/stat/misc_stat.h	/^  double sum() const {return _sum;}$/;"	f	class:itpp::Stat	access:public	signature:() const
itpp::Stat::~Stat	/usr/include/itpp/stat/misc_stat.h	/^  virtual ~Stat() {}$/;"	f	class:itpp::Stat	access:public	signature:()
itpp::Static	/usr/include/itpp/comm/channel.h	/^enum FADING_TYPE { Independent, Static, Correlated };$/;"	e	enum:itpp::FADING_TYPE
itpp::Static_Fading_Generator	/usr/include/itpp/comm/channel.h	/^class Static_Fading_Generator : public Fading_Generator$/;"	c	namespace:itpp	inherits:Fading_Generator
itpp::Static_Fading_Generator::Static_Fading_Generator	/usr/include/itpp/comm/channel.h	/^  Static_Fading_Generator() : Fading_Generator() {}$/;"	f	class:itpp::Static_Fading_Generator	access:public	signature:()
itpp::Static_Fading_Generator::generate	/usr/include/itpp/comm/channel.h	/^  virtual void generate(int no_samples, cvec& output);$/;"	p	class:itpp::Static_Fading_Generator	access:public	signature:(int no_samples, cvec& output)
itpp::Static_Fading_Generator::init	/usr/include/itpp/comm/channel.h	/^  virtual void init();$/;"	p	class:itpp::Static_Fading_Generator	access:public	signature:()
itpp::Static_Fading_Generator::static_sample	/usr/include/itpp/comm/channel.h	/^  std::complex<double> static_sample;$/;"	m	class:itpp::Static_Fading_Generator	access:protected
itpp::Static_Fading_Generator::~Static_Fading_Generator	/usr/include/itpp/comm/channel.h	/^  virtual ~Static_Fading_Generator() {}$/;"	f	class:itpp::Static_Fading_Generator	access:public	signature:()
itpp::TC	/usr/include/itpp/fixed/fix_base.h	/^  TC,                 \/\/!< Two's complement$/;"	e	enum:itpp::e_mode
itpp::TCP_Client_Application	/usr/include/itpp/protocol/tcp_client_server.h	/^class TCP_Client_Application$/;"	c	namespace:itpp
itpp::TCP_Client_Application::TCP_Client_Application	/usr/include/itpp/protocol/tcp_client_server.h	/^  TCP_Client_Application(TCP_Sender *tcp_snd_p, TCP_Receiver *tcp_recv_p) {$/;"	f	class:itpp::TCP_Client_Application	access:public	signature:(TCP_Sender *tcp_snd_p, TCP_Receiver *tcp_recv_p)
itpp::TCP_Client_Application::TCP_Client_Application::received_packet_indication	/usr/include/itpp/protocol/tcp_client_server.h	/^  void TCP_Client_Application::received_packet_indication(int label) {$/;"	f	class:itpp::TCP_Client_Application::TCP_Client_Application	access:private	signature:(int label)
itpp::TCP_Client_Application::TCP_Client_Application::save_to_file	/usr/include/itpp/protocol/tcp_client_server.h	/^  void TCP_Client_Application::save_to_file(string file) {$/;"	f	class:itpp::TCP_Client_Application::TCP_Client_Application	access:private	signature:(string file)
itpp::TCP_Client_Application::nbr_bytes_received	/usr/include/itpp/protocol/tcp_client_server.h	/^  unsigned nbr_bytes_received;$/;"	m	class:itpp::TCP_Client_Application	access:private
itpp::TCP_Client_Application::nbr_bytes_to_receive	/usr/include/itpp/protocol/tcp_client_server.h	/^  unsigned nbr_bytes_to_receive;$/;"	m	class:itpp::TCP_Client_Application	access:private
itpp::TCP_Client_Application::read_from_net	/usr/include/itpp/protocol/tcp_client_server.h	/^  void read_from_net(unsigned byte_size) {$/;"	f	class:itpp::TCP_Client_Application	access:public	signature:(unsigned byte_size)
itpp::TCP_Client_Application::select	/usr/include/itpp/protocol/tcp_client_server.h	/^  Slot<TCP_Client_Application, int> select;$/;"	m	class:itpp::TCP_Client_Application	access:public
itpp::TCP_Client_Application::seq_num_index	/usr/include/itpp/protocol/tcp_client_server.h	/^  int seq_num_index;$/;"	m	class:itpp::TCP_Client_Application	access:private
itpp::TCP_Client_Application::seq_num_time	/usr/include/itpp/protocol/tcp_client_server.h	/^  vec seq_num_time;$/;"	m	class:itpp::TCP_Client_Application	access:private
itpp::TCP_Client_Application::seq_num_val	/usr/include/itpp/protocol/tcp_client_server.h	/^  vec seq_num_val;$/;"	m	class:itpp::TCP_Client_Application	access:private
itpp::TCP_Client_Application::tcp_receiver_p	/usr/include/itpp/protocol/tcp_client_server.h	/^  TCP_Receiver *tcp_receiver_p;$/;"	m	class:itpp::TCP_Client_Application	access:private
itpp::TCP_Client_Application::tcp_sender_p	/usr/include/itpp/protocol/tcp_client_server.h	/^  TCP_Sender *tcp_sender_p;$/;"	m	class:itpp::TCP_Client_Application	access:private
itpp::TCP_Client_Application::~TCP_Client_Application	/usr/include/itpp/protocol/tcp_client_server.h	/^  ~TCP_Client_Application() { }$/;"	f	class:itpp::TCP_Client_Application	access:public	signature:()
itpp::TCP_Packet	/usr/include/itpp/protocol/tcp.h	/^class TCP_Packet : public itpp::Packet$/;"	c	namespace:itpp	inherits:itpp::Packet
itpp::TCP_Packet::TCP_Packet	/usr/include/itpp/protocol/tcp.h	/^  TCP_Packet();$/;"	p	class:itpp::TCP_Packet	access:public	signature:()
itpp::TCP_Packet::TCP_Packet	/usr/include/itpp/protocol/tcp.h	/^  TCP_Packet(const TCP_Packet &packet);$/;"	p	class:itpp::TCP_Packet	access:public	signature:(const TCP_Packet &packet)
itpp::TCP_Packet::TDebugInfo	/usr/include/itpp/protocol/tcp.h	/^  struct TDebugInfo {$/;"	s	class:itpp::TCP_Packet	access:protected
itpp::TCP_Packet::TDebugInfo::fCWnd	/usr/include/itpp/protocol/tcp.h	/^    unsigned   fCWnd; \/\/!< ADD DOCUMENTATION HERE$/;"	m	struct:itpp::TCP_Packet::TDebugInfo	access:public
itpp::TCP_Packet::TDebugInfo::fRTTEstimate	/usr/include/itpp/protocol/tcp.h	/^    double     fRTTEstimate; \/\/!< ADD DOCUMENTATION HERE$/;"	m	struct:itpp::TCP_Packet::TDebugInfo	access:public
itpp::TCP_Packet::TDebugInfo::fRecWnd	/usr/include/itpp/protocol/tcp.h	/^    unsigned   fRecWnd; \/\/!< ADD DOCUMENTATION HERE$/;"	m	struct:itpp::TCP_Packet::TDebugInfo	access:public
itpp::TCP_Packet::TDebugInfo::fRtxFlag	/usr/include/itpp/protocol/tcp.h	/^    bool   fRtxFlag; \/\/!< ADD DOCUMENTATION HERE$/;"	m	struct:itpp::TCP_Packet::TDebugInfo	access:public
itpp::TCP_Packet::TDebugInfo::fSSThresh	/usr/include/itpp/protocol/tcp.h	/^    unsigned   fSSThresh; \/\/!< ADD DOCUMENTATION HERE$/;"	m	struct:itpp::TCP_Packet::TDebugInfo	access:public
itpp::TCP_Packet::TDebugInfo::fSndNxt	/usr/include/itpp/protocol/tcp.h	/^    Sequence_Number   fSndNxt; \/\/!< ADD DOCUMENTATION HERE$/;"	m	struct:itpp::TCP_Packet::TDebugInfo	access:public
itpp::TCP_Packet::TDebugInfo::fSndUna	/usr/include/itpp/protocol/tcp.h	/^    Sequence_Number   fSndUna; \/\/!< ADD DOCUMENTATION HERE$/;"	m	struct:itpp::TCP_Packet::TDebugInfo	access:public
itpp::TCP_Packet::clone	/usr/include/itpp/protocol/tcp.h	/^  virtual TCP_Packet &clone() const;$/;"	p	class:itpp::TCP_Packet	access:public	signature:() const
itpp::TCP_Packet::fACK	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number   fACK;           \/**< \\brief acknowledgment (next expected sn) *\/$/;"	m	class:itpp::TCP_Packet	access:protected
itpp::TCP_Packet::fDestinationPort	/usr/include/itpp/protocol/tcp.h	/^  unsigned             fDestinationPort;$/;"	m	class:itpp::TCP_Packet	access:protected
itpp::TCP_Packet::fInfo	/usr/include/itpp/protocol/tcp.h	/^  TDebugInfo  *fInfo;$/;"	m	class:itpp::TCP_Packet	access:protected
itpp::TCP_Packet::fSegment	/usr/include/itpp/protocol/tcp.h	/^  TCP_Segment   fSegment;     \/**< \\brief data segment to be transmitted *\/$/;"	m	class:itpp::TCP_Packet	access:protected
itpp::TCP_Packet::fSessionId	/usr/include/itpp/protocol/tcp.h	/^  int    fSessionId;     \/**< \\brief session identifier *\/$/;"	m	class:itpp::TCP_Packet	access:protected
itpp::TCP_Packet::fSourcePort	/usr/include/itpp/protocol/tcp.h	/^  unsigned             fSourcePort;$/;"	m	class:itpp::TCP_Packet	access:protected
itpp::TCP_Packet::fWnd	/usr/include/itpp/protocol/tcp.h	/^  unsigned         fWnd;           \/**< \\brief window size (advertised by receiver) *\/$/;"	m	class:itpp::TCP_Packet	access:protected
itpp::TCP_Packet::get_ACK	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number get_ACK() const { return fACK; }$/;"	f	class:itpp::TCP_Packet	access:public	signature:() const
itpp::TCP_Packet::get_destination_port	/usr/include/itpp/protocol/tcp.h	/^  unsigned get_destination_port() const { return fDestinationPort; }$/;"	f	class:itpp::TCP_Packet	access:public	signature:() const
itpp::TCP_Packet::get_segment	/usr/include/itpp/protocol/tcp.h	/^  TCP_Segment get_segment() const { return fSegment; }$/;"	f	class:itpp::TCP_Packet	access:public	signature:() const
itpp::TCP_Packet::get_session_id	/usr/include/itpp/protocol/tcp.h	/^  int get_session_id() const {  return fSessionId; }$/;"	f	class:itpp::TCP_Packet	access:public	signature:() const
itpp::TCP_Packet::get_source_port	/usr/include/itpp/protocol/tcp.h	/^  unsigned get_source_port() const { return fSourcePort; }$/;"	f	class:itpp::TCP_Packet	access:public	signature:() const
itpp::TCP_Packet::get_wnd	/usr/include/itpp/protocol/tcp.h	/^  unsigned get_wnd() const { return fWnd; }$/;"	f	class:itpp::TCP_Packet	access:public	signature:() const
itpp::TCP_Packet::operator <<	/usr/include/itpp/protocol/tcp.h	/^  friend std::ostream & operator<<(std::ostream &, TCP_Packet &);$/;"	p	class:itpp::TCP_Packet	access:friend	signature:(std::ostream &, TCP_Packet &)
itpp::TCP_Packet::print_header	/usr/include/itpp/protocol/tcp.h	/^  virtual void print_header(std::ostream &) const;$/;"	p	class:itpp::TCP_Packet	access:public	signature:(std::ostream &) const
itpp::TCP_Packet::set_ACK	/usr/include/itpp/protocol/tcp.h	/^  void set_ACK(Sequence_Number val) { fACK = val; }$/;"	f	class:itpp::TCP_Packet	access:public	signature:(Sequence_Number val)
itpp::TCP_Packet::set_destination_port	/usr/include/itpp/protocol/tcp.h	/^  void set_destination_port(unsigned val) { fDestinationPort = val; }$/;"	f	class:itpp::TCP_Packet	access:public	signature:(unsigned val)
itpp::TCP_Packet::set_info	/usr/include/itpp/protocol/tcp.h	/^  void set_info(unsigned ssThresh, unsigned recWnd, unsigned cWnd, double estRTT, Sequence_Number sndUna, Sequence_Number sndNxt, bool isRtx);$/;"	p	class:itpp::TCP_Packet	access:public	signature:(unsigned ssThresh, unsigned recWnd, unsigned cWnd, double estRTT, Sequence_Number sndUna, Sequence_Number sndNxt, bool isRtx)
itpp::TCP_Packet::set_segment	/usr/include/itpp/protocol/tcp.h	/^  void set_segment(const TCP_Segment &seg) {  fSegment = seg; }$/;"	f	class:itpp::TCP_Packet	access:public	signature:(const TCP_Segment &seg)
itpp::TCP_Packet::set_session_id	/usr/include/itpp/protocol/tcp.h	/^  void set_session_id(int val) { fSessionId = val; }$/;"	f	class:itpp::TCP_Packet	access:public	signature:(int val)
itpp::TCP_Packet::set_source_port	/usr/include/itpp/protocol/tcp.h	/^  void set_source_port(unsigned val) { fSourcePort = val; }$/;"	f	class:itpp::TCP_Packet	access:public	signature:(unsigned val)
itpp::TCP_Packet::set_wnd	/usr/include/itpp/protocol/tcp.h	/^  void set_wnd(unsigned val) { fWnd = val; }$/;"	f	class:itpp::TCP_Packet	access:public	signature:(unsigned val)
itpp::TCP_Packet::~TCP_Packet	/usr/include/itpp/protocol/tcp.h	/^  virtual ~TCP_Packet();$/;"	p	class:itpp::TCP_Packet	access:public	signature:()
itpp::TCP_Receiver	/usr/include/itpp/protocol/tcp.h	/^class TCP_Receiver$/;"	c	namespace:itpp
itpp::TCP_Receiver::DelayedACKHandler	/usr/include/itpp/protocol/tcp.h	/^  virtual void DelayedACKHandler(Ttype);    \/**< \\brief  handler for delayed ACK timer *\/$/;"	p	class:itpp::TCP_Receiver	access:private	signature:(Ttype)
itpp::TCP_Receiver::GenerateFilename	/usr/include/itpp/protocol/tcp.h	/^  virtual std::string GenerateFilename();$/;"	p	class:itpp::TCP_Receiver	access:private	signature:()
itpp::TCP_Receiver::HandleEndOfProcessing	/usr/include/itpp/protocol/tcp.h	/^  virtual void HandleEndOfProcessing(Ttype); \/**< \\brief  handler for user msg proc. *\/$/;"	p	class:itpp::TCP_Receiver	access:private	signature:(Ttype)
itpp::TCP_Receiver::IndicateUserMessage	/usr/include/itpp/protocol/tcp.h	/^  void IndicateUserMessage(); \/**< \\brief indicate new data to higher layer *\/$/;"	p	class:itpp::TCP_Receiver	access:private	signature:()
itpp::TCP_Receiver::PeriodicACKHandler	/usr/include/itpp/protocol/tcp.h	/^  virtual void PeriodicACKHandler(Ttype);   \/**< \\brief  handler for periodic ACK timer *\/$/;"	p	class:itpp::TCP_Receiver	access:private	signature:(Ttype)
itpp::TCP_Receiver::ReceiveDataPacket	/usr/include/itpp/protocol/tcp.h	/^  virtual void ReceiveDataPacket(TCP_Packet & packet); \/**< \\brief  receive TCP packet *\/$/;"	p	class:itpp::TCP_Receiver	access:private	signature:(TCP_Packet & packet)
itpp::TCP_Receiver::ReceiveMessageFromNet	/usr/include/itpp/protocol/tcp.h	/^  virtual void ReceiveMessageFromNet(itpp::Packet* msg); \/**< \\brief  receive from network *\/$/;"	p	class:itpp::TCP_Receiver	access:private	signature:(itpp::Packet* msg)
itpp::TCP_Receiver::ScheduleACKMessage	/usr/include/itpp/protocol/tcp.h	/^  virtual void ScheduleACKMessage(); \/**< \\brief  prepare ACK message for sending *\/$/;"	p	class:itpp::TCP_Receiver	access:private	signature:()
itpp::TCP_Receiver::SendACK	/usr/include/itpp/protocol/tcp.h	/^  virtual void SendACK(bool);        \/**< \\brief  send an ACK if necessary or enforced *\/$/;"	p	class:itpp::TCP_Receiver	access:private	signature:(bool)
itpp::TCP_Receiver::SendACKMessage	/usr/include/itpp/protocol/tcp.h	/^  virtual void SendACKMessage(Ttype); \/**< \\brief  called by ACK scheduling timer *\/$/;"	p	class:itpp::TCP_Receiver	access:private	signature:(Ttype)
itpp::TCP_Receiver::TCP_Receiver	/usr/include/itpp/protocol/tcp.h	/^  TCP_Receiver(int label);$/;"	p	class:itpp::TCP_Receiver	access:public	signature:(int label)
itpp::TCP_Receiver::TraceReceivedSeqNo	/usr/include/itpp/protocol/tcp.h	/^  virtual void TraceReceivedSeqNo(const Sequence_Number &sn);$/;"	p	class:itpp::TCP_Receiver	access:private	signature:(const Sequence_Number &sn)
itpp::TCP_Receiver::fACKDelayTime	/usr/include/itpp/protocol/tcp.h	/^  Ttype  fACKDelayTime;       \/**< \\brief maximum time for delaying ACKs *\/$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::fACKOnBufferRead	/usr/include/itpp/protocol/tcp.h	/^  bool  fACKOnBufferRead;    \/**< \\brief send ACK when segment is read by user *\/$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::fACKOnBufferWrite	/usr/include/itpp/protocol/tcp.h	/^  bool  fACKOnBufferWrite;   \/**< \\brief send ACK after segment has been written *\/$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::fACKSchedulingDelay	/usr/include/itpp/protocol/tcp.h	/^  Ttype  fACKSchedulingDelay; \/**< \\brief ACK delay due to proc. scheduling *\/$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::fACKSchedulingTimer	/usr/include/itpp/protocol/tcp.h	/^  TTimer<TCP_Receiver> fACKSchedulingTimer;$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::fAdvRcvNxt	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number fAdvRcvNxt;       \/**< \\brief advertised next expected byte (ACK) *\/$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::fAdvRcvWnd	/usr/include/itpp/protocol/tcp.h	/^  unsigned        fAdvRcvWnd;       \/**< \\brief advertised receiver window *\/$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::fBufferSize	/usr/include/itpp/protocol/tcp.h	/^  unsigned  fBufferSize;       \/**< \\brief size of receiver buffer *\/$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::fDebug	/usr/include/itpp/protocol/tcp.h	/^  bool         fDebug;              \/**< \\brief print additional information *\/$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::fDelayedACK	/usr/include/itpp/protocol/tcp.h	/^  bool         fDelayedACK;         \/**< \\brief if true, use delayed ACK *\/$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::fDelayedACKTimer	/usr/include/itpp/protocol/tcp.h	/^  TTimer<TCP_Receiver> fDelayedACKTimer; \/**< \\brief timer for delayed ACK *\/$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::fLabel	/usr/include/itpp/protocol/tcp.h	/^  unsigned              fLabel;$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::fMSS	/usr/include/itpp/protocol/tcp.h	/^  unsigned     fMSS;            \/**< \\brief maximum segment size *\/$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::fMaxUserBlockSize	/usr/include/itpp/protocol/tcp.h	/^  unsigned  fMaxUserBlockSize;   \/**< \\brief max size of a user read block *\/$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::fMinUserBlockSize	/usr/include/itpp/protocol/tcp.h	/^  unsigned  fMinUserBlockSize;   \/**< \\brief min size of a user read block *\/$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::fPeriodicACKInterval	/usr/include/itpp/protocol/tcp.h	/^  Ttype  fPeriodicACKInterval;\/\/ interval after which an ACK is repeated$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::fPeriodicACKTimer	/usr/include/itpp/protocol/tcp.h	/^  TTimer<TCP_Receiver> fPeriodicACKTimer; \/**< \\brief timer for periodic ACKs *\/$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::fReceiverBuffer	/usr/include/itpp/protocol/tcp.h	/^  TCP_Receiver_Buffer  fReceiverBuffer;$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::fSendPeriodicACKs	/usr/include/itpp/protocol/tcp.h	/^  bool  fSendPeriodicACKs;   \/**< \\brief repeat ACKs if no data has been received *\/$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::fSessionId	/usr/include/itpp/protocol/tcp.h	/^  int fSessionId;  \/**< \\brief increased by 1 on connection release *\/$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::fStrictPeriodicACKs	/usr/include/itpp/protocol/tcp.h	/^  bool  fStrictPeriodicACKs; \/**< \\brief repeat ACKs independent of data received *\/$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::fTCPIPHeaderLength	/usr/include/itpp/protocol/tcp.h	/^  unsigned     fTCPIPHeaderLength;  \/**< \\brief overhead by TCP\/IP headers *\/$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::fTrace	/usr/include/itpp/protocol/tcp.h	/^  bool  fTrace;              \/**< \\brief trace end bytes of received packets *\/$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::fUserBlockProcDelay	/usr/include/itpp/protocol/tcp.h	/^  double  fUserBlockProcDelay; \/**< \\brief time to read data from buffer + forward *\/$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::fUserBlockProcTimer	/usr/include/itpp/protocol/tcp.h	/^  TTimer<TCP_Receiver> fUserBlockProcTimer;$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::fUserMessage	/usr/include/itpp/protocol/tcp.h	/^  Packet * fUserMessage;$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::fWaitingACKMsg	/usr/include/itpp/protocol/tcp.h	/^  TCP_Packet *  fWaitingACKMsg;$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::get_user_message	/usr/include/itpp/protocol/tcp.h	/^  itpp::Packet & get_user_message(); \/**< \\brief called by higher layer *\/$/;"	p	class:itpp::TCP_Receiver	access:public	signature:()
itpp::TCP_Receiver::is_user_message_available	/usr/include/itpp/protocol/tcp.h	/^  bool is_user_message_available(); \/**< \\brief called by higher layer *\/$/;"	p	class:itpp::TCP_Receiver	access:public	signature:()
itpp::TCP_Receiver::received_seq_num_index	/usr/include/itpp/protocol/tcp.h	/^  int received_seq_num_index;$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::received_seq_num_time	/usr/include/itpp/protocol/tcp.h	/^  vec received_seq_num_time;$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::received_seq_num_val	/usr/include/itpp/protocol/tcp.h	/^  ivec received_seq_num_val;$/;"	m	class:itpp::TCP_Receiver	access:private
itpp::TCP_Receiver::release	/usr/include/itpp/protocol/tcp.h	/^  virtual void release(std::string trace_filename = "");$/;"	p	class:itpp::TCP_Receiver	access:public	signature:(std::string trace_filename = Ó)
itpp::TCP_Receiver::save_trace	/usr/include/itpp/protocol/tcp.h	/^  virtual void save_trace(std::string filename);$/;"	p	class:itpp::TCP_Receiver	access:public	signature:(std::string filename)
itpp::TCP_Receiver::set_debug	/usr/include/itpp/protocol/tcp.h	/^  virtual void set_debug(bool enable_debug, bool enable_signal_debug);$/;"	p	class:itpp::TCP_Receiver	access:public	signature:(bool enable_debug, bool enable_signal_debug)
itpp::TCP_Receiver::set_debug	/usr/include/itpp/protocol/tcp.h	/^  virtual void set_debug(const bool enable_debug = true);$/;"	p	class:itpp::TCP_Receiver	access:public	signature:(const bool enable_debug = true)
itpp::TCP_Receiver::set_trace	/usr/include/itpp/protocol/tcp.h	/^  virtual void set_trace(const bool enable_trace = true);$/;"	p	class:itpp::TCP_Receiver	access:public	signature:(const bool enable_trace = true)
itpp::TCP_Receiver::setup	/usr/include/itpp/protocol/tcp.h	/^  virtual void setup();$/;"	p	class:itpp::TCP_Receiver	access:public	signature:()
itpp::TCP_Receiver::tcp_new_data	/usr/include/itpp/protocol/tcp.h	/^  Signal<int> tcp_new_data; \/**< \\brief indicate new data to higher layer *\/$/;"	m	class:itpp::TCP_Receiver	access:public
itpp::TCP_Receiver::tcp_receive	/usr/include/itpp/protocol/tcp.h	/^  Slot<TCP_Receiver, itpp::Packet*> tcp_receive;$/;"	m	class:itpp::TCP_Receiver	access:public
itpp::TCP_Receiver::tcp_release	/usr/include/itpp/protocol/tcp.h	/^  Slot<TCP_Receiver, std::string> tcp_release;$/;"	m	class:itpp::TCP_Receiver	access:public
itpp::TCP_Receiver::tcp_send_ack	/usr/include/itpp/protocol/tcp.h	/^  Signal<itpp::Packet*> tcp_send_ack;$/;"	m	class:itpp::TCP_Receiver	access:public
itpp::TCP_Receiver::~TCP_Receiver	/usr/include/itpp/protocol/tcp.h	/^  virtual ~TCP_Receiver();$/;"	p	class:itpp::TCP_Receiver	access:public	signature:()
itpp::TCP_Receiver_Buffer	/usr/include/itpp/protocol/tcp.h	/^class TCP_Receiver_Buffer$/;"	c	namespace:itpp
itpp::TCP_Receiver_Buffer::TCP_Receiver_Buffer	/usr/include/itpp/protocol/tcp.h	/^  TCP_Receiver_Buffer();$/;"	p	class:itpp::TCP_Receiver_Buffer	access:public	signature:()
itpp::TCP_Receiver_Buffer::TCP_Receiver_Buffer	/usr/include/itpp/protocol/tcp.h	/^  TCP_Receiver_Buffer(const TCP_Receiver_Buffer &);$/;"	p	class:itpp::TCP_Receiver_Buffer	access:public	signature:(const TCP_Receiver_Buffer &)
itpp::TCP_Receiver_Buffer::fBufList	/usr/include/itpp/protocol/tcp.h	/^  std::list <TCP_Segment> fBufList;$/;"	m	class:itpp::TCP_Receiver_Buffer	access:protected
itpp::TCP_Receiver_Buffer::fFirstByte	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number fFirstByte;         \/**< \\brief first byte stored or missing *\/$/;"	m	class:itpp::TCP_Receiver_Buffer	access:protected
itpp::TCP_Receiver_Buffer::first_block_size	/usr/include/itpp/protocol/tcp.h	/^  unsigned first_block_size() const;        \/**< \\brief size of first complete block *\/$/;"	p	class:itpp::TCP_Receiver_Buffer	access:public	signature:() const
itpp::TCP_Receiver_Buffer::first_byte	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number first_byte() const;      \/**< \\brief first byte stored or missing *\/$/;"	p	class:itpp::TCP_Receiver_Buffer	access:public	signature:() const
itpp::TCP_Receiver_Buffer::first_byte	/usr/include/itpp/protocol/tcp.h	/^inline Sequence_Number TCP_Receiver_Buffer::first_byte() const$/;"	f	class:itpp::TCP_Receiver_Buffer	signature:() const
itpp::TCP_Receiver_Buffer::info	/usr/include/itpp/protocol/tcp.h	/^  std::ostream &info(std::ostream &os, int detail = 0) const; \/**< \\brief print info *\/$/;"	p	class:itpp::TCP_Receiver_Buffer	access:public	signature:(std::ostream &os, int detail = 0) const
itpp::TCP_Receiver_Buffer::last_byte	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number last_byte() const;       \/**< \\brief highest byte received (+1) *\/$/;"	p	class:itpp::TCP_Receiver_Buffer	access:public	signature:() const
itpp::TCP_Receiver_Buffer::last_byte	/usr/include/itpp/protocol/tcp.h	/^inline Sequence_Number TCP_Receiver_Buffer::last_byte() const$/;"	f	class:itpp::TCP_Receiver_Buffer	signature:() const
itpp::TCP_Receiver_Buffer::next_expected	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number next_expected() const;   \/**< \\brief first byte missing *\/$/;"	p	class:itpp::TCP_Receiver_Buffer	access:public	signature:() const
itpp::TCP_Receiver_Buffer::next_expected	/usr/include/itpp/protocol/tcp.h	/^inline Sequence_Number TCP_Receiver_Buffer::next_expected() const$/;"	f	class:itpp::TCP_Receiver_Buffer	signature:() const
itpp::TCP_Receiver_Buffer::read	/usr/include/itpp/protocol/tcp.h	/^  void read(unsigned noOfBytes); \/**< \\brief read up to "noOfBytes" bytes from queue *\/$/;"	p	class:itpp::TCP_Receiver_Buffer	access:public	signature:(unsigned noOfBytes)
itpp::TCP_Receiver_Buffer::reset	/usr/include/itpp/protocol/tcp.h	/^  void reset(); \/**< \\brief clears internal list structure *\/$/;"	p	class:itpp::TCP_Receiver_Buffer	access:public	signature:()
itpp::TCP_Receiver_Buffer::window	/usr/include/itpp/protocol/tcp.h	/^  unsigned window() const;$/;"	p	class:itpp::TCP_Receiver_Buffer	access:public	signature:() const
itpp::TCP_Receiver_Buffer::write	/usr/include/itpp/protocol/tcp.h	/^  void write(TCP_Segment newBlock);  \/**< \\brief add segment to the queue *\/$/;"	p	class:itpp::TCP_Receiver_Buffer	access:public	signature:(TCP_Segment newBlock)
itpp::TCP_Receiver_Buffer::~TCP_Receiver_Buffer	/usr/include/itpp/protocol/tcp.h	/^  ~TCP_Receiver_Buffer();$/;"	p	class:itpp::TCP_Receiver_Buffer	access:public	signature:()
itpp::TCP_Segment	/usr/include/itpp/protocol/tcp.h	/^class TCP_Segment$/;"	c	namespace:itpp
itpp::TCP_Segment::TCP_Segment	/usr/include/itpp/protocol/tcp.h	/^  TCP_Segment();$/;"	p	class:itpp::TCP_Segment	access:public	signature:()
itpp::TCP_Segment::TCP_Segment	/usr/include/itpp/protocol/tcp.h	/^  TCP_Segment(const Sequence_Number &sn_begin, const Sequence_Number &sn_end);$/;"	p	class:itpp::TCP_Segment	access:public	signature:(const Sequence_Number &sn_begin, const Sequence_Number &sn_end)
itpp::TCP_Segment::TCP_Segment	/usr/include/itpp/protocol/tcp.h	/^  TCP_Segment(const TCP_Segment &segment);$/;"	p	class:itpp::TCP_Segment	access:public	signature:(const TCP_Segment &segment)
itpp::TCP_Segment::begin	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number begin() const { return seq_begin; }$/;"	f	class:itpp::TCP_Segment	access:public	signature:() const
itpp::TCP_Segment::can_be_combined	/usr/include/itpp/protocol/tcp.h	/^  bool can_be_combined(const TCP_Segment &segment) const;$/;"	p	class:itpp::TCP_Segment	access:public	signature:(const TCP_Segment &segment) const
itpp::TCP_Segment::can_be_combined	/usr/include/itpp/protocol/tcp.h	/^inline bool TCP_Segment::can_be_combined(const TCP_Segment &segment) const$/;"	f	class:itpp::TCP_Segment	signature:(const TCP_Segment &segment) const
itpp::TCP_Segment::combine	/usr/include/itpp/protocol/tcp.h	/^  void combine(const TCP_Segment &segment);$/;"	p	class:itpp::TCP_Segment	access:public	signature:(const TCP_Segment &segment)
itpp::TCP_Segment::end	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number end() const { return seq_end; }$/;"	f	class:itpp::TCP_Segment	access:public	signature:() const
itpp::TCP_Segment::is_contained	/usr/include/itpp/protocol/tcp.h	/^  bool is_contained(const TCP_Segment &segment) const;$/;"	p	class:itpp::TCP_Segment	access:public	signature:(const TCP_Segment &segment) const
itpp::TCP_Segment::is_contained	/usr/include/itpp/protocol/tcp.h	/^inline bool TCP_Segment::is_contained(const TCP_Segment &segment) const$/;"	f	class:itpp::TCP_Segment	signature:(const TCP_Segment &segment) const
itpp::TCP_Segment::length	/usr/include/itpp/protocol/tcp.h	/^  unsigned length() const;$/;"	p	class:itpp::TCP_Segment	access:public	signature:() const
itpp::TCP_Segment::length	/usr/include/itpp/protocol/tcp.h	/^inline unsigned TCP_Segment::length() const$/;"	f	class:itpp::TCP_Segment	signature:() const
itpp::TCP_Segment::operator !=	/usr/include/itpp/protocol/tcp.h	/^  bool operator!=(const TCP_Segment &segment) const;$/;"	p	class:itpp::TCP_Segment	access:public	signature:(const TCP_Segment &segment) const
itpp::TCP_Segment::operator !=	/usr/include/itpp/protocol/tcp.h	/^inline bool TCP_Segment::operator!=(const TCP_Segment &segment) const$/;"	f	class:itpp::TCP_Segment	signature:(const TCP_Segment &segment) const
itpp::TCP_Segment::operator <<	/usr/include/itpp/protocol/tcp.h	/^  friend std::ostream & operator<<(std::ostream &os, const TCP_Segment &segment);$/;"	p	class:itpp::TCP_Segment	access:friend	signature:(std::ostream &os, const TCP_Segment &segment)
itpp::TCP_Segment::operator =	/usr/include/itpp/protocol/tcp.h	/^  TCP_Segment &operator=(const TCP_Segment &segment);$/;"	p	class:itpp::TCP_Segment	access:public	signature:(const TCP_Segment &segment)
itpp::TCP_Segment::operator ==	/usr/include/itpp/protocol/tcp.h	/^  bool operator==(const TCP_Segment &segment) const;$/;"	p	class:itpp::TCP_Segment	access:public	signature:(const TCP_Segment &segment) const
itpp::TCP_Segment::operator ==	/usr/include/itpp/protocol/tcp.h	/^inline bool TCP_Segment::operator==(const TCP_Segment &segment) const$/;"	f	class:itpp::TCP_Segment	signature:(const TCP_Segment &segment) const
itpp::TCP_Segment::seq_begin	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number  seq_begin; \/**< \\brief no. of first byte of segment *\/$/;"	m	class:itpp::TCP_Segment	access:protected
itpp::TCP_Segment::seq_end	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number  seq_end;   \/**< \\brief no. of last byte of segment + 1 *\/$/;"	m	class:itpp::TCP_Segment	access:protected
itpp::TCP_Segment::set_begin	/usr/include/itpp/protocol/tcp.h	/^  void set_begin(const Sequence_Number &sn);$/;"	p	class:itpp::TCP_Segment	access:public	signature:(const Sequence_Number &sn)
itpp::TCP_Segment::set_begin	/usr/include/itpp/protocol/tcp.h	/^inline void TCP_Segment::set_begin(const Sequence_Number &sn)$/;"	f	class:itpp::TCP_Segment	signature:(const Sequence_Number &sn)
itpp::TCP_Segment::set_end	/usr/include/itpp/protocol/tcp.h	/^  void set_end(const Sequence_Number &sn);$/;"	p	class:itpp::TCP_Segment	access:public	signature:(const Sequence_Number &sn)
itpp::TCP_Segment::set_end	/usr/include/itpp/protocol/tcp.h	/^inline void TCP_Segment::set_end(const Sequence_Number &sn)$/;"	f	class:itpp::TCP_Segment	signature:(const Sequence_Number &sn)
itpp::TCP_Sender	/usr/include/itpp/protocol/tcp.h	/^class TCP_Sender$/;"	c	namespace:itpp
itpp::TCP_Sender::CWnd_index	/usr/include/itpp/protocol/tcp.h	/^  int CWnd_index;$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::CWnd_time	/usr/include/itpp/protocol/tcp.h	/^  vec CWnd_time;$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::CWnd_val	/usr/include/itpp/protocol/tcp.h	/^  vec CWnd_val;$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::CalcRTOValue	/usr/include/itpp/protocol/tcp.h	/^  virtual double CalcRTOValue() const;   \/**< \\brief  value for rtx timer *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:() const
itpp::TCP_Sender::FinishFastRecovery	/usr/include/itpp/protocol/tcp.h	/^  virtual void FinishFastRecovery();       \/**< \\brief  actions at end of fast recovery *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:()
itpp::TCP_Sender::GenerateFilename	/usr/include/itpp/protocol/tcp.h	/^  virtual std::string GenerateFilename();$/;"	p	class:itpp::TCP_Sender	access:private	signature:()
itpp::TCP_Sender::GetNextSegmentSize	/usr/include/itpp/protocol/tcp.h	/^  virtual unsigned GetNextSegmentSize(const Sequence_Number & begin);$/;"	p	class:itpp::TCP_Sender	access:private	signature:(const Sequence_Number & begin)
itpp::TCP_Sender::HandleACK	/usr/include/itpp/protocol/tcp.h	/^  virtual void HandleACK(TCP_Packet &);      \/**< \\brief  process incoming ACK *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:(TCP_Packet &)
itpp::TCP_Sender::HandleRtxTimeout	/usr/include/itpp/protocol/tcp.h	/^  virtual void HandleRtxTimeout(Ttype);       \/**< \\brief  what to do after Timeout *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:(Ttype)
itpp::TCP_Sender::HandleSWSATimeout	/usr/include/itpp/protocol/tcp.h	/^  virtual void HandleSWSATimeout(Ttype);      \/**< \\brief  handler for SWSA\/Nagle timer *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:(Ttype)
itpp::TCP_Sender::HandleUserMessageIndication	/usr/include/itpp/protocol/tcp.h	/^  virtual void HandleUserMessageIndication(itpp::Packet *user_data);$/;"	p	class:itpp::TCP_Sender	access:private	signature:(itpp::Packet *user_data)
itpp::TCP_Sender::IdleCheck	/usr/include/itpp/protocol/tcp.h	/^  virtual void IdleCheck();       \/**< \\brief  check whether SSR after idle is done *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:()
itpp::TCP_Sender::InitStatistics	/usr/include/itpp/protocol/tcp.h	/^  virtual void InitStatistics();       \/**< \\brief  reset statistic counters *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:()
itpp::TCP_Sender::RTTEstimate_index	/usr/include/itpp/protocol/tcp.h	/^  int RTTEstimate_index;$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::RTTEstimate_time	/usr/include/itpp/protocol/tcp.h	/^  vec RTTEstimate_time;$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::RTTEstimate_val	/usr/include/itpp/protocol/tcp.h	/^  vec RTTEstimate_val;$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::RTTsample_index	/usr/include/itpp/protocol/tcp.h	/^  int RTTsample_index;$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::RTTsample_time	/usr/include/itpp/protocol/tcp.h	/^  vec RTTsample_time;$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::RTTsample_val	/usr/include/itpp/protocol/tcp.h	/^  vec RTTsample_val;$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::ReceiveMessageFromNet	/usr/include/itpp/protocol/tcp.h	/^  virtual void ReceiveMessageFromNet(itpp::Packet *msg);$/;"	p	class:itpp::TCP_Sender	access:private	signature:(itpp::Packet *msg)
itpp::TCP_Sender::ReduceSSThresh	/usr/include/itpp/protocol/tcp.h	/^  virtual void ReduceSSThresh();       \/**< \\brief  halving on dup ACK or TO *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:()
itpp::TCP_Sender::SSThresh_index	/usr/include/itpp/protocol/tcp.h	/^  int SSThresh_index;$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::SSThresh_time	/usr/include/itpp/protocol/tcp.h	/^  vec SSThresh_time;$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::SSThresh_val	/usr/include/itpp/protocol/tcp.h	/^  vec SSThresh_val;$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::SendMsg	/usr/include/itpp/protocol/tcp.h	/^  virtual void SendMsg(TCP_Packet & msg);    \/**< \\brief  access to network *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:(TCP_Packet & msg)
itpp::TCP_Sender::SendNewData	/usr/include/itpp/protocol/tcp.h	/^  virtual void SendNewData(bool skipSWSA = false); \/**< \\brief  send new data *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:(bool skipSWSA = false)
itpp::TCP_Sender::SendWindow	/usr/include/itpp/protocol/tcp.h	/^  virtual unsigned SendWindow() const;   \/**< \\brief  min of CWnd, MaxCWnd and RecWnd *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:() const
itpp::TCP_Sender::SetRtxTimer	/usr/include/itpp/protocol/tcp.h	/^  virtual void SetRtxTimer();$/;"	p	class:itpp::TCP_Sender	access:private	signature:()
itpp::TCP_Sender::SocketWriteQueue	/usr/include/itpp/protocol/tcp.h	/^  std::queue<itpp::Packet*> SocketWriteQueue;$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::StopTransientPhase	/usr/include/itpp/protocol/tcp.h	/^  void StopTransientPhase(); \/**< \\brief reset statistic counters *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:()
itpp::TCP_Sender::TCP_Sender	/usr/include/itpp/protocol/tcp.h	/^  TCP_Sender(int label);$/;"	p	class:itpp::TCP_Sender	access:public	signature:(int label)
itpp::TCP_Sender::TraceACKedSeqNo	/usr/include/itpp/protocol/tcp.h	/^  virtual void TraceACKedSeqNo(const Sequence_Number sn);$/;"	p	class:itpp::TCP_Sender	access:private	signature:(const Sequence_Number sn)
itpp::TCP_Sender::TraceCWnd	/usr/include/itpp/protocol/tcp.h	/^  virtual void TraceCWnd();$/;"	p	class:itpp::TCP_Sender	access:private	signature:()
itpp::TCP_Sender::TraceRTTVariables	/usr/include/itpp/protocol/tcp.h	/^  virtual void TraceRTTVariables(double sampleRTT);$/;"	p	class:itpp::TCP_Sender	access:private	signature:(double sampleRTT)
itpp::TCP_Sender::TraceSSThresh	/usr/include/itpp/protocol/tcp.h	/^  virtual void TraceSSThresh();$/;"	p	class:itpp::TCP_Sender	access:private	signature:()
itpp::TCP_Sender::TraceSentSeqNo	/usr/include/itpp/protocol/tcp.h	/^  virtual void TraceSentSeqNo(const Sequence_Number sn);$/;"	p	class:itpp::TCP_Sender	access:private	signature:(const Sequence_Number sn)
itpp::TCP_Sender::UnaRetransmit	/usr/include/itpp/protocol/tcp.h	/^  virtual void UnaRetransmit();       \/**< \\brief  TO or fast retransmit *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:()
itpp::TCP_Sender::UpdateRTTVariables	/usr/include/itpp/protocol/tcp.h	/^  virtual void UpdateRTTVariables(double sampleRTT); \/**< \\brief  evaluate RTT measuremnt *\/$/;"	p	class:itpp::TCP_Sender	access:private	signature:(double sampleRTT)
itpp::TCP_Sender::eTCPVersion	/usr/include/itpp/protocol/tcp.h	/^  enum eTCPVersion {kTahoe, kReno, kNewReno};$/;"	g	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fBackoff	/usr/include/itpp/protocol/tcp.h	/^  int           fBackoff;               \/**< \\brief backoff for rtx timer *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fCWnd	/usr/include/itpp/protocol/tcp.h	/^  unsigned  fCWnd;       \/\/ congestion window$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fCarefulMulFastRtxAvoidance	/usr/include/itpp/protocol/tcp.h	/^  bool  fCarefulMulFastRtxAvoidance; \/**< \\brief see RFC 2582, Section 5 *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fCarefulSSThreshReduction	/usr/include/itpp/protocol/tcp.h	/^  bool  fCarefulSSThreshReduction; \/**< \\brief use min(cwnd, flight size)\/2 *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fDebug	/usr/include/itpp/protocol/tcp.h	/^  bool   fDebug;      \/\/ print additional information to cout$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fDupACKCnt	/usr/include/itpp/protocol/tcp.h	/^  unsigned fDupACKCnt;     \/**< \\brief counter for duplicate ACKs *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fDupACKThreshold	/usr/include/itpp/protocol/tcp.h	/^  unsigned  fDupACKThreshold;   \/**< \\brief duplicate ACK threshold *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fFlightSizeRecovery	/usr/include/itpp/protocol/tcp.h	/^  bool  fFlightSizeRecovery;\/\/ use flight size on fast rec. exit$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fGoBackN	/usr/include/itpp/protocol/tcp.h	/^  bool  fGoBackN;           \/**< \\brief use go-back-N on TO rtx *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fIgnoreDupACKOnTORecovery	/usr/include/itpp/protocol/tcp.h	/^  bool  fIgnoreDupACKOnTORecovery; \/**< \\brief avoid fast rtx during TO recovery *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fImmediateBackoffReset	/usr/include/itpp/protocol/tcp.h	/^  bool  fImmediateBackoffReset; \/**< \\brief reset backoff on first new ACK *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fInitialCWnd	/usr/include/itpp/protocol/tcp.h	/^  unsigned  fInitialCWnd;       \/**< \\brief initial congestion window -> RFC 2581 *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fInitialRTT	/usr/include/itpp/protocol/tcp.h	/^  double       fInitialRTT;        \/**< \\brief RTT assumed before first measurement *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fInitialSSThresh	/usr/include/itpp/protocol/tcp.h	/^  unsigned  fInitialSSThresh;   \/**< \\brief initial ssthresh -> RFC 2581 *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fKarn	/usr/include/itpp/protocol/tcp.h	/^  bool  fKarn;              \/**< \\brief exclude rtx packets from RTTM *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fLabel	/usr/include/itpp/protocol/tcp.h	/^  unsigned fLabel; \/\/ end point identification also used at receiver$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fLastSendTime	/usr/include/itpp/protocol/tcp.h	/^  Ttype   fLastSendTime; \/**< \\brief idle detection for SSR *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fMSS	/usr/include/itpp/protocol/tcp.h	/^  unsigned  fMSS;             \/\/ maximum segment size$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fMaxBackoff	/usr/include/itpp/protocol/tcp.h	/^  unsigned  fMaxBackoff;        \/**< \\brief max value of backoff value (Karn) *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fMaxCWnd	/usr/include/itpp/protocol/tcp.h	/^  unsigned   fMaxCWnd;           \/**< \\brief congestion window boundary *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fMaxRTO	/usr/include/itpp/protocol/tcp.h	/^  double  fMaxRTO;     \/\/ max value of retransmission TO$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fMaxRecWnd	/usr/include/itpp/protocol/tcp.h	/^  unsigned        fMaxRecWnd;        \/**< \\brief maximum observed rec. window *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fNagle	/usr/include/itpp/protocol/tcp.h	/^  bool         fNagle;             \/**< \\brief use Nagle algorithm *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fNumberOfFastRetransmits	/usr/include/itpp/protocol/tcp.h	/^  unsigned long       fNumberOfFastRetransmits;$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fNumberOfIdleTimeouts	/usr/include/itpp/protocol/tcp.h	/^  unsigned long       fNumberOfIdleTimeouts;$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fNumberOfRTTMeasurements	/usr/include/itpp/protocol/tcp.h	/^  unsigned long       fNumberOfRTTMeasurements;$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fNumberOfReceivedACKs	/usr/include/itpp/protocol/tcp.h	/^  unsigned long       fNumberOfReceivedACKs;$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fNumberOfTimeouts	/usr/include/itpp/protocol/tcp.h	/^  unsigned long       fNumberOfTimeouts;$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fPendingBackoffReset	/usr/include/itpp/protocol/tcp.h	/^  bool          fPendingBackoffReset;  \/**< \\brief reset backoff on next new ACK *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fRTTEstimate	/usr/include/itpp/protocol/tcp.h	/^  double          fRTTEstimate;        \/**< \\brief created from SRTT, RTTVar and gran. *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fRTTMByte	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number fRTTMByte;           \/**< \\brief byte for which RTTM is running *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fRTTMPending	/usr/include/itpp/protocol/tcp.h	/^  bool            fRTTMPending;        \/**< \\brief is currently RTTN running? *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fRTTMStartTime	/usr/include/itpp/protocol/tcp.h	/^  double          fRTTMStartTime;      \/**< \\brief beginning of a measurement *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fRTTVar	/usr/include/itpp/protocol/tcp.h	/^  double          fRTTVar;             \/**< \\brief variance of RTT time *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fRecWnd	/usr/include/itpp/protocol/tcp.h	/^  unsigned        fRecWnd;       \/\/ receiver advertised window$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fRecoveryDupACK	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number  fRecoveryDupACK;  \/**< \\brief sndmax on 3rd dup ACK (see RFC 2582) *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fRecoveryTO	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number  fRecoveryTO;  \/**< \\brief sndmax on TO (see RFC 2582) *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fRenoConservation	/usr/include/itpp/protocol/tcp.h	/^  bool  fRenoConservation;  \/**< \\brief use cons. of packets on fast rec. (std.) *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fRestartAfterIdle	/usr/include/itpp/protocol/tcp.h	/^  bool  fRestartAfterIdle;  \/**< \\brief perform SSR after idle period *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fRtxTimer	/usr/include/itpp/protocol/tcp.h	/^  TTimer<TCP_Sender>   fRtxTimer;     \/**< \\brief retransmission timer *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fSRTT	/usr/include/itpp/protocol/tcp.h	/^  double          fSRTT;               \/**< \\brief smoothed mean round trip time *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fSSThresh	/usr/include/itpp/protocol/tcp.h	/^  unsigned  fSSThresh;      \/**< \\brief threshold between slow start and cong. avoid. *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fSWSATimer	/usr/include/itpp/protocol/tcp.h	/^  TTimer<TCP_Sender>   fSWSATimer;    \/**< \\brief SWSA\/Nagle timer *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fSWSATimerValue	/usr/include/itpp/protocol/tcp.h	/^  double       fSWSATimerValue;    \/**< \\brief timer for silly wind. synd. avoidance *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fSessionId	/usr/include/itpp/protocol/tcp.h	/^  int fSessionId;  \/**< \\brief is increased when Release is called *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fSndMax	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number fSndMax;           \/**< \\brief highest byte that has been sent +1 *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fSndNxt	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number fSndNxt;       \/\/ next byte to be sent$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fSndUna	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number fSndUna;       \/\/ lowest unacknowledged sn$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fTCPIPHeaderLength	/usr/include/itpp/protocol/tcp.h	/^  unsigned  fTCPIPHeaderLength; \/**< \\brief additional msg length (normally 40 bytes) *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fTCPVersion	/usr/include/itpp/protocol/tcp.h	/^  eTCPVersion  fTCPVersion;     \/\/ one of Reno, Tahoe, NewReno$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fTimUna	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number      fTimUna;       \/**< \\brief byte rtx timer is running for *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fTimerGranularity	/usr/include/itpp/protocol/tcp.h	/^  double  fTimerGranularity;  \/**< \\brief granularity for rtx\/idle timer values *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fTrace	/usr/include/itpp/protocol/tcp.h	/^  bool   fTrace;      \/\/ store trace info in vectors$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fTraceACKedSeqNo	/usr/include/itpp/protocol/tcp.h	/^  bool  fTraceACKedSeqNo;   \/**< \\brief print trace of received ACKs to cout *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fTraceCWnd	/usr/include/itpp/protocol/tcp.h	/^  bool  fTraceCWnd;     \/\/ print CWnd trace to cout$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fTraceSentSeqNo	/usr/include/itpp/protocol/tcp.h	/^  bool  fTraceSentSeqNo;    \/**< \\brief print trace of sent SNs to cout *\/$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::fUserNxt	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number fUserNxt;       \/\/ next byte to be received from user$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::kNewReno	/usr/include/itpp/protocol/tcp.h	/^  enum eTCPVersion {kTahoe, kReno, kNewReno};$/;"	e	enum:itpp::TCP_Sender::eTCPVersion
itpp::TCP_Sender::kReno	/usr/include/itpp/protocol/tcp.h	/^  enum eTCPVersion {kTahoe, kReno, kNewReno};$/;"	e	enum:itpp::TCP_Sender::eTCPVersion
itpp::TCP_Sender::kTahoe	/usr/include/itpp/protocol/tcp.h	/^  enum eTCPVersion {kTahoe, kReno, kNewReno};$/;"	e	enum:itpp::TCP_Sender::eTCPVersion
itpp::TCP_Sender::print_item	/usr/include/itpp/protocol/tcp.h	/^  virtual void print_item(std::ostream &, const std::string &);$/;"	p	class:itpp::TCP_Sender	access:public	signature:(std::ostream &, const std::string &)
itpp::TCP_Sender::release	/usr/include/itpp/protocol/tcp.h	/^  virtual void release(std::string trace_filename = "");$/;"	p	class:itpp::TCP_Sender	access:public	signature:(std::string trace_filename = Ó)
itpp::TCP_Sender::save_trace	/usr/include/itpp/protocol/tcp.h	/^  virtual void save_trace(std::string filename);$/;"	p	class:itpp::TCP_Sender	access:public	signature:(std::string filename)
itpp::TCP_Sender::sender_recv_ack_seq_num_index	/usr/include/itpp/protocol/tcp.h	/^  int sender_recv_ack_seq_num_index;$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::sender_recv_ack_seq_num_time	/usr/include/itpp/protocol/tcp.h	/^  vec sender_recv_ack_seq_num_time;$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::sender_recv_ack_seq_num_val	/usr/include/itpp/protocol/tcp.h	/^  ivec sender_recv_ack_seq_num_val;$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::sent_seq_num_index	/usr/include/itpp/protocol/tcp.h	/^  int sent_seq_num_index;$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::sent_seq_num_time	/usr/include/itpp/protocol/tcp.h	/^  vec sent_seq_num_time;$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::sent_seq_num_val	/usr/include/itpp/protocol/tcp.h	/^  ivec sent_seq_num_val;$/;"	m	class:itpp::TCP_Sender	access:private
itpp::TCP_Sender::set_debug	/usr/include/itpp/protocol/tcp.h	/^  virtual void set_debug(bool enable_debug, bool enable_signal_debug);$/;"	p	class:itpp::TCP_Sender	access:public	signature:(bool enable_debug, bool enable_signal_debug)
itpp::TCP_Sender::set_debug	/usr/include/itpp/protocol/tcp.h	/^  virtual void set_debug(const bool enable_debug = true);$/;"	p	class:itpp::TCP_Sender	access:public	signature:(const bool enable_debug = true)
itpp::TCP_Sender::set_label	/usr/include/itpp/protocol/tcp.h	/^  virtual void set_label(int label);$/;"	p	class:itpp::TCP_Sender	access:private	signature:(int label)
itpp::TCP_Sender::set_trace	/usr/include/itpp/protocol/tcp.h	/^  virtual void set_trace(const bool enable_trace = true);$/;"	p	class:itpp::TCP_Sender	access:public	signature:(const bool enable_trace = true)
itpp::TCP_Sender::setup	/usr/include/itpp/protocol/tcp.h	/^  virtual void setup();$/;"	p	class:itpp::TCP_Sender	access:public	signature:()
itpp::TCP_Sender::tcp_receive_ack	/usr/include/itpp/protocol/tcp.h	/^  Slot<TCP_Sender, itpp::Packet*> tcp_receive_ack;$/;"	m	class:itpp::TCP_Sender	access:public
itpp::TCP_Sender::tcp_release	/usr/include/itpp/protocol/tcp.h	/^  Slot<TCP_Sender, std::string> tcp_release;$/;"	m	class:itpp::TCP_Sender	access:public
itpp::TCP_Sender::tcp_send	/usr/include/itpp/protocol/tcp.h	/^  Signal<itpp::Packet*> tcp_send;$/;"	m	class:itpp::TCP_Sender	access:public
itpp::TCP_Sender::tcp_socket_write	/usr/include/itpp/protocol/tcp.h	/^  Slot<TCP_Sender, itpp::Packet*> tcp_socket_write;$/;"	m	class:itpp::TCP_Sender	access:public
itpp::TCP_Sender::~TCP_Sender	/usr/include/itpp/protocol/tcp.h	/^  virtual ~TCP_Sender();$/;"	p	class:itpp::TCP_Sender	access:public	signature:()
itpp::TCP_Server_Application	/usr/include/itpp/protocol/tcp_client_server.h	/^class TCP_Server_Application$/;"	c	namespace:itpp
itpp::TCP_Server_Application::TCP_Server_Application	/usr/include/itpp/protocol/tcp_client_server.h	/^  TCP_Server_Application() {$/;"	f	class:itpp::TCP_Server_Application	access:public	signature:()
itpp::TCP_Server_Application::write	/usr/include/itpp/protocol/tcp_client_server.h	/^  Signal<itpp::Packet*> write;$/;"	m	class:itpp::TCP_Server_Application	access:public
itpp::TCP_Server_Application::write_to_net	/usr/include/itpp/protocol/tcp_client_server.h	/^  void write_to_net(unsigned byte_size, double delta_time) {$/;"	f	class:itpp::TCP_Server_Application	access:public	signature:(unsigned byte_size, double delta_time)
itpp::TCP_Server_Application::~TCP_Server_Application	/usr/include/itpp/protocol/tcp_client_server.h	/^  ~TCP_Server_Application() { }$/;"	f	class:itpp::TCP_Server_Application	access:public	signature:()
itpp::TDL_Channel	/usr/include/itpp/comm/channel.h	/^class TDL_Channel$/;"	c	namespace:itpp
itpp::TDL_Channel::N_taps	/usr/include/itpp/comm/channel.h	/^  int N_taps; \/\/!< Number of taps$/;"	m	class:itpp::TDL_Channel	access:protected
itpp::TDL_Channel::TDL_Channel	/usr/include/itpp/comm/channel.h	/^  TDL_Channel(const Channel_Specification &channel_spec, double sampling_time);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const Channel_Specification &channel_spec, double sampling_time)
itpp::TDL_Channel::TDL_Channel	/usr/include/itpp/comm/channel.h	/^  TDL_Channel(const vec &avg_power_dB = "0", const ivec &delay_prof = "0");$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const vec &avg_power_dB = Ó, const ivec &delay_prof = Ó)
itpp::TDL_Channel::a_prof	/usr/include/itpp/comm/channel.h	/^  vec a_prof; \/\/!< Average amplitude of each tap$/;"	m	class:itpp::TDL_Channel	access:protected
itpp::TDL_Channel::calc_frequency_response	/usr/include/itpp/comm/channel.h	/^  void calc_frequency_response(const Array<cvec> &channel_coeff, Array<cvec> &frequency_response, const int fft_size);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const Array<cvec> &channel_coeff, Array<cvec> &frequency_response, const int fft_size)
itpp::TDL_Channel::calc_frequency_response	/usr/include/itpp/comm/channel.h	/^  void calc_frequency_response(const cmat &channel_coeff, cmat &frequency_response, const int fft_size);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cmat &channel_coeff, cmat &frequency_response, const int fft_size)
itpp::TDL_Channel::calc_impulse_response	/usr/include/itpp/comm/channel.h	/^  void calc_impulse_response(const Array<cvec> &channel_coeff, Array<cvec> &impulse_response);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const Array<cvec> &channel_coeff, Array<cvec> &impulse_response)
itpp::TDL_Channel::calc_mean_excess_delay	/usr/include/itpp/comm/channel.h	/^  double calc_mean_excess_delay() const;$/;"	p	class:itpp::TDL_Channel	access:public	signature:() const
itpp::TDL_Channel::calc_rms_delay_spread	/usr/include/itpp/comm/channel.h	/^  double calc_rms_delay_spread() const;$/;"	p	class:itpp::TDL_Channel	access:public	signature:() const
itpp::TDL_Channel::d_prof	/usr/include/itpp/comm/channel.h	/^  ivec d_prof; \/\/!< Delay in samples for each tap$/;"	m	class:itpp::TDL_Channel	access:protected
itpp::TDL_Channel::discrete_Ts	/usr/include/itpp/comm/channel.h	/^  double discrete_Ts; \/\/!< Sampling time of discretization$/;"	m	class:itpp::TDL_Channel	access:protected
itpp::TDL_Channel::discretize	/usr/include/itpp/comm/channel.h	/^  void discretize(const vec &delay_profile);$/;"	p	class:itpp::TDL_Channel	access:protected	signature:(const vec &delay_profile)
itpp::TDL_Channel::fading_gen	/usr/include/itpp/comm/channel.h	/^  Array<Fading_Generator *> fading_gen; \/\/!< Fading generators for each tap$/;"	m	class:itpp::TDL_Channel	access:protected
itpp::TDL_Channel::fading_type	/usr/include/itpp/comm/channel.h	/^  FADING_TYPE fading_type; \/\/!< Fading type: Independent (default), Static or Correlated$/;"	m	class:itpp::TDL_Channel	access:protected
itpp::TDL_Channel::filter	/usr/include/itpp/comm/channel.h	/^  cvec filter(const cvec &input);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cvec &input)
itpp::TDL_Channel::filter	/usr/include/itpp/comm/channel.h	/^  cvec filter(const cvec &input, Array<cvec> &channel_coeff);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cvec &input, Array<cvec> &channel_coeff)
itpp::TDL_Channel::filter	/usr/include/itpp/comm/channel.h	/^  cvec filter(const cvec &input, cmat &channel_coeff);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cvec &input, cmat &channel_coeff)
itpp::TDL_Channel::filter	/usr/include/itpp/comm/channel.h	/^  void filter(const cvec &input, cvec &output);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cvec &input, cvec &output)
itpp::TDL_Channel::filter	/usr/include/itpp/comm/channel.h	/^  void filter(const cvec &input, cvec &output, Array<cvec> &channel_coeff);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cvec &input, cvec &output, Array<cvec> &channel_coeff)
itpp::TDL_Channel::filter	/usr/include/itpp/comm/channel.h	/^  void filter(const cvec &input, cvec &output, cmat &channel_coeff);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cvec &input, cvec &output, cmat &channel_coeff)
itpp::TDL_Channel::filter_known_channel	/usr/include/itpp/comm/channel.h	/^  void filter_known_channel(const cvec &input, cvec &output, const Array<cvec> &channel_coeff);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cvec &input, cvec &output, const Array<cvec> &channel_coeff)
itpp::TDL_Channel::filter_known_channel	/usr/include/itpp/comm/channel.h	/^  void filter_known_channel(const cvec &input, cvec &output, const cmat &channel_coeff);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cvec &input, cvec &output, const cmat &channel_coeff)
itpp::TDL_Channel::filter_length	/usr/include/itpp/comm/channel.h	/^  int filter_length; \/\/!< Filter length of FIR fading generator$/;"	m	class:itpp::TDL_Channel	access:protected
itpp::TDL_Channel::generate	/usr/include/itpp/comm/channel.h	/^  void generate(int no_samples, Array<cvec> &channel_coeff);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(int no_samples, Array<cvec> &channel_coeff)
itpp::TDL_Channel::generate	/usr/include/itpp/comm/channel.h	/^  void generate(int no_samples, cmat &channel_coeff);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(int no_samples, cmat &channel_coeff)
itpp::TDL_Channel::get_LOS_doppler	/usr/include/itpp/comm/channel.h	/^  double get_LOS_doppler(int tap_number) const { return los_dopp(tap_number); }$/;"	f	class:itpp::TDL_Channel	access:public	signature:(int tap_number) const
itpp::TDL_Channel::get_LOS_doppler	/usr/include/itpp/comm/channel.h	/^  vec get_LOS_doppler() const { return los_dopp; }$/;"	f	class:itpp::TDL_Channel	access:public	signature:() const
itpp::TDL_Channel::get_LOS_power	/usr/include/itpp/comm/channel.h	/^  double get_LOS_power(int tap_number) const { return los_power(tap_number); }$/;"	f	class:itpp::TDL_Channel	access:public	signature:(int tap_number) const
itpp::TDL_Channel::get_LOS_power	/usr/include/itpp/comm/channel.h	/^  vec get_LOS_power() const { return los_power; }$/;"	f	class:itpp::TDL_Channel	access:public	signature:() const
itpp::TDL_Channel::get_avg_power_dB	/usr/include/itpp/comm/channel.h	/^  vec get_avg_power_dB() const;$/;"	p	class:itpp::TDL_Channel	access:public	signature:() const
itpp::TDL_Channel::get_channel_profile	/usr/include/itpp/comm/channel.h	/^  void get_channel_profile(vec &avg_power_dB, ivec &delay_prof) const;$/;"	p	class:itpp::TDL_Channel	access:public	signature:(vec &avg_power_dB, ivec &delay_prof) const
itpp::TDL_Channel::get_correlated_method	/usr/include/itpp/comm/channel.h	/^  CORRELATED_METHOD get_correlated_method() const { return method; }$/;"	f	class:itpp::TDL_Channel	access:public	signature:() const
itpp::TDL_Channel::get_delay_prof	/usr/include/itpp/comm/channel.h	/^  ivec get_delay_prof() const { return d_prof; }$/;"	f	class:itpp::TDL_Channel	access:public	signature:() const
itpp::TDL_Channel::get_fading_type	/usr/include/itpp/comm/channel.h	/^  FADING_TYPE get_fading_type() const { return fading_type; }$/;"	f	class:itpp::TDL_Channel	access:public	signature:() const
itpp::TDL_Channel::get_no_frequencies	/usr/include/itpp/comm/channel.h	/^  int get_no_frequencies() const { return nrof_freq; }$/;"	f	class:itpp::TDL_Channel	access:public	signature:() const
itpp::TDL_Channel::get_norm_doppler	/usr/include/itpp/comm/channel.h	/^  double get_norm_doppler() const { return n_dopp; }$/;"	f	class:itpp::TDL_Channel	access:public	signature:() const
itpp::TDL_Channel::get_sampling_time	/usr/include/itpp/comm/channel.h	/^  double get_sampling_time() const { return discrete_Ts; }$/;"	f	class:itpp::TDL_Channel	access:public	signature:() const
itpp::TDL_Channel::get_time_offset	/usr/include/itpp/comm/channel.h	/^  double get_time_offset() const;$/;"	p	class:itpp::TDL_Channel	access:public	signature:() const
itpp::TDL_Channel::init	/usr/include/itpp/comm/channel.h	/^  void init();$/;"	p	class:itpp::TDL_Channel	access:public	signature:()
itpp::TDL_Channel::init_flag	/usr/include/itpp/comm/channel.h	/^  bool init_flag; \/\/!< Channel ready to produce data$/;"	m	class:itpp::TDL_Channel	access:protected
itpp::TDL_Channel::los_dopp	/usr/include/itpp/comm/channel.h	/^  vec los_dopp; \/\/!< Relative LOS Doppler for each Rice component$/;"	m	class:itpp::TDL_Channel	access:protected
itpp::TDL_Channel::los_power	/usr/include/itpp/comm/channel.h	/^  vec los_power; \/\/!< Relative power for each Rice component$/;"	m	class:itpp::TDL_Channel	access:protected
itpp::TDL_Channel::method	/usr/include/itpp/comm/channel.h	/^  CORRELATED_METHOD method; \/\/!< Correlated fading generation method: Rice_MEDS (default), IFFT or FIR$/;"	m	class:itpp::TDL_Channel	access:protected
itpp::TDL_Channel::n_dopp	/usr/include/itpp/comm/channel.h	/^  double n_dopp; \/\/!< Normalized Doppler of the correlated fading$/;"	m	class:itpp::TDL_Channel	access:protected
itpp::TDL_Channel::nrof_freq	/usr/include/itpp/comm/channel.h	/^  int nrof_freq; \/\/!< Number of sine frequencies in the Rice MEDS fading generator$/;"	m	class:itpp::TDL_Channel	access:protected
itpp::TDL_Channel::operator ()	/usr/include/itpp/comm/channel.h	/^  cvec operator()(const cvec &input);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cvec &input)
itpp::TDL_Channel::operator ()	/usr/include/itpp/comm/channel.h	/^  cvec operator()(const cvec &input, Array<cvec> &channel_coeff);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cvec &input, Array<cvec> &channel_coeff)
itpp::TDL_Channel::operator ()	/usr/include/itpp/comm/channel.h	/^  cvec operator()(const cvec &input, cmat &channel_coeff);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cvec &input, cmat &channel_coeff)
itpp::TDL_Channel::operator ()	/usr/include/itpp/comm/channel.h	/^  void operator()(const cvec &input, cvec &output, Array<cvec> &channel_coeff);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cvec &input, cvec &output, Array<cvec> &channel_coeff)
itpp::TDL_Channel::operator ()	/usr/include/itpp/comm/channel.h	/^  void operator()(const cvec &input, cvec &output, cmat &channel_coeff);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cvec &input, cvec &output, cmat &channel_coeff)
itpp::TDL_Channel::set_LOS	/usr/include/itpp/comm/channel.h	/^  void set_LOS(const vec& relative_power, const vec& relative_doppler = "");$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const vec& relative_power, const vec& relative_doppler = Ó)
itpp::TDL_Channel::set_LOS_doppler	/usr/include/itpp/comm/channel.h	/^  void set_LOS_doppler(const vec& relative_doppler);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const vec& relative_doppler)
itpp::TDL_Channel::set_LOS_power	/usr/include/itpp/comm/channel.h	/^  void set_LOS_power(const vec& relative_power);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const vec& relative_power)
itpp::TDL_Channel::set_channel_profile	/usr/include/itpp/comm/channel.h	/^  void set_channel_profile(const Channel_Specification &channel_spec, double sampling_time);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const Channel_Specification &channel_spec, double sampling_time)
itpp::TDL_Channel::set_channel_profile	/usr/include/itpp/comm/channel.h	/^  void set_channel_profile(const vec &avg_power_dB, const ivec &delay_prof);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const vec &avg_power_dB, const ivec &delay_prof)
itpp::TDL_Channel::set_channel_profile_exponential	/usr/include/itpp/comm/channel.h	/^  void set_channel_profile_exponential(int no_taps);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(int no_taps)
itpp::TDL_Channel::set_channel_profile_uniform	/usr/include/itpp/comm/channel.h	/^  void set_channel_profile_uniform(int no_taps);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(int no_taps)
itpp::TDL_Channel::set_correlated_method	/usr/include/itpp/comm/channel.h	/^  void set_correlated_method(CORRELATED_METHOD method);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(CORRELATED_METHOD method)
itpp::TDL_Channel::set_doppler_spectrum	/usr/include/itpp/comm/channel.h	/^  void set_doppler_spectrum(const DOPPLER_SPECTRUM *tap_spectrum);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const DOPPLER_SPECTRUM *tap_spectrum)
itpp::TDL_Channel::set_doppler_spectrum	/usr/include/itpp/comm/channel.h	/^  void set_doppler_spectrum(int tap_number, DOPPLER_SPECTRUM tap_spectrum);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(int tap_number, DOPPLER_SPECTRUM tap_spectrum)
itpp::TDL_Channel::set_fading_type	/usr/include/itpp/comm/channel.h	/^  void set_fading_type(FADING_TYPE fading_type);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(FADING_TYPE fading_type)
itpp::TDL_Channel::set_filter_length	/usr/include/itpp/comm/channel.h	/^  void set_filter_length(int filter_length);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(int filter_length)
itpp::TDL_Channel::set_no_frequencies	/usr/include/itpp/comm/channel.h	/^  void set_no_frequencies(int no_freq);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(int no_freq)
itpp::TDL_Channel::set_norm_doppler	/usr/include/itpp/comm/channel.h	/^  void set_norm_doppler(double norm_doppler);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(double norm_doppler)
itpp::TDL_Channel::set_time_offset	/usr/include/itpp/comm/channel.h	/^  void set_time_offset(int offset);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(int offset)
itpp::TDL_Channel::shift_time_offset	/usr/include/itpp/comm/channel.h	/^  void shift_time_offset(int no_samples);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(int no_samples)
itpp::TDL_Channel::tap_doppler_spectrum	/usr/include/itpp/comm/channel.h	/^  Array<DOPPLER_SPECTRUM> tap_doppler_spectrum; \/\/!< Doppler spectrum for each tap$/;"	m	class:itpp::TDL_Channel	access:protected
itpp::TDL_Channel::taps	/usr/include/itpp/comm/channel.h	/^  int taps() const { return N_taps; }$/;"	f	class:itpp::TDL_Channel	access:public	signature:() const
itpp::TDL_Channel::~TDL_Channel	/usr/include/itpp/comm/channel.h	/^  virtual ~TDL_Channel();$/;"	p	class:itpp::TDL_Channel	access:public	signature:()
itpp::TRN	/usr/include/itpp/fixed/fix_base.h	/^  TRN,                \/\/!< Truncation$/;"	e	enum:itpp::q_mode
itpp::TRN_ZERO	/usr/include/itpp/fixed/fix_base.h	/^  TRN_ZERO            \/\/!< Truncation to zero$/;"	e	enum:itpp::q_mode
itpp::TTimer	/usr/include/itpp/protocol/signals_slots.h	/^class TTimer$/;"	c	namespace:itpp
itpp::TTimer::ExpirationTime	/usr/include/itpp/protocol/signals_slots.h	/^  Ttype  ExpirationTime() const {$/;"	f	class:itpp::TTimer	access:public	signature:() const
itpp::TTimer::HandleCancelEvent	/usr/include/itpp/protocol/signals_slots.h	/^  virtual void HandleCancelEvent(Ttype) {$/;"	f	class:itpp::TTimer	access:protected	signature:(Ttype)
itpp::TTimer::HandleProcessEvent	/usr/include/itpp/protocol/signals_slots.h	/^  virtual void HandleProcessEvent(Ttype currentTime) {$/;"	f	class:itpp::TTimer	access:protected	signature:(Ttype currentTime)
itpp::TTimer::IsPending	/usr/include/itpp/protocol/signals_slots.h	/^  bool  IsPending() const { return fPending; }$/;"	f	class:itpp::TTimer	access:public	signature:() const
itpp::TTimer::Reset	/usr/include/itpp/protocol/signals_slots.h	/^  void  Reset() {$/;"	f	class:itpp::TTimer	access:public	signature:()
itpp::TTimer::Set	/usr/include/itpp/protocol/signals_slots.h	/^  void  Set(Ttype time, bool relative = true) {$/;"	f	class:itpp::TTimer	access:public	signature:(Ttype time, bool relative = true)
itpp::TTimer::TTimer	/usr/include/itpp/protocol/signals_slots.h	/^  TTimer(THandler & handler, void (THandler::*handlerFunction)(Ttype time)) :$/;"	f	class:itpp::TTimer	access:public	signature:(THandler & handler, void (THandler::*handlerFunction)(Ttype time))
itpp::TTimer::fExpirationTime	/usr/include/itpp/protocol/signals_slots.h	/^  Ttype  fExpirationTime;$/;"	m	class:itpp::TTimer	access:protected
itpp::TTimer::fPending	/usr/include/itpp/protocol/signals_slots.h	/^  bool  fPending;$/;"	m	class:itpp::TTimer	access:protected
itpp::TTimer::registered_handler	/usr/include/itpp/protocol/signals_slots.h	/^  THandler *registered_handler;$/;"	m	class:itpp::TTimer	access:private
itpp::TTimer::registered_handler_function	/usr/include/itpp/protocol/signals_slots.h	/^  void(THandler::*registered_handler_function)(Ttype expiry_time);$/;"	m	class:itpp::TTimer	access:private
itpp::TTimer::signal	/usr/include/itpp/protocol/signals_slots.h	/^  Signal<double> signal;     \/\/ Used internally$/;"	m	class:itpp::TTimer	access:private
itpp::TTimer::slot	/usr/include/itpp/protocol/signals_slots.h	/^  Slot<TTimer, double> slot; \/\/ Used internally$/;"	m	class:itpp::TTimer	access:private
itpp::TTimer::~TTimer	/usr/include/itpp/protocol/signals_slots.h	/^  virtual ~TTimer() {$/;"	f	class:itpp::TTimer	access:public	signature:()
itpp::Tail	/usr/include/itpp/comm/convcode.h	/^enum CONVOLUTIONAL_CODE_METHOD {Trunc, Tail, Tailbite};$/;"	e	enum:itpp::CONVOLUTIONAL_CODE_METHOD
itpp::Tailbite	/usr/include/itpp/comm/convcode.h	/^enum CONVOLUTIONAL_CODE_METHOD {Trunc, Tail, Tailbite};$/;"	e	enum:itpp::CONVOLUTIONAL_CODE_METHOD
itpp::Timer	/usr/include/itpp/base/timing.h	/^class Timer$/;"	c	namespace:itpp
itpp::Timer::Timer	/usr/include/itpp/base/timing.h	/^  Timer();$/;"	p	class:itpp::Timer	access:public	signature:()
itpp::Timer::elapsed_time	/usr/include/itpp/base/timing.h	/^  double elapsed_time;$/;"	m	class:itpp::Timer	access:protected
itpp::Timer::get_current_time	/usr/include/itpp/base/timing.h	/^  virtual double get_current_time() const = 0;$/;"	p	class:itpp::Timer	access:protected	signature:() const
itpp::Timer::get_time	/usr/include/itpp/base/timing.h	/^  double get_time() const;$/;"	p	class:itpp::Timer	access:public	signature:() const
itpp::Timer::reset	/usr/include/itpp/base/timing.h	/^  void reset(double t = 0.0);$/;"	p	class:itpp::Timer	access:public	signature:(double t = 0.0)
itpp::Timer::running	/usr/include/itpp/base/timing.h	/^  bool running;$/;"	m	class:itpp::Timer	access:protected
itpp::Timer::start	/usr/include/itpp/base/timing.h	/^  void start(void);$/;"	p	class:itpp::Timer	access:public	signature:(void)
itpp::Timer::start_time	/usr/include/itpp/base/timing.h	/^  double start_time;$/;"	m	class:itpp::Timer	access:protected
itpp::Timer::stop	/usr/include/itpp/base/timing.h	/^  double stop(void);$/;"	p	class:itpp::Timer	access:public	signature:(void)
itpp::Timer::stop_time	/usr/include/itpp/base/timing.h	/^  double stop_time;$/;"	m	class:itpp::Timer	access:protected
itpp::Timer::tic	/usr/include/itpp/base/timing.h	/^  void tic(void);$/;"	p	class:itpp::Timer	access:public	signature:(void)
itpp::Timer::toc	/usr/include/itpp/base/timing.h	/^  double toc(void);$/;"	p	class:itpp::Timer	access:public	signature:(void)
itpp::Timer::toc_print	/usr/include/itpp/base/timing.h	/^  void toc_print(void);$/;"	p	class:itpp::Timer	access:public	signature:(void)
itpp::Timer::~Timer	/usr/include/itpp/base/timing.h	/^  virtual ~Timer() { }$/;"	f	class:itpp::Timer	access:public	signature:()
itpp::Triangle_Source	/usr/include/itpp/signal/source.h	/^class Triangle_Source$/;"	c	namespace:itpp
itpp::Triangle_Source::A	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Triangle_Source	access:private
itpp::Triangle_Source::Triangle_Source	/usr/include/itpp/signal/source.h	/^  Triangle_Source(double freq, double mean = 0.0, double ampl = 1.0, double inphase = 0.0);$/;"	p	class:itpp::Triangle_Source	access:public	signature:(double freq, double mean = 0.0, double ampl = 1.0, double inphase = 0.0)
itpp::Triangle_Source::dtheta	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Triangle_Source	access:private
itpp::Triangle_Source::m	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Triangle_Source	access:private
itpp::Triangle_Source::operator ()	/usr/include/itpp/signal/source.h	/^  double operator()() { return sample(); }$/;"	f	class:itpp::Triangle_Source	access:public	signature:()
itpp::Triangle_Source::operator ()	/usr/include/itpp/signal/source.h	/^  mat operator()(int h, int w);$/;"	p	class:itpp::Triangle_Source	access:public	signature:(int h, int w)
itpp::Triangle_Source::operator ()	/usr/include/itpp/signal/source.h	/^  vec operator()(int n);$/;"	p	class:itpp::Triangle_Source	access:public	signature:(int n)
itpp::Triangle_Source::sample	/usr/include/itpp/signal/source.h	/^  double sample();$/;"	p	class:itpp::Triangle_Source	access:private	signature:()
itpp::Triangle_Source::theta	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Triangle_Source	access:private
itpp::Trunc	/usr/include/itpp/comm/convcode.h	/^enum CONVOLUTIONAL_CODE_METHOD {Trunc, Tail, Tailbite};$/;"	e	enum:itpp::CONVOLUTIONAL_CODE_METHOD
itpp::Ttype	/usr/include/itpp/protocol/events.h	/^typedef double Ttype; \/\/!< 64-bit floating point time$/;"	t	namespace:itpp
itpp::Turbo_Codec	/usr/include/itpp/comm/turbo.h	/^class Turbo_Codec$/;"	c	namespace:itpp
itpp::Turbo_Codec::Ec	/usr/include/itpp/comm/turbo.h	/^  double Ec, N0, Lc, R, logmax_scale_factor;$/;"	m	class:itpp::Turbo_Codec	access:private
itpp::Turbo_Codec::Lc	/usr/include/itpp/comm/turbo.h	/^  double Ec, N0, Lc, R, logmax_scale_factor;$/;"	m	class:itpp::Turbo_Codec	access:private
itpp::Turbo_Codec::N0	/usr/include/itpp/comm/turbo.h	/^  double Ec, N0, Lc, R, logmax_scale_factor;$/;"	m	class:itpp::Turbo_Codec	access:private
itpp::Turbo_Codec::Ncoded	/usr/include/itpp/comm/turbo.h	/^  int Ncoded, Nuncoded;$/;"	m	class:itpp::Turbo_Codec	access:private
itpp::Turbo_Codec::Nuncoded	/usr/include/itpp/comm/turbo.h	/^  int Ncoded, Nuncoded;$/;"	m	class:itpp::Turbo_Codec	access:private
itpp::Turbo_Codec::R	/usr/include/itpp/comm/turbo.h	/^  double Ec, N0, Lc, R, logmax_scale_factor;$/;"	m	class:itpp::Turbo_Codec	access:private
itpp::Turbo_Codec::Turbo_Codec	/usr/include/itpp/comm/turbo.h	/^  Turbo_Codec(void) {}$/;"	f	class:itpp::Turbo_Codec	access:public	signature:(void)
itpp::Turbo_Codec::adaptive_stop	/usr/include/itpp/comm/turbo.h	/^  bool adaptive_stop;$/;"	m	class:itpp::Turbo_Codec	access:private
itpp::Turbo_Codec::bit_interleaver	/usr/include/itpp/comm/turbo.h	/^  Sequence_Interleaver<bin> bit_interleaver;$/;"	m	class:itpp::Turbo_Codec	access:private
itpp::Turbo_Codec::decode	/usr/include/itpp/comm/turbo.h	/^  virtual void decode(const vec &received_signal, bvec &decoded_bits, const bvec &true_bits = "0");$/;"	p	class:itpp::Turbo_Codec	access:public	signature:(const vec &received_signal, bvec &decoded_bits, const bvec &true_bits = Ó)
itpp::Turbo_Codec::decode	/usr/include/itpp/comm/turbo.h	/^  virtual void decode(const vec &received_signal, bvec &decoded_bits, ivec &nrof_used_iterations,$/;"	p	class:itpp::Turbo_Codec	access:public	signature:(const vec &received_signal, bvec &decoded_bits, ivec &nrof_used_iterations, const bvec &true_bits = Ó)
itpp::Turbo_Codec::decode_block	/usr/include/itpp/comm/turbo.h	/^  virtual void decode_block(const vec &rec_syst1, const vec &rec_syst2, const mat &rec_parity1, const mat &rec_parity2,$/;"	p	class:itpp::Turbo_Codec	access:public	signature:(const vec &rec_syst1, const vec &rec_syst2, const mat &rec_parity1, const mat &rec_parity2, bmat &decoded_bits_i, int &nrof_used_iterations_i, const bvec &true_bits = Ó)
itpp::Turbo_Codec::decode_n3	/usr/include/itpp/comm/turbo.h	/^  void decode_n3(const vec &received_signal, bvec &decoded_bits, ivec &nrof_used_iterations,$/;"	p	class:itpp::Turbo_Codec	access:private	signature:(const vec &received_signal, bvec &decoded_bits, ivec &nrof_used_iterations, const bvec &true_bits = Ó)
itpp::Turbo_Codec::decoded_bits_previous_iteration	/usr/include/itpp/comm/turbo.h	/^  bvec decoded_bits_previous_iteration;$/;"	m	class:itpp::Turbo_Codec	access:private
itpp::Turbo_Codec::encode	/usr/include/itpp/comm/turbo.h	/^  void encode(const bvec &input, bvec &output);$/;"	p	class:itpp::Turbo_Codec	access:public	signature:(const bvec &input, bvec &output)
itpp::Turbo_Codec::encode_block	/usr/include/itpp/comm/turbo.h	/^  void encode_block(const bvec &input, bvec &in1, bvec &in2, bmat &parity1, bmat &parity2);$/;"	p	class:itpp::Turbo_Codec	access:public	signature:(const bvec &input, bvec &in1, bvec &in2, bmat &parity1, bmat &parity2)
itpp::Turbo_Codec::float_interleaver	/usr/include/itpp/comm/turbo.h	/^  Sequence_Interleaver<double> float_interleaver;$/;"	m	class:itpp::Turbo_Codec	access:private
itpp::Turbo_Codec::get_Ncoded	/usr/include/itpp/comm/turbo.h	/^  int get_Ncoded() const { return Ncoded; }$/;"	f	class:itpp::Turbo_Codec	access:public	signature:() const
itpp::Turbo_Codec::get_Nuncoded	/usr/include/itpp/comm/turbo.h	/^  int get_Nuncoded() const { return Nuncoded; }$/;"	f	class:itpp::Turbo_Codec	access:public	signature:() const
itpp::Turbo_Codec::interleaver_size	/usr/include/itpp/comm/turbo.h	/^  int interleaver_size;$/;"	m	class:itpp::Turbo_Codec	access:private
itpp::Turbo_Codec::iterations	/usr/include/itpp/comm/turbo.h	/^  int m_tail, n1, n2, n_tot, iterations;$/;"	m	class:itpp::Turbo_Codec	access:private
itpp::Turbo_Codec::logmax_scale_factor	/usr/include/itpp/comm/turbo.h	/^  double Ec, N0, Lc, R, logmax_scale_factor;$/;"	m	class:itpp::Turbo_Codec	access:private
itpp::Turbo_Codec::m_tail	/usr/include/itpp/comm/turbo.h	/^  int m_tail, n1, n2, n_tot, iterations;$/;"	m	class:itpp::Turbo_Codec	access:private
itpp::Turbo_Codec::metric	/usr/include/itpp/comm/turbo.h	/^  std::string metric;$/;"	m	class:itpp::Turbo_Codec	access:private
itpp::Turbo_Codec::n1	/usr/include/itpp/comm/turbo.h	/^  int m_tail, n1, n2, n_tot, iterations;$/;"	m	class:itpp::Turbo_Codec	access:private
itpp::Turbo_Codec::n2	/usr/include/itpp/comm/turbo.h	/^  int m_tail, n1, n2, n_tot, iterations;$/;"	m	class:itpp::Turbo_Codec	access:private
itpp::Turbo_Codec::n_tot	/usr/include/itpp/comm/turbo.h	/^  int m_tail, n1, n2, n_tot, iterations;$/;"	m	class:itpp::Turbo_Codec	access:private
itpp::Turbo_Codec::rscc1	/usr/include/itpp/comm/turbo.h	/^  Rec_Syst_Conv_Code rscc1, rscc2;$/;"	m	class:itpp::Turbo_Codec	access:private
itpp::Turbo_Codec::rscc2	/usr/include/itpp/comm/turbo.h	/^  Rec_Syst_Conv_Code rscc1, rscc2;$/;"	m	class:itpp::Turbo_Codec	access:private
itpp::Turbo_Codec::set_adaptive_stop	/usr/include/itpp/comm/turbo.h	/^  void set_adaptive_stop(bool in_adaptive_stop = true);$/;"	p	class:itpp::Turbo_Codec	access:public	signature:(bool in_adaptive_stop = true)
itpp::Turbo_Codec::set_awgn_channel_parameters	/usr/include/itpp/comm/turbo.h	/^  void set_awgn_channel_parameters(double in_Ec, double in_N0);$/;"	p	class:itpp::Turbo_Codec	access:public	signature:(double in_Ec, double in_N0)
itpp::Turbo_Codec::set_interleaver	/usr/include/itpp/comm/turbo.h	/^  void set_interleaver(const ivec &interleaver_sequence);$/;"	p	class:itpp::Turbo_Codec	access:public	signature:(const ivec &interleaver_sequence)
itpp::Turbo_Codec::set_iterations	/usr/include/itpp/comm/turbo.h	/^  void set_iterations(int in_iterations = 8);$/;"	p	class:itpp::Turbo_Codec	access:public	signature:(int in_iterations = 8)
itpp::Turbo_Codec::set_metric	/usr/include/itpp/comm/turbo.h	/^  void set_metric(std::string in_metric = "LOGMAX", double in_logmax_scale_factor = 1.0,$/;"	p	class:itpp::Turbo_Codec	access:public	signature:(std::string in_metric = Ó, double in_logmax_scale_factor = 1.0, LLR_calc_unit lcalc = LLR_calc_unit())
itpp::Turbo_Codec::set_parameters	/usr/include/itpp/comm/turbo.h	/^  void set_parameters(ivec gen1, ivec gen2, int constraint_length,$/;"	p	class:itpp::Turbo_Codec	access:public	signature:(ivec gen1, ivec gen2, int constraint_length, const ivec &interleaver_sequence, int in_iterations = 8, std::string in_metric = Ó, double in_logmax_scale_factor = 1.0, bool in_adaptive_stop = false, LLR_calc_unit lcalc = LLR_calc_unit())
itpp::Turbo_Codec::set_scaling_factor	/usr/include/itpp/comm/turbo.h	/^  void set_scaling_factor(double in_Lc);$/;"	p	class:itpp::Turbo_Codec	access:public	signature:(double in_Lc)
itpp::Turbo_Codec::~Turbo_Codec	/usr/include/itpp/comm/turbo.h	/^  virtual ~Turbo_Codec(void) {}$/;"	f	class:itpp::Turbo_Codec	access:public	signature:(void)
itpp::UINT64_POW2	/usr/include/itpp/fixed/fix_base.h	/^const uint64_t UINT64_POW2[64] = {$/;"	m	namespace:itpp
itpp::US	/usr/include/itpp/fixed/fix_base.h	/^  US                  \/\/!< Unsigned$/;"	e	enum:itpp::e_mode
itpp::Uniform_RNG	/usr/include/itpp/base/random.h	/^class Uniform_RNG$/;"	c	namespace:itpp
itpp::Uniform_RNG::RNG	/usr/include/itpp/base/random.h	/^  Random_Generator RNG;$/;"	m	class:itpp::Uniform_RNG	access:private
itpp::Uniform_RNG::Uniform_RNG	/usr/include/itpp/base/random.h	/^  Uniform_RNG(double min = 0, double max = 1.0);$/;"	p	class:itpp::Uniform_RNG	access:public	signature:(double min = 0, double max = 1.0)
itpp::Uniform_RNG::get_setup	/usr/include/itpp/base/random.h	/^  void get_setup(double &min, double &max) const;$/;"	p	class:itpp::Uniform_RNG	access:public	signature:(double &min, double &max) const
itpp::Uniform_RNG::hi_bound	/usr/include/itpp/base/random.h	/^  double lo_bound, hi_bound;$/;"	m	class:itpp::Uniform_RNG	access:private
itpp::Uniform_RNG::lo_bound	/usr/include/itpp/base/random.h	/^  double lo_bound, hi_bound;$/;"	m	class:itpp::Uniform_RNG	access:private
itpp::Uniform_RNG::operator ()	/usr/include/itpp/base/random.h	/^  double operator()() { return (sample() * (hi_bound - lo_bound) + lo_bound); }$/;"	f	class:itpp::Uniform_RNG	access:public	signature:()
itpp::Uniform_RNG::operator ()	/usr/include/itpp/base/random.h	/^  mat operator()(int h, int w) {$/;"	f	class:itpp::Uniform_RNG	access:public	signature:(int h, int w)
itpp::Uniform_RNG::operator ()	/usr/include/itpp/base/random.h	/^  vec operator()(int n) {$/;"	f	class:itpp::Uniform_RNG	access:public	signature:(int n)
itpp::Uniform_RNG::sample	/usr/include/itpp/base/random.h	/^  double sample() {  return RNG.random_01(); }$/;"	f	class:itpp::Uniform_RNG	access:public	signature:()
itpp::Uniform_RNG::sample_matrix	/usr/include/itpp/base/random.h	/^  void sample_matrix(int rows, int cols, mat &out) {$/;"	f	class:itpp::Uniform_RNG	access:public	signature:(int rows, int cols, mat &out)
itpp::Uniform_RNG::sample_vector	/usr/include/itpp/base/random.h	/^  void sample_vector(int size, vec &out) {$/;"	f	class:itpp::Uniform_RNG	access:public	signature:(int size, vec &out)
itpp::Uniform_RNG::setup	/usr/include/itpp/base/random.h	/^  void setup(double min, double max);$/;"	p	class:itpp::Uniform_RNG	access:public	signature:(double min, double max)
itpp::Vec	/usr/include/itpp/base/vec.h	/^class Vec$/;"	c	namespace:itpp
itpp::Vec::H	/usr/include/itpp/base/vec.h	/^  Mat<Num_T> H() const { return this->hermitian_transpose(); }$/;"	f	class:itpp::Vec	access:public	signature:() const
itpp::Vec::T	/usr/include/itpp/base/vec.h	/^  Mat<Num_T> T() const { return this->transpose(); }$/;"	f	class:itpp::Vec	access:public	signature:() const
itpp::Vec::Vec	/usr/include/itpp/base/vec.h	/^  Vec(const Num_T *c_array, int size, const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Vec	access:public	signature:(const Num_T *c_array, int size, const Factory &f = DEFAULT_FACTORY)
itpp::Vec::Vec	/usr/include/itpp/base/vec.h	/^  Vec(const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:public	signature:(const Vec<Num_T> &v)
itpp::Vec::Vec	/usr/include/itpp/base/vec.h	/^  Vec(const Vec<Num_T> &v, const Factory &f);$/;"	p	class:itpp::Vec	access:public	signature:(const Vec<Num_T> &v, const Factory &f)
itpp::Vec::Vec	/usr/include/itpp/base/vec.h	/^  Vec(const char *values, const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Vec	access:public	signature:(const char *values, const Factory &f = DEFAULT_FACTORY)
itpp::Vec::Vec	/usr/include/itpp/base/vec.h	/^  Vec(const std::string &values, const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Vec	access:public	signature:(const std::string &values, const Factory &f = DEFAULT_FACTORY)
itpp::Vec::Vec	/usr/include/itpp/base/vec.h	/^  explicit Vec(const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Vec	access:public	signature:(const Factory &f = DEFAULT_FACTORY)
itpp::Vec::Vec	/usr/include/itpp/base/vec.h	/^  explicit Vec(int size, const Factory &f = DEFAULT_FACTORY);$/;"	p	class:itpp::Vec	access:public	signature:(int size, const Factory &f = DEFAULT_FACTORY)
itpp::Vec::Vec	/usr/include/itpp/base/vec.h	/^Vec<Num_T>::Vec(const Factory &f) : datasize(0), data(0), factory(f) {}$/;"	f	class:itpp::Vec	signature:(const Factory &f)
itpp::Vec::Vec	/usr/include/itpp/base/vec.h	/^Vec<Num_T>::Vec(const Num_T *c_array, int size, const Factory &f) : datasize(0), data(0), factory(f)$/;"	f	class:itpp::Vec	signature:(const Num_T *c_array, int size, const Factory &f)
itpp::Vec::Vec	/usr/include/itpp/base/vec.h	/^Vec<Num_T>::Vec(const Vec<Num_T> &v) : datasize(0), data(0), factory(v.factory)$/;"	f	class:itpp::Vec	signature:(const Vec<Num_T> &v)
itpp::Vec::Vec	/usr/include/itpp/base/vec.h	/^Vec<Num_T>::Vec(const Vec<Num_T> &v, const Factory &f) : datasize(0), data(0), factory(f)$/;"	f	class:itpp::Vec	signature:(const Vec<Num_T> &v, const Factory &f)
itpp::Vec::Vec	/usr/include/itpp/base/vec.h	/^Vec<Num_T>::Vec(const char *values, const Factory &f) : datasize(0), data(0), factory(f)$/;"	f	class:itpp::Vec	signature:(const char *values, const Factory &f)
itpp::Vec::Vec	/usr/include/itpp/base/vec.h	/^Vec<Num_T>::Vec(const std::string &values, const Factory &f) : datasize(0), data(0), factory(f)$/;"	f	class:itpp::Vec	signature:(const std::string &values, const Factory &f)
itpp::Vec::Vec	/usr/include/itpp/base/vec.h	/^Vec<Num_T>::Vec(int size, const Factory &f) : datasize(0), data(0), factory(f)$/;"	f	class:itpp::Vec	signature:(int size, const Factory &f)
itpp::Vec::_data	/usr/include/itpp/base/vec.h	/^  Num_T *_data() { return data; }$/;"	f	class:itpp::Vec	access:public	signature:()
itpp::Vec::_data	/usr/include/itpp/base/vec.h	/^  const Num_T *_data() const { return data; }$/;"	f	class:itpp::Vec	access:public	signature:() const
itpp::Vec::_elem	/usr/include/itpp/base/vec.h	/^  Num_T &_elem(int i) { return data[i]; }$/;"	f	class:itpp::Vec	access:public	signature:(int i)
itpp::Vec::_elem	/usr/include/itpp/base/vec.h	/^  const Num_T &_elem(int i) const { return data[i]; }$/;"	f	class:itpp::Vec	access:public	signature:(int i) const
itpp::Vec::alloc	/usr/include/itpp/base/vec.h	/^  void alloc(int size);$/;"	p	class:itpp::Vec	access:protected	signature:(int size)
itpp::Vec::alloc	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::alloc(int size)$/;"	f	class:itpp::Vec	signature:(int size)
itpp::Vec::clear	/usr/include/itpp/base/vec.h	/^  void clear() { zeros(); }$/;"	f	class:itpp::Vec	access:public	signature:()
itpp::Vec::concat	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> concat<>(Num_T t, const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:friend	signature:(Num_T t, const Vec<Num_T> &v)
itpp::Vec::concat	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> concat<>(const Vec<Num_T> &v, Num_T t);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v, Num_T t)
itpp::Vec::concat	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> concat<>(const Vec<Num_T> &v1, const Vec<Num_T> &v2);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
itpp::Vec::concat	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> concat<>(const Vec<Num_T> &v1, const Vec<Num_T> &v2,$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2, const Vec<Num_T> &v3)
itpp::Vec::concat	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> concat<>(const Vec<Num_T> &v1, const Vec<Num_T> &v2,$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2, const Vec<Num_T> &v3, const Vec<Num_T> &v4)
itpp::Vec::concat	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> concat<>(const Vec<Num_T> &v1, const Vec<Num_T> &v2,$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2, const Vec<Num_T> &v3, const Vec<Num_T> &v4, const Vec<Num_T> &v5)
itpp::Vec::data	/usr/include/itpp/base/vec.h	/^  Num_T *data;$/;"	m	class:itpp::Vec	access:protected
itpp::Vec::datasize	/usr/include/itpp/base/vec.h	/^  int datasize;$/;"	m	class:itpp::Vec	access:protected
itpp::Vec::del	/usr/include/itpp/base/vec.h	/^  void del(int i);$/;"	p	class:itpp::Vec	access:public	signature:(int i)
itpp::Vec::del	/usr/include/itpp/base/vec.h	/^  void del(int i1, int i2);$/;"	p	class:itpp::Vec	access:public	signature:(int i1, int i2)
itpp::Vec::del	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::del(int i1, int i2)$/;"	f	class:itpp::Vec	signature:(int i1, int i2)
itpp::Vec::del	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::del(int index)$/;"	f	class:itpp::Vec	signature:(int index)
itpp::Vec::dot	/usr/include/itpp/base/vec.h	/^  friend Num_T dot<>(const Vec<Num_T> &v1, const Vec<Num_T> &v2);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
itpp::Vec::elem_div	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> elem_div<>(Num_T t, const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:friend	signature:(Num_T t, const Vec<Num_T> &v)
itpp::Vec::elem_div	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> elem_div<>(const Vec<Num_T> &v1, const Vec<Num_T> &v2);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
itpp::Vec::elem_div_out	/usr/include/itpp/base/vec.h	/^  friend void elem_div_out<>(const Vec<Num_T> &v1, const Vec<Num_T> &v2,$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2, Vec<Num_T> &out)
itpp::Vec::elem_div_sum	/usr/include/itpp/base/vec.h	/^  friend Num_T elem_div_sum<>(const Vec<Num_T> &a, const Vec<Num_T> &b);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b)
itpp::Vec::elem_mult	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> elem_mult<>(const Vec<Num_T> &a, const Vec<Num_T> &b);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b)
itpp::Vec::elem_mult	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> elem_mult<>(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, const Vec<Num_T> &c)
itpp::Vec::elem_mult	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> elem_mult<>(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, const Vec<Num_T> &c, const Vec<Num_T> &d)
itpp::Vec::elem_mult_inplace	/usr/include/itpp/base/vec.h	/^  friend void elem_mult_inplace<>(const Vec<Num_T> &a, Vec<Num_T> &b);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &a, Vec<Num_T> &b)
itpp::Vec::elem_mult_out	/usr/include/itpp/base/vec.h	/^  friend void elem_mult_out<>(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, Vec<Num_T> &out)
itpp::Vec::elem_mult_out	/usr/include/itpp/base/vec.h	/^  friend void elem_mult_out<>(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, const Vec<Num_T> &c, Vec<Num_T> &out)
itpp::Vec::elem_mult_out	/usr/include/itpp/base/vec.h	/^  friend void elem_mult_out<>(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, const Vec<Num_T> &c, const Vec<Num_T> &d, Vec<Num_T> &out)
itpp::Vec::elem_mult_sum	/usr/include/itpp/base/vec.h	/^  friend Num_T elem_mult_sum<>(const Vec<Num_T> &a, const Vec<Num_T> &b);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b)
itpp::Vec::factory	/usr/include/itpp/base/vec.h	/^  const Factory &factory;$/;"	m	class:itpp::Vec	access:protected
itpp::Vec::free	/usr/include/itpp/base/vec.h	/^  void free();$/;"	p	class:itpp::Vec	access:protected	signature:()
itpp::Vec::free	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::free()$/;"	f	class:itpp::Vec	signature:()
itpp::Vec::get	/usr/include/itpp/base/vec.h	/^  Vec<Num_T> get(const Vec<bin> &binlist) const;$/;"	p	class:itpp::Vec	access:public	signature:(const Vec<bin> &binlist) const
itpp::Vec::get	/usr/include/itpp/base/vec.h	/^  Vec<Num_T> get(int i1, int i2) const;$/;"	p	class:itpp::Vec	access:public	signature:(int i1, int i2) const
itpp::Vec::get	/usr/include/itpp/base/vec.h	/^  const Num_T &get(int i) const;$/;"	p	class:itpp::Vec	access:public	signature:(int i) const
itpp::Vec::get	/usr/include/itpp/base/vec.h	/^Vec<Num_T> Vec<Num_T>::get(const Vec<bin> &binlist) const$/;"	f	class:itpp::Vec	signature:(const Vec<bin> &binlist) const
itpp::Vec::get	/usr/include/itpp/base/vec.h	/^Vec<Num_T> Vec<Num_T>::get(int i1, int i2) const$/;"	f	class:itpp::Vec	signature:(int i1, int i2) const
itpp::Vec::get	/usr/include/itpp/base/vec.h	/^const Num_T& Vec<Num_T>::get(int i) const$/;"	f	class:itpp::Vec	signature:(int i) const
itpp::Vec::hermitian_transpose	/usr/include/itpp/base/vec.h	/^  Mat<Num_T> hermitian_transpose() const;$/;"	p	class:itpp::Vec	access:public	signature:() const
itpp::Vec::hermitian_transpose	/usr/include/itpp/base/vec.h	/^Mat<Num_T> Vec<Num_T>::hermitian_transpose() const$/;"	f	class:itpp::Vec	signature:() const
itpp::Vec::hermitian_transpose	/usr/include/itpp/base/vec.h	/^Mat<std::complex<double> > Vec<std::complex<double> >::hermitian_transpose() const;$/;"	p	class:itpp::Vec	signature:() const
itpp::Vec::in_range	/usr/include/itpp/base/vec.h	/^  bool in_range(int i) const { return ((i < datasize) && (i >= 0)); }$/;"	f	class:itpp::Vec	access:private	signature:(int i) const
itpp::Vec::ins	/usr/include/itpp/base/vec.h	/^  void ins(int i, Num_T t);$/;"	p	class:itpp::Vec	access:public	signature:(int i, Num_T t)
itpp::Vec::ins	/usr/include/itpp/base/vec.h	/^  void ins(int i, const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:public	signature:(int i, const Vec<Num_T> &v)
itpp::Vec::ins	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::ins(int index, const Num_T t)$/;"	f	class:itpp::Vec	signature:(int index, const Num_T t)
itpp::Vec::ins	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::ins(int index, const Vec<Num_T> &v)$/;"	f	class:itpp::Vec	signature:(int index, const Vec<Num_T> &v)
itpp::Vec::left	/usr/include/itpp/base/vec.h	/^  Vec<Num_T> left(int nr) const;$/;"	p	class:itpp::Vec	access:public	signature:(int nr) const
itpp::Vec::left	/usr/include/itpp/base/vec.h	/^Vec<Num_T> Vec<Num_T>::left(int nr) const$/;"	f	class:itpp::Vec	signature:(int nr) const
itpp::Vec::length	/usr/include/itpp/base/vec.h	/^  int length() const { return datasize; }$/;"	f	class:itpp::Vec	access:public	signature:() const
itpp::Vec::mid	/usr/include/itpp/base/vec.h	/^  Vec<Num_T> mid(int start, int nr) const;$/;"	p	class:itpp::Vec	access:public	signature:(int start, int nr) const
itpp::Vec::mid	/usr/include/itpp/base/vec.h	/^Vec<Num_T> Vec<Num_T>::mid(int start, int nr) const$/;"	f	class:itpp::Vec	signature:(int start, int nr) const
itpp::Vec::ones	/usr/include/itpp/base/vec.h	/^  void ones();$/;"	p	class:itpp::Vec	access:public	signature:()
itpp::Vec::ones	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::ones()$/;"	f	class:itpp::Vec	signature:()
itpp::Vec::operator !=	/usr/include/itpp/base/vec.h	/^  Vec<bin> operator!=(Num_T t) const;$/;"	p	class:itpp::Vec	access:public	signature:(Num_T t) const
itpp::Vec::operator !=	/usr/include/itpp/base/vec.h	/^  bool operator!=(const Vec<Num_T> &v) const;$/;"	p	class:itpp::Vec	access:public	signature:(const Vec<Num_T> &v) const
itpp::Vec::operator !=	/usr/include/itpp/base/vec.h	/^bool Vec<Num_T>::operator!=(const Vec<Num_T> &invector) const$/;"	f	class:itpp::Vec	signature:(const Vec<Num_T> &invector) const
itpp::Vec::operator !=	/usr/include/itpp/base/vec.h	/^bvec Vec<Num_T>::operator!=(Num_T t) const$/;"	f	class:itpp::Vec	signature:(Num_T t) const
itpp::Vec::operator !=	/usr/include/itpp/base/vec.h	/^bvec Vec<std::complex<double> >::operator!=(std::complex<double>) const;$/;"	p	class:itpp::Vec	signature:(std::complex<double>) const
itpp::Vec::operator ()	/usr/include/itpp/base/vec.h	/^  Num_T &operator()(int i);$/;"	p	class:itpp::Vec	access:public	signature:(int i)
itpp::Vec::operator ()	/usr/include/itpp/base/vec.h	/^  const Num_T &operator()(int i) const;$/;"	p	class:itpp::Vec	access:public	signature:(int i) const
itpp::Vec::operator ()	/usr/include/itpp/base/vec.h	/^  const Vec<Num_T> operator()(const Vec<int> &indexlist) const;$/;"	p	class:itpp::Vec	access:public	signature:(const Vec<int> &indexlist) const
itpp::Vec::operator ()	/usr/include/itpp/base/vec.h	/^  const Vec<Num_T> operator()(int i1, int i2) const;$/;"	p	class:itpp::Vec	access:public	signature:(int i1, int i2) const
itpp::Vec::operator ()	/usr/include/itpp/base/vec.h	/^Num_T& Vec<Num_T>::operator()(int i)$/;"	f	class:itpp::Vec	signature:(int i)
itpp::Vec::operator ()	/usr/include/itpp/base/vec.h	/^const Num_T& Vec<Num_T>::operator()(int i) const$/;"	f	class:itpp::Vec	signature:(int i) const
itpp::Vec::operator ()	/usr/include/itpp/base/vec.h	/^const Vec<Num_T> Vec<Num_T>::operator()(const Vec<int> &indexlist) const$/;"	f	class:itpp::Vec	signature:(const Vec<int> &indexlist) const
itpp::Vec::operator ()	/usr/include/itpp/base/vec.h	/^const Vec<Num_T> Vec<Num_T>::operator()(int i1, int i2) const$/;"	f	class:itpp::Vec	signature:(int i1, int i2) const
itpp::Vec::operator *<>	/usr/include/itpp/base/vec.h	/^  friend Num_T operator*<>(const Vec<Num_T> &v1, const Vec<Num_T> &v2);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
itpp::Vec::operator *<>	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> operator*<>(Num_T t, const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:friend	signature:(Num_T t, const Vec<Num_T> &v)
itpp::Vec::operator *<>	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> operator*<>(const Vec<Num_T> &v, Num_T t);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v, Num_T t)
itpp::Vec::operator *=	/usr/include/itpp/base/vec.h	/^  Vec<Num_T>& operator*=(Num_T t);$/;"	p	class:itpp::Vec	access:public	signature:(Num_T t)
itpp::Vec::operator *=	/usr/include/itpp/base/vec.h	/^Vec<Num_T>& Vec<Num_T>::operator*=(Num_T t)$/;"	f	class:itpp::Vec	signature:(Num_T t)
itpp::Vec::operator +<>	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> operator+<>(Num_T t, const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:friend	signature:(Num_T t, const Vec<Num_T> &v)
itpp::Vec::operator +<>	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> operator+<>(const Vec<Num_T> &v, Num_T t);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v, Num_T t)
itpp::Vec::operator +<>	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> operator+<>(const Vec<Num_T> &v1, const Vec<Num_T> &v2);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
itpp::Vec::operator +=	/usr/include/itpp/base/vec.h	/^  Vec<Num_T>& operator+=(Num_T t);$/;"	p	class:itpp::Vec	access:public	signature:(Num_T t)
itpp::Vec::operator +=	/usr/include/itpp/base/vec.h	/^  Vec<Num_T>& operator+=(const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:public	signature:(const Vec<Num_T> &v)
itpp::Vec::operator +=	/usr/include/itpp/base/vec.h	/^Vec<Num_T>& Vec<Num_T>::operator+=(Num_T t)$/;"	f	class:itpp::Vec	signature:(Num_T t)
itpp::Vec::operator +=	/usr/include/itpp/base/vec.h	/^Vec<Num_T>& Vec<Num_T>::operator+=(const Vec<Num_T> &v)$/;"	f	class:itpp::Vec	signature:(const Vec<Num_T> &v)
itpp::Vec::operator -<>	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> operator-<>(Num_T t, const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:friend	signature:(Num_T t, const Vec<Num_T> &v)
itpp::Vec::operator -<>	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> operator-<>(const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v)
itpp::Vec::operator -<>	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> operator-<>(const Vec<Num_T> &v, Num_T t);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v, Num_T t)
itpp::Vec::operator -<>	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> operator-<>(const Vec<Num_T> &v1, const Vec<Num_T> &v2);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
itpp::Vec::operator -=	/usr/include/itpp/base/vec.h	/^  Vec<Num_T>& operator-=(Num_T t);$/;"	p	class:itpp::Vec	access:public	signature:(Num_T t)
itpp::Vec::operator -=	/usr/include/itpp/base/vec.h	/^  Vec<Num_T>& operator-=(const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:public	signature:(const Vec<Num_T> &v)
itpp::Vec::operator -=	/usr/include/itpp/base/vec.h	/^Vec<Num_T>& Vec<Num_T>::operator-=(Num_T t)$/;"	f	class:itpp::Vec	signature:(Num_T t)
itpp::Vec::operator -=	/usr/include/itpp/base/vec.h	/^Vec<Num_T>& Vec<Num_T>::operator-=(const Vec<Num_T> &v)$/;"	f	class:itpp::Vec	signature:(const Vec<Num_T> &v)
itpp::Vec::operator /<>	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> operator\/<>(Num_T t, const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:friend	signature:(Num_T t, const Vec<Num_T> &v)
itpp::Vec::operator /<>	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> operator\/<>(const Vec<Num_T> &v, Num_T t);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v, Num_T t)
itpp::Vec::operator /=	/usr/include/itpp/base/vec.h	/^  Vec<Num_T>& operator\/=(Num_T t);$/;"	p	class:itpp::Vec	access:public	signature:(Num_T t)
itpp::Vec::operator /=	/usr/include/itpp/base/vec.h	/^  Vec<Num_T>& operator\/=(const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:public	signature:(const Vec<Num_T> &v)
itpp::Vec::operator /=	/usr/include/itpp/base/vec.h	/^Vec<Num_T>& Vec<Num_T>::operator\/=(Num_T t)$/;"	f	class:itpp::Vec	signature:(Num_T t)
itpp::Vec::operator /=	/usr/include/itpp/base/vec.h	/^Vec<Num_T>& Vec<Num_T>::operator\/=(const Vec<Num_T> &v)$/;"	f	class:itpp::Vec	signature:(const Vec<Num_T> &v)
itpp::Vec::operator <	/usr/include/itpp/base/vec.h	/^  Vec<bin> operator<(Num_T t) const;$/;"	p	class:itpp::Vec	access:public	signature:(Num_T t) const
itpp::Vec::operator <	/usr/include/itpp/base/vec.h	/^bvec Vec<Num_T>::operator<(Num_T t) const$/;"	f	class:itpp::Vec	signature:(Num_T t) const
itpp::Vec::operator <	/usr/include/itpp/base/vec.h	/^bvec Vec<std::complex<double> >::operator<(std::complex<double>) const;$/;"	p	class:itpp::Vec	signature:(std::complex<double>) const
itpp::Vec::operator <=	/usr/include/itpp/base/vec.h	/^  Vec<bin> operator<=(Num_T t) const;$/;"	p	class:itpp::Vec	access:public	signature:(Num_T t) const
itpp::Vec::operator <=	/usr/include/itpp/base/vec.h	/^bvec Vec<Num_T>::operator<=(Num_T t) const$/;"	f	class:itpp::Vec	signature:(Num_T t) const
itpp::Vec::operator <=	/usr/include/itpp/base/vec.h	/^bvec Vec<std::complex<double> >::operator<=(std::complex<double>) const;$/;"	p	class:itpp::Vec	signature:(std::complex<double>) const
itpp::Vec::operator =	/usr/include/itpp/base/vec.h	/^  Vec<Num_T>& operator=(Num_T t);$/;"	p	class:itpp::Vec	access:public	signature:(Num_T t)
itpp::Vec::operator =	/usr/include/itpp/base/vec.h	/^  Vec<Num_T>& operator=(const Mat<Num_T> &m);$/;"	p	class:itpp::Vec	access:public	signature:(const Mat<Num_T> &m)
itpp::Vec::operator =	/usr/include/itpp/base/vec.h	/^  Vec<Num_T>& operator=(const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:public	signature:(const Vec<Num_T> &v)
itpp::Vec::operator =	/usr/include/itpp/base/vec.h	/^  Vec<Num_T>& operator=(const char *values);$/;"	p	class:itpp::Vec	access:public	signature:(const char *values)
itpp::Vec::operator =	/usr/include/itpp/base/vec.h	/^Vec<Num_T>& Vec<Num_T>::operator=(Num_T t)$/;"	f	class:itpp::Vec	signature:(Num_T t)
itpp::Vec::operator =	/usr/include/itpp/base/vec.h	/^Vec<Num_T>& Vec<Num_T>::operator=(const Mat<Num_T> &m)$/;"	f	class:itpp::Vec	signature:(const Mat<Num_T> &m)
itpp::Vec::operator =	/usr/include/itpp/base/vec.h	/^Vec<Num_T>& Vec<Num_T>::operator=(const Vec<Num_T> &v)$/;"	f	class:itpp::Vec	signature:(const Vec<Num_T> &v)
itpp::Vec::operator =	/usr/include/itpp/base/vec.h	/^Vec<Num_T>& Vec<Num_T>::operator=(const char *values)$/;"	f	class:itpp::Vec	signature:(const char *values)
itpp::Vec::operator ==	/usr/include/itpp/base/vec.h	/^  Vec<bin> operator==(Num_T t) const;$/;"	p	class:itpp::Vec	access:public	signature:(Num_T t) const
itpp::Vec::operator ==	/usr/include/itpp/base/vec.h	/^  bool operator==(const Vec<Num_T> &v) const;$/;"	p	class:itpp::Vec	access:public	signature:(const Vec<Num_T> &v) const
itpp::Vec::operator ==	/usr/include/itpp/base/vec.h	/^bool Vec<Num_T>::operator==(const Vec<Num_T> &invector) const$/;"	f	class:itpp::Vec	signature:(const Vec<Num_T> &invector) const
itpp::Vec::operator ==	/usr/include/itpp/base/vec.h	/^bvec Vec<Num_T>::operator==(Num_T t) const$/;"	f	class:itpp::Vec	signature:(Num_T t) const
itpp::Vec::operator ==	/usr/include/itpp/base/vec.h	/^bvec Vec<std::complex<double> >::operator==(std::complex<double>) const;$/;"	p	class:itpp::Vec	signature:(std::complex<double>) const
itpp::Vec::operator >	/usr/include/itpp/base/vec.h	/^  Vec<bin> operator>(Num_T t) const;$/;"	p	class:itpp::Vec	access:public	signature:(Num_T t) const
itpp::Vec::operator >	/usr/include/itpp/base/vec.h	/^bvec Vec<Num_T>::operator>(Num_T t) const$/;"	f	class:itpp::Vec	signature:(Num_T t) const
itpp::Vec::operator >	/usr/include/itpp/base/vec.h	/^bvec Vec<std::complex<double> >::operator>(std::complex<double>) const;$/;"	p	class:itpp::Vec	signature:(std::complex<double>) const
itpp::Vec::operator >=	/usr/include/itpp/base/vec.h	/^  Vec<bin> operator>=(Num_T t) const;$/;"	p	class:itpp::Vec	access:public	signature:(Num_T t) const
itpp::Vec::operator >=	/usr/include/itpp/base/vec.h	/^bvec Vec<Num_T>::operator>=(Num_T t) const$/;"	f	class:itpp::Vec	signature:(Num_T t) const
itpp::Vec::operator >=	/usr/include/itpp/base/vec.h	/^bvec Vec<std::complex<double> >::operator>=(std::complex<double>) const;$/;"	p	class:itpp::Vec	signature:(std::complex<double>) const
itpp::Vec::operator []	/usr/include/itpp/base/vec.h	/^  Num_T &operator[](int i);$/;"	p	class:itpp::Vec	access:public	signature:(int i)
itpp::Vec::operator []	/usr/include/itpp/base/vec.h	/^  const Num_T &operator[](int i) const;$/;"	p	class:itpp::Vec	access:public	signature:(int i) const
itpp::Vec::operator []	/usr/include/itpp/base/vec.h	/^Num_T& Vec<Num_T>::operator[](int i)$/;"	f	class:itpp::Vec	signature:(int i)
itpp::Vec::operator []	/usr/include/itpp/base/vec.h	/^const Num_T& Vec<Num_T>::operator[](int i) const$/;"	f	class:itpp::Vec	signature:(int i) const
itpp::Vec::outer_product	/usr/include/itpp/base/vec.h	/^  friend Mat<Num_T> outer_product<>(const Vec<Num_T> &v1,$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2, bool hermitian)
itpp::Vec::replace_commas	/usr/include/itpp/base/vec.h	/^  std::string replace_commas(const std::string &str);$/;"	p	class:itpp::Vec	access:private	signature:(const std::string &str)
itpp::Vec::replace_mid	/usr/include/itpp/base/vec.h	/^  void replace_mid(int i, const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:public	signature:(int i, const Vec<Num_T> &v)
itpp::Vec::replace_mid	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::replace_mid(int i, const Vec<Num_T> &v)$/;"	f	class:itpp::Vec	signature:(int i, const Vec<Num_T> &v)
itpp::Vec::right	/usr/include/itpp/base/vec.h	/^  Vec<Num_T> right(int nr) const;$/;"	p	class:itpp::Vec	access:public	signature:(int nr) const
itpp::Vec::right	/usr/include/itpp/base/vec.h	/^Vec<Num_T> Vec<Num_T>::right(int nr) const$/;"	f	class:itpp::Vec	signature:(int nr) const
itpp::Vec::set	/usr/include/itpp/base/vec.h	/^  void set(const char *str);$/;"	p	class:itpp::Vec	access:public	signature:(const char *str)
itpp::Vec::set	/usr/include/itpp/base/vec.h	/^  void set(const std::string &str);$/;"	p	class:itpp::Vec	access:public	signature:(const std::string &str)
itpp::Vec::set	/usr/include/itpp/base/vec.h	/^  void set(int i, Num_T t);$/;"	p	class:itpp::Vec	access:public	signature:(int i, Num_T t)
itpp::Vec::set	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::set(const char *str)$/;"	f	class:itpp::Vec	signature:(const char *str)
itpp::Vec::set	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::set(const std::string &str)$/;"	f	class:itpp::Vec	signature:(const std::string &str)
itpp::Vec::set	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::set(int i, Num_T t)$/;"	f	class:itpp::Vec	signature:(int i, Num_T t)
itpp::Vec::set	/usr/include/itpp/base/vec.h	/^void Vec<bin>::set(const std::string &str);$/;"	p	class:itpp::Vec	signature:(const std::string &str)
itpp::Vec::set	/usr/include/itpp/base/vec.h	/^void Vec<double>::set(const std::string &str);$/;"	p	class:itpp::Vec	signature:(const std::string &str)
itpp::Vec::set	/usr/include/itpp/base/vec.h	/^void Vec<int>::set(const std::string &str);$/;"	p	class:itpp::Vec	signature:(const std::string &str)
itpp::Vec::set	/usr/include/itpp/base/vec.h	/^void Vec<short int>::set(const std::string &str);$/;"	p	class:itpp::Vec	signature:(const std::string &str)
itpp::Vec::set	/usr/include/itpp/base/vec.h	/^void Vec<std::complex<double> >::set(const std::string &str);$/;"	p	class:itpp::Vec	signature:(const std::string &str)
itpp::Vec::set_length	/usr/include/itpp/base/vec.h	/^  void set_length(int size, bool copy = false) { set_size(size, copy); }$/;"	f	class:itpp::Vec	access:public	signature:(int size, bool copy = false)
itpp::Vec::set_size	/usr/include/itpp/base/vec.h	/^  void set_size(int size, bool copy = false);$/;"	p	class:itpp::Vec	access:public	signature:(int size, bool copy = false)
itpp::Vec::set_size	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::set_size(int size, bool copy)$/;"	f	class:itpp::Vec	signature:(int size, bool copy)
itpp::Vec::set_subvector	/usr/include/itpp/base/vec.h	/^  void set_subvector(int i, const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:public	signature:(int i, const Vec<Num_T> &v)
itpp::Vec::set_subvector	/usr/include/itpp/base/vec.h	/^  void set_subvector(int i1, int i2, Num_T t);$/;"	p	class:itpp::Vec	access:public	signature:(int i1, int i2, Num_T t)
itpp::Vec::set_subvector	/usr/include/itpp/base/vec.h	/^  void set_subvector(int i1, int i2, const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:public	signature:(int i1, int i2, const Vec<Num_T> &v)
itpp::Vec::set_subvector	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>:: set_subvector(int i, const Vec<Num_T> &v)$/;"	f	class:itpp::Vec	signature:(int i, const Vec<Num_T> &v)
itpp::Vec::set_subvector	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::set_subvector(int i1, int i2, Num_T t)$/;"	f	class:itpp::Vec	signature:(int i1, int i2, Num_T t)
itpp::Vec::set_subvector	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::set_subvector(int i1, int i2, const Vec<Num_T> &v)$/;"	f	class:itpp::Vec	signature:(int i1, int i2, const Vec<Num_T> &v)
itpp::Vec::shift_left	/usr/include/itpp/base/vec.h	/^  void shift_left(Num_T t, int n = 1);$/;"	p	class:itpp::Vec	access:public	signature:(Num_T t, int n = 1)
itpp::Vec::shift_left	/usr/include/itpp/base/vec.h	/^  void shift_left(const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:public	signature:(const Vec<Num_T> &v)
itpp::Vec::shift_left	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::shift_left(Num_T t, int n)$/;"	f	class:itpp::Vec	signature:(Num_T t, int n)
itpp::Vec::shift_left	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::shift_left(const Vec<Num_T> &v)$/;"	f	class:itpp::Vec	signature:(const Vec<Num_T> &v)
itpp::Vec::shift_right	/usr/include/itpp/base/vec.h	/^  void shift_right(Num_T t, int n = 1);$/;"	p	class:itpp::Vec	access:public	signature:(Num_T t, int n = 1)
itpp::Vec::shift_right	/usr/include/itpp/base/vec.h	/^  void shift_right(const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:public	signature:(const Vec<Num_T> &v)
itpp::Vec::shift_right	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::shift_right(Num_T t, int n)$/;"	f	class:itpp::Vec	signature:(Num_T t, int n)
itpp::Vec::shift_right	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::shift_right(const Vec<Num_T> &v)$/;"	f	class:itpp::Vec	signature:(const Vec<Num_T> &v)
itpp::Vec::size	/usr/include/itpp/base/vec.h	/^  int size() const { return datasize; }$/;"	f	class:itpp::Vec	access:public	signature:() const
itpp::Vec::split	/usr/include/itpp/base/vec.h	/^  Vec<Num_T> split(int pos);$/;"	p	class:itpp::Vec	access:public	signature:(int pos)
itpp::Vec::split	/usr/include/itpp/base/vec.h	/^Vec<Num_T> Vec<Num_T>::split(int pos)$/;"	f	class:itpp::Vec	signature:(int pos)
itpp::Vec::transpose	/usr/include/itpp/base/vec.h	/^  Mat<Num_T> transpose() const;$/;"	p	class:itpp::Vec	access:public	signature:() const
itpp::Vec::transpose	/usr/include/itpp/base/vec.h	/^Mat<Num_T> Vec<Num_T>::transpose() const$/;"	f	class:itpp::Vec	signature:() const
itpp::Vec::value_type	/usr/include/itpp/base/vec.h	/^  typedef Num_T value_type;$/;"	t	class:itpp::Vec	access:public
itpp::Vec::zeros	/usr/include/itpp/base/vec.h	/^  void zeros();$/;"	p	class:itpp::Vec	access:public	signature:()
itpp::Vec::zeros	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::zeros()$/;"	f	class:itpp::Vec	signature:()
itpp::Vec::~Vec	/usr/include/itpp/base/vec.h	/^  ~Vec();$/;"	p	class:itpp::Vec	access:public	signature:()
itpp::Vec::~Vec	/usr/include/itpp/base/vec.h	/^Vec<Num_T>::~Vec()$/;"	f	class:itpp::Vec	signature:()
itpp::Vector_Quantizer	/usr/include/itpp/srccode/vq.h	/^class Vector_Quantizer$/;"	c	namespace:itpp
itpp::Vector_Quantizer::CodeBook	/usr/include/itpp/srccode/vq.h	/^  vec CodeBook;$/;"	m	class:itpp::Vector_Quantizer	access:protected
itpp::Vector_Quantizer::Dim	/usr/include/itpp/srccode/vq.h	/^  int Dim;$/;"	m	class:itpp::Vector_Quantizer	access:protected
itpp::Vector_Quantizer::LatestDist	/usr/include/itpp/srccode/vq.h	/^  double LatestDist;$/;"	m	class:itpp::Vector_Quantizer	access:protected
itpp::Vector_Quantizer::Q	/usr/include/itpp/srccode/vq.h	/^  vec Q(const vec &x);$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:(const vec &x)
itpp::Vector_Quantizer::Q	/usr/include/itpp/srccode/vq.h	/^inline vec Vector_Quantizer::Q(const vec &x) { return decode(encode(x)); }$/;"	f	class:itpp::Vector_Quantizer	signature:(const vec &x)
itpp::Vector_Quantizer::Size	/usr/include/itpp/srccode/vq.h	/^  int Size;$/;"	m	class:itpp::Vector_Quantizer	access:protected
itpp::Vector_Quantizer::Vector_Quantizer	/usr/include/itpp/srccode/vq.h	/^  Vector_Quantizer();$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:()
itpp::Vector_Quantizer::Vector_Quantizer	/usr/include/itpp/srccode/vq.h	/^  Vector_Quantizer(const char *Name);$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:(const char *Name)
itpp::Vector_Quantizer::decode	/usr/include/itpp/srccode/vq.h	/^  Array<vec> decode(const ivec &Index) const;$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:(const ivec &Index) const
itpp::Vector_Quantizer::decode	/usr/include/itpp/srccode/vq.h	/^  vec decode(int Index) const;$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:(int Index) const
itpp::Vector_Quantizer::decode	/usr/include/itpp/srccode/vq.h	/^inline vec Vector_Quantizer::decode(int Index) const { return get_codevector(Index); }$/;"	f	class:itpp::Vector_Quantizer	signature:(int Index) const
itpp::Vector_Quantizer::dim	/usr/include/itpp/srccode/vq.h	/^  int dim() const;$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:() const
itpp::Vector_Quantizer::dim	/usr/include/itpp/srccode/vq.h	/^inline int Vector_Quantizer::dim() const { return Dim; }$/;"	f	class:itpp::Vector_Quantizer	signature:() const
itpp::Vector_Quantizer::encode	/usr/include/itpp/srccode/vq.h	/^  int encode(const vec &x);$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:(const vec &x)
itpp::Vector_Quantizer::encode	/usr/include/itpp/srccode/vq.h	/^  ivec encode(const vec &x, int num);$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:(const vec &x, int num)
itpp::Vector_Quantizer::get_codebook	/usr/include/itpp/srccode/vq.h	/^  mat get_codebook() const;$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:() const
itpp::Vector_Quantizer::get_codevector	/usr/include/itpp/srccode/vq.h	/^  vec get_codevector(int Index) const;$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:(int Index) const
itpp::Vector_Quantizer::latest_distortion	/usr/include/itpp/srccode/vq.h	/^  double latest_distortion();$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:()
itpp::Vector_Quantizer::latest_distortion	/usr/include/itpp/srccode/vq.h	/^inline double Vector_Quantizer::latest_distortion() { return LatestDist; }$/;"	f	class:itpp::Vector_Quantizer	signature:()
itpp::Vector_Quantizer::load	/usr/include/itpp/srccode/vq.h	/^  void load(const char *Name);$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:(const char *Name)
itpp::Vector_Quantizer::modify_codevector	/usr/include/itpp/srccode/vq.h	/^  void modify_codevector(int no, double mul, const vec &add);$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:(int no, double mul, const vec &add)
itpp::Vector_Quantizer::nobits	/usr/include/itpp/srccode/vq.h	/^  int nobits() const;$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:() const
itpp::Vector_Quantizer::nobits	/usr/include/itpp/srccode/vq.h	/^inline int Vector_Quantizer::nobits() const { return levels2bits(Size); }$/;"	f	class:itpp::Vector_Quantizer	signature:() const
itpp::Vector_Quantizer::operator ()	/usr/include/itpp/srccode/vq.h	/^  vec operator()(const vec &x);$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:(const vec &x)
itpp::Vector_Quantizer::operator ()	/usr/include/itpp/srccode/vq.h	/^inline vec Vector_Quantizer::operator()(const vec &x) { return Q(x); }$/;"	f	class:itpp::Vector_Quantizer	signature:(const vec &x)
itpp::Vector_Quantizer::save	/usr/include/itpp/srccode/vq.h	/^  void save(const char *Name) const;$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:(const char *Name) const
itpp::Vector_Quantizer::set_codebook	/usr/include/itpp/srccode/vq.h	/^  void set_codebook(const mat &CB);$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:(const mat &CB)
itpp::Vector_Quantizer::set_codevector	/usr/include/itpp/srccode/vq.h	/^  void set_codevector(int Index, const vec &indata);$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:(int Index, const vec &indata)
itpp::Vector_Quantizer::size	/usr/include/itpp/srccode/vq.h	/^  int size() const;$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:() const
itpp::Vector_Quantizer::size	/usr/include/itpp/srccode/vq.h	/^inline int Vector_Quantizer::size() const { return Size; }$/;"	f	class:itpp::Vector_Quantizer	signature:() const
itpp::WRAP	/usr/include/itpp/fixed/fix_base.h	/^  WRAP,               \/\/!< Wrap-around$/;"	e	enum:itpp::o_mode
itpp::WRAP_SM	/usr/include/itpp/fixed/fix_base.h	/^  WRAP_SM             \/\/!< Sign magnitued wrap-around (Not implemented)$/;"	e	enum:itpp::o_mode
itpp::Weibull_RNG	/usr/include/itpp/base/random.h	/^class Weibull_RNG$/;"	c	namespace:itpp
itpp::Weibull_RNG::RNG	/usr/include/itpp/base/random.h	/^  Random_Generator RNG;$/;"	m	class:itpp::Weibull_RNG	access:private
itpp::Weibull_RNG::Weibull_RNG	/usr/include/itpp/base/random.h	/^  Weibull_RNG(double lambda = 1.0, double beta = 1.0);$/;"	p	class:itpp::Weibull_RNG	access:public	signature:(double lambda = 1.0, double beta = 1.0)
itpp::Weibull_RNG::b	/usr/include/itpp/base/random.h	/^  double l, b;$/;"	m	class:itpp::Weibull_RNG	access:private
itpp::Weibull_RNG::get_setup	/usr/include/itpp/base/random.h	/^  void get_setup(double &lambda, double &beta) { lambda = l; beta = b; }$/;"	f	class:itpp::Weibull_RNG	access:public	signature:(double &lambda, double &beta)
itpp::Weibull_RNG::l	/usr/include/itpp/base/random.h	/^  double l, b;$/;"	m	class:itpp::Weibull_RNG	access:private
itpp::Weibull_RNG::mean	/usr/include/itpp/base/random.h	/^  double mean, var;$/;"	m	class:itpp::Weibull_RNG	access:private
itpp::Weibull_RNG::operator ()	/usr/include/itpp/base/random.h	/^  double operator()() { return sample(); }$/;"	f	class:itpp::Weibull_RNG	access:public	signature:()
itpp::Weibull_RNG::operator ()	/usr/include/itpp/base/random.h	/^  mat operator()(int h, int w);$/;"	p	class:itpp::Weibull_RNG	access:public	signature:(int h, int w)
itpp::Weibull_RNG::operator ()	/usr/include/itpp/base/random.h	/^  vec operator()(int n);$/;"	p	class:itpp::Weibull_RNG	access:public	signature:(int n)
itpp::Weibull_RNG::sample	/usr/include/itpp/base/random.h	/^  double sample() {$/;"	f	class:itpp::Weibull_RNG	access:private	signature:()
itpp::Weibull_RNG::setup	/usr/include/itpp/base/random.h	/^  void setup(double lambda, double beta);$/;"	p	class:itpp::Weibull_RNG	access:public	signature:(double lambda, double beta)
itpp::Weibull_RNG::var	/usr/include/itpp/base/random.h	/^  double mean, var;$/;"	m	class:itpp::Weibull_RNG	access:private
itpp::abs	/usr/include/itpp/base/binary.h	/^inline bin abs(const bin &inbin) { return inbin; }$/;"	f	namespace:itpp	signature:(const bin &inbin)
itpp::abs	/usr/include/itpp/base/math/elem_math.h	/^inline imat abs(const imat &x) { return apply_function<int>(std::abs, x); }$/;"	f	namespace:itpp	signature:(const imat &x)
itpp::abs	/usr/include/itpp/base/math/elem_math.h	/^inline ivec abs(const ivec &x) { return apply_function<int>(std::abs, x); }$/;"	f	namespace:itpp	signature:(const ivec &x)
itpp::abs	/usr/include/itpp/base/math/elem_math.h	/^inline mat abs(const mat &x) { return apply_function<double>(std::fabs, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::abs	/usr/include/itpp/base/math/elem_math.h	/^inline vec abs(const vec &x) { return apply_function<double>(std::fabs, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::abs	/usr/include/itpp/base/math/elem_math.h	/^mat abs(const cmat &x);$/;"	p	namespace:itpp	signature:(const cmat &x)
itpp::abs	/usr/include/itpp/base/math/elem_math.h	/^vec abs(const cvec &x);$/;"	p	namespace:itpp	signature:(const cvec &x)
itpp::abs	/usr/include/itpp/fixed/fix_functions.h	/^Fix abs(const Fix &x);$/;"	p	namespace:itpp	signature:(const Fix &x)
itpp::ac2poly	/usr/include/itpp/srccode/lpcfunc.h	/^vec ac2poly(const vec &ac);$/;"	p	namespace:itpp	signature:(const vec &ac)
itpp::ac2rc	/usr/include/itpp/srccode/lpcfunc.h	/^vec ac2rc(const vec &ac);$/;"	p	namespace:itpp	signature:(const vec &ac)
itpp::acos	/usr/include/itpp/base/math/trig_hyp.h	/^inline mat acos(const mat &x) { return apply_function<double>(std::acos, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::acos	/usr/include/itpp/base/math/trig_hyp.h	/^inline vec acos(const vec &x) { return apply_function<double>(std::acos, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::acosh	/usr/include/itpp/base/math/trig_hyp.h	/^inline mat acosh(const mat &x) { return apply_function<double>(::acosh, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::acosh	/usr/include/itpp/base/math/trig_hyp.h	/^inline vec acosh(const vec &x) { return apply_function<double>(::acosh, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::all	/usr/include/itpp/base/matfunc.h	/^bool all(const bvec &testvec);$/;"	p	namespace:itpp	signature:(const bvec &testvec)
itpp::angle	/usr/include/itpp/base/math/elem_math.h	/^inline mat angle(const cmat &x) { return arg(x); }$/;"	f	namespace:itpp	signature:(const cmat &x)
itpp::angle	/usr/include/itpp/base/math/elem_math.h	/^inline vec angle(const cvec &x) { return arg(x); }$/;"	f	namespace:itpp	signature:(const cvec &x)
itpp::any	/usr/include/itpp/base/matfunc.h	/^bool any(const bvec &testvec);$/;"	p	namespace:itpp	signature:(const bvec &testvec)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template bmat apply_function(bin(*f)(bin), const bmat &m);$/;"	p	namespace:itpp	signature:(bin(f)bin), const bmat &m)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template bmat apply_function(bin(*f)(bin, bin), const bin& x, const bmat &m);$/;"	p	namespace:itpp	signature:(bin(f)bin, bin), const bin& x, const bmat &m)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template bmat apply_function(bin(*f)(bin, bin), const bmat &m, const bin& x);$/;"	p	namespace:itpp	signature:(bin(f)bin, bin), const bmat &m, const bin& x)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template bvec apply_function(bin(*f)(bin), const bvec &v);$/;"	p	namespace:itpp	signature:(bin(f)bin), const bvec &v)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template bvec apply_function(bin(*f)(bin, bin), const bin& x, const bvec &v);$/;"	p	namespace:itpp	signature:(bin(f)bin, bin), const bin& x, const bvec &v)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template bvec apply_function(bin(*f)(bin, bin), const bvec &v, const bin& x);$/;"	p	namespace:itpp	signature:(bin(f)bin, bin), const bvec &v, const bin& x)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template cmat apply_function(std::complex<double> (*f)(const std::complex<double> &),$/;"	p	namespace:itpp	signature:(std::complex<double> (f)const std::complex<double> &), const cmat &m)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template cmat apply_function(std::complex<double> (*f)(const std::complex<double> &,$/;"	p	namespace:itpp	signature:(std::complex<double> (f)const std::complex<double> &, const std::complex<double> &), const cmat &m, const std::complex<double>& x)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template cmat apply_function(std::complex<double> (*f)(const std::complex<double> &,$/;"	p	namespace:itpp	signature:(std::complex<double> (f)const std::complex<double> &, const std::complex<double> &), const std::complex<double>& x, const cmat &m)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template cvec apply_function(std::complex<double> (*f)(const std::complex<double> &),$/;"	p	namespace:itpp	signature:(std::complex<double> (f)const std::complex<double> &), const cvec &v)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template cvec apply_function(std::complex<double> (*f)(const std::complex<double> &,$/;"	p	namespace:itpp	signature:(std::complex<double> (f)const std::complex<double> &, const std::complex<double> &), const cvec &v, const std::complex<double>& x)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template cvec apply_function(std::complex<double> (*f)(const std::complex<double> &,$/;"	p	namespace:itpp	signature:(std::complex<double> (f)const std::complex<double> &, const std::complex<double> &), const std::complex<double>& x, const cvec &v)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template imat apply_function(int (*f)(int), const imat &m);$/;"	p	namespace:itpp	signature:(int (*f)(int), const imat &m)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template imat apply_function(int (*f)(int, int), const imat &m, const int& x);$/;"	p	namespace:itpp	signature:(int (*f)(int, int), const imat &m, const int& x)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template imat apply_function(int (*f)(int, int), const int& x, const imat &m);$/;"	p	namespace:itpp	signature:(int (*f)(int, int), const int& x, const imat &m)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template ivec apply_function(int (*f)(int), const ivec &v);$/;"	p	namespace:itpp	signature:(int (*f)(int), const ivec &v)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template ivec apply_function(int (*f)(int, int), const int& x, const ivec &v);$/;"	p	namespace:itpp	signature:(int (*f)(int, int), const int& x, const ivec &v)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template ivec apply_function(int (*f)(int, int), const ivec &v, const int& x);$/;"	p	namespace:itpp	signature:(int (*f)(int, int), const ivec &v, const int& x)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template mat apply_function(double(*f)(double), const mat &m);$/;"	p	namespace:itpp	signature:(double(*f)(double), const mat &m)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template mat apply_function(double(*f)(double, double), const double& x, const mat &m);$/;"	p	namespace:itpp	signature:(double(*f)(double, double), const double& x, const mat &m)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template mat apply_function(double(*f)(double, double), const mat &m, const double& x);$/;"	p	namespace:itpp	signature:(double(*f)(double, double), const mat &m, const double& x)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template smat apply_function(short(*f)(short), const smat &m);$/;"	p	namespace:itpp	signature:(short(*f)(short), const smat &m)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template smat apply_function(short(*f)(short, short), const short& x, const smat &m);$/;"	p	namespace:itpp	signature:(short(*f)(short, short), const short& x, const smat &m)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template smat apply_function(short(*f)(short, short), const smat &m, const short& x);$/;"	p	namespace:itpp	signature:(short(*f)(short, short), const smat &m, const short& x)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template svec apply_function(short(*f)(short), const svec &v);$/;"	p	namespace:itpp	signature:(short(*f)(short), const svec &v)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template svec apply_function(short(*f)(short, short), const short& x, const svec &v);$/;"	p	namespace:itpp	signature:(short(*f)(short, short), const short& x, const svec &v)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template svec apply_function(short(*f)(short, short), const svec &v, const short& x);$/;"	p	namespace:itpp	signature:(short(*f)(short, short), const svec &v, const short& x)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template vec apply_function(double(*f)(double), const vec &v);$/;"	p	namespace:itpp	signature:(double(*f)(double), const vec &v)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template vec apply_function(double(*f)(double, double), const double& x, const vec &v);$/;"	p	namespace:itpp	signature:(double(*f)(double, double), const double& x, const vec &v)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^extern template vec apply_function(double(*f)(double, double), const vec &v, const double& x);$/;"	p	namespace:itpp	signature:(double(*f)(double, double), const vec &v, const double& x)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^inline Mat<T> apply_function(T(*f)(T), const Mat<T>& m)$/;"	f	namespace:itpp	signature:(T(f)T), const Mat<T>& m)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^inline Mat<T> apply_function(T(*f)(T, T), const Mat<T>& m, const T& x)$/;"	f	namespace:itpp	signature:(T(f)T, T), const Mat<T>& m, const T& x)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^inline Mat<T> apply_function(T(*f)(T, T), const T& x, const Mat<T>& m)$/;"	f	namespace:itpp	signature:(T(f)T, T), const T& x, const Mat<T>& m)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^inline Mat<T> apply_function(T(*f)(const T&), const Mat<T>& m)$/;"	f	namespace:itpp	signature:(T(f)const T&), const Mat<T>& m)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^inline Mat<T> apply_function(T(*f)(const T&, const T&), const Mat<T>& m,$/;"	f	namespace:itpp	signature:(T(f)const T&, const T&), const Mat<T>& m, const T& x)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^inline Mat<T> apply_function(T(*f)(const T&, const T&), const T& x,$/;"	f	namespace:itpp	signature:(T(f)const T&, const T&), const T& x, const Mat<T>& m)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^inline Vec<T> apply_function(T(*f)(T), const Vec<T>& v)$/;"	f	namespace:itpp	signature:(T(f)T), const Vec<T>& v)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^inline Vec<T> apply_function(T(*f)(T, T), const T& x, const Vec<T>& v)$/;"	f	namespace:itpp	signature:(T(f)T, T), const T& x, const Vec<T>& v)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^inline Vec<T> apply_function(T(*f)(T, T), const Vec<T>& v, const T& x)$/;"	f	namespace:itpp	signature:(T(f)T, T), const Vec<T>& v, const T& x)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^inline Vec<T> apply_function(T(*f)(const T&), const Vec<T>& v)$/;"	f	namespace:itpp	signature:(T(f)const T&), const Vec<T>& v)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^inline Vec<T> apply_function(T(*f)(const T&, const T&), const T& x,$/;"	f	namespace:itpp	signature:(T(f)const T&, const T&), const T& x, const Vec<T>& v)
itpp::apply_function	/usr/include/itpp/base/help_functions.h	/^inline Vec<T> apply_function(T(*f)(const T&, const T&), const Vec<T>& v,$/;"	f	namespace:itpp	signature:(T(f)const T&, const T&), const Vec<T>& v, const T& x)
itpp::arg	/usr/include/itpp/base/math/elem_math.h	/^mat arg(const cmat &x);$/;"	p	namespace:itpp	signature:(const cmat &x)
itpp::arg	/usr/include/itpp/base/math/elem_math.h	/^vec arg(const cvec &x);$/;"	p	namespace:itpp	signature:(const cvec &x)
itpp::arma_estimator	/usr/include/itpp/signal/filter_design.h	/^void arma_estimator(const int m, const int n, const vec &R, vec &b, vec &a);$/;"	p	namespace:itpp	signature:(const int m, const int n, const vec &R, vec &b, vec &a)
itpp::asin	/usr/include/itpp/base/math/trig_hyp.h	/^inline mat asin(const mat &x) { return apply_function<double>(std::asin, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::asin	/usr/include/itpp/base/math/trig_hyp.h	/^inline vec asin(const vec &x) { return apply_function<double>(std::asin, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::asinh	/usr/include/itpp/base/math/trig_hyp.h	/^inline mat asinh(const mat &x) { return apply_function<double>(::asinh, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::asinh	/usr/include/itpp/base/math/trig_hyp.h	/^inline vec asinh(const vec &x) { return apply_function<double>(::asinh, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::assert_fixshift	/usr/include/itpp/fixed/fix_functions.h	/^inline void assert_fixshift(const CFix &x, int shift)$/;"	f	namespace:itpp	signature:(const CFix &x, int shift)
itpp::assert_fixshift	/usr/include/itpp/fixed/fix_functions.h	/^inline void assert_fixshift(const Fix &x, int shift)$/;"	f	namespace:itpp	signature:(const Fix &x, int shift)
itpp::assert_fixshift	/usr/include/itpp/fixed/fix_functions.h	/^inline void assert_fixshift(const std::complex<double> &, int) {}$/;"	f	namespace:itpp	signature:(const std::complex<double> &, int)
itpp::assert_fixshift	/usr/include/itpp/fixed/fix_functions.h	/^inline void assert_fixshift(double, int) {}$/;"	f	namespace:itpp	signature:(double, int)
itpp::assert_shifts	/usr/include/itpp/fixed/cfix.h	/^int assert_shifts(const CFix &x, const CFix &y);$/;"	p	namespace:itpp	signature:(const CFix &x, const CFix &y)
itpp::assert_shifts	/usr/include/itpp/fixed/cfix.h	/^int assert_shifts(const CFix &x, const Fix &y);$/;"	p	namespace:itpp	signature:(const CFix &x, const Fix &y)
itpp::assert_shifts	/usr/include/itpp/fixed/cfix.h	/^int assert_shifts(const CFix &x, int y);$/;"	p	namespace:itpp	signature:(const CFix &x, int y)
itpp::assert_shifts	/usr/include/itpp/fixed/fix.h	/^int assert_shifts(const Fix &x, const Fix &y);$/;"	p	namespace:itpp	signature:(const Fix &x, const Fix &y)
itpp::assert_shifts	/usr/include/itpp/fixed/fix.h	/^int assert_shifts(const Fix &x, int y);$/;"	p	namespace:itpp	signature:(const Fix &x, int y)
itpp::atan	/usr/include/itpp/base/math/trig_hyp.h	/^inline mat atan(const mat &x) { return apply_function<double>(std::atan, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::atan	/usr/include/itpp/base/math/trig_hyp.h	/^inline vec atan(const vec &x) { return apply_function<double>(std::atan, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::atanh	/usr/include/itpp/base/math/trig_hyp.h	/^inline mat atanh(const mat &x) { return apply_function<double>(::atanh, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::atanh	/usr/include/itpp/base/math/trig_hyp.h	/^inline vec atanh(const vec &x) { return apply_function<double>(::atanh, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::autocorr	/usr/include/itpp/srccode/lpcfunc.h	/^vec autocorr(const vec &x, int order);$/;"	p	namespace:itpp	signature:(const vec &x, int order)
itpp::axpy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void axpy_vector(int n, double alpha, const double *x, double *y)$/;"	f	namespace:itpp	signature:(int n, double alpha, const double *x, double *y)
itpp::axpy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void axpy_vector(int n, double alpha, const double *x, int incx,$/;"	f	namespace:itpp	signature:(int n, double alpha, const double *x, int incx, double *y, int incy)
itpp::axpy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void axpy_vector(int n, std::complex<double> alpha,$/;"	f	namespace:itpp	signature:(int n, std::complex<double> alpha, const std::complex<double> *x, int incx, std::complex<double> *y, int incy)
itpp::axpy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void axpy_vector(int n, std::complex<double> alpha,$/;"	f	namespace:itpp	signature:(int n, std::complex<double> alpha, const std::complex<double> *x, std::complex<double> *y)
itpp::axpy_vector	/usr/include/itpp/base/copy_vector.h	/^void axpy_vector(int n, T alpha, const T *x, T *y)$/;"	f	namespace:itpp	signature:(int n, T alpha, const T *x, T *y)
itpp::axpy_vector	/usr/include/itpp/base/copy_vector.h	/^void axpy_vector(int n, T alpha, const T *x, int incx, T *y, int incy)$/;"	f	namespace:itpp	signature:(int n, T alpha, const T *x, int incx, T *y, int incy)
itpp::backslash	/usr/include/itpp/base/algebra/ls_solve.h	/^bool backslash(const cmat &A, const cmat &B, cmat &X);$/;"	p	namespace:itpp	signature:(const cmat &A, const cmat &B, cmat &X)
itpp::backslash	/usr/include/itpp/base/algebra/ls_solve.h	/^bool backslash(const cmat &A, const cvec &b, cvec &x);$/;"	p	namespace:itpp	signature:(const cmat &A, const cvec &b, cvec &x)
itpp::backslash	/usr/include/itpp/base/algebra/ls_solve.h	/^bool backslash(const mat &A, const mat &B, mat &X);$/;"	p	namespace:itpp	signature:(const mat &A, const mat &B, mat &X)
itpp::backslash	/usr/include/itpp/base/algebra/ls_solve.h	/^bool backslash(const mat &A, const vec &b, vec &x);$/;"	p	namespace:itpp	signature:(const mat &A, const vec &b, vec &x)
itpp::backslash	/usr/include/itpp/base/algebra/ls_solve.h	/^cmat backslash(const cmat &A, const cmat &B);$/;"	p	namespace:itpp	signature:(const cmat &A, const cmat &B)
itpp::backslash	/usr/include/itpp/base/algebra/ls_solve.h	/^cvec backslash(const cmat &A, const cvec &b);$/;"	p	namespace:itpp	signature:(const cmat &A, const cvec &b)
itpp::backslash	/usr/include/itpp/base/algebra/ls_solve.h	/^mat backslash(const mat &A, const mat &B);$/;"	p	namespace:itpp	signature:(const mat &A, const mat &B)
itpp::backslash	/usr/include/itpp/base/algebra/ls_solve.h	/^vec backslash(const mat &A, const vec &b);$/;"	p	namespace:itpp	signature:(const mat &A, const vec &b)
itpp::backward_substitution	/usr/include/itpp/base/algebra/ls_solve.h	/^vec backward_substitution(const mat &U, const vec &b);$/;"	p	namespace:itpp	signature:(const mat &U, const vec &b)
itpp::backward_substitution	/usr/include/itpp/base/algebra/ls_solve.h	/^vec backward_substitution(const mat &U, int q, const vec &b);$/;"	p	namespace:itpp	signature:(const mat &U, int q, const vec &b)
itpp::backward_substitution	/usr/include/itpp/base/algebra/ls_solve.h	/^void backward_substitution(const mat &U, const vec &b, vec &x);$/;"	p	namespace:itpp	signature:(const mat &U, const vec &b, vec &x)
itpp::backward_substitution	/usr/include/itpp/base/algebra/ls_solve.h	/^void backward_substitution(const mat &U, int q, const vec &b, vec &x);$/;"	p	namespace:itpp	signature:(const mat &U, int q, const vec &b, vec &x)
itpp::besseli	/usr/include/itpp/base/bessel.h	/^double besseli(double nu, double x);$/;"	p	namespace:itpp	signature:(double nu, double x)
itpp::besseli	/usr/include/itpp/base/bessel.h	/^vec besseli(double nu, const vec &x);$/;"	p	namespace:itpp	signature:(double nu, const vec &x)
itpp::besselj	/usr/include/itpp/base/bessel.h	/^double besselj(double nu, double x);$/;"	p	namespace:itpp	signature:(double nu, double x)
itpp::besselj	/usr/include/itpp/base/bessel.h	/^double besselj(int nu, double x);$/;"	p	namespace:itpp	signature:(int nu, double x)
itpp::besselj	/usr/include/itpp/base/bessel.h	/^vec besselj(double nu, const vec &x);$/;"	p	namespace:itpp	signature:(double nu, const vec &x)
itpp::besselj	/usr/include/itpp/base/bessel.h	/^vec besselj(int nu, const vec &x);$/;"	p	namespace:itpp	signature:(int nu, const vec &x)
itpp::besselk	/usr/include/itpp/base/bessel.h	/^double besselk(int nu, double x);$/;"	p	namespace:itpp	signature:(int nu, double x)
itpp::besselk	/usr/include/itpp/base/bessel.h	/^vec besselk(int nu, const vec &x);$/;"	p	namespace:itpp	signature:(int nu, const vec &x)
itpp::bessely	/usr/include/itpp/base/bessel.h	/^double bessely(double nu, double x);$/;"	p	namespace:itpp	signature:(double nu, double x)
itpp::bessely	/usr/include/itpp/base/bessel.h	/^double bessely(int nu, double x);$/;"	p	namespace:itpp	signature:(int nu, double x)
itpp::bessely	/usr/include/itpp/base/bessel.h	/^vec bessely(double nu, const vec &x);$/;"	p	namespace:itpp	signature:(double nu, const vec &x)
itpp::bessely	/usr/include/itpp/base/bessel.h	/^vec bessely(int nu, const vec &x);$/;"	p	namespace:itpp	signature:(int nu, const vec &x)
itpp::bfstream	/usr/include/itpp/base/binfile.h	/^class bfstream : public bfstream_base, public std::fstream$/;"	c	namespace:itpp	inherits:bfstream_base,std::fstream
itpp::bfstream::bfstream	/usr/include/itpp/base/binfile.h	/^  bfstream();$/;"	p	class:itpp::bfstream	access:public	signature:()
itpp::bfstream::bfstream	/usr/include/itpp/base/binfile.h	/^  bfstream(const std::string& name, endian e = b_endian);$/;"	p	class:itpp::bfstream	access:public	signature:(const std::string& name, endian e = b_endian)
itpp::bfstream::length	/usr/include/itpp/base/binfile.h	/^  int length();$/;"	p	class:itpp::bfstream	access:public	signature:()
itpp::bfstream::open	/usr/include/itpp/base/binfile.h	/^  void open(const std::string& name, bool trunc = false, endian e = b_endian);$/;"	p	class:itpp::bfstream	access:public	signature:(const std::string& name, bool trunc = false, endian e = b_endian)
itpp::bfstream::open_readonly	/usr/include/itpp/base/binfile.h	/^  void open_readonly(const std::string& name, endian e = b_endian);$/;"	p	class:itpp::bfstream	access:public	signature:(const std::string& name, endian e = b_endian)
itpp::bfstream::operator <<	/usr/include/itpp/base/binfile.h	/^  bfstream& operator<<(char a);$/;"	p	class:itpp::bfstream	access:public	signature:(char a)
itpp::bfstream::operator <<	/usr/include/itpp/base/binfile.h	/^  bfstream& operator<<(const char* a);$/;"	p	class:itpp::bfstream	access:public	signature:(const char* a)
itpp::bfstream::operator <<	/usr/include/itpp/base/binfile.h	/^  bfstream& operator<<(const std::string& a);$/;"	p	class:itpp::bfstream	access:public	signature:(const std::string& a)
itpp::bfstream::operator <<	/usr/include/itpp/base/binfile.h	/^  bfstream& operator<<(double a);$/;"	p	class:itpp::bfstream	access:public	signature:(double a)
itpp::bfstream::operator <<	/usr/include/itpp/base/binfile.h	/^  bfstream& operator<<(float a);$/;"	p	class:itpp::bfstream	access:public	signature:(float a)
itpp::bfstream::operator <<	/usr/include/itpp/base/binfile.h	/^  bfstream& operator<<(int16_t a);$/;"	p	class:itpp::bfstream	access:public	signature:(int16_t a)
itpp::bfstream::operator <<	/usr/include/itpp/base/binfile.h	/^  bfstream& operator<<(int32_t a);$/;"	p	class:itpp::bfstream	access:public	signature:(int32_t a)
itpp::bfstream::operator <<	/usr/include/itpp/base/binfile.h	/^  bfstream& operator<<(int64_t a);$/;"	p	class:itpp::bfstream	access:public	signature:(int64_t a)
itpp::bfstream::operator <<	/usr/include/itpp/base/binfile.h	/^  bfstream& operator<<(uint16_t a);$/;"	p	class:itpp::bfstream	access:public	signature:(uint16_t a)
itpp::bfstream::operator <<	/usr/include/itpp/base/binfile.h	/^  bfstream& operator<<(uint32_t a);$/;"	p	class:itpp::bfstream	access:public	signature:(uint32_t a)
itpp::bfstream::operator <<	/usr/include/itpp/base/binfile.h	/^  bfstream& operator<<(uint64_t a);$/;"	p	class:itpp::bfstream	access:public	signature:(uint64_t a)
itpp::bfstream::operator <<	/usr/include/itpp/base/binfile.h	/^  bfstream& operator<<(unsigned char a);$/;"	p	class:itpp::bfstream	access:public	signature:(unsigned char a)
itpp::bfstream::operator >>	/usr/include/itpp/base/binfile.h	/^  bfstream& operator>>(char& a);$/;"	p	class:itpp::bfstream	access:public	signature:(char& a)
itpp::bfstream::operator >>	/usr/include/itpp/base/binfile.h	/^  bfstream& operator>>(char* a);$/;"	p	class:itpp::bfstream	access:public	signature:(char* a)
itpp::bfstream::operator >>	/usr/include/itpp/base/binfile.h	/^  bfstream& operator>>(double& a);$/;"	p	class:itpp::bfstream	access:public	signature:(double& a)
itpp::bfstream::operator >>	/usr/include/itpp/base/binfile.h	/^  bfstream& operator>>(float& a);$/;"	p	class:itpp::bfstream	access:public	signature:(float& a)
itpp::bfstream::operator >>	/usr/include/itpp/base/binfile.h	/^  bfstream& operator>>(int16_t& a);$/;"	p	class:itpp::bfstream	access:public	signature:(int16_t& a)
itpp::bfstream::operator >>	/usr/include/itpp/base/binfile.h	/^  bfstream& operator>>(int32_t& a);$/;"	p	class:itpp::bfstream	access:public	signature:(int32_t& a)
itpp::bfstream::operator >>	/usr/include/itpp/base/binfile.h	/^  bfstream& operator>>(int64_t& a);$/;"	p	class:itpp::bfstream	access:public	signature:(int64_t& a)
itpp::bfstream::operator >>	/usr/include/itpp/base/binfile.h	/^  bfstream& operator>>(std::string& a);$/;"	p	class:itpp::bfstream	access:public	signature:(std::string& a)
itpp::bfstream::operator >>	/usr/include/itpp/base/binfile.h	/^  bfstream& operator>>(uint16_t& a);$/;"	p	class:itpp::bfstream	access:public	signature:(uint16_t& a)
itpp::bfstream::operator >>	/usr/include/itpp/base/binfile.h	/^  bfstream& operator>>(uint32_t& a);$/;"	p	class:itpp::bfstream	access:public	signature:(uint32_t& a)
itpp::bfstream::operator >>	/usr/include/itpp/base/binfile.h	/^  bfstream& operator>>(uint64_t& a);$/;"	p	class:itpp::bfstream	access:public	signature:(uint64_t& a)
itpp::bfstream::operator >>	/usr/include/itpp/base/binfile.h	/^  bfstream& operator>>(unsigned char& a);$/;"	p	class:itpp::bfstream	access:public	signature:(unsigned char& a)
itpp::bfstream::~bfstream	/usr/include/itpp/base/binfile.h	/^  ~bfstream() { }$/;"	f	class:itpp::bfstream	access:public	signature:()
itpp::bfstream_base	/usr/include/itpp/base/binfile.h	/^class bfstream_base$/;"	c	namespace:itpp
itpp::bfstream_base::b_endian	/usr/include/itpp/base/binfile.h	/^  enum endian { l_endian, b_endian };$/;"	e	enum:itpp::bfstream_base::endian
itpp::bfstream_base::bfstream_base	/usr/include/itpp/base/binfile.h	/^  bfstream_base(endian e = b_endian);$/;"	p	class:itpp::bfstream_base	access:public	signature:(endian e = b_endian)
itpp::bfstream_base::endian	/usr/include/itpp/base/binfile.h	/^  enum endian { l_endian, b_endian };$/;"	g	class:itpp::bfstream_base	access:public
itpp::bfstream_base::get_endianity	/usr/include/itpp/base/binfile.h	/^  endian get_endianity() const {$/;"	f	class:itpp::bfstream_base	access:public	signature:() const
itpp::bfstream_base::get_native_endianity	/usr/include/itpp/base/binfile.h	/^  endian get_native_endianity() const { return native_endianity; }$/;"	f	class:itpp::bfstream_base	access:public	signature:() const
itpp::bfstream_base::l_endian	/usr/include/itpp/base/binfile.h	/^  enum endian { l_endian, b_endian };$/;"	e	enum:itpp::bfstream_base::endian
itpp::bfstream_base::native_endianity	/usr/include/itpp/base/binfile.h	/^  endian native_endianity;$/;"	m	class:itpp::bfstream_base	access:protected
itpp::bfstream_base::set_endianity	/usr/include/itpp/base/binfile.h	/^  void set_endianity(endian e) {$/;"	f	class:itpp::bfstream_base	access:public	signature:(endian e)
itpp::bfstream_base::set_native_endianity	/usr/include/itpp/base/binfile.h	/^  void set_native_endianity() { switch_endianity = false; }$/;"	f	class:itpp::bfstream_base	access:public	signature:()
itpp::bfstream_base::switch_endianity	/usr/include/itpp/base/binfile.h	/^  bool switch_endianity;$/;"	m	class:itpp::bfstream_base	access:protected
itpp::bidiag	/usr/include/itpp/base/matfunc.h	/^Mat<T> bidiag(const Vec<T> &main, const Vec<T> &sup)$/;"	f	namespace:itpp	signature:(const Vec<T> &main, const Vec<T> &sup)
itpp::bidiag	/usr/include/itpp/base/matfunc.h	/^extern template cmat bidiag(const cvec &, const cvec &);$/;"	p	namespace:itpp	signature:(const cvec &, const cvec &)
itpp::bidiag	/usr/include/itpp/base/matfunc.h	/^extern template mat bidiag(const vec &, const vec &);$/;"	p	namespace:itpp	signature:(const vec &, const vec &)
itpp::bidiag	/usr/include/itpp/base/matfunc.h	/^extern template void bidiag(const cmat &, cvec &, cvec &);$/;"	p	namespace:itpp	signature:(const cmat &, cvec &, cvec &)
itpp::bidiag	/usr/include/itpp/base/matfunc.h	/^extern template void bidiag(const cvec &, const cvec &, cmat &);$/;"	p	namespace:itpp	signature:(const cvec &, const cvec &, cmat &)
itpp::bidiag	/usr/include/itpp/base/matfunc.h	/^extern template void bidiag(const mat &, vec &, vec &);$/;"	p	namespace:itpp	signature:(const mat &, vec &, vec &)
itpp::bidiag	/usr/include/itpp/base/matfunc.h	/^extern template void bidiag(const vec &, const vec &, mat &);$/;"	p	namespace:itpp	signature:(const vec &, const vec &, mat &)
itpp::bidiag	/usr/include/itpp/base/matfunc.h	/^void bidiag(const Mat<T> &m, Vec<T> &main, Vec<T> &sup)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, Vec<T> &main, Vec<T> &sup)
itpp::bidiag	/usr/include/itpp/base/matfunc.h	/^void bidiag(const Vec<T> &main, const Vec<T> &sup, Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Vec<T> &main, const Vec<T> &sup, Mat<T> &m)
itpp::bifstream	/usr/include/itpp/base/binfile.h	/^class bifstream : public bfstream_base, public std::ifstream$/;"	c	namespace:itpp	inherits:bfstream_base,std::ifstream
itpp::bifstream::bifstream	/usr/include/itpp/base/binfile.h	/^  bifstream();$/;"	p	class:itpp::bifstream	access:public	signature:()
itpp::bifstream::bifstream	/usr/include/itpp/base/binfile.h	/^  bifstream(const std::string& name, endian e = b_endian);$/;"	p	class:itpp::bifstream	access:public	signature:(const std::string& name, endian e = b_endian)
itpp::bifstream::length	/usr/include/itpp/base/binfile.h	/^  int length();$/;"	p	class:itpp::bifstream	access:public	signature:()
itpp::bifstream::open	/usr/include/itpp/base/binfile.h	/^  void open(const std::string& name, endian e = b_endian);$/;"	p	class:itpp::bifstream	access:public	signature:(const std::string& name, endian e = b_endian)
itpp::bifstream::operator >>	/usr/include/itpp/base/binfile.h	/^  bifstream& operator>>(char& a);$/;"	p	class:itpp::bifstream	access:public	signature:(char& a)
itpp::bifstream::operator >>	/usr/include/itpp/base/binfile.h	/^  bifstream& operator>>(char* a);$/;"	p	class:itpp::bifstream	access:public	signature:(char* a)
itpp::bifstream::operator >>	/usr/include/itpp/base/binfile.h	/^  bifstream& operator>>(double& a);$/;"	p	class:itpp::bifstream	access:public	signature:(double& a)
itpp::bifstream::operator >>	/usr/include/itpp/base/binfile.h	/^  bifstream& operator>>(float& a);$/;"	p	class:itpp::bifstream	access:public	signature:(float& a)
itpp::bifstream::operator >>	/usr/include/itpp/base/binfile.h	/^  bifstream& operator>>(int16_t& a);$/;"	p	class:itpp::bifstream	access:public	signature:(int16_t& a)
itpp::bifstream::operator >>	/usr/include/itpp/base/binfile.h	/^  bifstream& operator>>(int32_t& a);$/;"	p	class:itpp::bifstream	access:public	signature:(int32_t& a)
itpp::bifstream::operator >>	/usr/include/itpp/base/binfile.h	/^  bifstream& operator>>(int64_t& a);$/;"	p	class:itpp::bifstream	access:public	signature:(int64_t& a)
itpp::bifstream::operator >>	/usr/include/itpp/base/binfile.h	/^  bifstream& operator>>(std::string& a);$/;"	p	class:itpp::bifstream	access:public	signature:(std::string& a)
itpp::bifstream::operator >>	/usr/include/itpp/base/binfile.h	/^  bifstream& operator>>(uint16_t& a);$/;"	p	class:itpp::bifstream	access:public	signature:(uint16_t& a)
itpp::bifstream::operator >>	/usr/include/itpp/base/binfile.h	/^  bifstream& operator>>(uint32_t& a);$/;"	p	class:itpp::bifstream	access:public	signature:(uint32_t& a)
itpp::bifstream::operator >>	/usr/include/itpp/base/binfile.h	/^  bifstream& operator>>(uint64_t& a);$/;"	p	class:itpp::bifstream	access:public	signature:(uint64_t& a)
itpp::bifstream::operator >>	/usr/include/itpp/base/binfile.h	/^  bifstream& operator>>(unsigned char& a);$/;"	p	class:itpp::bifstream	access:public	signature:(unsigned char& a)
itpp::bifstream::~bifstream	/usr/include/itpp/base/binfile.h	/^  ~bifstream() { }$/;"	f	class:itpp::bifstream	access:public	signature:()
itpp::bin	/usr/include/itpp/base/binary.h	/^class bin$/;"	c	namespace:itpp
itpp::bin2dec	/usr/include/itpp/base/converters.h	/^int bin2dec(const bvec &inbvec, bool msb_first = true);$/;"	p	namespace:itpp	signature:(const bvec &inbvec, bool msb_first = true)
itpp::bin2mxArray	/usr/include/itpp/itmex.h	/^void bin2mxArray(const bin &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const bin &in, mxArray *out)
itpp::bin2oct	/usr/include/itpp/base/converters.h	/^ivec bin2oct(const bvec &inbits);$/;"	p	namespace:itpp	signature:(const bvec &inbits)
itpp::bin2pol	/usr/include/itpp/base/converters.h	/^ivec bin2pol(const bvec &inbvec);$/;"	p	namespace:itpp	signature:(const bvec &inbvec)
itpp::bin::b	/usr/include/itpp/base/binary.h	/^  char b;$/;"	m	class:itpp::bin	access:private
itpp::bin::bin	/usr/include/itpp/base/binary.h	/^  bin(): b(0) {}$/;"	f	class:itpp::bin	access:public	signature:()
itpp::bin::bin	/usr/include/itpp/base/binary.h	/^  bin(const bin &inbin): b(inbin.b) {}$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin)
itpp::bin::bin	/usr/include/itpp/base/binary.h	/^  bin(const int &value): b(static_cast<char>(value)) {$/;"	f	class:itpp::bin	access:public	signature:(const int &value)
itpp::bin::operator !	/usr/include/itpp/base/binary.h	/^  bin operator!(void) const { return bin(b ^ 1); }$/;"	f	class:itpp::bin	access:public	signature:(void) const
itpp::bin::operator !=	/usr/include/itpp/base/binary.h	/^  bool operator!=(const bin &inbin) const { return b != inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin) const
itpp::bin::operator !=	/usr/include/itpp/base/binary.h	/^  bool operator!=(const int &i) const { return b != i; }$/;"	f	class:itpp::bin	access:public	signature:(const int &i) const
itpp::bin::operator &	/usr/include/itpp/base/binary.h	/^  bin operator&(const bin &inbin) const { return bin(b & inbin.b); }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin) const
itpp::bin::operator &=	/usr/include/itpp/base/binary.h	/^  void operator&=(const bin &inbin) { b &= inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin)
itpp::bin::operator *	/usr/include/itpp/base/binary.h	/^  bin operator*(const bin &inbin) const { return bin(b & inbin.b); }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin) const
itpp::bin::operator *=	/usr/include/itpp/base/binary.h	/^  void operator*=(const bin &inbin) { b &= inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin)
itpp::bin::operator +	/usr/include/itpp/base/binary.h	/^  bin operator+(const bin &inbin) const { return bin(b ^ inbin.b); }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin) const
itpp::bin::operator +=	/usr/include/itpp/base/binary.h	/^  void operator+=(const bin &inbin) { b ^= inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin)
itpp::bin::operator -	/usr/include/itpp/base/binary.h	/^  bin operator-() const { return bin(b); }$/;"	f	class:itpp::bin	access:public	signature:() const
itpp::bin::operator -	/usr/include/itpp/base/binary.h	/^  bin operator-(const bin &inbin) const { return bin(b ^ inbin.b); }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin) const
itpp::bin::operator -=	/usr/include/itpp/base/binary.h	/^  void operator-=(const bin &inbin) { b ^= inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin)
itpp::bin::operator /	/usr/include/itpp/base/binary.h	/^  bin operator\/(const bin &inbin) const { return bin(b | inbin.b); }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin) const
itpp::bin::operator /=	/usr/include/itpp/base/binary.h	/^  void operator\/=(const bin &inbin) { b |= inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin)
itpp::bin::operator <	/usr/include/itpp/base/binary.h	/^  bool operator<(const bin &inbin) const  { return b < inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin) const
itpp::bin::operator <=	/usr/include/itpp/base/binary.h	/^  bool operator<=(const bin &inbin) const { return b <= inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin) const
itpp::bin::operator =	/usr/include/itpp/base/binary.h	/^  void operator=(const bin &inbin) { b = inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin)
itpp::bin::operator =	/usr/include/itpp/base/binary.h	/^  void operator=(const int &value) {$/;"	f	class:itpp::bin	access:public	signature:(const int &value)
itpp::bin::operator ==	/usr/include/itpp/base/binary.h	/^  bool operator==(const bin &inbin) const { return b == inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin) const
itpp::bin::operator ==	/usr/include/itpp/base/binary.h	/^  bool operator==(const int &i) const { return b == i; }$/;"	f	class:itpp::bin	access:public	signature:(const int &i) const
itpp::bin::operator >	/usr/include/itpp/base/binary.h	/^  bool operator>(const bin &inbin) const  { return b > inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin) const
itpp::bin::operator >=	/usr/include/itpp/base/binary.h	/^  bool operator>=(const bin &inbin) const { return b >= inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin) const
itpp::bin::operator ^	/usr/include/itpp/base/binary.h	/^  bin operator^(const bin &inbin) const { return bin(b ^ inbin.b); }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin) const
itpp::bin::operator ^=	/usr/include/itpp/base/binary.h	/^  void operator^=(const bin &inbin) { b ^= inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin)
itpp::bin::operator bool	/usr/include/itpp/base/binary.h	/^  operator bool() const   { return b != 0; }$/;"	f	class:itpp::bin	access:public	signature:() const
itpp::bin::operator double	/usr/include/itpp/base/binary.h	/^  operator double() const { return static_cast<double>(b); }$/;"	f	class:itpp::bin	access:public	signature:() const
itpp::bin::operator float	/usr/include/itpp/base/binary.h	/^  operator float() const  { return static_cast<float>(b); }$/;"	f	class:itpp::bin	access:public	signature:() const
itpp::bin::operator int	/usr/include/itpp/base/binary.h	/^  operator int() const    { return static_cast<int>(b); }$/;"	f	class:itpp::bin	access:public	signature:() const
itpp::bin::operator short	/usr/include/itpp/base/binary.h	/^  operator short() const  { return static_cast<short>(b); }$/;"	f	class:itpp::bin	access:public	signature:() const
itpp::bin::operator |	/usr/include/itpp/base/binary.h	/^  bin operator|(const bin &inbin) const { return bin(b | inbin.b); }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin) const
itpp::bin::operator |=	/usr/include/itpp/base/binary.h	/^  void operator|=(const bin &inbin) { b |= inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin)
itpp::bin::operator ~	/usr/include/itpp/base/binary.h	/^  bin operator~(void) const { return bin(b ^ 1); }$/;"	f	class:itpp::bin	access:public	signature:(void) const
itpp::bin::value	/usr/include/itpp/base/binary.h	/^  char value() const { return b; }$/;"	f	class:itpp::bin	access:public	signature:() const
itpp::binom	/usr/include/itpp/base/math/elem_math.h	/^double binom(int n, int k);$/;"	p	namespace:itpp	signature:(int n, int k)
itpp::binom_i	/usr/include/itpp/base/math/elem_math.h	/^int binom_i(int n, int k);$/;"	p	namespace:itpp	signature:(int n, int k)
itpp::bitalloc	/usr/include/itpp/srccode/vqtrain.h	/^ivec bitalloc(const vec& variances, int nobits);$/;"	p	namespace:itpp	signature:(const vec& variances, int nobits)
itpp::bitrv	/usr/include/itpp/signal/transforms.h	/^void bitrv(Vec<T> &out)$/;"	f	namespace:itpp	signature:(Vec<T> &out)
itpp::blackman	/usr/include/itpp/signal/window.h	/^vec blackman(int n);$/;"	p	namespace:itpp	signature:(int n)
itpp::bmat	/usr/include/itpp/base/mat.h	/^typedef Mat<bin> bmat;$/;"	t	namespace:itpp
itpp::bmat2mxArray	/usr/include/itpp/itmex.h	/^void bmat2mxArray(const bmat &in, mxArray *out)$/;"	f	namespace:itpp	signature:(const bmat &in, mxArray *out)
itpp::bmat2mxArray	/usr/include/itpp/itmex.h	/^void bmat2mxArray(const bmat &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const bmat &in, mxArray *out)
itpp::bofstream	/usr/include/itpp/base/binfile.h	/^class bofstream : public bfstream_base, public std::ofstream$/;"	c	namespace:itpp	inherits:bfstream_base,std::ofstream
itpp::bofstream::bofstream	/usr/include/itpp/base/binfile.h	/^  bofstream();$/;"	p	class:itpp::bofstream	access:public	signature:()
itpp::bofstream::bofstream	/usr/include/itpp/base/binfile.h	/^  bofstream(const std::string& name, endian e = b_endian);$/;"	p	class:itpp::bofstream	access:public	signature:(const std::string& name, endian e = b_endian)
itpp::bofstream::open	/usr/include/itpp/base/binfile.h	/^  void open(const std::string& name, endian e = b_endian);$/;"	p	class:itpp::bofstream	access:public	signature:(const std::string& name, endian e = b_endian)
itpp::bofstream::operator <<	/usr/include/itpp/base/binfile.h	/^  bofstream& operator<<(char a);$/;"	p	class:itpp::bofstream	access:public	signature:(char a)
itpp::bofstream::operator <<	/usr/include/itpp/base/binfile.h	/^  bofstream& operator<<(const char* a);$/;"	p	class:itpp::bofstream	access:public	signature:(const char* a)
itpp::bofstream::operator <<	/usr/include/itpp/base/binfile.h	/^  bofstream& operator<<(const std::string& a);$/;"	p	class:itpp::bofstream	access:public	signature:(const std::string& a)
itpp::bofstream::operator <<	/usr/include/itpp/base/binfile.h	/^  bofstream& operator<<(double a);$/;"	p	class:itpp::bofstream	access:public	signature:(double a)
itpp::bofstream::operator <<	/usr/include/itpp/base/binfile.h	/^  bofstream& operator<<(float a);$/;"	p	class:itpp::bofstream	access:public	signature:(float a)
itpp::bofstream::operator <<	/usr/include/itpp/base/binfile.h	/^  bofstream& operator<<(int16_t a);$/;"	p	class:itpp::bofstream	access:public	signature:(int16_t a)
itpp::bofstream::operator <<	/usr/include/itpp/base/binfile.h	/^  bofstream& operator<<(int32_t a);$/;"	p	class:itpp::bofstream	access:public	signature:(int32_t a)
itpp::bofstream::operator <<	/usr/include/itpp/base/binfile.h	/^  bofstream& operator<<(int64_t a);$/;"	p	class:itpp::bofstream	access:public	signature:(int64_t a)
itpp::bofstream::operator <<	/usr/include/itpp/base/binfile.h	/^  bofstream& operator<<(uint16_t a);$/;"	p	class:itpp::bofstream	access:public	signature:(uint16_t a)
itpp::bofstream::operator <<	/usr/include/itpp/base/binfile.h	/^  bofstream& operator<<(uint32_t a);$/;"	p	class:itpp::bofstream	access:public	signature:(uint32_t a)
itpp::bofstream::operator <<	/usr/include/itpp/base/binfile.h	/^  bofstream& operator<<(uint64_t a);$/;"	p	class:itpp::bofstream	access:public	signature:(uint64_t a)
itpp::bofstream::operator <<	/usr/include/itpp/base/binfile.h	/^  bofstream& operator<<(unsigned char a);$/;"	p	class:itpp::bofstream	access:public	signature:(unsigned char a)
itpp::bofstream::~bofstream	/usr/include/itpp/base/binfile.h	/^  ~bofstream() { }$/;"	f	class:itpp::bofstream	access:public	signature:()
itpp::bvec	/usr/include/itpp/base/vec.h	/^typedef Vec<bin> bvec;$/;"	t	namespace:itpp
itpp::bvec2mxArray	/usr/include/itpp/itmex.h	/^void bvec2mxArray(const bvec &in, mxArray *out)$/;"	f	namespace:itpp	signature:(const bvec &in, mxArray *out)
itpp::bvec2mxArray	/usr/include/itpp/itmex.h	/^void bvec2mxArray(const bvec &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const bvec &in, mxArray *out)
itpp::ceil	/usr/include/itpp/base/converters.h	/^inline mat ceil(const mat &x) { return apply_function<double>(std::ceil, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::ceil	/usr/include/itpp/base/converters.h	/^inline vec ceil(const vec &x) { return apply_function<double>(std::ceil, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::ceil_i	/usr/include/itpp/base/converters.h	/^imat ceil_i(const mat &x);$/;"	p	namespace:itpp	signature:(const mat &x)
itpp::ceil_i	/usr/include/itpp/base/converters.h	/^inline int ceil_i(double x) { return static_cast<int>(std::ceil(x)); }$/;"	f	namespace:itpp	signature:(double x)
itpp::ceil_i	/usr/include/itpp/base/converters.h	/^ivec ceil_i(const vec &x);$/;"	p	namespace:itpp	signature:(const vec &x)
itpp::cepstrum2poly	/usr/include/itpp/srccode/lpcfunc.h	/^vec cepstrum2poly(const vec &c);$/;"	p	namespace:itpp	signature:(const vec &c)
itpp::cfixed1	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<1, TC, WRAP> cfixed1;$/;"	t	namespace:itpp
itpp::cfixed10	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<10, TC, WRAP> cfixed10;$/;"	t	namespace:itpp
itpp::cfixed11	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<11, TC, WRAP> cfixed11;$/;"	t	namespace:itpp
itpp::cfixed12	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<12, TC, WRAP> cfixed12;$/;"	t	namespace:itpp
itpp::cfixed13	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<13, TC, WRAP> cfixed13;$/;"	t	namespace:itpp
itpp::cfixed14	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<14, TC, WRAP> cfixed14;$/;"	t	namespace:itpp
itpp::cfixed15	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<15, TC, WRAP> cfixed15;$/;"	t	namespace:itpp
itpp::cfixed16	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<16, TC, WRAP> cfixed16;$/;"	t	namespace:itpp
itpp::cfixed17	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<17, TC, WRAP> cfixed17;$/;"	t	namespace:itpp
itpp::cfixed18	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<18, TC, WRAP> cfixed18;$/;"	t	namespace:itpp
itpp::cfixed19	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<19, TC, WRAP> cfixed19;$/;"	t	namespace:itpp
itpp::cfixed2	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<2, TC, WRAP> cfixed2;$/;"	t	namespace:itpp
itpp::cfixed20	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<20, TC, WRAP> cfixed20;$/;"	t	namespace:itpp
itpp::cfixed21	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<21, TC, WRAP> cfixed21;$/;"	t	namespace:itpp
itpp::cfixed22	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<22, TC, WRAP> cfixed22;$/;"	t	namespace:itpp
itpp::cfixed23	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<23, TC, WRAP> cfixed23;$/;"	t	namespace:itpp
itpp::cfixed24	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<24, TC, WRAP> cfixed24;$/;"	t	namespace:itpp
itpp::cfixed25	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<25, TC, WRAP> cfixed25;$/;"	t	namespace:itpp
itpp::cfixed26	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<26, TC, WRAP> cfixed26;$/;"	t	namespace:itpp
itpp::cfixed27	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<27, TC, WRAP> cfixed27;$/;"	t	namespace:itpp
itpp::cfixed28	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<28, TC, WRAP> cfixed28;$/;"	t	namespace:itpp
itpp::cfixed29	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<29, TC, WRAP> cfixed29;$/;"	t	namespace:itpp
itpp::cfixed3	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<3, TC, WRAP> cfixed3;$/;"	t	namespace:itpp
itpp::cfixed30	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<30, TC, WRAP> cfixed30;$/;"	t	namespace:itpp
itpp::cfixed31	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<31, TC, WRAP> cfixed31;$/;"	t	namespace:itpp
itpp::cfixed32	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<32, TC, WRAP> cfixed32;$/;"	t	namespace:itpp
itpp::cfixed33	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<33, TC, WRAP> cfixed33;$/;"	t	namespace:itpp
itpp::cfixed34	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<34, TC, WRAP> cfixed34;$/;"	t	namespace:itpp
itpp::cfixed35	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<35, TC, WRAP> cfixed35;$/;"	t	namespace:itpp
itpp::cfixed36	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<36, TC, WRAP> cfixed36;$/;"	t	namespace:itpp
itpp::cfixed37	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<37, TC, WRAP> cfixed37;$/;"	t	namespace:itpp
itpp::cfixed38	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<38, TC, WRAP> cfixed38;$/;"	t	namespace:itpp
itpp::cfixed39	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<39, TC, WRAP> cfixed39;$/;"	t	namespace:itpp
itpp::cfixed4	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<4, TC, WRAP> cfixed4;$/;"	t	namespace:itpp
itpp::cfixed40	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<40, TC, WRAP> cfixed40;$/;"	t	namespace:itpp
itpp::cfixed41	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<41, TC, WRAP> cfixed41;$/;"	t	namespace:itpp
itpp::cfixed42	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<42, TC, WRAP> cfixed42;$/;"	t	namespace:itpp
itpp::cfixed43	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<43, TC, WRAP> cfixed43;$/;"	t	namespace:itpp
itpp::cfixed44	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<44, TC, WRAP> cfixed44;$/;"	t	namespace:itpp
itpp::cfixed45	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<45, TC, WRAP> cfixed45;$/;"	t	namespace:itpp
itpp::cfixed46	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<46, TC, WRAP> cfixed46;$/;"	t	namespace:itpp
itpp::cfixed47	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<47, TC, WRAP> cfixed47;$/;"	t	namespace:itpp
itpp::cfixed48	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<48, TC, WRAP> cfixed48;$/;"	t	namespace:itpp
itpp::cfixed49	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<49, TC, WRAP> cfixed49;$/;"	t	namespace:itpp
itpp::cfixed5	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<5, TC, WRAP> cfixed5;$/;"	t	namespace:itpp
itpp::cfixed50	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<50, TC, WRAP> cfixed50;$/;"	t	namespace:itpp
itpp::cfixed51	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<51, TC, WRAP> cfixed51;$/;"	t	namespace:itpp
itpp::cfixed52	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<52, TC, WRAP> cfixed52;$/;"	t	namespace:itpp
itpp::cfixed53	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<53, TC, WRAP> cfixed53;$/;"	t	namespace:itpp
itpp::cfixed54	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<54, TC, WRAP> cfixed54;$/;"	t	namespace:itpp
itpp::cfixed55	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<55, TC, WRAP> cfixed55;$/;"	t	namespace:itpp
itpp::cfixed56	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<56, TC, WRAP> cfixed56;$/;"	t	namespace:itpp
itpp::cfixed57	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<57, TC, WRAP> cfixed57;$/;"	t	namespace:itpp
itpp::cfixed58	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<58, TC, WRAP> cfixed58;$/;"	t	namespace:itpp
itpp::cfixed59	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<59, TC, WRAP> cfixed59;$/;"	t	namespace:itpp
itpp::cfixed6	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<6, TC, WRAP> cfixed6;$/;"	t	namespace:itpp
itpp::cfixed60	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<60, TC, WRAP> cfixed60;$/;"	t	namespace:itpp
itpp::cfixed61	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<61, TC, WRAP> cfixed61;$/;"	t	namespace:itpp
itpp::cfixed62	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<62, TC, WRAP> cfixed62;$/;"	t	namespace:itpp
itpp::cfixed63	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<63, TC, WRAP> cfixed63;$/;"	t	namespace:itpp
itpp::cfixed64	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<64, TC, WRAP> cfixed64;$/;"	t	namespace:itpp
itpp::cfixed7	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<7, TC, WRAP> cfixed7;$/;"	t	namespace:itpp
itpp::cfixed8	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<8, TC, WRAP> cfixed8;$/;"	t	namespace:itpp
itpp::cfixed9	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<9, TC, WRAP> cfixed9;$/;"	t	namespace:itpp
itpp::cfixmat	/usr/include/itpp/fixed/cfix.h	/^typedef Mat<CFix> cfixmat;$/;"	t	namespace:itpp
itpp::cfixmat::set	/usr/include/itpp/fixed/cfix.h	/^template<> void cfixmat::set(const char *values);$/;"	p	class:itpp::cfixmat	signature:(const char *values)
itpp::cfixvec	/usr/include/itpp/fixed/cfix.h	/^typedef Vec<CFix> cfixvec;$/;"	t	namespace:itpp
itpp::cfixvec::set	/usr/include/itpp/fixed/cfix.h	/^template<> void cfixvec::set(const char *values);$/;"	p	class:itpp::cfixvec	signature:(const char *values)
itpp::check_big_endianness	/usr/include/itpp/base/math/misc.h	/^bool check_big_endianness();$/;"	p	namespace:itpp	signature:()
itpp::chirp	/usr/include/itpp/srccode/lpcfunc.h	/^vec chirp(const vec &a, double factor);$/;"	p	namespace:itpp	signature:(const vec &a, double factor)
itpp::chol	/usr/include/itpp/base/algebra/cholesky.h	/^bool chol(const cmat &X, cmat &F);$/;"	p	namespace:itpp	signature:(const cmat &X, cmat &F)
itpp::chol	/usr/include/itpp/base/algebra/cholesky.h	/^bool chol(const mat &X, mat &F);$/;"	p	namespace:itpp	signature:(const mat &X, mat &F)
itpp::chol	/usr/include/itpp/base/algebra/cholesky.h	/^cmat chol(const cmat &X);$/;"	p	namespace:itpp	signature:(const cmat &X)
itpp::chol	/usr/include/itpp/base/algebra/cholesky.h	/^mat chol(const mat &X);$/;"	p	namespace:itpp	signature:(const mat &X)
itpp::cmat	/usr/include/itpp/base/mat.h	/^typedef Mat<std::complex<double> > cmat;$/;"	t	namespace:itpp
itpp::cmat2mxArray	/usr/include/itpp/itmex.h	/^void cmat2mxArray(const cmat &in, mxArray *out)$/;"	f	namespace:itpp	signature:(const cmat &in, mxArray *out)
itpp::cmat2mxArray	/usr/include/itpp/itmex.h	/^void cmat2mxArray(const cmat &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const cmat &in, mxArray *out)
itpp::cmat::hermitian_transpose	/usr/include/itpp/base/mat.h	/^cmat cmat::hermitian_transpose() const;$/;"	p	class:itpp::cmat	signature:() const
itpp::cmat::operator *=	/usr/include/itpp/base/mat.h	/^template<> cmat& cmat::operator*=(const cmat &m);$/;"	p	class:itpp::cmat	signature:(const cmat &m)
itpp::compare_spectra	/usr/include/itpp/comm/convcode.h	/^int compare_spectra(ivec v1, ivec v2);$/;"	p	namespace:itpp	signature:(ivec v1, ivec v2)
itpp::compare_spectra	/usr/include/itpp/comm/convcode.h	/^int compare_spectra(ivec v1, ivec v2, vec weight_profile);$/;"	p	namespace:itpp	signature:(ivec v1, ivec v2, vec weight_profile)
itpp::concat	/usr/include/itpp/base/array.h	/^const Array<T> concat(const Array<T> &a, const T e)$/;"	f	namespace:itpp	signature:(const Array<T> &a, const T e)
itpp::concat	/usr/include/itpp/base/array.h	/^const Array<T> concat(const Array<T> &a1, const Array<T> &a2)$/;"	f	namespace:itpp	signature:(const Array<T> &a1, const Array<T> &a2)
itpp::concat	/usr/include/itpp/base/array.h	/^const Array<T> concat(const Array<T> &a1, const Array<T> &a2,$/;"	f	namespace:itpp	signature:(const Array<T> &a1, const Array<T> &a2, const Array<T> &a3)
itpp::concat	/usr/include/itpp/base/array.h	/^const Array<T> concat(const T e, const Array<T> &a)$/;"	f	namespace:itpp	signature:(const T e, const Array<T> &a)
itpp::concat	/usr/include/itpp/base/array.h	/^template<class T> const Array<T> concat(const Array<T> &a, const T e);$/;"	p	namespace:itpp	signature:(const Array<T> &a, const T e)
itpp::concat	/usr/include/itpp/base/array.h	/^template<class T> const Array<T> concat(const Array<T> &a1,$/;"	p	namespace:itpp	signature:(const Array<T> &a1, const Array<T> &a2)
itpp::concat	/usr/include/itpp/base/array.h	/^template<class T> const Array<T> concat(const Array<T> &a1,$/;"	p	namespace:itpp	signature:(const Array<T> &a1, const Array<T> &a2, const Array<T> &a3)
itpp::concat	/usr/include/itpp/base/array.h	/^template<class T> const Array<T> concat(const T e, const Array<T> &a);$/;"	p	namespace:itpp	signature:(const T e, const Array<T> &a)
itpp::concat	/usr/include/itpp/base/vec.h	/^Vec<Num_T> concat(Num_T a, const Vec<Num_T> &v);$/;"	p	namespace:itpp	signature:(Num_T a, const Vec<Num_T> &v)
itpp::concat	/usr/include/itpp/base/vec.h	/^Vec<Num_T> concat(Num_T t, const Vec<Num_T> &v)$/;"	f	namespace:itpp	signature:(Num_T t, const Vec<Num_T> &v)
itpp::concat	/usr/include/itpp/base/vec.h	/^Vec<Num_T> concat(const Vec<Num_T> &v, Num_T a);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v, Num_T a)
itpp::concat	/usr/include/itpp/base/vec.h	/^Vec<Num_T> concat(const Vec<Num_T> &v, Num_T t)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v, Num_T t)
itpp::concat	/usr/include/itpp/base/vec.h	/^Vec<Num_T> concat(const Vec<Num_T> &v1, const Vec<Num_T> &v2)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
itpp::concat	/usr/include/itpp/base/vec.h	/^Vec<Num_T> concat(const Vec<Num_T> &v1, const Vec<Num_T> &v2);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
itpp::concat	/usr/include/itpp/base/vec.h	/^Vec<Num_T> concat(const Vec<Num_T> &v1, const Vec<Num_T> &v2,$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2, const Vec<Num_T> &v3)
itpp::concat	/usr/include/itpp/base/vec.h	/^Vec<Num_T> concat(const Vec<Num_T> &v1, const Vec<Num_T> &v2,$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2, const Vec<Num_T> &v3, const Vec<Num_T> &v4)
itpp::concat	/usr/include/itpp/base/vec.h	/^Vec<Num_T> concat(const Vec<Num_T> &v1, const Vec<Num_T> &v2,$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2, const Vec<Num_T> &v3, const Vec<Num_T> &v4, const Vec<Num_T> &v5)
itpp::concat	/usr/include/itpp/base/vec.h	/^Vec<Num_T> concat(const Vec<Num_T> &v1, const Vec<Num_T> &v2,$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2, const Vec<Num_T> &v3)
itpp::concat	/usr/include/itpp/base/vec.h	/^Vec<Num_T> concat(const Vec<Num_T> &v1, const Vec<Num_T> &v2,$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2, const Vec<Num_T> &v3, const Vec<Num_T> &v4)
itpp::concat	/usr/include/itpp/base/vec.h	/^Vec<Num_T> concat(const Vec<Num_T> &v1, const Vec<Num_T> &v2,$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2, const Vec<Num_T> &v3, const Vec<Num_T> &v4, const Vec<Num_T> &v5)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template bvec concat(bin a, const bvec &v);$/;"	p	namespace:itpp	signature:(bin a, const bvec &v)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template bvec concat(const bvec &v, bin a);$/;"	p	namespace:itpp	signature:(const bvec &v, bin a)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template bvec concat(const bvec &v1, const bvec &v2);$/;"	p	namespace:itpp	signature:(const bvec &v1, const bvec &v2)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template bvec concat(const bvec &v1, const bvec &v2, const bvec &v3);$/;"	p	namespace:itpp	signature:(const bvec &v1, const bvec &v2, const bvec &v3)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template bvec concat(const bvec &v1, const bvec &v2, const bvec &v3,$/;"	p	namespace:itpp	signature:(const bvec &v1, const bvec &v2, const bvec &v3, const bvec &v4, const bvec &v5)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template bvec concat(const bvec &v1, const bvec &v2,$/;"	p	namespace:itpp	signature:(const bvec &v1, const bvec &v2, const bvec &v3, const bvec &v4)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template cvec concat(const cvec &v, std::complex<double> a);$/;"	p	namespace:itpp	signature:(const cvec &v, std::complex<double> a)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template cvec concat(const cvec &v1, const cvec &v2);$/;"	p	namespace:itpp	signature:(const cvec &v1, const cvec &v2)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template cvec concat(const cvec &v1, const cvec &v2, const cvec &v3);$/;"	p	namespace:itpp	signature:(const cvec &v1, const cvec &v2, const cvec &v3)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template cvec concat(const cvec &v1, const cvec &v2, const cvec &v3,$/;"	p	namespace:itpp	signature:(const cvec &v1, const cvec &v2, const cvec &v3, const cvec &v4, const cvec &v5)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template cvec concat(const cvec &v1, const cvec &v2,$/;"	p	namespace:itpp	signature:(const cvec &v1, const cvec &v2, const cvec &v3, const cvec &v4)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template cvec concat(std::complex<double> a, const cvec &v);$/;"	p	namespace:itpp	signature:(std::complex<double> a, const cvec &v)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template ivec concat(const ivec &v, int a);$/;"	p	namespace:itpp	signature:(const ivec &v, int a)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template ivec concat(const ivec &v1, const ivec &v2);$/;"	p	namespace:itpp	signature:(const ivec &v1, const ivec &v2)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template ivec concat(const ivec &v1, const ivec &v2, const ivec &v3);$/;"	p	namespace:itpp	signature:(const ivec &v1, const ivec &v2, const ivec &v3)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template ivec concat(const ivec &v1, const ivec &v2, const ivec &v3,$/;"	p	namespace:itpp	signature:(const ivec &v1, const ivec &v2, const ivec &v3, const ivec &v4, const ivec &v5)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template ivec concat(const ivec &v1, const ivec &v2,$/;"	p	namespace:itpp	signature:(const ivec &v1, const ivec &v2, const ivec &v3, const ivec &v4)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template ivec concat(int a, const ivec &v);$/;"	p	namespace:itpp	signature:(int a, const ivec &v)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template svec concat(const svec &v, short a);$/;"	p	namespace:itpp	signature:(const svec &v, short a)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template svec concat(const svec &v1, const svec &v2);$/;"	p	namespace:itpp	signature:(const svec &v1, const svec &v2)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template svec concat(const svec &v1, const svec &v2, const svec &v3);$/;"	p	namespace:itpp	signature:(const svec &v1, const svec &v2, const svec &v3)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template svec concat(const svec &v1, const svec &v2, const svec &v3,$/;"	p	namespace:itpp	signature:(const svec &v1, const svec &v2, const svec &v3, const svec &v4, const svec &v5)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template svec concat(const svec &v1, const svec &v2,$/;"	p	namespace:itpp	signature:(const svec &v1, const svec &v2, const svec &v3, const svec &v4)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template svec concat(short a, const svec &v);$/;"	p	namespace:itpp	signature:(short a, const svec &v)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template vec concat(const vec &v, double a);$/;"	p	namespace:itpp	signature:(const vec &v, double a)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template vec concat(const vec &v1, const vec &v2);$/;"	p	namespace:itpp	signature:(const vec &v1, const vec &v2)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template vec concat(const vec &v1, const vec &v2, const vec &v3);$/;"	p	namespace:itpp	signature:(const vec &v1, const vec &v2, const vec &v3)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template vec concat(const vec &v1, const vec &v2, const vec &v3,$/;"	p	namespace:itpp	signature:(const vec &v1, const vec &v2, const vec &v3, const vec &v4, const vec &v5)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template vec concat(const vec &v1, const vec &v2,$/;"	p	namespace:itpp	signature:(const vec &v1, const vec &v2, const vec &v3, const vec &v4)
itpp::concat	/usr/include/itpp/base/vec.h	/^extern template vec concat(double a, const vec &v);$/;"	p	namespace:itpp	signature:(double a, const vec &v)
itpp::concat_horizontal	/usr/include/itpp/base/mat.h	/^Mat<Num_T> concat_horizontal(const Mat<Num_T> &m1, const Mat<Num_T> &m2)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::concat_horizontal	/usr/include/itpp/base/mat.h	/^Mat<Num_T> concat_horizontal(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::concat_horizontal	/usr/include/itpp/base/mat.h	/^extern template bmat concat_horizontal(const bmat &m1, const bmat &m2);$/;"	p	namespace:itpp	signature:(const bmat &m1, const bmat &m2)
itpp::concat_horizontal	/usr/include/itpp/base/mat.h	/^extern template cmat concat_horizontal(const cmat &m1, const cmat &m2);$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2)
itpp::concat_horizontal	/usr/include/itpp/base/mat.h	/^extern template imat concat_horizontal(const imat &m1, const imat &m2);$/;"	p	namespace:itpp	signature:(const imat &m1, const imat &m2)
itpp::concat_horizontal	/usr/include/itpp/base/mat.h	/^extern template mat concat_horizontal(const mat &m1, const mat &m2);$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2)
itpp::concat_horizontal	/usr/include/itpp/base/mat.h	/^extern template smat concat_horizontal(const smat &m1, const smat &m2);$/;"	p	namespace:itpp	signature:(const smat &m1, const smat &m2)
itpp::concat_vertical	/usr/include/itpp/base/mat.h	/^Mat<Num_T> concat_vertical(const Mat<Num_T> &m1, const Mat<Num_T> &m2)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::concat_vertical	/usr/include/itpp/base/mat.h	/^Mat<Num_T> concat_vertical(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::concat_vertical	/usr/include/itpp/base/mat.h	/^extern template bmat concat_vertical(const bmat &m1, const bmat &m2);$/;"	p	namespace:itpp	signature:(const bmat &m1, const bmat &m2)
itpp::concat_vertical	/usr/include/itpp/base/mat.h	/^extern template cmat concat_vertical(const cmat &m1, const cmat &m2);$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2)
itpp::concat_vertical	/usr/include/itpp/base/mat.h	/^extern template imat concat_vertical(const imat &m1, const imat &m2);$/;"	p	namespace:itpp	signature:(const imat &m1, const imat &m2)
itpp::concat_vertical	/usr/include/itpp/base/mat.h	/^extern template mat concat_vertical(const mat &m1, const mat &m2);$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2)
itpp::concat_vertical	/usr/include/itpp/base/mat.h	/^extern template smat concat_vertical(const smat &m1, const smat &m2);$/;"	p	namespace:itpp	signature:(const smat &m1, const smat &m2)
itpp::conference	/usr/include/itpp/base/specmat.h	/^imat conference(int n);$/;"	p	namespace:itpp	signature:(int n)
itpp::conj	/usr/include/itpp/base/math/elem_math.h	/^cmat conj(const cmat &x);$/;"	p	namespace:itpp	signature:(const cmat &x)
itpp::conj	/usr/include/itpp/base/math/elem_math.h	/^cvec conj(const cvec &x);$/;"	p	namespace:itpp	signature:(const cvec &x)
itpp::conj	/usr/include/itpp/base/math/elem_math.h	/^inline cmat conj(const cmat &x)$/;"	f	namespace:itpp	signature:(const cmat &x)
itpp::conj	/usr/include/itpp/base/math/elem_math.h	/^inline cvec conj(const cvec &x)$/;"	f	namespace:itpp	signature:(const cvec &x)
itpp::conj	/usr/include/itpp/fixed/fix_functions.h	/^CFix conj(const CFix &x);$/;"	p	namespace:itpp	signature:(const CFix &x)
itpp::copy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void copy_vector(const int n, const bin *x, bin *y) { memcpy(y, x, (unsigned int)n*sizeof(bin)); }$/;"	f	namespace:itpp	signature:(const int n, const bin *x, bin *y)
itpp::copy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void copy_vector(const int n, const double *x, const int incx,$/;"	f	namespace:itpp	signature:(const int n, const double *x, const int incx, double *y, const int incy)
itpp::copy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void copy_vector(const int n, const double *x, double *y) { memcpy(y, x, (unsigned int)n*sizeof(double)); }$/;"	f	namespace:itpp	signature:(const int n, const double *x, double *y)
itpp::copy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void copy_vector(const int n, const double *x, double *y)$/;"	f	namespace:itpp	signature:(const int n, const double *x, double *y)
itpp::copy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void copy_vector(const int n, const float *x, float *y) { memcpy(y, x, (unsigned int)n*sizeof(float)); }$/;"	f	namespace:itpp	signature:(const int n, const float *x, float *y)
itpp::copy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void copy_vector(const int n, const int *x, int *y) { memcpy(y, x, (unsigned int)n*sizeof(int)); }$/;"	f	namespace:itpp	signature:(const int n, const int *x, int *y)
itpp::copy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void copy_vector(const int n, const short *x, short *y) { memcpy(y, x, (unsigned int)n*sizeof(short)); }$/;"	f	namespace:itpp	signature:(const int n, const short *x, short *y)
itpp::copy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void copy_vector(const int n, const std::complex<double> *x, std::complex<double> *y) { memcpy(y, x, (unsigned int)n*sizeof(std::complex<double>)); }$/;"	f	namespace:itpp	signature:(const int n, const std::complex<double> *x, std::complex<double> *y)
itpp::copy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void copy_vector(const int n, const std::complex<double> *x,$/;"	f	namespace:itpp	signature:(const int n, const std::complex<double> *x, const int incx, std::complex<double> *y, const int incy)
itpp::copy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void copy_vector(const int n, const std::complex<double> *x,$/;"	f	namespace:itpp	signature:(const int n, const std::complex<double> *x, std::complex<double> *y)
itpp::copy_vector	/usr/include/itpp/base/copy_vector.h	/^inline void copy_vector(const int n, const std::complex<float> *x, std::complex<float> *y) { memcpy(y, x, (unsigned int)n*sizeof(std::complex<float>)); }$/;"	f	namespace:itpp	signature:(const int n, const std::complex<float> *x, std::complex<float> *y)
itpp::copy_vector	/usr/include/itpp/base/copy_vector.h	/^void copy_vector(const int n, const T *x, T *y)$/;"	f	namespace:itpp	signature:(const int n, const T *x, T *y)
itpp::copy_vector	/usr/include/itpp/base/copy_vector.h	/^void copy_vector(const int n, const T *x, const int incx, T *y, const int incy)$/;"	f	namespace:itpp	signature:(const int n, const T *x, const int incx, T *y, const int incy)
itpp::cos	/usr/include/itpp/base/math/trig_hyp.h	/^inline mat cos(const mat &x) { return apply_function<double>(std::cos, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::cos	/usr/include/itpp/base/math/trig_hyp.h	/^inline vec cos(const vec &x) { return apply_function<double>(std::cos, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::cosh	/usr/include/itpp/base/math/trig_hyp.h	/^inline mat cosh(const mat &x) { return apply_function<double>(std::cosh, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::cosh	/usr/include/itpp/base/math/trig_hyp.h	/^inline vec cosh(const vec &x) { return apply_function<double>(std::cosh, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::cov	/usr/include/itpp/signal/sigfun.h	/^mat cov(const mat &X, bool is_zero_mean = false);$/;"	p	namespace:itpp	signature:(const mat &X, bool is_zero_mean = false)
itpp::create_elements	/usr/include/itpp/base/factory.h	/^void create_elements(Array<T>* &ptr, int n, const Factory &f)$/;"	f	namespace:itpp	signature:(Array<T>* &ptr, int n, const Factory &f)
itpp::create_elements	/usr/include/itpp/base/factory.h	/^void create_elements(Mat<T>* &ptr, int n, const Factory &f)$/;"	f	namespace:itpp	signature:(Mat<T>* &ptr, int n, const Factory &f)
itpp::create_elements	/usr/include/itpp/base/factory.h	/^void create_elements(T* &ptr, int n, const Factory &)$/;"	f	namespace:itpp	signature:(T* &ptr, int n, const Factory &)
itpp::create_elements	/usr/include/itpp/base/factory.h	/^void create_elements(Vec<T>* &ptr, int n, const Factory &f)$/;"	f	namespace:itpp	signature:(Vec<T>* &ptr, int n, const Factory &f)
itpp::create_elements	/usr/include/itpp/base/factory.h	/^void create_elements<bin>(bin* &ptr, int n, const Factory &)$/;"	f	namespace:itpp	signature:(bin* &ptr, int n, const Factory &)
itpp::create_elements	/usr/include/itpp/base/factory.h	/^void create_elements<double>(double* &ptr, int n, const Factory &)$/;"	f	namespace:itpp	signature:(double* &ptr, int n, const Factory &)
itpp::create_elements	/usr/include/itpp/base/factory.h	/^void create_elements<int>(int* &ptr, int n, const Factory &)$/;"	f	namespace:itpp	signature:(int* &ptr, int n, const Factory &)
itpp::create_elements	/usr/include/itpp/base/factory.h	/^void create_elements<short int>(short int* &ptr, int n, const Factory &)$/;"	f	namespace:itpp	signature:(short int* &ptr, int n, const Factory &)
itpp::create_elements	/usr/include/itpp/base/factory.h	/^void create_elements<std::complex<double> >(std::complex<double>* &ptr,$/;"	f	namespace:itpp	signature:(std::complex<double>* &ptr, int n, const Factory &)
itpp::create_elements	/usr/include/itpp/base/factory.h	/^void create_elements<unsigned char>(unsigned char* &ptr, int n,$/;"	f	namespace:itpp	signature:(unsigned char* &ptr, int n, const Factory &)
itpp::create_elements	/usr/include/itpp/fixed/fix_factory.h	/^void create_elements<CFix>(CFix* &ptr, const int n, const Factory &f);$/;"	p	namespace:itpp	signature:(CFix* &ptr, const int n, const Factory &f)
itpp::create_elements	/usr/include/itpp/fixed/fix_factory.h	/^void create_elements<Fix>(Fix* &ptr, const int n, const Factory &f);$/;"	p	namespace:itpp	signature:(Fix* &ptr, const int n, const Factory &f)
itpp::cross	/usr/include/itpp/base/matfunc.h	/^Vec<T> cross(const Vec<T> &v1, const Vec<T> &v2)$/;"	f	namespace:itpp	signature:(const Vec<T> &v1, const Vec<T> &v2)
itpp::cross	/usr/include/itpp/base/matfunc.h	/^extern template bvec cross(const bvec &v1, const bvec &v2);$/;"	p	namespace:itpp	signature:(const bvec &v1, const bvec &v2)
itpp::cross	/usr/include/itpp/base/matfunc.h	/^extern template cvec cross(const cvec &v1, const cvec &v2);$/;"	p	namespace:itpp	signature:(const cvec &v1, const cvec &v2)
itpp::cross	/usr/include/itpp/base/matfunc.h	/^extern template ivec cross(const ivec &v1, const ivec &v2);$/;"	p	namespace:itpp	signature:(const ivec &v1, const ivec &v2)
itpp::cross	/usr/include/itpp/base/matfunc.h	/^extern template svec cross(const svec &v1, const svec &v2);$/;"	p	namespace:itpp	signature:(const svec &v1, const svec &v2)
itpp::cross	/usr/include/itpp/base/matfunc.h	/^extern template vec cross(const vec &v1, const vec &v2);$/;"	p	namespace:itpp	signature:(const vec &v1, const vec &v2)
itpp::cumsum	/usr/include/itpp/base/matfunc.h	/^Mat<T> cumsum(const Mat<T> &m, int dim = 1)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, int dim = 1)
itpp::cumsum	/usr/include/itpp/base/matfunc.h	/^Vec<T> cumsum(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
itpp::cumsum	/usr/include/itpp/base/matfunc.h	/^extern template bmat cumsum(const bmat &m, int dim);$/;"	p	namespace:itpp	signature:(const bmat &m, int dim)
itpp::cumsum	/usr/include/itpp/base/matfunc.h	/^extern template bvec cumsum(const bvec &v);$/;"	p	namespace:itpp	signature:(const bvec &v)
itpp::cumsum	/usr/include/itpp/base/matfunc.h	/^extern template cmat cumsum(const cmat &m, int dim);$/;"	p	namespace:itpp	signature:(const cmat &m, int dim)
itpp::cumsum	/usr/include/itpp/base/matfunc.h	/^extern template cvec cumsum(const cvec &v);$/;"	p	namespace:itpp	signature:(const cvec &v)
itpp::cumsum	/usr/include/itpp/base/matfunc.h	/^extern template imat cumsum(const imat &m, int dim);$/;"	p	namespace:itpp	signature:(const imat &m, int dim)
itpp::cumsum	/usr/include/itpp/base/matfunc.h	/^extern template ivec cumsum(const ivec &v);$/;"	p	namespace:itpp	signature:(const ivec &v)
itpp::cumsum	/usr/include/itpp/base/matfunc.h	/^extern template mat cumsum(const mat &m, int dim);$/;"	p	namespace:itpp	signature:(const mat &m, int dim)
itpp::cumsum	/usr/include/itpp/base/matfunc.h	/^extern template smat cumsum(const smat &m, int dim);$/;"	p	namespace:itpp	signature:(const smat &m, int dim)
itpp::cumsum	/usr/include/itpp/base/matfunc.h	/^extern template svec cumsum(const svec &v);$/;"	p	namespace:itpp	signature:(const svec &v)
itpp::cumsum	/usr/include/itpp/base/matfunc.h	/^extern template vec cumsum(const vec &v);$/;"	p	namespace:itpp	signature:(const vec &v)
itpp::cvec	/usr/include/itpp/base/vec.h	/^typedef Vec<std::complex<double> > cvec;$/;"	t	namespace:itpp
itpp::cvec2mxArray	/usr/include/itpp/itmex.h	/^void cvec2mxArray(const cvec &in, mxArray *out)$/;"	f	namespace:itpp	signature:(const cvec &in, mxArray *out)
itpp::cvec2mxArray	/usr/include/itpp/itmex.h	/^void cvec2mxArray(const cvec &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const cvec &in, mxArray *out)
itpp::cvectorize	/usr/include/itpp/base/matfunc.h	/^Vec<T> cvectorize(const Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
itpp::cvectorize	/usr/include/itpp/base/matfunc.h	/^extern template bvec cvectorize(const bmat &m);$/;"	p	namespace:itpp	signature:(const bmat &m)
itpp::cvectorize	/usr/include/itpp/base/matfunc.h	/^extern template cvec cvectorize(const cmat &m);$/;"	p	namespace:itpp	signature:(const cmat &m)
itpp::cvectorize	/usr/include/itpp/base/matfunc.h	/^extern template ivec cvectorize(const imat &m);$/;"	p	namespace:itpp	signature:(const imat &m)
itpp::cvectorize	/usr/include/itpp/base/matfunc.h	/^extern template svec cvectorize(const smat &m);$/;"	p	namespace:itpp	signature:(const smat &m)
itpp::cvectorize	/usr/include/itpp/base/matfunc.h	/^extern template vec cvectorize(const mat &m);$/;"	p	namespace:itpp	signature:(const mat &m)
itpp::dB	/usr/include/itpp/base/math/log_exp.h	/^inline double dB(double x) { return 10.0 * log10(x); }$/;"	f	namespace:itpp	signature:(double x)
itpp::dB	/usr/include/itpp/base/math/log_exp.h	/^inline mat dB(const mat &x)$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::dB	/usr/include/itpp/base/math/log_exp.h	/^inline vec dB(const vec &x)$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::dct	/usr/include/itpp/signal/transforms.h	/^vec dct(const vec &in);$/;"	p	namespace:itpp	signature:(const vec &in)
itpp::dct	/usr/include/itpp/signal/transforms.h	/^void dct(const vec &in, vec &out);$/;"	p	namespace:itpp	signature:(const vec &in, vec &out)
itpp::dec2bin	/usr/include/itpp/base/converters.h	/^bvec dec2bin(int index, bool msb_first = true);$/;"	p	namespace:itpp	signature:(int index, bool msb_first = true)
itpp::dec2bin	/usr/include/itpp/base/converters.h	/^bvec dec2bin(int length, int index);$/;"	p	namespace:itpp	signature:(int length, int index)
itpp::dec2bin	/usr/include/itpp/base/converters.h	/^void dec2bin(int index, bvec &v);$/;"	p	namespace:itpp	signature:(int index, bvec &v)
itpp::deg_to_rad	/usr/include/itpp/base/converters.h	/^inline double deg_to_rad(double x) { return (itpp::pi \/ 180.0 * x); }$/;"	f	namespace:itpp	signature:(double x)
itpp::destroy_elements	/usr/include/itpp/base/factory.h	/^void destroy_elements(T* &ptr, int n)$/;"	f	namespace:itpp	signature:(T* &ptr, int n)
itpp::destroy_elements	/usr/include/itpp/base/factory.h	/^void destroy_elements<bin>(bin* &ptr, int)$/;"	f	namespace:itpp	signature:(bin* &ptr, int)
itpp::destroy_elements	/usr/include/itpp/base/factory.h	/^void destroy_elements<double>(double* &ptr, int)$/;"	f	namespace:itpp	signature:(double* &ptr, int)
itpp::destroy_elements	/usr/include/itpp/base/factory.h	/^void destroy_elements<int>(int* &ptr, int)$/;"	f	namespace:itpp	signature:(int* &ptr, int)
itpp::destroy_elements	/usr/include/itpp/base/factory.h	/^void destroy_elements<short int>(short int* &ptr, int)$/;"	f	namespace:itpp	signature:(short int* &ptr, int)
itpp::destroy_elements	/usr/include/itpp/base/factory.h	/^void destroy_elements<std::complex<double> >(std::complex<double>* &ptr, int)$/;"	f	namespace:itpp	signature:(std::complex<double>* &ptr, int)
itpp::destroy_elements	/usr/include/itpp/base/factory.h	/^void destroy_elements<unsigned char>(unsigned char* &ptr, int)$/;"	f	namespace:itpp	signature:(unsigned char* &ptr, int)
itpp::det	/usr/include/itpp/base/algebra/det.h	/^double det(const mat &X);$/;"	p	namespace:itpp	signature:(const mat &X)
itpp::det	/usr/include/itpp/base/algebra/det.h	/^std::complex<double> det(const cmat &X);$/;"	p	namespace:itpp	signature:(const cmat &X)
itpp::dht	/usr/include/itpp/signal/transforms.h	/^Vec<T> dht(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
itpp::dht	/usr/include/itpp/signal/transforms.h	/^extern template cvec dht(const cvec &v);$/;"	p	namespace:itpp	signature:(const cvec &v)
itpp::dht	/usr/include/itpp/signal/transforms.h	/^extern template vec dht(const vec &v);$/;"	p	namespace:itpp	signature:(const vec &v)
itpp::dht	/usr/include/itpp/signal/transforms.h	/^extern template void dht(const cvec &vin, cvec &vout);$/;"	p	namespace:itpp	signature:(const cvec &vin, cvec &vout)
itpp::dht	/usr/include/itpp/signal/transforms.h	/^extern template void dht(const vec &vin, vec &vout);$/;"	p	namespace:itpp	signature:(const vec &vin, vec &vout)
itpp::dht	/usr/include/itpp/signal/transforms.h	/^template <class T> Vec<T> dht(const Vec<T> &v);$/;"	p	namespace:itpp	signature:(const Vec<T> &v)
itpp::dht	/usr/include/itpp/signal/transforms.h	/^template <class T> void dht(const Vec<T> &vin, Vec<T> &vout);$/;"	p	namespace:itpp	signature:(const Vec<T> &vin, Vec<T> &vout)
itpp::dht	/usr/include/itpp/signal/transforms.h	/^void dht(const Vec<T> &vin, Vec<T> &vout)$/;"	f	namespace:itpp	signature:(const Vec<T> &vin, Vec<T> &vout)
itpp::dht2	/usr/include/itpp/signal/transforms.h	/^Mat<T> dht2(const Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
itpp::dht2	/usr/include/itpp/signal/transforms.h	/^extern template cmat dht2(const cmat &m);$/;"	p	namespace:itpp	signature:(const cmat &m)
itpp::dht2	/usr/include/itpp/signal/transforms.h	/^extern template mat  dht2(const mat &m);$/;"	p	namespace:itpp	signature:(const mat &m)
itpp::dht2	/usr/include/itpp/signal/transforms.h	/^template <class T> Mat<T> dht2(const Mat<T> &m);$/;"	p	namespace:itpp	signature:(const Mat<T> &m)
itpp::diag	/usr/include/itpp/base/matfunc.h	/^Mat<T> diag(const Vec<T> &v, const int K = 0)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, const int K = 0)
itpp::diag	/usr/include/itpp/base/matfunc.h	/^Vec<T> diag(const Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
itpp::diag	/usr/include/itpp/base/matfunc.h	/^extern template cmat diag(const cvec &v, const int K);$/;"	p	namespace:itpp	signature:(const cvec &v, const int K)
itpp::diag	/usr/include/itpp/base/matfunc.h	/^extern template cvec diag(const cmat &in);$/;"	p	namespace:itpp	signature:(const cmat &in)
itpp::diag	/usr/include/itpp/base/matfunc.h	/^extern template mat diag(const vec &v, const int K);$/;"	p	namespace:itpp	signature:(const vec &v, const int K)
itpp::diag	/usr/include/itpp/base/matfunc.h	/^extern template vec diag(const mat &in);$/;"	p	namespace:itpp	signature:(const mat &in)
itpp::diag	/usr/include/itpp/base/matfunc.h	/^extern template void diag(const cvec &in, cmat &m);$/;"	p	namespace:itpp	signature:(const cvec &in, cmat &m)
itpp::diag	/usr/include/itpp/base/matfunc.h	/^extern template void diag(const vec &in, mat &m);$/;"	p	namespace:itpp	signature:(const vec &in, mat &m)
itpp::diag	/usr/include/itpp/base/matfunc.h	/^void diag(const Vec<T> &v, Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, Mat<T> &m)
itpp::divgfx	/usr/include/itpp/comm/galois.h	/^GFX divgfx(const GFX &c, const GFX &g);$/;"	p	namespace:itpp	signature:(const GFX &c, const GFX &g)
itpp::dot	/usr/include/itpp/base/vec.h	/^Num_T dot(const Vec<Num_T> &v1, const Vec<Num_T> &v2)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
itpp::dot	/usr/include/itpp/base/vec.h	/^Num_T dot(const Vec<Num_T> &v1, const Vec<Num_T> &v2);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
itpp::dot	/usr/include/itpp/base/vec.h	/^double dot(const vec &v1, const vec &v2)$/;"	f	namespace:itpp	signature:(const vec &v1, const vec &v2)
itpp::dot	/usr/include/itpp/base/vec.h	/^extern template bin dot(const bvec &v1, const bvec &v2);$/;"	p	namespace:itpp	signature:(const bvec &v1, const bvec &v2)
itpp::dot	/usr/include/itpp/base/vec.h	/^extern template double dot(const vec &v1, const vec &v2);$/;"	p	namespace:itpp	signature:(const vec &v1, const vec &v2)
itpp::dot	/usr/include/itpp/base/vec.h	/^extern template int dot(const ivec &v1, const ivec &v2);$/;"	p	namespace:itpp	signature:(const ivec &v1, const ivec &v2)
itpp::dot	/usr/include/itpp/base/vec.h	/^extern template short dot(const svec &v1, const svec &v2);$/;"	p	namespace:itpp	signature:(const svec &v1, const svec &v2)
itpp::dot	/usr/include/itpp/base/vec.h	/^extern template std::complex<double> dot(const cvec &v1, const cvec &v2);$/;"	p	namespace:itpp	signature:(const cvec &v1, const cvec &v2)
itpp::dot	/usr/include/itpp/base/vec.h	/^std::complex<double> dot(const cvec &v1, const cvec &v2)$/;"	f	namespace:itpp	signature:(const cvec &v1, const cvec &v2)
itpp::double2mxArray	/usr/include/itpp/itmex.h	/^void double2mxArray(const double &in, mxArray *out)$/;"	f	namespace:itpp	signature:(const double &in, mxArray *out)
itpp::double2mxArray	/usr/include/itpp/itmex.h	/^void double2mxArray(const double &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const double &in, mxArray *out)
itpp::double_complex2mxArray	/usr/include/itpp/itmex.h	/^void double_complex2mxArray(const std::complex<double> &in, mxArray *out)$/;"	f	namespace:itpp	signature:(const std::complex<double> &in, mxArray *out)
itpp::double_complex2mxArray	/usr/include/itpp/itmex.h	/^void double_complex2mxArray(const std::complex<double> &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const std::complex<double> &in, mxArray *out)
itpp::dwht	/usr/include/itpp/signal/transforms.h	/^Vec<T> dwht(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
itpp::dwht	/usr/include/itpp/signal/transforms.h	/^extern template cvec dwht(const cvec &v);$/;"	p	namespace:itpp	signature:(const cvec &v)
itpp::dwht	/usr/include/itpp/signal/transforms.h	/^extern template vec dwht(const vec &v);$/;"	p	namespace:itpp	signature:(const vec &v)
itpp::dwht	/usr/include/itpp/signal/transforms.h	/^extern template void dwht(const cvec &vin, cvec &vout);$/;"	p	namespace:itpp	signature:(const cvec &vin, cvec &vout)
itpp::dwht	/usr/include/itpp/signal/transforms.h	/^extern template void dwht(const vec &vin, vec &vout);$/;"	p	namespace:itpp	signature:(const vec &vin, vec &vout)
itpp::dwht	/usr/include/itpp/signal/transforms.h	/^template <class T> Vec<T> dwht(const Vec<T> &v);$/;"	p	namespace:itpp	signature:(const Vec<T> &v)
itpp::dwht	/usr/include/itpp/signal/transforms.h	/^template <class T> void dwht(const Vec<T> &vin, Vec<T> &vout);$/;"	p	namespace:itpp	signature:(const Vec<T> &vin, Vec<T> &vout)
itpp::dwht	/usr/include/itpp/signal/transforms.h	/^void dwht(const Vec<T> &vin, Vec<T> &vout)$/;"	f	namespace:itpp	signature:(const Vec<T> &vin, Vec<T> &vout)
itpp::dwht2	/usr/include/itpp/signal/transforms.h	/^Mat<T> dwht2(const Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
itpp::dwht2	/usr/include/itpp/signal/transforms.h	/^extern template cmat dwht2(const cmat &m);$/;"	p	namespace:itpp	signature:(const cmat &m)
itpp::dwht2	/usr/include/itpp/signal/transforms.h	/^extern template mat  dwht2(const mat &m);$/;"	p	namespace:itpp	signature:(const mat &m)
itpp::dwht2	/usr/include/itpp/signal/transforms.h	/^template <class T> Mat<T> dwht2(const Mat<T> &m);$/;"	p	namespace:itpp	signature:(const Mat<T> &m)
itpp::e_mode	/usr/include/itpp/fixed/fix_base.h	/^enum e_mode {$/;"	g	namespace:itpp
itpp::eig	/usr/include/itpp/base/algebra/eigen.h	/^bool eig(const cmat &A, cvec &d);$/;"	p	namespace:itpp	signature:(const cmat &A, cvec &d)
itpp::eig	/usr/include/itpp/base/algebra/eigen.h	/^bool eig(const cmat &A, cvec &d, cmat &V);$/;"	p	namespace:itpp	signature:(const cmat &A, cvec &d, cmat &V)
itpp::eig	/usr/include/itpp/base/algebra/eigen.h	/^bool eig(const mat &A, cvec &d);$/;"	p	namespace:itpp	signature:(const mat &A, cvec &d)
itpp::eig	/usr/include/itpp/base/algebra/eigen.h	/^bool eig(const mat &A, cvec &d, cmat &V);$/;"	p	namespace:itpp	signature:(const mat &A, cvec &d, cmat &V)
itpp::eig	/usr/include/itpp/base/algebra/eigen.h	/^cvec eig(const cmat &A);$/;"	p	namespace:itpp	signature:(const cmat &A)
itpp::eig	/usr/include/itpp/base/algebra/eigen.h	/^cvec eig(const mat &A);$/;"	p	namespace:itpp	signature:(const mat &A)
itpp::eig_sym	/usr/include/itpp/base/algebra/eigen.h	/^bool eig_sym(const cmat &A, vec &d);$/;"	p	namespace:itpp	signature:(const cmat &A, vec &d)
itpp::eig_sym	/usr/include/itpp/base/algebra/eigen.h	/^bool eig_sym(const cmat &A, vec &d, cmat &V);$/;"	p	namespace:itpp	signature:(const cmat &A, vec &d, cmat &V)
itpp::eig_sym	/usr/include/itpp/base/algebra/eigen.h	/^bool eig_sym(const mat &A, vec &d);$/;"	p	namespace:itpp	signature:(const mat &A, vec &d)
itpp::eig_sym	/usr/include/itpp/base/algebra/eigen.h	/^bool eig_sym(const mat &A, vec &d, mat &V);$/;"	p	namespace:itpp	signature:(const mat &A, vec &d, mat &V)
itpp::eig_sym	/usr/include/itpp/base/algebra/eigen.h	/^vec eig_sym(const cmat &A);$/;"	p	namespace:itpp	signature:(const cmat &A)
itpp::eig_sym	/usr/include/itpp/base/algebra/eigen.h	/^vec eig_sym(const mat &A);$/;"	p	namespace:itpp	signature:(const mat &A)
itpp::elem_div	/usr/include/itpp/base/mat.h	/^Mat<Num_T> elem_div(const Mat<Num_T> &m1, const Mat<Num_T> &m2)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::elem_div	/usr/include/itpp/base/mat.h	/^Mat<Num_T> elem_div(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::elem_div	/usr/include/itpp/base/mat.h	/^extern template bmat elem_div(const bmat &m1, const bmat &m2);$/;"	p	namespace:itpp	signature:(const bmat &m1, const bmat &m2)
itpp::elem_div	/usr/include/itpp/base/mat.h	/^extern template cmat elem_div(const cmat &m1, const cmat &m2);$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2)
itpp::elem_div	/usr/include/itpp/base/mat.h	/^extern template imat elem_div(const imat &m1, const imat &m2);$/;"	p	namespace:itpp	signature:(const imat &m1, const imat &m2)
itpp::elem_div	/usr/include/itpp/base/mat.h	/^extern template mat elem_div(const mat &m1, const mat &m2);$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2)
itpp::elem_div	/usr/include/itpp/base/mat.h	/^extern template smat elem_div(const smat &m1, const smat &m2);$/;"	p	namespace:itpp	signature:(const smat &m1, const smat &m2)
itpp::elem_div	/usr/include/itpp/base/vec.h	/^Vec<Num_T> elem_div(Num_T t, const Vec<Num_T> &v)$/;"	f	namespace:itpp	signature:(Num_T t, const Vec<Num_T> &v)
itpp::elem_div	/usr/include/itpp/base/vec.h	/^Vec<Num_T> elem_div(Num_T t, const Vec<Num_T> &v);$/;"	p	namespace:itpp	signature:(Num_T t, const Vec<Num_T> &v)
itpp::elem_div	/usr/include/itpp/base/vec.h	/^Vec<Num_T> elem_div(const Vec<Num_T> &a, const Vec<Num_T> &b)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b)
itpp::elem_div	/usr/include/itpp/base/vec.h	/^Vec<Num_T> elem_div(const Vec<Num_T> &a, const Vec<Num_T> &b);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b)
itpp::elem_div	/usr/include/itpp/base/vec.h	/^extern template bvec elem_div(bin t, const bvec &v);$/;"	p	namespace:itpp	signature:(bin t, const bvec &v)
itpp::elem_div	/usr/include/itpp/base/vec.h	/^extern template bvec elem_div(const bvec &a, const bvec &b);$/;"	p	namespace:itpp	signature:(const bvec &a, const bvec &b)
itpp::elem_div	/usr/include/itpp/base/vec.h	/^extern template cvec elem_div(const cvec &a, const cvec &b);$/;"	p	namespace:itpp	signature:(const cvec &a, const cvec &b)
itpp::elem_div	/usr/include/itpp/base/vec.h	/^extern template cvec elem_div(std::complex<double> t, const cvec &v);$/;"	p	namespace:itpp	signature:(std::complex<double> t, const cvec &v)
itpp::elem_div	/usr/include/itpp/base/vec.h	/^extern template ivec elem_div(const ivec &a, const ivec &b);$/;"	p	namespace:itpp	signature:(const ivec &a, const ivec &b)
itpp::elem_div	/usr/include/itpp/base/vec.h	/^extern template ivec elem_div(int t, const ivec &v);$/;"	p	namespace:itpp	signature:(int t, const ivec &v)
itpp::elem_div	/usr/include/itpp/base/vec.h	/^extern template svec elem_div(const svec &a, const svec &b);$/;"	p	namespace:itpp	signature:(const svec &a, const svec &b)
itpp::elem_div	/usr/include/itpp/base/vec.h	/^extern template svec elem_div(short t, const svec &v);$/;"	p	namespace:itpp	signature:(short t, const svec &v)
itpp::elem_div	/usr/include/itpp/base/vec.h	/^extern template vec elem_div(const vec &a, const vec &b);$/;"	p	namespace:itpp	signature:(const vec &a, const vec &b)
itpp::elem_div	/usr/include/itpp/base/vec.h	/^extern template vec elem_div(double t, const vec &v);$/;"	p	namespace:itpp	signature:(double t, const vec &v)
itpp::elem_div_out	/usr/include/itpp/base/mat.h	/^extern template void elem_div_out(const bmat &m1, const bmat &m2, bmat &out);$/;"	p	namespace:itpp	signature:(const bmat &m1, const bmat &m2, bmat &out)
itpp::elem_div_out	/usr/include/itpp/base/mat.h	/^extern template void elem_div_out(const cmat &m1, const cmat &m2, cmat &out);$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2, cmat &out)
itpp::elem_div_out	/usr/include/itpp/base/mat.h	/^extern template void elem_div_out(const imat &m1, const imat &m2, imat &out);$/;"	p	namespace:itpp	signature:(const imat &m1, const imat &m2, imat &out)
itpp::elem_div_out	/usr/include/itpp/base/mat.h	/^extern template void elem_div_out(const mat &m1, const mat &m2, mat &out);$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2, mat &out)
itpp::elem_div_out	/usr/include/itpp/base/mat.h	/^extern template void elem_div_out(const smat &m1, const smat &m2, smat &out);$/;"	p	namespace:itpp	signature:(const smat &m1, const smat &m2, smat &out)
itpp::elem_div_out	/usr/include/itpp/base/mat.h	/^void elem_div_out(const Mat<Num_T> &m1, const Mat<Num_T> &m2,$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2, Mat<Num_T> &out)
itpp::elem_div_out	/usr/include/itpp/base/mat.h	/^void elem_div_out(const Mat<Num_T> &m1, const Mat<Num_T> &m2,$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2, Mat<Num_T> &out)
itpp::elem_div_out	/usr/include/itpp/base/vec.h	/^extern template void elem_div_out(const bvec &a, const bvec &b, bvec &out);$/;"	p	namespace:itpp	signature:(const bvec &a, const bvec &b, bvec &out)
itpp::elem_div_out	/usr/include/itpp/base/vec.h	/^extern template void elem_div_out(const cvec &a, const cvec &b, cvec &out);$/;"	p	namespace:itpp	signature:(const cvec &a, const cvec &b, cvec &out)
itpp::elem_div_out	/usr/include/itpp/base/vec.h	/^extern template void elem_div_out(const ivec &a, const ivec &b, ivec &out);$/;"	p	namespace:itpp	signature:(const ivec &a, const ivec &b, ivec &out)
itpp::elem_div_out	/usr/include/itpp/base/vec.h	/^extern template void elem_div_out(const svec &a, const svec &b, svec &out);$/;"	p	namespace:itpp	signature:(const svec &a, const svec &b, svec &out)
itpp::elem_div_out	/usr/include/itpp/base/vec.h	/^extern template void elem_div_out(const vec &a, const vec &b, vec &out);$/;"	p	namespace:itpp	signature:(const vec &a, const vec &b, vec &out)
itpp::elem_div_out	/usr/include/itpp/base/vec.h	/^void elem_div_out(const Vec<Num_T> &a, const Vec<Num_T> &b, Vec<Num_T> &out)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, Vec<Num_T> &out)
itpp::elem_div_out	/usr/include/itpp/base/vec.h	/^void elem_div_out(const Vec<Num_T> &a, const Vec<Num_T> &b, Vec<Num_T> &out);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, Vec<Num_T> &out)
itpp::elem_div_sum	/usr/include/itpp/base/mat.h	/^Num_T elem_div_sum(const Mat<Num_T> &m1, const Mat<Num_T> &m2)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::elem_div_sum	/usr/include/itpp/base/mat.h	/^Num_T elem_div_sum(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::elem_div_sum	/usr/include/itpp/base/mat.h	/^extern template bin elem_div_sum(const bmat &m1, const bmat &m2);$/;"	p	namespace:itpp	signature:(const bmat &m1, const bmat &m2)
itpp::elem_div_sum	/usr/include/itpp/base/mat.h	/^extern template double elem_div_sum(const mat &m1, const mat &m2);$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2)
itpp::elem_div_sum	/usr/include/itpp/base/mat.h	/^extern template int elem_div_sum(const imat &m1, const imat &m2);$/;"	p	namespace:itpp	signature:(const imat &m1, const imat &m2)
itpp::elem_div_sum	/usr/include/itpp/base/mat.h	/^extern template short elem_div_sum(const smat &m1, const smat &m2);$/;"	p	namespace:itpp	signature:(const smat &m1, const smat &m2)
itpp::elem_div_sum	/usr/include/itpp/base/mat.h	/^extern template std::complex<double> elem_div_sum(const cmat &m1,$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2)
itpp::elem_div_sum	/usr/include/itpp/base/vec.h	/^Num_T elem_div_sum(const Vec<Num_T> &a, const Vec<Num_T> &b)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b)
itpp::elem_div_sum	/usr/include/itpp/base/vec.h	/^Num_T elem_div_sum(const Vec<Num_T> &a, const Vec<Num_T> &b);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b)
itpp::elem_div_sum	/usr/include/itpp/base/vec.h	/^extern template bin elem_div_sum(const bvec &a, const bvec &b);$/;"	p	namespace:itpp	signature:(const bvec &a, const bvec &b)
itpp::elem_div_sum	/usr/include/itpp/base/vec.h	/^extern template double elem_div_sum(const vec &a, const vec &b);$/;"	p	namespace:itpp	signature:(const vec &a, const vec &b)
itpp::elem_div_sum	/usr/include/itpp/base/vec.h	/^extern template int elem_div_sum(const ivec &a, const ivec &b);$/;"	p	namespace:itpp	signature:(const ivec &a, const ivec &b)
itpp::elem_div_sum	/usr/include/itpp/base/vec.h	/^extern template short elem_div_sum(const svec &a, const svec &b);$/;"	p	namespace:itpp	signature:(const svec &a, const svec &b)
itpp::elem_div_sum	/usr/include/itpp/base/vec.h	/^extern template std::complex<double> elem_div_sum(const cvec &a,$/;"	p	namespace:itpp	signature:(const cvec &a, const cvec &b)
itpp::elem_mult	/usr/include/itpp/base/mat.h	/^Mat<Num_T> elem_mult(const Mat<Num_T> &m1, const Mat<Num_T> &m2)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::elem_mult	/usr/include/itpp/base/mat.h	/^Mat<Num_T> elem_mult(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::elem_mult	/usr/include/itpp/base/mat.h	/^extern template bmat elem_mult(const bmat &m1, const bmat &m2);$/;"	p	namespace:itpp	signature:(const bmat &m1, const bmat &m2)
itpp::elem_mult	/usr/include/itpp/base/mat.h	/^extern template cmat elem_mult(const cmat &m1, const cmat &m2);$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2)
itpp::elem_mult	/usr/include/itpp/base/mat.h	/^extern template imat elem_mult(const imat &m1, const imat &m2);$/;"	p	namespace:itpp	signature:(const imat &m1, const imat &m2)
itpp::elem_mult	/usr/include/itpp/base/mat.h	/^extern template mat elem_mult(const mat &m1, const mat &m2);$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2)
itpp::elem_mult	/usr/include/itpp/base/mat.h	/^extern template smat elem_mult(const smat &m1, const smat &m2);$/;"	p	namespace:itpp	signature:(const smat &m1, const smat &m2)
itpp::elem_mult	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T> elem_mult(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2)$/;"	f	namespace:itpp	signature:(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2)
itpp::elem_mult	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T> elem_mult(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2);$/;"	p	namespace:itpp	signature:(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2)
itpp::elem_mult	/usr/include/itpp/base/svec.h	/^Vec<T> elem_mult(const Sparse_Vec<T> &v1, const Vec<T> &v2)$/;"	f	namespace:itpp	signature:(const Sparse_Vec<T> &v1, const Vec<T> &v2)
itpp::elem_mult	/usr/include/itpp/base/svec.h	/^Vec<T> elem_mult(const Sparse_Vec<T> &v1, const Vec<T> &v2);$/;"	p	namespace:itpp	signature:(const Sparse_Vec<T> &v1, const Vec<T> &v2)
itpp::elem_mult	/usr/include/itpp/base/svec.h	/^Vec<T> elem_mult(const Vec<T> &v1, const Sparse_Vec<T> &v2)$/;"	f	namespace:itpp	signature:(const Vec<T> &v1, const Sparse_Vec<T> &v2)
itpp::elem_mult	/usr/include/itpp/base/svec.h	/^Vec<T> elem_mult(const Vec<T> &v1, const Sparse_Vec<T> &v2);$/;"	p	namespace:itpp	signature:(const Vec<T> &v1, const Sparse_Vec<T> &v2)
itpp::elem_mult	/usr/include/itpp/base/svec.h	/^extern template cvec elem_mult(const cvec &, const sparse_cvec &);$/;"	p	namespace:itpp	signature:(const cvec &, const sparse_cvec &)
itpp::elem_mult	/usr/include/itpp/base/svec.h	/^extern template cvec elem_mult(const sparse_cvec &, const cvec &);$/;"	p	namespace:itpp	signature:(const sparse_cvec &, const cvec &)
itpp::elem_mult	/usr/include/itpp/base/svec.h	/^extern template ivec elem_mult(const ivec &, const sparse_ivec &);$/;"	p	namespace:itpp	signature:(const ivec &, const sparse_ivec &)
itpp::elem_mult	/usr/include/itpp/base/svec.h	/^extern template ivec elem_mult(const sparse_ivec &, const ivec &);$/;"	p	namespace:itpp	signature:(const sparse_ivec &, const ivec &)
itpp::elem_mult	/usr/include/itpp/base/svec.h	/^extern template sparse_cvec elem_mult(const sparse_cvec &,$/;"	p	namespace:itpp	signature:(const sparse_cvec &, const sparse_cvec &)
itpp::elem_mult	/usr/include/itpp/base/svec.h	/^extern template sparse_ivec elem_mult(const sparse_ivec &,$/;"	p	namespace:itpp	signature:(const sparse_ivec &, const sparse_ivec &)
itpp::elem_mult	/usr/include/itpp/base/svec.h	/^extern template sparse_vec elem_mult(const sparse_vec &, const sparse_vec &);$/;"	p	namespace:itpp	signature:(const sparse_vec &, const sparse_vec &)
itpp::elem_mult	/usr/include/itpp/base/svec.h	/^extern template vec elem_mult(const sparse_vec &, const vec &);$/;"	p	namespace:itpp	signature:(const sparse_vec &, const vec &)
itpp::elem_mult	/usr/include/itpp/base/svec.h	/^extern template vec elem_mult(const vec &, const sparse_vec &);$/;"	p	namespace:itpp	signature:(const vec &, const sparse_vec &)
itpp::elem_mult	/usr/include/itpp/base/vec.h	/^Vec<Num_T> elem_mult(const Vec<Num_T> &a, const Vec<Num_T> &b)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b)
itpp::elem_mult	/usr/include/itpp/base/vec.h	/^Vec<Num_T> elem_mult(const Vec<Num_T> &a, const Vec<Num_T> &b);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b)
itpp::elem_mult	/usr/include/itpp/base/vec.h	/^Vec<Num_T> elem_mult(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, const Vec<Num_T> &c)
itpp::elem_mult	/usr/include/itpp/base/vec.h	/^Vec<Num_T> elem_mult(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, const Vec<Num_T> &c, const Vec<Num_T> &d)
itpp::elem_mult	/usr/include/itpp/base/vec.h	/^Vec<Num_T> elem_mult(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, const Vec<Num_T> &c)
itpp::elem_mult	/usr/include/itpp/base/vec.h	/^Vec<Num_T> elem_mult(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, const Vec<Num_T> &c, const Vec<Num_T> &d)
itpp::elem_mult	/usr/include/itpp/base/vec.h	/^extern template bvec elem_mult(const bvec &a, const bvec &b);$/;"	p	namespace:itpp	signature:(const bvec &a, const bvec &b)
itpp::elem_mult	/usr/include/itpp/base/vec.h	/^extern template bvec elem_mult(const bvec &a, const bvec &b, const bvec &c);$/;"	p	namespace:itpp	signature:(const bvec &a, const bvec &b, const bvec &c)
itpp::elem_mult	/usr/include/itpp/base/vec.h	/^extern template bvec elem_mult(const bvec &a, const bvec &b,$/;"	p	namespace:itpp	signature:(const bvec &a, const bvec &b, const bvec &c, const bvec &d)
itpp::elem_mult	/usr/include/itpp/base/vec.h	/^extern template cvec elem_mult(const cvec &a, const cvec &b);$/;"	p	namespace:itpp	signature:(const cvec &a, const cvec &b)
itpp::elem_mult	/usr/include/itpp/base/vec.h	/^extern template cvec elem_mult(const cvec &a, const cvec &b, const cvec &c);$/;"	p	namespace:itpp	signature:(const cvec &a, const cvec &b, const cvec &c)
itpp::elem_mult	/usr/include/itpp/base/vec.h	/^extern template cvec elem_mult(const cvec &a, const cvec &b,$/;"	p	namespace:itpp	signature:(const cvec &a, const cvec &b, const cvec &c, const cvec &d)
itpp::elem_mult	/usr/include/itpp/base/vec.h	/^extern template ivec elem_mult(const ivec &a, const ivec &b);$/;"	p	namespace:itpp	signature:(const ivec &a, const ivec &b)
itpp::elem_mult	/usr/include/itpp/base/vec.h	/^extern template ivec elem_mult(const ivec &a, const ivec &b, const ivec &c);$/;"	p	namespace:itpp	signature:(const ivec &a, const ivec &b, const ivec &c)
itpp::elem_mult	/usr/include/itpp/base/vec.h	/^extern template ivec elem_mult(const ivec &a, const ivec &b,$/;"	p	namespace:itpp	signature:(const ivec &a, const ivec &b, const ivec &c, const ivec &d)
itpp::elem_mult	/usr/include/itpp/base/vec.h	/^extern template svec elem_mult(const svec &a, const svec &b);$/;"	p	namespace:itpp	signature:(const svec &a, const svec &b)
itpp::elem_mult	/usr/include/itpp/base/vec.h	/^extern template svec elem_mult(const svec &a, const svec &b, const svec &c);$/;"	p	namespace:itpp	signature:(const svec &a, const svec &b, const svec &c)
itpp::elem_mult	/usr/include/itpp/base/vec.h	/^extern template svec elem_mult(const svec &a, const svec &b,$/;"	p	namespace:itpp	signature:(const svec &a, const svec &b, const svec &c, const svec &d)
itpp::elem_mult	/usr/include/itpp/base/vec.h	/^extern template vec elem_mult(const vec &a, const vec &b);$/;"	p	namespace:itpp	signature:(const vec &a, const vec &b)
itpp::elem_mult	/usr/include/itpp/base/vec.h	/^extern template vec elem_mult(const vec &a, const vec &b, const vec &c);$/;"	p	namespace:itpp	signature:(const vec &a, const vec &b, const vec &c)
itpp::elem_mult	/usr/include/itpp/base/vec.h	/^extern template vec elem_mult(const vec &a, const vec &b,$/;"	p	namespace:itpp	signature:(const vec &a, const vec &b, const vec &c, const vec &d)
itpp::elem_mult_inplace	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_inplace(const bmat &m1, bmat &m2);$/;"	p	namespace:itpp	signature:(const bmat &m1, bmat &m2)
itpp::elem_mult_inplace	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_inplace(const cmat &m1, cmat &m2);$/;"	p	namespace:itpp	signature:(const cmat &m1, cmat &m2)
itpp::elem_mult_inplace	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_inplace(const imat &m1, imat &m2);$/;"	p	namespace:itpp	signature:(const imat &m1, imat &m2)
itpp::elem_mult_inplace	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_inplace(const mat &m1, mat &m2);$/;"	p	namespace:itpp	signature:(const mat &m1, mat &m2)
itpp::elem_mult_inplace	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_inplace(const smat &m1, smat &m2);$/;"	p	namespace:itpp	signature:(const smat &m1, smat &m2)
itpp::elem_mult_inplace	/usr/include/itpp/base/mat.h	/^void elem_mult_inplace(const Mat<Num_T> &m1, Mat<Num_T> &m2)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, Mat<Num_T> &m2)
itpp::elem_mult_inplace	/usr/include/itpp/base/mat.h	/^void elem_mult_inplace(const Mat<Num_T> &m1, Mat<Num_T> &m2);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, Mat<Num_T> &m2)
itpp::elem_mult_inplace	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_inplace(const bvec &a, bvec &b);$/;"	p	namespace:itpp	signature:(const bvec &a, bvec &b)
itpp::elem_mult_inplace	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_inplace(const cvec &a, cvec &b);$/;"	p	namespace:itpp	signature:(const cvec &a, cvec &b)
itpp::elem_mult_inplace	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_inplace(const ivec &a, ivec &b);$/;"	p	namespace:itpp	signature:(const ivec &a, ivec &b)
itpp::elem_mult_inplace	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_inplace(const svec &a, svec &b);$/;"	p	namespace:itpp	signature:(const svec &a, svec &b)
itpp::elem_mult_inplace	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_inplace(const vec &a, vec &b);$/;"	p	namespace:itpp	signature:(const vec &a, vec &b)
itpp::elem_mult_inplace	/usr/include/itpp/base/vec.h	/^void elem_mult_inplace(const Vec<Num_T> &a, Vec<Num_T> &b)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &a, Vec<Num_T> &b)
itpp::elem_mult_inplace	/usr/include/itpp/base/vec.h	/^void elem_mult_inplace(const Vec<Num_T> &a, Vec<Num_T> &b);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &a, Vec<Num_T> &b)
itpp::elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const bmat &m1, const bmat &m2,$/;"	p	namespace:itpp	signature:(const bmat &m1, const bmat &m2, bmat &out)
itpp::elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const bmat &m1, const bmat &m2,$/;"	p	namespace:itpp	signature:(const bmat &m1, const bmat &m2, const bmat &m3, bmat &out)
itpp::elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const bmat &m1, const bmat &m2,$/;"	p	namespace:itpp	signature:(const bmat &m1, const bmat &m2, const bmat &m3, const bmat &m4, bmat &out)
itpp::elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const cmat &m1, const cmat &m2,$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2, cmat &out)
itpp::elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const cmat &m1, const cmat &m2,$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2, const cmat &m3, cmat &out)
itpp::elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const cmat &m1, const cmat &m2,$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2, const cmat &m3, const cmat &m4, cmat &out)
itpp::elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const imat &m1, const imat &m2,$/;"	p	namespace:itpp	signature:(const imat &m1, const imat &m2, const imat &m3, const imat &m4, imat &out)
itpp::elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const imat &m1, const imat &m2,$/;"	p	namespace:itpp	signature:(const imat &m1, const imat &m2, const imat &m3, imat &out)
itpp::elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const imat &m1, const imat &m2,$/;"	p	namespace:itpp	signature:(const imat &m1, const imat &m2, imat &out)
itpp::elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const mat &m1, const mat &m2, mat &out);$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2, mat &out)
itpp::elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const mat &m1, const mat &m2,$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2, const mat &m3, const mat &m4, mat &out)
itpp::elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const mat &m1, const mat &m2,$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2, const mat &m3, mat &out)
itpp::elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const smat &m1, const smat &m2,$/;"	p	namespace:itpp	signature:(const smat &m1, const smat &m2, const smat &m3, const smat &m4, smat &out)
itpp::elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const smat &m1, const smat &m2,$/;"	p	namespace:itpp	signature:(const smat &m1, const smat &m2, const smat &m3, smat &out)
itpp::elem_mult_out	/usr/include/itpp/base/mat.h	/^extern template void elem_mult_out(const smat &m1, const smat &m2,$/;"	p	namespace:itpp	signature:(const smat &m1, const smat &m2, smat &out)
itpp::elem_mult_out	/usr/include/itpp/base/mat.h	/^void elem_mult_out(const Mat<Num_T> &m1, const Mat<Num_T> &m2,$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2, Mat<Num_T> &out)
itpp::elem_mult_out	/usr/include/itpp/base/mat.h	/^void elem_mult_out(const Mat<Num_T> &m1, const Mat<Num_T> &m2,$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2, const Mat<Num_T> &m3, Mat<Num_T> &out)
itpp::elem_mult_out	/usr/include/itpp/base/mat.h	/^void elem_mult_out(const Mat<Num_T> &m1, const Mat<Num_T> &m2,$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2, const Mat<Num_T> &m3, const Mat<Num_T> &m4, Mat<Num_T> &out)
itpp::elem_mult_out	/usr/include/itpp/base/mat.h	/^void elem_mult_out(const Mat<Num_T> &m1, const Mat<Num_T> &m2,$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2, Mat<Num_T> &out)
itpp::elem_mult_out	/usr/include/itpp/base/mat.h	/^void elem_mult_out(const Mat<Num_T> &m1, const Mat<Num_T> &m2,$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2, const Mat<Num_T> &m3, Mat<Num_T> &out)
itpp::elem_mult_out	/usr/include/itpp/base/mat.h	/^void elem_mult_out(const Mat<Num_T> &m1, const Mat<Num_T> &m2,$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2, const Mat<Num_T> &m3, const Mat<Num_T> &m4, Mat<Num_T> &out)
itpp::elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const bvec &a, const bvec &b, bvec &out);$/;"	p	namespace:itpp	signature:(const bvec &a, const bvec &b, bvec &out)
itpp::elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const bvec &a, const bvec &b,$/;"	p	namespace:itpp	signature:(const bvec &a, const bvec &b, const bvec &c, bvec &out)
itpp::elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const bvec &a, const bvec &b,$/;"	p	namespace:itpp	signature:(const bvec &a, const bvec &b, const bvec &c, const bvec &d, bvec &out)
itpp::elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const cvec &a, const cvec &b, cvec &out);$/;"	p	namespace:itpp	signature:(const cvec &a, const cvec &b, cvec &out)
itpp::elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const cvec &a, const cvec &b,$/;"	p	namespace:itpp	signature:(const cvec &a, const cvec &b, const cvec &c, const cvec &d, cvec &out)
itpp::elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const cvec &a, const cvec &b,$/;"	p	namespace:itpp	signature:(const cvec &a, const cvec &b, const cvec &c, cvec &out)
itpp::elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const ivec &a, const ivec &b, ivec &out);$/;"	p	namespace:itpp	signature:(const ivec &a, const ivec &b, ivec &out)
itpp::elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const ivec &a, const ivec &b,$/;"	p	namespace:itpp	signature:(const ivec &a, const ivec &b, const ivec &c, const ivec &d, ivec &out)
itpp::elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const ivec &a, const ivec &b,$/;"	p	namespace:itpp	signature:(const ivec &a, const ivec &b, const ivec &c, ivec &out)
itpp::elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const svec &a, const svec &b, svec &out);$/;"	p	namespace:itpp	signature:(const svec &a, const svec &b, svec &out)
itpp::elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const svec &a, const svec &b,$/;"	p	namespace:itpp	signature:(const svec &a, const svec &b, const svec &c, const svec &d, svec &out)
itpp::elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const svec &a, const svec &b,$/;"	p	namespace:itpp	signature:(const svec &a, const svec &b, const svec &c, svec &out)
itpp::elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const vec &a, const vec &b, const vec &c,$/;"	p	namespace:itpp	signature:(const vec &a, const vec &b, const vec &c, const vec &d, vec &out)
itpp::elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const vec &a, const vec &b, vec &out);$/;"	p	namespace:itpp	signature:(const vec &a, const vec &b, vec &out)
itpp::elem_mult_out	/usr/include/itpp/base/vec.h	/^extern template void elem_mult_out(const vec &a, const vec &b,$/;"	p	namespace:itpp	signature:(const vec &a, const vec &b, const vec &c, vec &out)
itpp::elem_mult_out	/usr/include/itpp/base/vec.h	/^void elem_mult_out(const Vec<Num_T> &a, const Vec<Num_T> &b, Vec<Num_T> &out)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, Vec<Num_T> &out)
itpp::elem_mult_out	/usr/include/itpp/base/vec.h	/^void elem_mult_out(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, const Vec<Num_T> &c, Vec<Num_T> &out)
itpp::elem_mult_out	/usr/include/itpp/base/vec.h	/^void elem_mult_out(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, const Vec<Num_T> &c, const Vec<Num_T> &d, Vec<Num_T> &out)
itpp::elem_mult_out	/usr/include/itpp/base/vec.h	/^void elem_mult_out(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, Vec<Num_T> &out)
itpp::elem_mult_out	/usr/include/itpp/base/vec.h	/^void elem_mult_out(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, const Vec<Num_T> &c, Vec<Num_T> &out)
itpp::elem_mult_out	/usr/include/itpp/base/vec.h	/^void elem_mult_out(const Vec<Num_T> &a, const Vec<Num_T> &b,$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b, const Vec<Num_T> &c, const Vec<Num_T> &d, Vec<Num_T> &out)
itpp::elem_mult_s	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T> elem_mult_s(const Sparse_Vec<T> &v1, const Vec<T> &v2)$/;"	f	namespace:itpp	signature:(const Sparse_Vec<T> &v1, const Vec<T> &v2)
itpp::elem_mult_s	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T> elem_mult_s(const Sparse_Vec<T> &v1, const Vec<T> &v2);$/;"	p	namespace:itpp	signature:(const Sparse_Vec<T> &v1, const Vec<T> &v2)
itpp::elem_mult_s	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T> elem_mult_s(const Vec<T> &v1, const Sparse_Vec<T> &v2)$/;"	f	namespace:itpp	signature:(const Vec<T> &v1, const Sparse_Vec<T> &v2)
itpp::elem_mult_s	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T> elem_mult_s(const Vec<T> &v1, const Sparse_Vec<T> &v2);$/;"	p	namespace:itpp	signature:(const Vec<T> &v1, const Sparse_Vec<T> &v2)
itpp::elem_mult_s	/usr/include/itpp/base/svec.h	/^extern template sparse_cvec elem_mult_s(const cvec &, const sparse_cvec &);$/;"	p	namespace:itpp	signature:(const cvec &, const sparse_cvec &)
itpp::elem_mult_s	/usr/include/itpp/base/svec.h	/^extern template sparse_cvec elem_mult_s(const sparse_cvec &, const cvec &);$/;"	p	namespace:itpp	signature:(const sparse_cvec &, const cvec &)
itpp::elem_mult_s	/usr/include/itpp/base/svec.h	/^extern template sparse_ivec elem_mult_s(const ivec &, const sparse_ivec &);$/;"	p	namespace:itpp	signature:(const ivec &, const sparse_ivec &)
itpp::elem_mult_s	/usr/include/itpp/base/svec.h	/^extern template sparse_ivec elem_mult_s(const sparse_ivec &, const ivec &);$/;"	p	namespace:itpp	signature:(const sparse_ivec &, const ivec &)
itpp::elem_mult_s	/usr/include/itpp/base/svec.h	/^extern template sparse_vec elem_mult_s(const sparse_vec &, const vec &);$/;"	p	namespace:itpp	signature:(const sparse_vec &, const vec &)
itpp::elem_mult_s	/usr/include/itpp/base/svec.h	/^extern template sparse_vec elem_mult_s(const vec &, const sparse_vec &);$/;"	p	namespace:itpp	signature:(const vec &, const sparse_vec &)
itpp::elem_mult_sum	/usr/include/itpp/base/mat.h	/^Num_T elem_mult_sum(const Mat<Num_T> &m1, const Mat<Num_T> &m2)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::elem_mult_sum	/usr/include/itpp/base/mat.h	/^Num_T elem_mult_sum(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::elem_mult_sum	/usr/include/itpp/base/mat.h	/^extern template bin elem_mult_sum(const bmat &m1, const bmat &m2);$/;"	p	namespace:itpp	signature:(const bmat &m1, const bmat &m2)
itpp::elem_mult_sum	/usr/include/itpp/base/mat.h	/^extern template double elem_mult_sum(const mat &m1, const mat &m2);$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2)
itpp::elem_mult_sum	/usr/include/itpp/base/mat.h	/^extern template int elem_mult_sum(const imat &m1, const imat &m2);$/;"	p	namespace:itpp	signature:(const imat &m1, const imat &m2)
itpp::elem_mult_sum	/usr/include/itpp/base/mat.h	/^extern template short elem_mult_sum(const smat &m1, const smat &m2);$/;"	p	namespace:itpp	signature:(const smat &m1, const smat &m2)
itpp::elem_mult_sum	/usr/include/itpp/base/mat.h	/^extern template std::complex<double> elem_mult_sum(const cmat &m1,$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2)
itpp::elem_mult_sum	/usr/include/itpp/base/vec.h	/^Num_T elem_mult_sum(const Vec<Num_T> &a, const Vec<Num_T> &b)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b)
itpp::elem_mult_sum	/usr/include/itpp/base/vec.h	/^Num_T elem_mult_sum(const Vec<Num_T> &a, const Vec<Num_T> &b);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &a, const Vec<Num_T> &b)
itpp::elem_mult_sum	/usr/include/itpp/base/vec.h	/^extern template bin elem_mult_sum(const bvec &a, const bvec &b);$/;"	p	namespace:itpp	signature:(const bvec &a, const bvec &b)
itpp::elem_mult_sum	/usr/include/itpp/base/vec.h	/^extern template double elem_mult_sum(const vec &a, const vec &b);$/;"	p	namespace:itpp	signature:(const vec &a, const vec &b)
itpp::elem_mult_sum	/usr/include/itpp/base/vec.h	/^extern template int elem_mult_sum(const ivec &a, const ivec &b);$/;"	p	namespace:itpp	signature:(const ivec &a, const ivec &b)
itpp::elem_mult_sum	/usr/include/itpp/base/vec.h	/^extern template short elem_mult_sum(const svec &a, const svec &b);$/;"	p	namespace:itpp	signature:(const svec &a, const svec &b)
itpp::elem_mult_sum	/usr/include/itpp/base/vec.h	/^extern template std::complex<double> elem_mult_sum(const cvec &a,$/;"	p	namespace:itpp	signature:(const cvec &a, const cvec &b)
itpp::energy	/usr/include/itpp/stat/misc_stat.h	/^double energy(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
itpp::eps	/usr/include/itpp/base/math/misc.h	/^const double eps = std::numeric_limits<double>::epsilon();$/;"	m	namespace:itpp
itpp::erf	/usr/include/itpp/base/math/error.h	/^inline cmat erf(const cmat &x)$/;"	f	namespace:itpp	signature:(const cmat &x)
itpp::erf	/usr/include/itpp/base/math/error.h	/^inline cvec erf(const cvec &x)$/;"	f	namespace:itpp	signature:(const cvec &x)
itpp::erf	/usr/include/itpp/base/math/error.h	/^inline mat erf(const mat &x)$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::erf	/usr/include/itpp/base/math/error.h	/^inline vec erf(const vec &x)$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::erf	/usr/include/itpp/base/math/error.h	/^std::complex<double> erf(const std::complex<double>& z);$/;"	p	namespace:itpp	signature:(const std::complex<double>& z)
itpp::erfc	/usr/include/itpp/base/math/error.h	/^inline mat erfc(const mat &x)$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::erfc	/usr/include/itpp/base/math/error.h	/^inline vec erfc(const vec &x)$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::erfinv	/usr/include/itpp/base/math/error.h	/^double erfinv(double x);$/;"	p	namespace:itpp	signature:(double x)
itpp::erfinv	/usr/include/itpp/base/math/error.h	/^inline mat erfinv(const mat &x)$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::erfinv	/usr/include/itpp/base/math/error.h	/^inline vec erfinv(const vec &x)$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::error_msg_style	/usr/include/itpp/base/itassert.h	/^enum error_msg_style { Full, Minimum };$/;"	g	namespace:itpp
itpp::exist	/usr/include/itpp/base/binfile.h	/^bool exist(const std::string& name);$/;"	p	namespace:itpp	signature:(const std::string& name)
itpp::exp	/usr/include/itpp/base/math/log_exp.h	/^inline cmat exp(const cmat &m)$/;"	f	namespace:itpp	signature:(const cmat &m)
itpp::exp	/usr/include/itpp/base/math/log_exp.h	/^inline cvec exp(const cvec &x)$/;"	f	namespace:itpp	signature:(const cvec &x)
itpp::exp	/usr/include/itpp/base/math/log_exp.h	/^inline mat exp(const mat &m)$/;"	f	namespace:itpp	signature:(const mat &m)
itpp::exp	/usr/include/itpp/base/math/log_exp.h	/^inline vec exp(const vec &x)$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::eye	/usr/include/itpp/base/specmat.h	/^mat eye(int size);$/;"	p	namespace:itpp	signature:(int size)
itpp::eye	/usr/include/itpp/base/specmat.h	/^void eye(int size, Mat<T> &m);$/;"	p	namespace:itpp	signature:(int size, Mat<T> &m)
itpp::eye_b	/usr/include/itpp/base/specmat.h	/^bmat eye_b(int size);$/;"	p	namespace:itpp	signature:(int size)
itpp::eye_c	/usr/include/itpp/base/specmat.h	/^cmat eye_c(int size);$/;"	p	namespace:itpp	signature:(int size)
itpp::eye_i	/usr/include/itpp/base/specmat.h	/^imat eye_i(int size);$/;"	p	namespace:itpp	signature:(int size)
itpp::fact	/usr/include/itpp/base/math/elem_math.h	/^double fact(int index);$/;"	p	namespace:itpp	signature:(int index)
itpp::fft	/usr/include/itpp/signal/transforms.h	/^cvec fft(const cvec &in);$/;"	p	namespace:itpp	signature:(const cvec &in)
itpp::fft	/usr/include/itpp/signal/transforms.h	/^cvec fft(const cvec &in, const int N);$/;"	p	namespace:itpp	signature:(const cvec &in, const int N)
itpp::fft	/usr/include/itpp/signal/transforms.h	/^void fft(const cvec &in, cvec &out);$/;"	p	namespace:itpp	signature:(const cvec &in, cvec &out)
itpp::fft_real	/usr/include/itpp/signal/transforms.h	/^cvec fft_real(const vec &in, const int N);$/;"	p	namespace:itpp	signature:(const vec &in, const int N)
itpp::fft_real	/usr/include/itpp/signal/transforms.h	/^cvec fft_real(const vec& in);$/;"	p	namespace:itpp	signature:(const vec& in)
itpp::fft_real	/usr/include/itpp/signal/transforms.h	/^void fft_real(const vec& in, cvec &out);$/;"	p	namespace:itpp	signature:(const vec& in, cvec &out)
itpp::filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const cvec &b, const cvec &a, const cvec &input);$/;"	p	namespace:itpp	signature:(const cvec &b, const cvec &a, const cvec &input)
itpp::filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const cvec &b, const cvec &a, const cvec &input, const cvec &state_in, cvec &state_out);$/;"	p	namespace:itpp	signature:(const cvec &b, const cvec &a, const cvec &input, const cvec &state_in, cvec &state_out)
itpp::filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const cvec &b, const cvec &a, const vec &input);$/;"	p	namespace:itpp	signature:(const cvec &b, const cvec &a, const vec &input)
itpp::filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const cvec &b, const cvec &a, const vec &input, const cvec &state_in, cvec &state_out);$/;"	p	namespace:itpp	signature:(const cvec &b, const cvec &a, const vec &input, const cvec &state_in, cvec &state_out)
itpp::filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const cvec &b, const int one, const cvec &input);$/;"	p	namespace:itpp	signature:(const cvec &b, const int one, const cvec &input)
itpp::filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const cvec &b, const int one, const cvec &input, const cvec &state_in, cvec &state_out);$/;"	p	namespace:itpp	signature:(const cvec &b, const int one, const cvec &input, const cvec &state_in, cvec &state_out)
itpp::filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const cvec &b, const int one, const vec &input);$/;"	p	namespace:itpp	signature:(const cvec &b, const int one, const vec &input)
itpp::filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const cvec &b, const int one, const vec &input, const cvec &state_in, cvec &state_out);$/;"	p	namespace:itpp	signature:(const cvec &b, const int one, const vec &input, const cvec &state_in, cvec &state_out)
itpp::filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const int one, const cvec &a, const cvec &input);$/;"	p	namespace:itpp	signature:(const int one, const cvec &a, const cvec &input)
itpp::filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const int one, const cvec &a, const cvec &input, const cvec &state_in, cvec &state_out);$/;"	p	namespace:itpp	signature:(const int one, const cvec &a, const cvec &input, const cvec &state_in, cvec &state_out)
itpp::filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const int one, const cvec &a, const vec &input);$/;"	p	namespace:itpp	signature:(const int one, const cvec &a, const vec &input)
itpp::filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const int one, const cvec &a, const vec &input, const cvec &state_in, cvec &state_out);$/;"	p	namespace:itpp	signature:(const int one, const cvec &a, const vec &input, const cvec &state_in, cvec &state_out)
itpp::filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const int one, const vec &a, const cvec &input);$/;"	p	namespace:itpp	signature:(const int one, const vec &a, const cvec &input)
itpp::filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const int one, const vec &a, const cvec &input, const cvec &state_in, cvec &state_out);$/;"	p	namespace:itpp	signature:(const int one, const vec &a, const cvec &input, const cvec &state_in, cvec &state_out)
itpp::filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const vec &b, const int one, const cvec &input);$/;"	p	namespace:itpp	signature:(const vec &b, const int one, const cvec &input)
itpp::filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const vec &b, const int one, const cvec &input, const cvec &state_in, cvec &state_out);$/;"	p	namespace:itpp	signature:(const vec &b, const int one, const cvec &input, const cvec &state_in, cvec &state_out)
itpp::filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const vec &b, const vec &a, const cvec &input);$/;"	p	namespace:itpp	signature:(const vec &b, const vec &a, const cvec &input)
itpp::filter	/usr/include/itpp/signal/filter.h	/^cvec filter(const vec &b, const vec &a, const cvec &input, const cvec &state_in, cvec &state_out);$/;"	p	namespace:itpp	signature:(const vec &b, const vec &a, const cvec &input, const cvec &state_in, cvec &state_out)
itpp::filter	/usr/include/itpp/signal/filter.h	/^vec filter(const int one, const vec &a, const vec &input);$/;"	p	namespace:itpp	signature:(const int one, const vec &a, const vec &input)
itpp::filter	/usr/include/itpp/signal/filter.h	/^vec filter(const int one, const vec &a, const vec &input, const vec &state_in, vec &state_out);$/;"	p	namespace:itpp	signature:(const int one, const vec &a, const vec &input, const vec &state_in, vec &state_out)
itpp::filter	/usr/include/itpp/signal/filter.h	/^vec filter(const vec &b, const int one, const vec &input);$/;"	p	namespace:itpp	signature:(const vec &b, const int one, const vec &input)
itpp::filter	/usr/include/itpp/signal/filter.h	/^vec filter(const vec &b, const int one, const vec &input, const vec &state_in, vec &state_out);$/;"	p	namespace:itpp	signature:(const vec &b, const int one, const vec &input, const vec &state_in, vec &state_out)
itpp::filter	/usr/include/itpp/signal/filter.h	/^vec filter(const vec &b, const vec &a, const vec &input);$/;"	p	namespace:itpp	signature:(const vec &b, const vec &a, const vec &input)
itpp::filter	/usr/include/itpp/signal/filter.h	/^vec filter(const vec &b, const vec &a, const vec &input, const vec &state_in, vec &state_out);$/;"	p	namespace:itpp	signature:(const vec &b, const vec &a, const vec &input, const vec &state_in, vec &state_out)
itpp::filter_design_autocorrelation	/usr/include/itpp/signal/filter_design.h	/^void filter_design_autocorrelation(const int N, const vec &f, const vec &m, vec &R);$/;"	p	namespace:itpp	signature:(const int N, const vec &f, const vec &m, vec &R)
itpp::filter_spectrum	/usr/include/itpp/signal/sigfun.h	/^vec filter_spectrum(const vec &a, const vec &b, int nfft = 256);$/;"	p	namespace:itpp	signature:(const vec &a, const vec &b, int nfft = 256)
itpp::filter_spectrum	/usr/include/itpp/signal/sigfun.h	/^vec filter_spectrum(const vec &a, int nfft = 256);$/;"	p	namespace:itpp	signature:(const vec &a, int nfft = 256)
itpp::find	/usr/include/itpp/base/specmat.h	/^ivec find(const bvec &invector);$/;"	p	namespace:itpp	signature:(const bvec &invector)
itpp::fir1	/usr/include/itpp/signal/filter.h	/^vec fir1(int N, double cutoff);$/;"	p	namespace:itpp	signature:(int N, double cutoff)
itpp::fixed1	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<1, TC, WRAP> fixed1;$/;"	t	namespace:itpp
itpp::fixed10	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<10, TC, WRAP> fixed10;$/;"	t	namespace:itpp
itpp::fixed11	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<11, TC, WRAP> fixed11;$/;"	t	namespace:itpp
itpp::fixed12	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<12, TC, WRAP> fixed12;$/;"	t	namespace:itpp
itpp::fixed13	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<13, TC, WRAP> fixed13;$/;"	t	namespace:itpp
itpp::fixed14	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<14, TC, WRAP> fixed14;$/;"	t	namespace:itpp
itpp::fixed15	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<15, TC, WRAP> fixed15;$/;"	t	namespace:itpp
itpp::fixed16	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<16, TC, WRAP> fixed16;$/;"	t	namespace:itpp
itpp::fixed17	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<17, TC, WRAP> fixed17;$/;"	t	namespace:itpp
itpp::fixed18	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<18, TC, WRAP> fixed18;$/;"	t	namespace:itpp
itpp::fixed19	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<19, TC, WRAP> fixed19;$/;"	t	namespace:itpp
itpp::fixed2	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<2, TC, WRAP> fixed2;$/;"	t	namespace:itpp
itpp::fixed20	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<20, TC, WRAP> fixed20;$/;"	t	namespace:itpp
itpp::fixed21	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<21, TC, WRAP> fixed21;$/;"	t	namespace:itpp
itpp::fixed22	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<22, TC, WRAP> fixed22;$/;"	t	namespace:itpp
itpp::fixed23	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<23, TC, WRAP> fixed23;$/;"	t	namespace:itpp
itpp::fixed24	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<24, TC, WRAP> fixed24;$/;"	t	namespace:itpp
itpp::fixed25	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<25, TC, WRAP> fixed25;$/;"	t	namespace:itpp
itpp::fixed26	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<26, TC, WRAP> fixed26;$/;"	t	namespace:itpp
itpp::fixed27	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<27, TC, WRAP> fixed27;$/;"	t	namespace:itpp
itpp::fixed28	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<28, TC, WRAP> fixed28;$/;"	t	namespace:itpp
itpp::fixed29	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<29, TC, WRAP> fixed29;$/;"	t	namespace:itpp
itpp::fixed3	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<3, TC, WRAP> fixed3;$/;"	t	namespace:itpp
itpp::fixed30	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<30, TC, WRAP> fixed30;$/;"	t	namespace:itpp
itpp::fixed31	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<31, TC, WRAP> fixed31;$/;"	t	namespace:itpp
itpp::fixed32	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<32, TC, WRAP> fixed32;$/;"	t	namespace:itpp
itpp::fixed33	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<33, TC, WRAP> fixed33;$/;"	t	namespace:itpp
itpp::fixed34	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<34, TC, WRAP> fixed34;$/;"	t	namespace:itpp
itpp::fixed35	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<35, TC, WRAP> fixed35;$/;"	t	namespace:itpp
itpp::fixed36	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<36, TC, WRAP> fixed36;$/;"	t	namespace:itpp
itpp::fixed37	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<37, TC, WRAP> fixed37;$/;"	t	namespace:itpp
itpp::fixed38	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<38, TC, WRAP> fixed38;$/;"	t	namespace:itpp
itpp::fixed39	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<39, TC, WRAP> fixed39;$/;"	t	namespace:itpp
itpp::fixed4	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<4, TC, WRAP> fixed4;$/;"	t	namespace:itpp
itpp::fixed40	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<40, TC, WRAP> fixed40;$/;"	t	namespace:itpp
itpp::fixed41	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<41, TC, WRAP> fixed41;$/;"	t	namespace:itpp
itpp::fixed42	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<42, TC, WRAP> fixed42;$/;"	t	namespace:itpp
itpp::fixed43	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<43, TC, WRAP> fixed43;$/;"	t	namespace:itpp
itpp::fixed44	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<44, TC, WRAP> fixed44;$/;"	t	namespace:itpp
itpp::fixed45	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<45, TC, WRAP> fixed45;$/;"	t	namespace:itpp
itpp::fixed46	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<46, TC, WRAP> fixed46;$/;"	t	namespace:itpp
itpp::fixed47	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<47, TC, WRAP> fixed47;$/;"	t	namespace:itpp
itpp::fixed48	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<48, TC, WRAP> fixed48;$/;"	t	namespace:itpp
itpp::fixed49	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<49, TC, WRAP> fixed49;$/;"	t	namespace:itpp
itpp::fixed5	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<5, TC, WRAP> fixed5;$/;"	t	namespace:itpp
itpp::fixed50	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<50, TC, WRAP> fixed50;$/;"	t	namespace:itpp
itpp::fixed51	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<51, TC, WRAP> fixed51;$/;"	t	namespace:itpp
itpp::fixed52	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<52, TC, WRAP> fixed52;$/;"	t	namespace:itpp
itpp::fixed53	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<53, TC, WRAP> fixed53;$/;"	t	namespace:itpp
itpp::fixed54	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<54, TC, WRAP> fixed54;$/;"	t	namespace:itpp
itpp::fixed55	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<55, TC, WRAP> fixed55;$/;"	t	namespace:itpp
itpp::fixed56	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<56, TC, WRAP> fixed56;$/;"	t	namespace:itpp
itpp::fixed57	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<57, TC, WRAP> fixed57;$/;"	t	namespace:itpp
itpp::fixed58	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<58, TC, WRAP> fixed58;$/;"	t	namespace:itpp
itpp::fixed59	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<59, TC, WRAP> fixed59;$/;"	t	namespace:itpp
itpp::fixed6	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<6, TC, WRAP> fixed6;$/;"	t	namespace:itpp
itpp::fixed60	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<60, TC, WRAP> fixed60;$/;"	t	namespace:itpp
itpp::fixed61	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<61, TC, WRAP> fixed61;$/;"	t	namespace:itpp
itpp::fixed62	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<62, TC, WRAP> fixed62;$/;"	t	namespace:itpp
itpp::fixed63	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<63, TC, WRAP> fixed63;$/;"	t	namespace:itpp
itpp::fixed64	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<64, TC, WRAP> fixed64;$/;"	t	namespace:itpp
itpp::fixed7	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<7, TC, WRAP> fixed7;$/;"	t	namespace:itpp
itpp::fixed8	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<8, TC, WRAP> fixed8;$/;"	t	namespace:itpp
itpp::fixed9	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<9, TC, WRAP> fixed9;$/;"	t	namespace:itpp
itpp::fixmat	/usr/include/itpp/fixed/fix.h	/^typedef Mat<Fix> fixmat;$/;"	t	namespace:itpp
itpp::fixmat::set	/usr/include/itpp/fixed/fix.h	/^template<> void fixmat::set(const char *values);$/;"	p	class:itpp::fixmat	signature:(const char *values)
itpp::fixrep	/usr/include/itpp/fixed/fix_base.h	/^typedef int64_t fixrep;$/;"	t	namespace:itpp
itpp::fixvec	/usr/include/itpp/fixed/fix.h	/^typedef Vec<Fix> fixvec;$/;"	t	namespace:itpp
itpp::fixvec::set	/usr/include/itpp/fixed/fix.h	/^template<> void fixvec::set(const char *values);$/;"	p	class:itpp::fixvec	signature:(const char *values)
itpp::floor	/usr/include/itpp/base/converters.h	/^inline mat floor(const mat &x) { return apply_function<double>(std::floor, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::floor	/usr/include/itpp/base/converters.h	/^inline vec floor(const vec &x) { return apply_function<double>(std::floor, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::floor_i	/usr/include/itpp/base/converters.h	/^imat floor_i(const mat &x);$/;"	p	namespace:itpp	signature:(const mat &x)
itpp::floor_i	/usr/include/itpp/base/converters.h	/^inline int floor_i(double x) { return static_cast<int>(std::floor(x)); }$/;"	f	namespace:itpp	signature:(double x)
itpp::floor_i	/usr/include/itpp/base/converters.h	/^ivec floor_i(const vec &x);$/;"	p	namespace:itpp	signature:(const vec &x)
itpp::flush	/usr/include/itpp/base/itfile.h	/^inline it_file& flush(it_file& f)$/;"	f	namespace:itpp	signature:(it_file& f)
itpp::flush	/usr/include/itpp/base/itfile.h	/^inline it_file_old& flush(it_file_old& f)$/;"	f	namespace:itpp	signature:(it_file_old& f)
itpp::fminunc	/usr/include/itpp/optim/newton_search.h	/^vec fminunc(double(*function)(const vec&), vec(*gradient)(const vec&), const vec &x0);$/;"	p	namespace:itpp	signature:(double(*function)(const vec&), vec(*gradient)(const vec&), const vec &x0)
itpp::forward_substitution	/usr/include/itpp/base/algebra/ls_solve.h	/^vec forward_substitution(const mat &L, const vec &b);$/;"	p	namespace:itpp	signature:(const mat &L, const vec &b)
itpp::forward_substitution	/usr/include/itpp/base/algebra/ls_solve.h	/^vec forward_substitution(const mat &L, int p, const vec &b);$/;"	p	namespace:itpp	signature:(const mat &L, int p, const vec &b)
itpp::forward_substitution	/usr/include/itpp/base/algebra/ls_solve.h	/^void forward_substitution(const mat &L, const vec &b, vec &x);$/;"	p	namespace:itpp	signature:(const mat &L, const vec &b, vec &x)
itpp::forward_substitution	/usr/include/itpp/base/algebra/ls_solve.h	/^void forward_substitution(const mat &L, int p, const vec &b, vec &x);$/;"	p	namespace:itpp	signature:(const mat &L, int p, const vec &b, vec &x)
itpp::freqz	/usr/include/itpp/signal/filter_design.h	/^cvec freqz(const cvec &b, const cvec& a, const int N = 512);$/;"	p	namespace:itpp	signature:(const cvec &b, const cvec& a, const int N = 512)
itpp::freqz	/usr/include/itpp/signal/filter_design.h	/^cvec freqz(const cvec &b, const cvec& a, const vec &w);$/;"	p	namespace:itpp	signature:(const cvec &b, const cvec& a, const vec &w)
itpp::freqz	/usr/include/itpp/signal/filter_design.h	/^cvec freqz(const vec &b, const vec& a, const int N = 512);$/;"	p	namespace:itpp	signature:(const vec &b, const vec& a, const int N = 512)
itpp::freqz	/usr/include/itpp/signal/filter_design.h	/^cvec freqz(const vec &b, const vec& a, const vec &w);$/;"	p	namespace:itpp	signature:(const vec &b, const vec& a, const vec &w)
itpp::freqz	/usr/include/itpp/signal/filter_design.h	/^void freqz(const cvec &b, const cvec& a, const int N, cvec &h, vec &w);$/;"	p	namespace:itpp	signature:(const cvec &b, const cvec& a, const int N, cvec &h, vec &w)
itpp::freqz	/usr/include/itpp/signal/filter_design.h	/^void freqz(const vec &b, const vec& a, const int N, cvec &h, vec &w);$/;"	p	namespace:itpp	signature:(const vec &b, const vec& a, const int N, cvec &h, vec &w)
itpp::full	/usr/include/itpp/base/smat.h	/^inline Mat<T> full(const Sparse_Mat<T> &s)$/;"	f	namespace:itpp	signature:(const Sparse_Mat<T> &s)
itpp::full	/usr/include/itpp/base/svec.h	/^inline Vec<T> full(const Sparse_Vec<T> &s)$/;"	f	namespace:itpp	signature:(const Sparse_Vec<T> &s)
itpp::gamma	/usr/include/itpp/base/math/elem_math.h	/^inline double gamma(double x) { return tgamma(x); }$/;"	f	namespace:itpp	signature:(double x)
itpp::gamma	/usr/include/itpp/base/math/elem_math.h	/^inline mat gamma(const mat &x) { return apply_function<double>(tgamma, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::gamma	/usr/include/itpp/base/math/elem_math.h	/^inline vec gamma(const vec &x) { return apply_function<double>(tgamma, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::gcd	/usr/include/itpp/base/math/elem_math.h	/^int gcd(int a, int b);$/;"	p	namespace:itpp	signature:(int a, int b)
itpp::geometric_mean	/usr/include/itpp/stat/misc_stat.h	/^double geometric_mean(const Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
itpp::geometric_mean	/usr/include/itpp/stat/misc_stat.h	/^double geometric_mean(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
itpp::gf2dense_eye	/usr/include/itpp/base/gf2mat.h	/^GF2mat gf2dense_eye(int m);$/;"	p	namespace:itpp	signature:(int m)
itpp::givens	/usr/include/itpp/base/specmat.h	/^mat givens(double a, double b);$/;"	p	namespace:itpp	signature:(double a, double b)
itpp::givens	/usr/include/itpp/base/specmat.h	/^void givens(double a, double b, double &c, double &s);$/;"	p	namespace:itpp	signature:(double a, double b, double &c, double &s)
itpp::givens	/usr/include/itpp/base/specmat.h	/^void givens(double a, double b, mat &m);$/;"	p	namespace:itpp	signature:(double a, double b, mat &m)
itpp::givens_t	/usr/include/itpp/base/specmat.h	/^mat givens_t(double a, double b);$/;"	p	namespace:itpp	signature:(double a, double b)
itpp::givens_t	/usr/include/itpp/base/specmat.h	/^void givens_t(double a, double b, mat &m);$/;"	p	namespace:itpp	signature:(double a, double b, mat &m)
itpp::gmmtrain	/usr/include/itpp/srccode/gmm.h	/^GMM gmmtrain(Array<vec> &TrainingData, int M, int NOITER = 30, bool VERBOSE = true);$/;"	p	namespace:itpp	signature:(Array<vec> &TrainingData, int M, int NOITER = 30, bool VERBOSE = true)
itpp::gray_code	/usr/include/itpp/base/converters.h	/^inline int gray_code(int x) { return x ^(x >> 1); }$/;"	f	namespace:itpp	signature:(int x)
itpp::graycode	/usr/include/itpp/comm/commfunc.h	/^bmat graycode(int m);$/;"	p	namespace:itpp	signature:(int m)
itpp::hadamard	/usr/include/itpp/base/specmat.h	/^imat hadamard(int size);$/;"	p	namespace:itpp	signature:(int size)
itpp::hamming	/usr/include/itpp/signal/window.h	/^vec hamming(int size);$/;"	p	namespace:itpp	signature:(int size)
itpp::hamming_distance	/usr/include/itpp/comm/commfunc.h	/^int hamming_distance(const bvec &a, const bvec &b);$/;"	p	namespace:itpp	signature:(const bvec &a, const bvec &b)
itpp::hann	/usr/include/itpp/signal/window.h	/^vec hann(int n);$/;"	p	namespace:itpp	signature:(int n)
itpp::hanning	/usr/include/itpp/signal/window.h	/^vec hanning(int n);$/;"	p	namespace:itpp	signature:(int n)
itpp::hermitian_transpose	/usr/include/itpp/base/matfunc.h	/^Mat<T> hermitian_transpose(const Mat<T> &m) { return m.H(); }$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
itpp::hermitian_transpose	/usr/include/itpp/base/matfunc.h	/^extern template bmat hermitian_transpose(const bmat &m);$/;"	p	namespace:itpp	signature:(const bmat &m)
itpp::hermitian_transpose	/usr/include/itpp/base/matfunc.h	/^extern template cmat hermitian_transpose(const cmat &m);$/;"	p	namespace:itpp	signature:(const cmat &m)
itpp::hermitian_transpose	/usr/include/itpp/base/matfunc.h	/^extern template imat hermitian_transpose(const imat &m);$/;"	p	namespace:itpp	signature:(const imat &m)
itpp::hermitian_transpose	/usr/include/itpp/base/matfunc.h	/^extern template mat hermitian_transpose(const mat &m);$/;"	p	namespace:itpp	signature:(const mat &m)
itpp::hermitian_transpose	/usr/include/itpp/base/matfunc.h	/^extern template smat hermitian_transpose(const smat &m);$/;"	p	namespace:itpp	signature:(const smat &m)
itpp::hermitian_transpose	/usr/include/itpp/base/matfunc.h	/^extern template void hermitian_transpose(const bmat &m, bmat &out);$/;"	p	namespace:itpp	signature:(const bmat &m, bmat &out)
itpp::hermitian_transpose	/usr/include/itpp/base/matfunc.h	/^extern template void hermitian_transpose(const cmat &m, cmat &out);$/;"	p	namespace:itpp	signature:(const cmat &m, cmat &out)
itpp::hermitian_transpose	/usr/include/itpp/base/matfunc.h	/^extern template void hermitian_transpose(const imat &m, imat &out);$/;"	p	namespace:itpp	signature:(const imat &m, imat &out)
itpp::hermitian_transpose	/usr/include/itpp/base/matfunc.h	/^extern template void hermitian_transpose(const mat &m, mat &out);$/;"	p	namespace:itpp	signature:(const mat &m, mat &out)
itpp::hermitian_transpose	/usr/include/itpp/base/matfunc.h	/^extern template void hermitian_transpose(const smat &m, smat &out);$/;"	p	namespace:itpp	signature:(const smat &m, smat &out)
itpp::hermitian_transpose	/usr/include/itpp/base/matfunc.h	/^void hermitian_transpose(const Mat<T> &m, Mat<T> &out) { out = m.H(); }$/;"	f	namespace:itpp	signature:(const Mat<T> &m, Mat<T> &out)
itpp::house	/usr/include/itpp/base/specmat.h	/^void house(const vec &x, vec &v, double &beta);$/;"	p	namespace:itpp	signature:(const vec &x, vec &v, double &beta)
itpp::idct	/usr/include/itpp/signal/transforms.h	/^vec idct(const vec &in);$/;"	p	namespace:itpp	signature:(const vec &in)
itpp::idct	/usr/include/itpp/signal/transforms.h	/^void idct(const vec &in, vec &out);$/;"	p	namespace:itpp	signature:(const vec &in, vec &out)
itpp::ifft	/usr/include/itpp/signal/transforms.h	/^cvec ifft(const cvec &in);$/;"	p	namespace:itpp	signature:(const cvec &in)
itpp::ifft	/usr/include/itpp/signal/transforms.h	/^cvec ifft(const cvec &in, const int N);$/;"	p	namespace:itpp	signature:(const cvec &in, const int N)
itpp::ifft	/usr/include/itpp/signal/transforms.h	/^void ifft(const cvec &in, cvec &out);$/;"	p	namespace:itpp	signature:(const cvec &in, cvec &out)
itpp::ifft_real	/usr/include/itpp/signal/transforms.h	/^vec ifft_real(const cvec &in);$/;"	p	namespace:itpp	signature:(const cvec &in)
itpp::ifft_real	/usr/include/itpp/signal/transforms.h	/^vec ifft_real(const cvec &in, const int N);$/;"	p	namespace:itpp	signature:(const cvec &in, const int N)
itpp::ifft_real	/usr/include/itpp/signal/transforms.h	/^void ifft_real(const cvec &in, vec &out);$/;"	p	namespace:itpp	signature:(const cvec &in, vec &out)
itpp::imag	/usr/include/itpp/base/math/elem_math.h	/^mat imag(const cmat &x);$/;"	p	namespace:itpp	signature:(const cmat &x)
itpp::imag	/usr/include/itpp/base/math/elem_math.h	/^vec imag(const cvec &x);$/;"	p	namespace:itpp	signature:(const cvec &x)
itpp::imag	/usr/include/itpp/fixed/fix_functions.h	/^Fix imag(const CFix &x);$/;"	p	namespace:itpp	signature:(const CFix &x)
itpp::imat	/usr/include/itpp/base/mat.h	/^typedef Mat<int> imat;$/;"	t	namespace:itpp
itpp::imat2mxArray	/usr/include/itpp/itmex.h	/^void imat2mxArray(const imat &in, mxArray *out)$/;"	f	namespace:itpp	signature:(const imat &in, mxArray *out)
itpp::imat2mxArray	/usr/include/itpp/itmex.h	/^void imat2mxArray(const imat &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const imat &in, mxArray *out)
itpp::img_double2int	/usr/include/itpp/srccode/pnm.h	/^imat img_double2int(const mat & m,$/;"	p	namespace:itpp	signature:(const mat & m, int max_val = 255, double double_min = 0 , double double_max = 1)
itpp::img_int2double	/usr/include/itpp/srccode/pnm.h	/^mat img_int2double(const imat & m,$/;"	p	namespace:itpp	signature:(const imat & m, int max_val = 255, double double_min = 0, double double_max = 1)
itpp::impulse	/usr/include/itpp/base/specmat.h	/^vec impulse(int size);$/;"	p	namespace:itpp	signature:(int size)
itpp::index_zero_pad	/usr/include/itpp/base/matfunc.h	/^T index_zero_pad(const Vec<T> &v, const int index)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, const int index)
itpp::int2bits	/usr/include/itpp/base/math/log_exp.h	/^inline int int2bits(int n)$/;"	f	namespace:itpp	signature:(int n)
itpp::int2bits	/usr/include/itpp/base/math/log_exp.h	/^inline ivec int2bits(const ivec& v)$/;"	f	namespace:itpp	signature:(const ivec& v)
itpp::int2mxArray	/usr/include/itpp/itmex.h	/^void int2mxArray(const int &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const int &in, mxArray *out)
itpp::interchange_permutations	/usr/include/itpp/base/algebra/lu.h	/^void interchange_permutations(vec &b, const ivec &p);$/;"	p	namespace:itpp	signature:(vec &b, const ivec &p)
itpp::inv	/usr/include/itpp/base/algebra/inv.h	/^bool inv(const cmat &X, cmat &Y);$/;"	p	namespace:itpp	signature:(const cmat &X, cmat &Y)
itpp::inv	/usr/include/itpp/base/algebra/inv.h	/^bool inv(const mat &X, mat &Y);$/;"	p	namespace:itpp	signature:(const mat &X, mat &Y)
itpp::inv	/usr/include/itpp/base/algebra/inv.h	/^cmat inv(const cmat &X);$/;"	p	namespace:itpp	signature:(const cmat &X)
itpp::inv	/usr/include/itpp/base/algebra/inv.h	/^mat inv(const mat &X);$/;"	p	namespace:itpp	signature:(const mat &X)
itpp::inv_dB	/usr/include/itpp/base/math/log_exp.h	/^inline double inv_dB(double x) { return pow(10.0, 0.1 * x); }$/;"	f	namespace:itpp	signature:(double x)
itpp::inv_dB	/usr/include/itpp/base/math/log_exp.h	/^inline mat inv_dB(const mat &x)$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::inv_dB	/usr/include/itpp/base/math/log_exp.h	/^inline vec inv_dB(const vec &x)$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::is2rc	/usr/include/itpp/srccode/lpcfunc.h	/^vec is2rc(const vec &is);$/;"	p	namespace:itpp	signature:(const vec &is)
itpp::is_even	/usr/include/itpp/base/math/misc.h	/^inline bool is_even(int x) { return ((x&1) == 0); }$/;"	f	namespace:itpp	signature:(int x)
itpp::is_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline bool is_fix(const CFix &) {return true;}$/;"	f	namespace:itpp	signature:(const CFix &)
itpp::is_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline bool is_fix(const Fix &) {return true;}$/;"	f	namespace:itpp	signature:(const Fix &)
itpp::is_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline bool is_fix(const cfixmat &) {return true;}$/;"	f	namespace:itpp	signature:(const cfixmat &)
itpp::is_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline bool is_fix(const cfixvec &) {return true;}$/;"	f	namespace:itpp	signature:(const cfixvec &)
itpp::is_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline bool is_fix(const fixmat &) {return true;}$/;"	f	namespace:itpp	signature:(const fixmat &)
itpp::is_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline bool is_fix(const fixvec &) {return true;}$/;"	f	namespace:itpp	signature:(const fixvec &)
itpp::is_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<class T> inline bool is_fix(const Array<T> &) {return is_fix(T());}$/;"	f	namespace:itpp	signature:(const Array<T> &)
itpp::is_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<class T> inline bool is_fix(const T &) {return false;}$/;"	f	namespace:itpp	signature:(const T &)
itpp::is_hermitian	/usr/include/itpp/base/matfunc.h	/^bool is_hermitian(const Mat<Num_T>& X)$/;"	f	namespace:itpp	signature:(const Mat<Num_T>& X)
itpp::is_hermitian	/usr/include/itpp/base/matfunc.h	/^extern template bool is_hermitian(const cmat &X);$/;"	p	namespace:itpp	signature:(const cmat &X)
itpp::is_hermitian	/usr/include/itpp/base/matfunc.h	/^extern template bool is_hermitian(const mat &X);$/;"	p	namespace:itpp	signature:(const mat &X)
itpp::is_int	/usr/include/itpp/base/math/misc.h	/^inline bool is_int(double x)$/;"	f	namespace:itpp	signature:(double x)
itpp::is_unitary	/usr/include/itpp/base/matfunc.h	/^bool is_unitary(const Mat<Num_T>& X)$/;"	f	namespace:itpp	signature:(const Mat<Num_T>& X)
itpp::is_unitary	/usr/include/itpp/base/matfunc.h	/^extern template bool is_unitary(const cmat &X);$/;"	p	namespace:itpp	signature:(const cmat &X)
itpp::is_unitary	/usr/include/itpp/base/matfunc.h	/^extern template bool is_unitary(const mat &X);$/;"	p	namespace:itpp	signature:(const mat &X)
itpp::it_assert_f	/usr/include/itpp/base/itassert.h	/^void it_assert_f(std::string ass, std::string msg, std::string file, int line);$/;"	p	namespace:itpp	signature:(std::string ass, std::string msg, std::string file, int line)
itpp::it_disable_warnings	/usr/include/itpp/base/itassert.h	/^void it_disable_warnings();$/;"	p	namespace:itpp	signature:()
itpp::it_enable_exceptions	/usr/include/itpp/base/itassert.h	/^void it_enable_exceptions(bool on);$/;"	p	namespace:itpp	signature:(bool on)
itpp::it_enable_warnings	/usr/include/itpp/base/itassert.h	/^void it_enable_warnings();$/;"	p	namespace:itpp	signature:()
itpp::it_error_f	/usr/include/itpp/base/itassert.h	/^void it_error_f(std::string msg, std::string file, int line);$/;"	p	namespace:itpp	signature:(std::string msg, std::string file, int line)
itpp::it_error_msg_style	/usr/include/itpp/base/itassert.h	/^void it_error_msg_style(error_msg_style style);$/;"	p	namespace:itpp	signature:(error_msg_style style)
itpp::it_file	/usr/include/itpp/base/itfile.h	/^class it_file : public it_ifile$/;"	c	namespace:itpp	inherits:it_ifile
itpp::it_file::close	/usr/include/itpp/base/itfile.h	/^  void close();$/;"	p	class:itpp::it_file	access:public	signature:()
itpp::it_file::exists	/usr/include/itpp/base/itfile.h	/^  bool exists(const std::string& name);$/;"	p	class:itpp::it_file	access:public	signature:(const std::string& name)
itpp::it_file::flush	/usr/include/itpp/base/itfile.h	/^  void flush();$/;"	p	class:itpp::it_file	access:public	signature:()
itpp::it_file::fname	/usr/include/itpp/base/itfile.h	/^  std::string fname;$/;"	m	class:itpp::it_file	access:private
itpp::it_file::get_low_precision	/usr/include/itpp/base/itfile.h	/^  bool get_low_precision() const { return low_prec; }$/;"	f	class:itpp::it_file	access:public	signature:() const
itpp::it_file::it_file	/usr/include/itpp/base/itfile.h	/^  explicit it_file(const std::string& filename, bool trunc = false);$/;"	p	class:itpp::it_file	access:public	signature:(const std::string& filename, bool trunc = false)
itpp::it_file::it_file	/usr/include/itpp/base/itfile.h	/^  it_file();$/;"	p	class:itpp::it_file	access:public	signature:()
itpp::it_file::it_manip	/usr/include/itpp/base/itfile.h	/^  typedef it_file& (*it_manip)(it_file&);$/;"	t	class:itpp::it_file	access:public
itpp::it_file::low_level	/usr/include/itpp/base/itfile.h	/^  bfstream& low_level() { return s; }$/;"	f	class:itpp::it_file	access:public	signature:()
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(bin x);$/;"	p	class:itpp::it_file	access:public	signature:(bin x)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(bool x);$/;"	p	class:itpp::it_file	access:public	signature:(bool x)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(char x);$/;"	p	class:itpp::it_file	access:public	signature:(char x)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const Array<bin>& v);$/;"	p	class:itpp::it_file	access:public	signature:(const Array<bin>& v)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const Array<double>& v);$/;"	p	class:itpp::it_file	access:public	signature:(const Array<double>& v)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const Array<float>& v);$/;"	p	class:itpp::it_file	access:public	signature:(const Array<float>& v)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const Array<int>& v);$/;"	p	class:itpp::it_file	access:public	signature:(const Array<int>& v)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const Array<short>& v);$/;"	p	class:itpp::it_file	access:public	signature:(const Array<short>& v)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const Array<std::complex<double> >& v);$/;"	p	class:itpp::it_file	access:public	signature:(const Array<std::complex<double> >& v)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const Array<std::complex<float> >& v);$/;"	p	class:itpp::it_file	access:public	signature:(const Array<std::complex<float> >& v)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const bmat& m);$/;"	p	class:itpp::it_file	access:public	signature:(const bmat& m)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const bvec& v);$/;"	p	class:itpp::it_file	access:public	signature:(const bvec& v)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const cmat& m);$/;"	p	class:itpp::it_file	access:public	signature:(const cmat& m)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const cvec& v);$/;"	p	class:itpp::it_file	access:public	signature:(const cvec& v)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const imat& m);$/;"	p	class:itpp::it_file	access:public	signature:(const imat& m)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const ivec& v);$/;"	p	class:itpp::it_file	access:public	signature:(const ivec& v)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const mat& m);$/;"	p	class:itpp::it_file	access:public	signature:(const mat& m)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const smat& m);$/;"	p	class:itpp::it_file	access:public	signature:(const smat& m)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const std::complex<double>& x);$/;"	p	class:itpp::it_file	access:public	signature:(const std::complex<double>& x)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const std::complex<float>& x);$/;"	p	class:itpp::it_file	access:public	signature:(const std::complex<float>& x)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const std::string& str);$/;"	p	class:itpp::it_file	access:public	signature:(const std::string& str)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const svec& v);$/;"	p	class:itpp::it_file	access:public	signature:(const svec& v)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const vec& v);$/;"	p	class:itpp::it_file	access:public	signature:(const vec& v)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(double x);$/;"	p	class:itpp::it_file	access:public	signature:(double x)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(float x);$/;"	p	class:itpp::it_file	access:public	signature:(float x)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(int x);$/;"	p	class:itpp::it_file	access:public	signature:(int x)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(short x);$/;"	p	class:itpp::it_file	access:public	signature:(short x)
itpp::it_file::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(uint64_t x);$/;"	p	class:itpp::it_file	access:public	signature:(uint64_t x)
itpp::it_file::low_prec	/usr/include/itpp/base/itfile.h	/^  bool low_prec;$/;"	m	class:itpp::it_file	access:protected
itpp::it_file::next_desc	/usr/include/itpp/base/itfile.h	/^  std::string next_desc;$/;"	m	class:itpp::it_file	access:protected
itpp::it_file::next_name	/usr/include/itpp/base/itfile.h	/^  std::string next_name;$/;"	m	class:itpp::it_file	access:protected
itpp::it_file::open	/usr/include/itpp/base/itfile.h	/^  void open(const std::string& filename, bool trunc = false);$/;"	p	class:itpp::it_file	access:public	signature:(const std::string& filename, bool trunc = false)
itpp::it_file::operator <<	/usr/include/itpp/base/itfile.h	/^  it_file& operator<<(it_manip func) { return (*func)(*this); }$/;"	f	class:itpp::it_file	access:public	signature:(it_manip func)
itpp::it_file::pack	/usr/include/itpp/base/itfile.h	/^  void pack();$/;"	p	class:itpp::it_file	access:public	signature:()
itpp::it_file::remove	/usr/include/itpp/base/itfile.h	/^  void remove();$/;"	p	class:itpp::it_file	access:protected	signature:()
itpp::it_file::remove	/usr/include/itpp/base/itfile.h	/^  void remove(const std::string& name);$/;"	p	class:itpp::it_file	access:public	signature:(const std::string& name)
itpp::it_file::set_low_precision	/usr/include/itpp/base/itfile.h	/^  void set_low_precision(bool p = true)  { low_prec = p; }$/;"	f	class:itpp::it_file	access:public	signature:(bool p = true)
itpp::it_file::set_next_name	/usr/include/itpp/base/itfile.h	/^  void set_next_name(const std::string& name,$/;"	f	class:itpp::it_file	access:public	signature:(const std::string& name, const std::string& description = Ó)
itpp::it_file::write_data_header	/usr/include/itpp/base/itfile.h	/^  void write_data_header(const std::string& type, const std::string& name,$/;"	p	class:itpp::it_file	access:public	signature:(const std::string& type, const std::string& name, uint64_t size, const std::string& description = Ó)
itpp::it_file::write_data_header	/usr/include/itpp/base/itfile.h	/^  void write_data_header(const std::string& type, uint64_t size);$/;"	p	class:itpp::it_file	access:public	signature:(const std::string& type, uint64_t size)
itpp::it_file::write_data_header_here	/usr/include/itpp/base/itfile.h	/^  void write_data_header_here(const data_header& h);$/;"	p	class:itpp::it_file	access:protected	signature:(const data_header& h)
itpp::it_file::write_file_header	/usr/include/itpp/base/itfile.h	/^  void write_file_header();$/;"	p	class:itpp::it_file	access:public	signature:()
itpp::it_file::~it_file	/usr/include/itpp/base/itfile.h	/^  virtual ~it_file() { }$/;"	f	class:itpp::it_file	access:public	signature:()
itpp::it_file_base	/usr/include/itpp/base/itfile.h	/^class it_file_base$/;"	c	namespace:itpp
itpp::it_file_base::data_header	/usr/include/itpp/base/itfile.h	/^  struct data_header {$/;"	s	class:itpp::it_file_base	access:public
itpp::it_file_base::data_header::block_bytes	/usr/include/itpp/base/itfile.h	/^    uint64_t block_bytes;$/;"	m	struct:itpp::it_file_base::data_header	access:public
itpp::it_file_base::data_header::data_bytes	/usr/include/itpp/base/itfile.h	/^    uint64_t data_bytes;$/;"	m	struct:itpp::it_file_base::data_header	access:public
itpp::it_file_base::data_header::desc	/usr/include/itpp/base/itfile.h	/^    std::string desc;$/;"	m	struct:itpp::it_file_base::data_header	access:public
itpp::it_file_base::data_header::hdr_bytes	/usr/include/itpp/base/itfile.h	/^    uint64_t hdr_bytes;$/;"	m	struct:itpp::it_file_base::data_header	access:public
itpp::it_file_base::data_header::name	/usr/include/itpp/base/itfile.h	/^    std::string name;$/;"	m	struct:itpp::it_file_base::data_header	access:public
itpp::it_file_base::data_header::type	/usr/include/itpp/base/itfile.h	/^    std::string type;$/;"	m	struct:itpp::it_file_base::data_header	access:public
itpp::it_file_base::file_header	/usr/include/itpp/base/itfile.h	/^  struct file_header {$/;"	s	class:itpp::it_file_base	access:protected
itpp::it_file_base::file_header::magic	/usr/include/itpp/base/itfile.h	/^    char magic[4];$/;"	m	struct:itpp::it_file_base::file_header	access:public
itpp::it_file_base::file_header::version	/usr/include/itpp/base/itfile.h	/^    char version;$/;"	m	struct:itpp::it_file_base::file_header	access:public
itpp::it_file_base::file_magic	/usr/include/itpp/base/itfile.h	/^  static char file_magic[4];$/;"	m	class:itpp::it_file_base	access:protected
itpp::it_file_base::file_version	/usr/include/itpp/base/itfile.h	/^  static char file_version;$/;"	m	class:itpp::it_file_base	access:protected
itpp::it_file_base_old	/usr/include/itpp/base/itfile.h	/^class it_file_base_old$/;"	c	namespace:itpp
itpp::it_file_base_old::data_header	/usr/include/itpp/base/itfile.h	/^  struct data_header {$/;"	s	class:itpp::it_file_base_old	access:public
itpp::it_file_base_old::data_header::block_bytes	/usr/include/itpp/base/itfile.h	/^    uint32_t hdr_bytes, data_bytes, block_bytes;$/;"	m	struct:itpp::it_file_base_old::data_header	access:public
itpp::it_file_base_old::data_header::data_bytes	/usr/include/itpp/base/itfile.h	/^    uint32_t hdr_bytes, data_bytes, block_bytes;$/;"	m	struct:itpp::it_file_base_old::data_header	access:public
itpp::it_file_base_old::data_header::endianity	/usr/include/itpp/base/itfile.h	/^    char endianity;$/;"	m	struct:itpp::it_file_base_old::data_header	access:public
itpp::it_file_base_old::data_header::hdr_bytes	/usr/include/itpp/base/itfile.h	/^    uint32_t hdr_bytes, data_bytes, block_bytes;$/;"	m	struct:itpp::it_file_base_old::data_header	access:public
itpp::it_file_base_old::data_header::name	/usr/include/itpp/base/itfile.h	/^    std::string name;$/;"	m	struct:itpp::it_file_base_old::data_header	access:public
itpp::it_file_base_old::data_header::type	/usr/include/itpp/base/itfile.h	/^    std::string type;$/;"	m	struct:itpp::it_file_base_old::data_header	access:public
itpp::it_file_base_old::file_header	/usr/include/itpp/base/itfile.h	/^  struct file_header {$/;"	s	class:itpp::it_file_base_old	access:protected
itpp::it_file_base_old::file_header::magic	/usr/include/itpp/base/itfile.h	/^    char magic[4];$/;"	m	struct:itpp::it_file_base_old::file_header	access:public
itpp::it_file_base_old::file_header::version	/usr/include/itpp/base/itfile.h	/^    char version;$/;"	m	struct:itpp::it_file_base_old::file_header	access:public
itpp::it_file_base_old::file_magic	/usr/include/itpp/base/itfile.h	/^  static char file_magic[4];$/;"	m	class:itpp::it_file_base_old	access:protected
itpp::it_file_base_old::file_version	/usr/include/itpp/base/itfile.h	/^  static char file_version;$/;"	m	class:itpp::it_file_base_old	access:protected
itpp::it_file_old	/usr/include/itpp/base/itfile.h	/^class it_file_old : public it_ifile_old$/;"	c	namespace:itpp	inherits:it_ifile_old
itpp::it_file_old::close	/usr/include/itpp/base/itfile.h	/^  void close();$/;"	p	class:itpp::it_file_old	access:public	signature:()
itpp::it_file_old::exists	/usr/include/itpp/base/itfile.h	/^  bool exists(const std::string& name);$/;"	p	class:itpp::it_file_old	access:public	signature:(const std::string& name)
itpp::it_file_old::flush	/usr/include/itpp/base/itfile.h	/^  void flush();$/;"	p	class:itpp::it_file_old	access:public	signature:()
itpp::it_file_old::get_low_precision	/usr/include/itpp/base/itfile.h	/^  bool get_low_precision() { return low_prec; }$/;"	f	class:itpp::it_file_old	access:public	signature:()
itpp::it_file_old::it_file_old	/usr/include/itpp/base/itfile.h	/^  explicit it_file_old(const std::string& name, bool trunc = false);$/;"	p	class:itpp::it_file_old	access:public	signature:(const std::string& name, bool trunc = false)
itpp::it_file_old::it_file_old	/usr/include/itpp/base/itfile.h	/^  it_file_old();$/;"	p	class:itpp::it_file_old	access:public	signature:()
itpp::it_file_old::it_manip	/usr/include/itpp/base/itfile.h	/^  typedef it_file_old& (*it_manip)(it_file_old&);$/;"	t	class:itpp::it_file_old	access:public
itpp::it_file_old::low_level	/usr/include/itpp/base/itfile.h	/^  bfstream& low_level() { return s; }$/;"	f	class:itpp::it_file_old	access:public	signature:()
itpp::it_file_old::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(bin x);$/;"	p	class:itpp::it_file_old	access:public	signature:(bin x)
itpp::it_file_old::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(char x);$/;"	p	class:itpp::it_file_old	access:public	signature:(char x)
itpp::it_file_old::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const Array<bin>& v);$/;"	p	class:itpp::it_file_old	access:public	signature:(const Array<bin>& v)
itpp::it_file_old::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const Array<double>& v);$/;"	p	class:itpp::it_file_old	access:public	signature:(const Array<double>& v)
itpp::it_file_old::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const Array<float>& v);$/;"	p	class:itpp::it_file_old	access:public	signature:(const Array<float>& v)
itpp::it_file_old::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const Array<int>& v);$/;"	p	class:itpp::it_file_old	access:public	signature:(const Array<int>& v)
itpp::it_file_old::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const Array<std::complex<double> >& v);$/;"	p	class:itpp::it_file_old	access:public	signature:(const Array<std::complex<double> >& v)
itpp::it_file_old::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const Array<std::complex<float> >& v);$/;"	p	class:itpp::it_file_old	access:public	signature:(const Array<std::complex<float> >& v)
itpp::it_file_old::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const bmat& m);$/;"	p	class:itpp::it_file_old	access:public	signature:(const bmat& m)
itpp::it_file_old::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const bvec& v);$/;"	p	class:itpp::it_file_old	access:public	signature:(const bvec& v)
itpp::it_file_old::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const cmat& m);$/;"	p	class:itpp::it_file_old	access:public	signature:(const cmat& m)
itpp::it_file_old::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const cvec& v);$/;"	p	class:itpp::it_file_old	access:public	signature:(const cvec& v)
itpp::it_file_old::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const imat& m);$/;"	p	class:itpp::it_file_old	access:public	signature:(const imat& m)
itpp::it_file_old::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const ivec& v);$/;"	p	class:itpp::it_file_old	access:public	signature:(const ivec& v)
itpp::it_file_old::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const mat& m);$/;"	p	class:itpp::it_file_old	access:public	signature:(const mat& m)
itpp::it_file_old::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const std::complex<double>& x);$/;"	p	class:itpp::it_file_old	access:public	signature:(const std::complex<double>& x)
itpp::it_file_old::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const std::complex<float>& x);$/;"	p	class:itpp::it_file_old	access:public	signature:(const std::complex<float>& x)
itpp::it_file_old::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const std::string& str);$/;"	p	class:itpp::it_file_old	access:public	signature:(const std::string& str)
itpp::it_file_old::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const vec& v);$/;"	p	class:itpp::it_file_old	access:public	signature:(const vec& v)
itpp::it_file_old::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(double x);$/;"	p	class:itpp::it_file_old	access:public	signature:(double x)
itpp::it_file_old::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(float x);$/;"	p	class:itpp::it_file_old	access:public	signature:(float x)
itpp::it_file_old::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(int x);$/;"	p	class:itpp::it_file_old	access:public	signature:(int x)
itpp::it_file_old::low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(short x);$/;"	p	class:itpp::it_file_old	access:public	signature:(short x)
itpp::it_file_old::low_prec	/usr/include/itpp/base/itfile.h	/^  bool low_prec;$/;"	m	class:itpp::it_file_old	access:protected
itpp::it_file_old::next_name	/usr/include/itpp/base/itfile.h	/^  std::string next_name;$/;"	m	class:itpp::it_file_old	access:protected
itpp::it_file_old::open	/usr/include/itpp/base/itfile.h	/^  void open(const std::string& name, bool trunc = false);$/;"	p	class:itpp::it_file_old	access:public	signature:(const std::string& name, bool trunc = false)
itpp::it_file_old::operator <<	/usr/include/itpp/base/itfile.h	/^  it_file_old& operator<<(it_manip func) { return (*func)(*this); }$/;"	f	class:itpp::it_file_old	access:public	signature:(it_manip func)
itpp::it_file_old::pack	/usr/include/itpp/base/itfile.h	/^  void pack();$/;"	p	class:itpp::it_file_old	access:public	signature:()
itpp::it_file_old::remove	/usr/include/itpp/base/itfile.h	/^  void remove();$/;"	p	class:itpp::it_file_old	access:protected	signature:()
itpp::it_file_old::remove	/usr/include/itpp/base/itfile.h	/^  void remove(const std::string& name);$/;"	p	class:itpp::it_file_old	access:public	signature:(const std::string& name)
itpp::it_file_old::set_low_precision	/usr/include/itpp/base/itfile.h	/^  void set_low_precision(bool p = true)  { low_prec = p; }$/;"	f	class:itpp::it_file_old	access:public	signature:(bool p = true)
itpp::it_file_old::set_next_name	/usr/include/itpp/base/itfile.h	/^  void set_next_name(const std::string& n) { next_name = n; }$/;"	f	class:itpp::it_file_old	access:public	signature:(const std::string& n)
itpp::it_file_old::write_data_header	/usr/include/itpp/base/itfile.h	/^  void write_data_header(const std::string& type, const std::string& name,$/;"	p	class:itpp::it_file_old	access:public	signature:(const std::string& type, const std::string& name, uint32_t size)
itpp::it_file_old::write_data_header	/usr/include/itpp/base/itfile.h	/^  void write_data_header(const std::string& type, uint32_t size);$/;"	p	class:itpp::it_file_old	access:public	signature:(const std::string& type, uint32_t size)
itpp::it_file_old::write_data_header_here	/usr/include/itpp/base/itfile.h	/^  void write_data_header_here(const data_header& h);$/;"	p	class:itpp::it_file_old	access:protected	signature:(const data_header& h)
itpp::it_file_old::write_file_header	/usr/include/itpp/base/itfile.h	/^  void write_file_header();$/;"	p	class:itpp::it_file_old	access:public	signature:()
itpp::it_file_old::~it_file_old	/usr/include/itpp/base/itfile.h	/^  virtual ~it_file_old() { }$/;"	f	class:itpp::it_file_old	access:public	signature:()
itpp::it_ifile	/usr/include/itpp/base/itfile.h	/^class it_ifile : public it_file_base$/;"	c	namespace:itpp	inherits:it_file_base
itpp::it_ifile::close	/usr/include/itpp/base/itfile.h	/^  virtual void close();$/;"	p	class:itpp::it_ifile	access:public	signature:()
itpp::it_ifile::info	/usr/include/itpp/base/itfile.h	/^  void info(std::string& name, std::string& type, std::string& desc,$/;"	p	class:itpp::it_ifile	access:public	signature:(std::string& name, std::string& type, std::string& desc, uint64_t& bytes)
itpp::it_ifile::it_ifile	/usr/include/itpp/base/itfile.h	/^  explicit it_ifile(const std::string& filename);$/;"	p	class:itpp::it_ifile	access:public	signature:(const std::string& filename)
itpp::it_ifile::it_ifile	/usr/include/itpp/base/itfile.h	/^  it_ifile();$/;"	p	class:itpp::it_ifile	access:public	signature:()
itpp::it_ifile::low_level	/usr/include/itpp/base/itfile.h	/^  bfstream& low_level() { return s; }$/;"	f	class:itpp::it_ifile	access:public	signature:()
itpp::it_ifile::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(Array<bin>& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(Array<bin>& v)
itpp::it_ifile::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(Array<float>& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(Array<float>& v)
itpp::it_ifile::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(Array<int>& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(Array<int>& v)
itpp::it_ifile::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(Array<short>& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(Array<short>& v)
itpp::it_ifile::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(Array<std::complex<float> >& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(Array<std::complex<float> >& v)
itpp::it_ifile::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(bin& x);$/;"	p	class:itpp::it_ifile	access:public	signature:(bin& x)
itpp::it_ifile::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(bmat& m);$/;"	p	class:itpp::it_ifile	access:public	signature:(bmat& m)
itpp::it_ifile::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(bool &x);$/;"	p	class:itpp::it_ifile	access:public	signature:(bool &x)
itpp::it_ifile::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(bvec& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(bvec& v)
itpp::it_ifile::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(char& x);$/;"	p	class:itpp::it_ifile	access:public	signature:(char& x)
itpp::it_ifile::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(double& x);$/;"	p	class:itpp::it_ifile	access:public	signature:(double& x)
itpp::it_ifile::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(float& x);$/;"	p	class:itpp::it_ifile	access:public	signature:(float& x)
itpp::it_ifile::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(imat& m);$/;"	p	class:itpp::it_ifile	access:public	signature:(imat& m)
itpp::it_ifile::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(int& x);$/;"	p	class:itpp::it_ifile	access:public	signature:(int& x)
itpp::it_ifile::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(ivec& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(ivec& v)
itpp::it_ifile::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(short& x);$/;"	p	class:itpp::it_ifile	access:public	signature:(short& x)
itpp::it_ifile::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(smat& m);$/;"	p	class:itpp::it_ifile	access:public	signature:(smat& m)
itpp::it_ifile::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(std::complex<double>& x);$/;"	p	class:itpp::it_ifile	access:public	signature:(std::complex<double>& x)
itpp::it_ifile::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(std::complex<float>& x);$/;"	p	class:itpp::it_ifile	access:public	signature:(std::complex<float>& x)
itpp::it_ifile::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(std::string& str);$/;"	p	class:itpp::it_ifile	access:public	signature:(std::string& str)
itpp::it_ifile::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(svec& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(svec& v)
itpp::it_ifile::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(uint64_t& x);$/;"	p	class:itpp::it_ifile	access:public	signature:(uint64_t& x)
itpp::it_ifile::low_level_read_hi	/usr/include/itpp/base/itfile.h	/^  void low_level_read_hi(Array<double>& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(Array<double>& v)
itpp::it_ifile::low_level_read_hi	/usr/include/itpp/base/itfile.h	/^  void low_level_read_hi(Array<std::complex<double> >& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(Array<std::complex<double> >& v)
itpp::it_ifile::low_level_read_hi	/usr/include/itpp/base/itfile.h	/^  void low_level_read_hi(cmat& m);$/;"	p	class:itpp::it_ifile	access:public	signature:(cmat& m)
itpp::it_ifile::low_level_read_hi	/usr/include/itpp/base/itfile.h	/^  void low_level_read_hi(cvec& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(cvec& v)
itpp::it_ifile::low_level_read_hi	/usr/include/itpp/base/itfile.h	/^  void low_level_read_hi(mat& m);$/;"	p	class:itpp::it_ifile	access:public	signature:(mat& m)
itpp::it_ifile::low_level_read_hi	/usr/include/itpp/base/itfile.h	/^  void low_level_read_hi(vec& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(vec& v)
itpp::it_ifile::low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(Array<double>& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(Array<double>& v)
itpp::it_ifile::low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(Array<std::complex<double> >& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(Array<std::complex<double> >& v)
itpp::it_ifile::low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(cmat& m);$/;"	p	class:itpp::it_ifile	access:public	signature:(cmat& m)
itpp::it_ifile::low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(cvec& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(cvec& v)
itpp::it_ifile::low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(mat& m);$/;"	p	class:itpp::it_ifile	access:public	signature:(mat& m)
itpp::it_ifile::low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(vec& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(vec& v)
itpp::it_ifile::open	/usr/include/itpp/base/itfile.h	/^  void open(const std::string& filename);$/;"	p	class:itpp::it_ifile	access:public	signature:(const std::string& filename)
itpp::it_ifile::read_check_file_header	/usr/include/itpp/base/itfile.h	/^  bool read_check_file_header();$/;"	p	class:itpp::it_ifile	access:public	signature:()
itpp::it_ifile::read_data_header	/usr/include/itpp/base/itfile.h	/^  void read_data_header(data_header& h);$/;"	p	class:itpp::it_ifile	access:public	signature:(data_header& h)
itpp::it_ifile::s	/usr/include/itpp/base/itfile.h	/^  bfstream s;$/;"	m	class:itpp::it_ifile	access:protected
itpp::it_ifile::seek	/usr/include/itpp/base/itfile.h	/^  bool seek(const std::string& name);$/;"	p	class:itpp::it_ifile	access:public	signature:(const std::string& name)
itpp::it_ifile::seek	/usr/include/itpp/base/itfile.h	/^  bool seek(int n);$/;"	p	class:itpp::it_ifile	access:public	signature:(int n)
itpp::it_ifile::~it_ifile	/usr/include/itpp/base/itfile.h	/^  virtual ~it_ifile() { }$/;"	f	class:itpp::it_ifile	access:public	signature:()
itpp::it_ifile_old	/usr/include/itpp/base/itfile.h	/^class it_ifile_old : public it_file_base_old$/;"	c	namespace:itpp	inherits:it_file_base_old
itpp::it_ifile_old::close	/usr/include/itpp/base/itfile.h	/^  virtual void close();$/;"	p	class:itpp::it_ifile_old	access:public	signature:()
itpp::it_ifile_old::info	/usr/include/itpp/base/itfile.h	/^  void info(std::string& name, std::string& type, int& bytes);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(std::string& name, std::string& type, int& bytes)
itpp::it_ifile_old::it_ifile_old	/usr/include/itpp/base/itfile.h	/^  explicit it_ifile_old(const std::string& name);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(const std::string& name)
itpp::it_ifile_old::it_ifile_old	/usr/include/itpp/base/itfile.h	/^  it_ifile_old();$/;"	p	class:itpp::it_ifile_old	access:public	signature:()
itpp::it_ifile_old::low_level	/usr/include/itpp/base/itfile.h	/^  bfstream& low_level() { return s; }$/;"	f	class:itpp::it_ifile_old	access:public	signature:()
itpp::it_ifile_old::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(Array<bin>& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(Array<bin>& v)
itpp::it_ifile_old::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(Array<int>& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(Array<int>& v)
itpp::it_ifile_old::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(bin& x);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(bin& x)
itpp::it_ifile_old::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(bmat& m);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(bmat& m)
itpp::it_ifile_old::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(bvec& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(bvec& v)
itpp::it_ifile_old::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(char& x);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(char& x)
itpp::it_ifile_old::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(double& x);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(double& x)
itpp::it_ifile_old::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(float& x);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(float& x)
itpp::it_ifile_old::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(imat& m);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(imat& m)
itpp::it_ifile_old::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(int& x);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(int& x)
itpp::it_ifile_old::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(ivec& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(ivec& v)
itpp::it_ifile_old::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(short& x);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(short& x)
itpp::it_ifile_old::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(std::complex<double>& x);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(std::complex<double>& x)
itpp::it_ifile_old::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(std::complex<float>& x);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(std::complex<float>& x)
itpp::it_ifile_old::low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(std::string& str);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(std::string& str)
itpp::it_ifile_old::low_level_read_hi	/usr/include/itpp/base/itfile.h	/^  void low_level_read_hi(Array<double>& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(Array<double>& v)
itpp::it_ifile_old::low_level_read_hi	/usr/include/itpp/base/itfile.h	/^  void low_level_read_hi(Array<std::complex<double> >& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(Array<std::complex<double> >& v)
itpp::it_ifile_old::low_level_read_hi	/usr/include/itpp/base/itfile.h	/^  void low_level_read_hi(cmat& m);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(cmat& m)
itpp::it_ifile_old::low_level_read_hi	/usr/include/itpp/base/itfile.h	/^  void low_level_read_hi(cvec& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(cvec& v)
itpp::it_ifile_old::low_level_read_hi	/usr/include/itpp/base/itfile.h	/^  void low_level_read_hi(mat& m);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(mat& m)
itpp::it_ifile_old::low_level_read_hi	/usr/include/itpp/base/itfile.h	/^  void low_level_read_hi(vec& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(vec& v)
itpp::it_ifile_old::low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(Array<double>& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(Array<double>& v)
itpp::it_ifile_old::low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(Array<float>& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(Array<float>& v)
itpp::it_ifile_old::low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(Array<std::complex<double> >& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(Array<std::complex<double> >& v)
itpp::it_ifile_old::low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(Array<std::complex<float> >& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(Array<std::complex<float> >& v)
itpp::it_ifile_old::low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(cmat& m);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(cmat& m)
itpp::it_ifile_old::low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(cvec& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(cvec& v)
itpp::it_ifile_old::low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(mat& m);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(mat& m)
itpp::it_ifile_old::low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(vec& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(vec& v)
itpp::it_ifile_old::open	/usr/include/itpp/base/itfile.h	/^  void open(const std::string& name);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(const std::string& name)
itpp::it_ifile_old::read_check_file_header	/usr/include/itpp/base/itfile.h	/^  bool read_check_file_header();$/;"	p	class:itpp::it_ifile_old	access:public	signature:()
itpp::it_ifile_old::read_data_header	/usr/include/itpp/base/itfile.h	/^  void read_data_header(data_header& h);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(data_header& h)
itpp::it_ifile_old::s	/usr/include/itpp/base/itfile.h	/^  bfstream s;$/;"	m	class:itpp::it_ifile_old	access:protected
itpp::it_ifile_old::seek	/usr/include/itpp/base/itfile.h	/^  bool seek(const std::string& name);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(const std::string& name)
itpp::it_ifile_old::seek	/usr/include/itpp/base/itfile.h	/^  bool seek(int n);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(int n)
itpp::it_ifile_old::~it_ifile_old	/usr/include/itpp/base/itfile.h	/^  virtual ~it_ifile_old() { }$/;"	f	class:itpp::it_ifile_old	access:public	signature:()
itpp::it_info_f	/usr/include/itpp/base/itassert.h	/^void it_info_f(std::string msg);$/;"	p	namespace:itpp	signature:(std::string msg)
itpp::it_load_var_as	/usr/include/itpp/base/itfile.h	/^void it_load_var_as(T& v, const std::string& name)$/;"	f	namespace:itpp	signature:(T& v, const std::string& name)
itpp::it_redirect_warnings	/usr/include/itpp/base/itassert.h	/^void it_redirect_warnings(std::ostream *warn_stream);$/;"	p	namespace:itpp	signature:(std::ostream *warn_stream)
itpp::it_save_var_as	/usr/include/itpp/base/itfile.h	/^void it_save_var_as(const T& v, const std::string& name)$/;"	f	namespace:itpp	signature:(const T& v, const std::string& name)
itpp::it_warning_f	/usr/include/itpp/base/itassert.h	/^void it_warning_f(std::string msg, std::string file, int line);$/;"	p	namespace:itpp	signature:(std::string msg, std::string file, int line)
itpp::itpp_version	/usr/include/itpp/base/math/misc.h	/^std::string itpp_version();$/;"	p	namespace:itpp	signature:()
itpp::ivec	/usr/include/itpp/base/vec.h	/^typedef Vec<int> ivec;$/;"	t	namespace:itpp
itpp::ivec2mxArray	/usr/include/itpp/itmex.h	/^void ivec2mxArray(const ivec &in, mxArray *out)$/;"	f	namespace:itpp	signature:(const ivec &in, mxArray *out)
itpp::ivec2mxArray	/usr/include/itpp/itmex.h	/^void ivec2mxArray(const ivec &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const ivec &in, mxArray *out)
itpp::jacobsthal	/usr/include/itpp/base/specmat.h	/^imat jacobsthal(int p);$/;"	p	namespace:itpp	signature:(int p)
itpp::kmeans	/usr/include/itpp/srccode/vqtrain.h	/^mat kmeans(Array<vec> &DB, int SIZE, int NOITER = 9999, bool VERBOSE = true);$/;"	p	namespace:itpp	signature:(Array<vec> &DB, int SIZE, int NOITER = 9999, bool VERBOSE = true)
itpp::kmeansiter	/usr/include/itpp/srccode/vqtrain.h	/^double kmeansiter(Array<vec> &DB, mat &codebook);$/;"	p	namespace:itpp	signature:(Array<vec> &DB, mat &codebook)
itpp::kron	/usr/include/itpp/base/matfunc.h	/^Mat<Num_T> kron(const Mat<Num_T>& X, const Mat<Num_T>& Y)$/;"	f	namespace:itpp	signature:(const Mat<Num_T>& X, const Mat<Num_T>& Y)
itpp::kron	/usr/include/itpp/base/matfunc.h	/^extern template bmat kron(const bmat &X, const bmat &Y);$/;"	p	namespace:itpp	signature:(const bmat &X, const bmat &Y)
itpp::kron	/usr/include/itpp/base/matfunc.h	/^extern template cmat kron(const cmat &X, const cmat &Y);$/;"	p	namespace:itpp	signature:(const cmat &X, const cmat &Y)
itpp::kron	/usr/include/itpp/base/matfunc.h	/^extern template imat kron(const imat &X, const imat &Y);$/;"	p	namespace:itpp	signature:(const imat &X, const imat &Y)
itpp::kron	/usr/include/itpp/base/matfunc.h	/^extern template mat kron(const mat &X, const mat &Y);$/;"	p	namespace:itpp	signature:(const mat &X, const mat &Y)
itpp::kron	/usr/include/itpp/base/matfunc.h	/^extern template smat kron(const smat &X, const smat &Y);$/;"	p	namespace:itpp	signature:(const smat &X, const smat &Y)
itpp::kurtosis	/usr/include/itpp/stat/misc_stat.h	/^inline double kurtosis(const vec &x) {return kurtosisexcess(x) + 3;}$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::kurtosisexcess	/usr/include/itpp/stat/misc_stat.h	/^double kurtosisexcess(const vec &x);$/;"	p	namespace:itpp	signature:(const vec &x)
itpp::lar2rc	/usr/include/itpp/srccode/lpcfunc.h	/^vec lar2rc(const vec &lar);$/;"	p	namespace:itpp	signature:(const vec &lar)
itpp::lbg	/usr/include/itpp/srccode/vqtrain.h	/^mat lbg(Array<vec> &DB, int SIZE, int NOITER = 9999, bool VERBOSE = true);$/;"	p	namespace:itpp	signature:(Array<vec> &DB, int SIZE, int NOITER = 9999, bool VERBOSE = true)
itpp::length	/usr/include/itpp/base/matfunc.h	/^extern template int length(const bvec &v);$/;"	p	namespace:itpp	signature:(const bvec &v)
itpp::length	/usr/include/itpp/base/matfunc.h	/^extern template int length(const cvec &v);$/;"	p	namespace:itpp	signature:(const cvec &v)
itpp::length	/usr/include/itpp/base/matfunc.h	/^extern template int length(const ivec &v);$/;"	p	namespace:itpp	signature:(const ivec &v)
itpp::length	/usr/include/itpp/base/matfunc.h	/^extern template int length(const svec &v);$/;"	p	namespace:itpp	signature:(const svec &v)
itpp::length	/usr/include/itpp/base/matfunc.h	/^extern template int length(const vec &v);$/;"	p	namespace:itpp	signature:(const vec &v)
itpp::length	/usr/include/itpp/base/matfunc.h	/^int length(const Vec<T> &v) { return v.length(); }$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
itpp::lerouxguegenrc	/usr/include/itpp/srccode/lpcfunc.h	/^vec lerouxguegenrc(const vec &R, int order);$/;"	p	namespace:itpp	signature:(const vec &R, int order)
itpp::levels2bits	/usr/include/itpp/base/math/log_exp.h	/^inline int levels2bits(int n)$/;"	f	namespace:itpp	signature:(int n)
itpp::levels2bits	/usr/include/itpp/base/math/log_exp.h	/^inline ivec levels2bits(const ivec& v)$/;"	f	namespace:itpp	signature:(const ivec& v)
itpp::levinson	/usr/include/itpp/srccode/lpcfunc.h	/^vec levinson(const vec &R2, int order);$/;"	p	namespace:itpp	signature:(const vec &R2, int order)
itpp::lininterp	/usr/include/itpp/signal/resampling.h	/^Mat<T> lininterp(const Mat<T> &m, double f_base, double f_ups,$/;"	f	namespace:itpp	signature:(const Mat<T> &m, double f_base, double f_ups, int nrof_samples, double t_start = 0)
itpp::lininterp	/usr/include/itpp/signal/resampling.h	/^Mat<T> lininterp(const Mat<T> &m, int usf)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, int usf)
itpp::lininterp	/usr/include/itpp/signal/resampling.h	/^Vec<T> lininterp(const Vec<T> &v, double f_base, double f_ups,$/;"	f	namespace:itpp	signature:(const Vec<T> &v, double f_base, double f_ups, int nrof_samples, double t_start = 0)
itpp::lininterp	/usr/include/itpp/signal/resampling.h	/^Vec<T> lininterp(const Vec<T> &v, int usf)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, int usf)
itpp::lininterp	/usr/include/itpp/signal/resampling.h	/^extern template cmat lininterp(const cmat &m, double f_base, double f_ups, int nrof_samples, double t_start);$/;"	p	namespace:itpp	signature:(const cmat &m, double f_base, double f_ups, int nrof_samples, double t_start)
itpp::lininterp	/usr/include/itpp/signal/resampling.h	/^extern template cmat lininterp(const cmat &v, int usf);$/;"	p	namespace:itpp	signature:(const cmat &v, int usf)
itpp::lininterp	/usr/include/itpp/signal/resampling.h	/^extern template cvec lininterp(const cvec &v, double f_base, double f_ups, int nrof_samples, double t_start);$/;"	p	namespace:itpp	signature:(const cvec &v, double f_base, double f_ups, int nrof_samples, double t_start)
itpp::lininterp	/usr/include/itpp/signal/resampling.h	/^extern template cvec lininterp(const cvec &v, int usf);$/;"	p	namespace:itpp	signature:(const cvec &v, int usf)
itpp::lininterp	/usr/include/itpp/signal/resampling.h	/^extern template mat lininterp(const mat &m, double f_base, double f_ups, int nrof_samples, double t_start);$/;"	p	namespace:itpp	signature:(const mat &m, double f_base, double f_ups, int nrof_samples, double t_start)
itpp::lininterp	/usr/include/itpp/signal/resampling.h	/^extern template mat lininterp(const mat &v, int usf);$/;"	p	namespace:itpp	signature:(const mat &v, int usf)
itpp::lininterp	/usr/include/itpp/signal/resampling.h	/^extern template vec lininterp(const vec &v, double f_base, double f_ups, int nrof_samples, double t_start);$/;"	p	namespace:itpp	signature:(const vec &v, double f_base, double f_ups, int nrof_samples, double t_start)
itpp::lininterp	/usr/include/itpp/signal/resampling.h	/^extern template vec lininterp(const vec &v, int usf);$/;"	p	namespace:itpp	signature:(const vec &v, int usf)
itpp::lininterp	/usr/include/itpp/signal/resampling.h	/^extern template void lininterp(const cmat &v, int usf,  cmat &u);$/;"	p	namespace:itpp	signature:(const cmat &v, int usf, cmat &u)
itpp::lininterp	/usr/include/itpp/signal/resampling.h	/^extern template void lininterp(const cvec &v, int usf,  cvec &u);$/;"	p	namespace:itpp	signature:(const cvec &v, int usf, cvec &u)
itpp::lininterp	/usr/include/itpp/signal/resampling.h	/^extern template void lininterp(const mat &v, int usf,  mat &u);$/;"	p	namespace:itpp	signature:(const mat &v, int usf, mat &u)
itpp::lininterp	/usr/include/itpp/signal/resampling.h	/^extern template void lininterp(const vec &v, int usf,  vec &u);$/;"	p	namespace:itpp	signature:(const vec &v, int usf, vec &u)
itpp::lininterp	/usr/include/itpp/signal/resampling.h	/^void lininterp(const Mat<T> &m, int usf, Mat<T> &u)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, int usf, Mat<T> &u)
itpp::lininterp	/usr/include/itpp/signal/resampling.h	/^void lininterp(const Vec<T> &v, int usf, Vec<T> &u)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, int usf, Vec<T> &u)
itpp::linspace	/usr/include/itpp/base/specmat.h	/^vec linspace(double from, double to, int length = 100);$/;"	p	namespace:itpp	signature:(double from, double to, int length = 100)
itpp::log	/usr/include/itpp/base/math/log_exp.h	/^inline cmat log(const cmat &x)$/;"	f	namespace:itpp	signature:(const cmat &x)
itpp::log	/usr/include/itpp/base/math/log_exp.h	/^inline cvec log(const cvec &x)$/;"	f	namespace:itpp	signature:(const cvec &x)
itpp::log	/usr/include/itpp/base/math/log_exp.h	/^inline mat log(const mat &x)$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::log	/usr/include/itpp/base/math/log_exp.h	/^inline vec log(const vec &x)$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::log10	/usr/include/itpp/base/math/log_exp.h	/^inline mat log10(const mat &x)$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::log10	/usr/include/itpp/base/math/log_exp.h	/^inline vec log10(const vec &x)$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::log2	/usr/include/itpp/base/math/log_exp.h	/^inline mat log2(const mat &x)$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::log2	/usr/include/itpp/base/math/log_exp.h	/^inline vec log2(const vec &x)$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::log_add	/usr/include/itpp/base/math/log_exp.h	/^inline double log_add(double log_a, double log_b)$/;"	f	namespace:itpp	signature:(double log_a, double log_b)
itpp::log_binom	/usr/include/itpp/base/math/elem_math.h	/^double log_binom(int n, int k);$/;"	p	namespace:itpp	signature:(int n, int k)
itpp::log_double_max	/usr/include/itpp/base/math/log_exp.h	/^const double log_double_max = std::log(std::numeric_limits<double>::max());$/;"	m	namespace:itpp
itpp::log_double_min	/usr/include/itpp/base/math/log_exp.h	/^const double log_double_min = std::log(std::numeric_limits<double>::min());$/;"	m	namespace:itpp
itpp::logb	/usr/include/itpp/base/math/log_exp.h	/^inline double logb(double b, double x)$/;"	f	namespace:itpp	signature:(double b, double x)
itpp::logb	/usr/include/itpp/base/math/log_exp.h	/^inline mat logb(double b, const mat &x)$/;"	f	namespace:itpp	signature:(double b, const mat &x)
itpp::logb	/usr/include/itpp/base/math/log_exp.h	/^inline vec logb(double b, const vec &x)$/;"	f	namespace:itpp	signature:(double b, const vec &x)
itpp::lpc	/usr/include/itpp/srccode/lpcfunc.h	/^vec lpc(const vec &x, int order);$/;"	p	namespace:itpp	signature:(const vec &x, int order)
itpp::ls_solve	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve(const cmat &A, const cmat &B, cmat &X);$/;"	p	namespace:itpp	signature:(const cmat &A, const cmat &B, cmat &X)
itpp::ls_solve	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve(const cmat &A, const cvec &b, cvec &x);$/;"	p	namespace:itpp	signature:(const cmat &A, const cvec &b, cvec &x)
itpp::ls_solve	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve(const mat &A, const mat &B, mat &X);$/;"	p	namespace:itpp	signature:(const mat &A, const mat &B, mat &X)
itpp::ls_solve	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve(const mat &A, const vec &b, vec &x);$/;"	p	namespace:itpp	signature:(const mat &A, const vec &b, vec &x)
itpp::ls_solve	/usr/include/itpp/base/algebra/ls_solve.h	/^cmat ls_solve(const cmat &A, const cmat &B);$/;"	p	namespace:itpp	signature:(const cmat &A, const cmat &B)
itpp::ls_solve	/usr/include/itpp/base/algebra/ls_solve.h	/^cvec ls_solve(const cmat &A, const cvec &b);$/;"	p	namespace:itpp	signature:(const cmat &A, const cvec &b)
itpp::ls_solve	/usr/include/itpp/base/algebra/ls_solve.h	/^mat ls_solve(const mat &A, const mat &B);$/;"	p	namespace:itpp	signature:(const mat &A, const mat &B)
itpp::ls_solve	/usr/include/itpp/base/algebra/ls_solve.h	/^vec ls_solve(const mat &A, const vec &b);$/;"	p	namespace:itpp	signature:(const mat &A, const vec &b)
itpp::ls_solve_chol	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve_chol(const cmat &A, const cmat &B, cmat &X);$/;"	p	namespace:itpp	signature:(const cmat &A, const cmat &B, cmat &X)
itpp::ls_solve_chol	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve_chol(const cmat &A, const cvec &b, cvec &x);$/;"	p	namespace:itpp	signature:(const cmat &A, const cvec &b, cvec &x)
itpp::ls_solve_chol	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve_chol(const mat &A, const mat &B, mat &X);$/;"	p	namespace:itpp	signature:(const mat &A, const mat &B, mat &X)
itpp::ls_solve_chol	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve_chol(const mat &A, const vec &b, vec &x);$/;"	p	namespace:itpp	signature:(const mat &A, const vec &b, vec &x)
itpp::ls_solve_chol	/usr/include/itpp/base/algebra/ls_solve.h	/^cmat ls_solve_chol(const cmat &A, const cmat &B);$/;"	p	namespace:itpp	signature:(const cmat &A, const cmat &B)
itpp::ls_solve_chol	/usr/include/itpp/base/algebra/ls_solve.h	/^cvec ls_solve_chol(const cmat &A, const cvec &b);$/;"	p	namespace:itpp	signature:(const cmat &A, const cvec &b)
itpp::ls_solve_chol	/usr/include/itpp/base/algebra/ls_solve.h	/^mat ls_solve_chol(const mat &A, const mat &B);$/;"	p	namespace:itpp	signature:(const mat &A, const mat &B)
itpp::ls_solve_chol	/usr/include/itpp/base/algebra/ls_solve.h	/^vec ls_solve_chol(const mat &A, const vec &b);$/;"	p	namespace:itpp	signature:(const mat &A, const vec &b)
itpp::ls_solve_od	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve_od(const cmat &A, const cmat &B, cmat &X);$/;"	p	namespace:itpp	signature:(const cmat &A, const cmat &B, cmat &X)
itpp::ls_solve_od	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve_od(const cmat &A, const cvec &b, cvec &x);$/;"	p	namespace:itpp	signature:(const cmat &A, const cvec &b, cvec &x)
itpp::ls_solve_od	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve_od(const mat &A, const mat &B, mat &X);$/;"	p	namespace:itpp	signature:(const mat &A, const mat &B, mat &X)
itpp::ls_solve_od	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve_od(const mat &A, const vec &b, vec &x);$/;"	p	namespace:itpp	signature:(const mat &A, const vec &b, vec &x)
itpp::ls_solve_od	/usr/include/itpp/base/algebra/ls_solve.h	/^cmat ls_solve_od(const cmat &A, const cmat &B);$/;"	p	namespace:itpp	signature:(const cmat &A, const cmat &B)
itpp::ls_solve_od	/usr/include/itpp/base/algebra/ls_solve.h	/^cvec ls_solve_od(const cmat &A, const cvec &b);$/;"	p	namespace:itpp	signature:(const cmat &A, const cvec &b)
itpp::ls_solve_od	/usr/include/itpp/base/algebra/ls_solve.h	/^mat ls_solve_od(const mat &A, const mat &B);$/;"	p	namespace:itpp	signature:(const mat &A, const mat &B)
itpp::ls_solve_od	/usr/include/itpp/base/algebra/ls_solve.h	/^vec ls_solve_od(const mat &A, const vec &b);$/;"	p	namespace:itpp	signature:(const mat &A, const vec &b)
itpp::ls_solve_ud	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve_ud(const cmat &A, const cmat &B, cmat &X);$/;"	p	namespace:itpp	signature:(const cmat &A, const cmat &B, cmat &X)
itpp::ls_solve_ud	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve_ud(const cmat &A, const cvec &b, cvec &x);$/;"	p	namespace:itpp	signature:(const cmat &A, const cvec &b, cvec &x)
itpp::ls_solve_ud	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve_ud(const mat &A, const mat &B, mat &X);$/;"	p	namespace:itpp	signature:(const mat &A, const mat &B, mat &X)
itpp::ls_solve_ud	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve_ud(const mat &A, const vec &b, vec &x);$/;"	p	namespace:itpp	signature:(const mat &A, const vec &b, vec &x)
itpp::ls_solve_ud	/usr/include/itpp/base/algebra/ls_solve.h	/^cmat ls_solve_ud(const cmat &A, const cmat &B);$/;"	p	namespace:itpp	signature:(const cmat &A, const cmat &B)
itpp::ls_solve_ud	/usr/include/itpp/base/algebra/ls_solve.h	/^cvec ls_solve_ud(const cmat &A, const cvec &b);$/;"	p	namespace:itpp	signature:(const cmat &A, const cvec &b)
itpp::ls_solve_ud	/usr/include/itpp/base/algebra/ls_solve.h	/^mat ls_solve_ud(const mat &A, const mat &B);$/;"	p	namespace:itpp	signature:(const mat &A, const mat &B)
itpp::ls_solve_ud	/usr/include/itpp/base/algebra/ls_solve.h	/^vec ls_solve_ud(const mat &A, const vec &b);$/;"	p	namespace:itpp	signature:(const mat &A, const vec &b)
itpp::lsf2poly	/usr/include/itpp/srccode/lpcfunc.h	/^vec lsf2poly(const vec &lsf);$/;"	p	namespace:itpp	signature:(const vec &lsf)
itpp::lshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void lshift_fix(CFix &y, int n) {y.lshift(n);}$/;"	f	namespace:itpp	signature:(CFix &y, int n)
itpp::lshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void lshift_fix(Fix &y, int n) {y.lshift(n);}$/;"	f	namespace:itpp	signature:(Fix &y, int n)
itpp::lshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void lshift_fix(cfixmat &y, int n)$/;"	f	namespace:itpp	signature:(cfixmat &y, int n)
itpp::lshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void lshift_fix(cfixvec &y, int n)$/;"	f	namespace:itpp	signature:(cfixvec &y, int n)
itpp::lshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void lshift_fix(cmat &, int) {}$/;"	f	namespace:itpp	signature:(cmat &, int)
itpp::lshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void lshift_fix(cvec &, int) {}$/;"	f	namespace:itpp	signature:(cvec &, int)
itpp::lshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void lshift_fix(double &, int) {}$/;"	f	namespace:itpp	signature:(double &, int)
itpp::lshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void lshift_fix(fixmat &y, int n)$/;"	f	namespace:itpp	signature:(fixmat &y, int n)
itpp::lshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void lshift_fix(fixvec &y, int n)$/;"	f	namespace:itpp	signature:(fixvec &y, int n)
itpp::lshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void lshift_fix(mat &, int) {}$/;"	f	namespace:itpp	signature:(mat &, int)
itpp::lshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void lshift_fix(std::complex<double> &, int) {}$/;"	f	namespace:itpp	signature:(std::complex<double> &, int)
itpp::lshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void lshift_fix(vec &, int) {}$/;"	f	namespace:itpp	signature:(vec &, int)
itpp::lshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<class T> inline void lshift_fix(Array<T> &y, int n)$/;"	f	namespace:itpp	signature:(Array<T> &y, int n)
itpp::lu	/usr/include/itpp/base/algebra/lu.h	/^bool lu(const cmat &X, cmat &L, cmat &U, ivec &p);$/;"	p	namespace:itpp	signature:(const cmat &X, cmat &L, cmat &U, ivec &p)
itpp::lu	/usr/include/itpp/base/algebra/lu.h	/^bool lu(const mat &X, mat &L, mat &U, ivec &p);$/;"	p	namespace:itpp	signature:(const mat &X, mat &L, mat &U, ivec &p)
itpp::m_2pi	/usr/include/itpp/base/math/misc.h	/^const double m_2pi = 2 * pi;$/;"	m	namespace:itpp
itpp::mat	/usr/include/itpp/base/mat.h	/^typedef Mat<double> mat;$/;"	t	namespace:itpp
itpp::mat2mxArray	/usr/include/itpp/itmex.h	/^void mat2mxArray(const mat &in, mxArray *out)$/;"	f	namespace:itpp	signature:(const mat &in, mxArray *out)
itpp::mat2mxArray	/usr/include/itpp/itmex.h	/^void mat2mxArray(const mat &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const mat &in, mxArray *out)
itpp::mat::operator *=	/usr/include/itpp/base/mat.h	/^template<> mat& mat::operator*=(const mat &m);$/;"	p	class:itpp::mat	signature:(const mat &m)
itpp::mat_1x1	/usr/include/itpp/base/specmat.h	/^Mat<T> mat_1x1(T m00)$/;"	f	namespace:itpp	signature:(T m00)
itpp::mat_1x2	/usr/include/itpp/base/specmat.h	/^Mat<T> mat_1x2(T m00, T m01)$/;"	f	namespace:itpp	signature:(T m00, T m01)
itpp::mat_1x3	/usr/include/itpp/base/specmat.h	/^Mat<T> mat_1x3(T m00, T m01, T m02)$/;"	f	namespace:itpp	signature:(T m00, T m01, T m02)
itpp::mat_2x1	/usr/include/itpp/base/specmat.h	/^Mat<T> mat_2x1(T m00,$/;"	f	namespace:itpp	signature:(T m00, T m10)
itpp::mat_2x2	/usr/include/itpp/base/specmat.h	/^Mat<T> mat_2x2(T m00, T m01,$/;"	f	namespace:itpp	signature:(T m00, T m01, T m10, T m11)
itpp::mat_2x3	/usr/include/itpp/base/specmat.h	/^Mat<T> mat_2x3(T m00, T m01, T m02,$/;"	f	namespace:itpp	signature:(T m00, T m01, T m02, T m10, T m11, T m12)
itpp::mat_3x1	/usr/include/itpp/base/specmat.h	/^Mat<T> mat_3x1(T m00,$/;"	f	namespace:itpp	signature:(T m00, T m10, T m20)
itpp::mat_3x2	/usr/include/itpp/base/specmat.h	/^Mat<T> mat_3x2(T m00, T m01,$/;"	f	namespace:itpp	signature:(T m00, T m01, T m10, T m11, T m20, T m21)
itpp::mat_3x3	/usr/include/itpp/base/specmat.h	/^Mat<T> mat_3x3(T m00, T m01, T m02,$/;"	f	namespace:itpp	signature:(T m00, T m01, T m02, T m10, T m11, T m12, T m20, T m21, T m22)
itpp::max	/usr/include/itpp/base/math/min_max.h	/^T max(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
itpp::max	/usr/include/itpp/base/math/min_max.h	/^T max(const Vec<T> &v, int& index)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, int& index)
itpp::max	/usr/include/itpp/base/math/min_max.h	/^Vec<T> max(const Mat<T> &m, int dim = 1)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, int dim = 1)
itpp::max	/usr/include/itpp/base/math/min_max.h	/^Vec<T> max(const Mat<T> &m, ivec &index, int dim = 1)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, ivec &index, int dim = 1)
itpp::max	/usr/include/itpp/protocol/tcp.h	/^inline const Sequence_Number & max(const Sequence_Number &n1, const Sequence_Number &n2) { return (n1 > n2) ? n1 : n2; }$/;"	f	namespace:itpp	signature:(const Sequence_Number &n1, const Sequence_Number &n2)
itpp::max_index	/usr/include/itpp/base/math/min_max.h	/^int max_index(const Vec<T> &in)$/;"	f	namespace:itpp	signature:(const Vec<T> &in)
itpp::max_index	/usr/include/itpp/base/math/min_max.h	/^void max_index(const Mat<T> &m, int &row, int &col)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, int &row, int &col)
itpp::mean	/usr/include/itpp/stat/misc_stat.h	/^double mean(const imat &m);$/;"	p	namespace:itpp	signature:(const imat &m)
itpp::mean	/usr/include/itpp/stat/misc_stat.h	/^double mean(const ivec &v);$/;"	p	namespace:itpp	signature:(const ivec &v)
itpp::mean	/usr/include/itpp/stat/misc_stat.h	/^double mean(const mat &m);$/;"	p	namespace:itpp	signature:(const mat &m)
itpp::mean	/usr/include/itpp/stat/misc_stat.h	/^double mean(const smat &m);$/;"	p	namespace:itpp	signature:(const smat &m)
itpp::mean	/usr/include/itpp/stat/misc_stat.h	/^double mean(const svec &v);$/;"	p	namespace:itpp	signature:(const svec &v)
itpp::mean	/usr/include/itpp/stat/misc_stat.h	/^double mean(const vec &v);$/;"	p	namespace:itpp	signature:(const vec &v)
itpp::mean	/usr/include/itpp/stat/misc_stat.h	/^std::complex<double> mean(const cmat &m);$/;"	p	namespace:itpp	signature:(const cmat &m)
itpp::mean	/usr/include/itpp/stat/misc_stat.h	/^std::complex<double> mean(const cvec &v);$/;"	p	namespace:itpp	signature:(const cvec &v)
itpp::median	/usr/include/itpp/stat/misc_stat.h	/^double median(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
itpp::min	/usr/include/itpp/base/math/min_max.h	/^T min(const Vec<T> &in)$/;"	f	namespace:itpp	signature:(const Vec<T> &in)
itpp::min	/usr/include/itpp/base/math/min_max.h	/^T min(const Vec<T> &in, int& index)$/;"	f	namespace:itpp	signature:(const Vec<T> &in, int& index)
itpp::min	/usr/include/itpp/base/math/min_max.h	/^Vec<T> min(const Mat<T> &m,  ivec &index, int dim = 1)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, ivec &index, int dim = 1)
itpp::min	/usr/include/itpp/base/math/min_max.h	/^Vec<T> min(const Mat<T> &m, int dim = 1)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, int dim = 1)
itpp::min	/usr/include/itpp/protocol/tcp.h	/^inline const Sequence_Number & min(const Sequence_Number &n1, const Sequence_Number &n2) { return (n1 < n2) ? n1 : n2; }$/;"	f	namespace:itpp	signature:(const Sequence_Number &n1, const Sequence_Number &n2)
itpp::min_index	/usr/include/itpp/base/math/min_max.h	/^int min_index(const Vec<T> &in)$/;"	f	namespace:itpp	signature:(const Vec<T> &in)
itpp::min_index	/usr/include/itpp/base/math/min_max.h	/^void min_index(const Mat<T> &m, int &row, int &col)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, int &row, int &col)
itpp::mod	/usr/include/itpp/base/math/elem_math.h	/^inline int mod(int k, int n)$/;"	f	namespace:itpp	signature:(int k, int n)
itpp::modgfx	/usr/include/itpp/comm/galois.h	/^GFX modgfx(const GFX &a, const GFX &b);$/;"	p	namespace:itpp	signature:(const GFX &a, const GFX &b)
itpp::modified_yule_walker	/usr/include/itpp/signal/filter_design.h	/^void modified_yule_walker(const int m, const int n, const int N, const vec &R, vec &a);$/;"	p	namespace:itpp	signature:(const int m, const int n, const int N, const vec &R, vec &a)
itpp::moment	/usr/include/itpp/stat/misc_stat.h	/^double moment(const vec &x, const int r);$/;"	p	namespace:itpp	signature:(const vec &x, const int r)
itpp::mult_trans	/usr/include/itpp/base/gf2mat.h	/^GF2mat mult_trans(const GF2mat &X, const GF2mat &Y);$/;"	p	namespace:itpp	signature:(const GF2mat &X, const GF2mat &Y)
itpp::mult_trans	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> mult_trans(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)$/;"	f	namespace:itpp	signature:(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)
itpp::mult_trans	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> mult_trans(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2);$/;"	p	namespace:itpp	signature:(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)
itpp::mult_trans	/usr/include/itpp/base/smat.h	/^extern template sparse_cmat mult_trans(const sparse_cmat &, const sparse_cmat &);$/;"	p	namespace:itpp	signature:(const sparse_cmat &, const sparse_cmat &)
itpp::mult_trans	/usr/include/itpp/base/smat.h	/^extern template sparse_imat mult_trans(const sparse_imat &, const sparse_imat &);$/;"	p	namespace:itpp	signature:(const sparse_imat &, const sparse_imat &)
itpp::mult_trans	/usr/include/itpp/base/smat.h	/^extern template sparse_mat mult_trans(const sparse_mat &, const sparse_mat &);$/;"	p	namespace:itpp	signature:(const sparse_mat &, const sparse_mat &)
itpp::mxArray2Ccmat	/usr/include/itpp/itmex.h	/^void mxArray2Ccmat(const mxArray *in, double **out_real, double **out_imag)$/;"	f	namespace:itpp	signature:(const mxArray *in, double **out_real, double **out_imag)
itpp::mxArray2Ccmat	/usr/include/itpp/itmex.h	/^void mxArray2Ccmat(const mxArray *in, double **out_real, double **out_imag);$/;"	p	namespace:itpp	signature:(const mxArray *in, double **out_real, double **out_imag)
itpp::mxArray2Ccvec	/usr/include/itpp/itmex.h	/^void mxArray2Ccvec(const mxArray *in, double *out_real, double *out_imag)$/;"	f	namespace:itpp	signature:(const mxArray *in, double *out_real, double *out_imag)
itpp::mxArray2Ccvec	/usr/include/itpp/itmex.h	/^void mxArray2Ccvec(const mxArray *in, double *out_real, double *out_imag);$/;"	p	namespace:itpp	signature:(const mxArray *in, double *out_real, double *out_imag)
itpp::mxArray2Cimat	/usr/include/itpp/itmex.h	/^void mxArray2Cimat(const mxArray *in, int **out)$/;"	f	namespace:itpp	signature:(const mxArray *in, int **out)
itpp::mxArray2Cimat	/usr/include/itpp/itmex.h	/^void mxArray2Cimat(const mxArray *in, int **out);$/;"	p	namespace:itpp	signature:(const mxArray *in, int **out)
itpp::mxArray2Civec	/usr/include/itpp/itmex.h	/^void mxArray2Civec(const mxArray *in, int *out)$/;"	f	namespace:itpp	signature:(const mxArray *in, int *out)
itpp::mxArray2Civec	/usr/include/itpp/itmex.h	/^void mxArray2Civec(const mxArray *in, int *out);$/;"	p	namespace:itpp	signature:(const mxArray *in, int *out)
itpp::mxArray2Cmat	/usr/include/itpp/itmex.h	/^void mxArray2Cmat(const mxArray *in, double **out)$/;"	f	namespace:itpp	signature:(const mxArray *in, double **out)
itpp::mxArray2Cmat	/usr/include/itpp/itmex.h	/^void mxArray2Cmat(const mxArray *in, double **out);$/;"	p	namespace:itpp	signature:(const mxArray *in, double **out)
itpp::mxArray2Csmat	/usr/include/itpp/itmex.h	/^void mxArray2Csmat(const mxArray *in, short **out)$/;"	f	namespace:itpp	signature:(const mxArray *in, short **out)
itpp::mxArray2Csmat	/usr/include/itpp/itmex.h	/^void mxArray2Csmat(const mxArray *in, short **out);$/;"	p	namespace:itpp	signature:(const mxArray *in, short **out)
itpp::mxArray2Csvec	/usr/include/itpp/itmex.h	/^void mxArray2Csvec(const mxArray *in, short *out)$/;"	f	namespace:itpp	signature:(const mxArray *in, short *out)
itpp::mxArray2Csvec	/usr/include/itpp/itmex.h	/^void mxArray2Csvec(const mxArray *in, short *out);$/;"	p	namespace:itpp	signature:(const mxArray *in, short *out)
itpp::mxArray2Cvec	/usr/include/itpp/itmex.h	/^void mxArray2Cvec(const mxArray *in, double *out)$/;"	f	namespace:itpp	signature:(const mxArray *in, double *out)
itpp::mxArray2Cvec	/usr/include/itpp/itmex.h	/^void mxArray2Cvec(const mxArray *in, double *out);$/;"	p	namespace:itpp	signature:(const mxArray *in, double *out)
itpp::mxArray2bin	/usr/include/itpp/itmex.h	/^bin mxArray2bin(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2bin	/usr/include/itpp/itmex.h	/^bin mxArray2bin(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2bmat	/usr/include/itpp/itmex.h	/^bmat mxArray2bmat(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2bmat	/usr/include/itpp/itmex.h	/^bmat mxArray2bmat(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2bvec	/usr/include/itpp/itmex.h	/^bvec mxArray2bvec(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2bvec	/usr/include/itpp/itmex.h	/^bvec mxArray2bvec(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2cmat	/usr/include/itpp/itmex.h	/^cmat mxArray2cmat(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2cmat	/usr/include/itpp/itmex.h	/^cmat mxArray2cmat(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2cvec	/usr/include/itpp/itmex.h	/^cvec mxArray2cvec(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2cvec	/usr/include/itpp/itmex.h	/^cvec mxArray2cvec(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2double	/usr/include/itpp/itmex.h	/^double mxArray2double(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2double	/usr/include/itpp/itmex.h	/^double mxArray2double(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2double_complex	/usr/include/itpp/itmex.h	/^std::complex<double> mxArray2double_complex(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2double_complex	/usr/include/itpp/itmex.h	/^std::complex<double> mxArray2double_complex(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2imat	/usr/include/itpp/itmex.h	/^imat mxArray2imat(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2imat	/usr/include/itpp/itmex.h	/^imat mxArray2imat(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2int	/usr/include/itpp/itmex.h	/^int mxArray2int(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2int	/usr/include/itpp/itmex.h	/^int mxArray2int(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2ivec	/usr/include/itpp/itmex.h	/^ivec mxArray2ivec(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2ivec	/usr/include/itpp/itmex.h	/^ivec mxArray2ivec(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2mat	/usr/include/itpp/itmex.h	/^mat mxArray2mat(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2mat	/usr/include/itpp/itmex.h	/^mat mxArray2mat(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2short	/usr/include/itpp/itmex.h	/^short mxArray2short(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2short	/usr/include/itpp/itmex.h	/^short mxArray2short(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2smat	/usr/include/itpp/itmex.h	/^smat mxArray2smat(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2smat	/usr/include/itpp/itmex.h	/^smat mxArray2smat(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2string	/usr/include/itpp/itmex.h	/^std::string mxArray2string(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2string	/usr/include/itpp/itmex.h	/^std::string mxArray2string(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2svec	/usr/include/itpp/itmex.h	/^svec mxArray2svec(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2svec	/usr/include/itpp/itmex.h	/^svec mxArray2svec(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2vec	/usr/include/itpp/itmex.h	/^vec mxArray2vec(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
itpp::mxArray2vec	/usr/include/itpp/itmex.h	/^vec mxArray2vec(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
itpp::needed_bits	/usr/include/itpp/base/math/log_exp.h	/^inline int needed_bits(int n)$/;"	f	namespace:itpp	signature:(int n)
itpp::needed_bits	/usr/include/itpp/base/math/log_exp.h	/^inline ivec needed_bits(const ivec& v)$/;"	f	namespace:itpp	signature:(const ivec& v)
itpp::norm	/usr/include/itpp/stat/misc_stat.h	/^double norm(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
itpp::norm	/usr/include/itpp/stat/misc_stat.h	/^double norm(const Vec<T> &v, const std::string &s)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, const std::string &s)
itpp::norm	/usr/include/itpp/stat/misc_stat.h	/^double norm(const Vec<T> &v, int p)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, int p)
itpp::norm	/usr/include/itpp/stat/misc_stat.h	/^double norm(const cmat &m, const std::string &s);$/;"	p	namespace:itpp	signature:(const cmat &m, const std::string &s)
itpp::norm	/usr/include/itpp/stat/misc_stat.h	/^double norm(const cmat &m, int p = 2);$/;"	p	namespace:itpp	signature:(const cmat &m, int p = 2)
itpp::norm	/usr/include/itpp/stat/misc_stat.h	/^double norm(const cvec &v);$/;"	p	namespace:itpp	signature:(const cvec &v)
itpp::norm	/usr/include/itpp/stat/misc_stat.h	/^double norm(const cvec &v, const std::string &s);$/;"	p	namespace:itpp	signature:(const cvec &v, const std::string &s)
itpp::norm	/usr/include/itpp/stat/misc_stat.h	/^double norm(const cvec &v, int p);$/;"	p	namespace:itpp	signature:(const cvec &v, int p)
itpp::norm	/usr/include/itpp/stat/misc_stat.h	/^double norm(const mat &m, const std::string &s);$/;"	p	namespace:itpp	signature:(const mat &m, const std::string &s)
itpp::norm	/usr/include/itpp/stat/misc_stat.h	/^double norm(const mat &m, int p = 2);$/;"	p	namespace:itpp	signature:(const mat &m, int p = 2)
itpp::o_mode	/usr/include/itpp/fixed/fix_base.h	/^enum o_mode {$/;"	g	namespace:itpp
itpp::oct2bin	/usr/include/itpp/base/converters.h	/^bvec oct2bin(const ivec &octalindex, short keepzeros = 0);$/;"	p	namespace:itpp	signature:(const ivec &octalindex, short keepzeros = 0)
itpp::ones	/usr/include/itpp/base/specmat.h	/^mat ones(int rows, int cols);$/;"	p	namespace:itpp	signature:(int rows, int cols)
itpp::ones	/usr/include/itpp/base/specmat.h	/^vec ones(int size);$/;"	p	namespace:itpp	signature:(int size)
itpp::ones_b	/usr/include/itpp/base/specmat.h	/^bmat ones_b(int rows, int cols);$/;"	p	namespace:itpp	signature:(int rows, int cols)
itpp::ones_b	/usr/include/itpp/base/specmat.h	/^bvec ones_b(int size);$/;"	p	namespace:itpp	signature:(int size)
itpp::ones_c	/usr/include/itpp/base/specmat.h	/^cmat ones_c(int rows, int cols);$/;"	p	namespace:itpp	signature:(int rows, int cols)
itpp::ones_c	/usr/include/itpp/base/specmat.h	/^cvec ones_c(int size);$/;"	p	namespace:itpp	signature:(int size)
itpp::ones_i	/usr/include/itpp/base/specmat.h	/^imat ones_i(int rows, int cols);$/;"	p	namespace:itpp	signature:(int rows, int cols)
itpp::ones_i	/usr/include/itpp/base/specmat.h	/^ivec ones_i(int size);$/;"	p	namespace:itpp	signature:(int size)
itpp::operator *	/usr/include/itpp/base/gf2mat.h	/^GF2mat operator*(const GF2mat &X, const GF2mat &Y);$/;"	p	namespace:itpp	signature:(const GF2mat &X, const GF2mat &Y)
itpp::operator *	/usr/include/itpp/base/gf2mat.h	/^bvec operator*(const GF2mat &X, const bvec &y);$/;"	p	namespace:itpp	signature:(const GF2mat &X, const bvec &y)
itpp::operator *	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator*(Num_T t, const Mat<Num_T> &m)$/;"	f	namespace:itpp	signature:(Num_T t, const Mat<Num_T> &m)
itpp::operator *	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator*(Num_T t, const Mat<Num_T> &m);$/;"	p	namespace:itpp	signature:(Num_T t, const Mat<Num_T> &m)
itpp::operator *	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator*(const Mat<Num_T> &m, Num_T t)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m, Num_T t)
itpp::operator *	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator*(const Mat<Num_T> &m, Num_T t);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m, Num_T t)
itpp::operator *	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator*(const Mat<Num_T> &m1, const Mat<Num_T> &m2)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::operator *	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator*(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::operator *	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator*(const Vec<Num_T> &v, const Mat<Num_T> &m)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v, const Mat<Num_T> &m)
itpp::operator *	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator*(const Vec<Num_T> &v, const Mat<Num_T> &m);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v, const Mat<Num_T> &m)
itpp::operator *	/usr/include/itpp/base/mat.h	/^Vec<Num_T> operator*(const Mat<Num_T> &m, const Vec<Num_T> &v)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m, const Vec<Num_T> &v)
itpp::operator *	/usr/include/itpp/base/mat.h	/^Vec<Num_T> operator*(const Mat<Num_T> &m, const Vec<Num_T> &v);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m, const Vec<Num_T> &v)
itpp::operator *	/usr/include/itpp/base/mat.h	/^extern template bmat operator*(bin t, const bmat &m);$/;"	p	namespace:itpp	signature:(bin t, const bmat &m)
itpp::operator *	/usr/include/itpp/base/mat.h	/^extern template bmat operator*(const bmat &m, bin t);$/;"	p	namespace:itpp	signature:(const bmat &m, bin t)
itpp::operator *	/usr/include/itpp/base/mat.h	/^extern template bmat operator*(const bmat &m1, const bmat &m2);$/;"	p	namespace:itpp	signature:(const bmat &m1, const bmat &m2)
itpp::operator *	/usr/include/itpp/base/mat.h	/^extern template bmat operator*(const bvec &v, const bmat &m);$/;"	p	namespace:itpp	signature:(const bvec &v, const bmat &m)
itpp::operator *	/usr/include/itpp/base/mat.h	/^extern template bvec operator*(const bmat &m, const bvec &v);$/;"	p	namespace:itpp	signature:(const bmat &m, const bvec &v)
itpp::operator *	/usr/include/itpp/base/mat.h	/^extern template cmat operator*(const cmat &m, std::complex<double> t);$/;"	p	namespace:itpp	signature:(const cmat &m, std::complex<double> t)
itpp::operator *	/usr/include/itpp/base/mat.h	/^extern template cmat operator*(const cmat &m1, const cmat &m2);$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2)
itpp::operator *	/usr/include/itpp/base/mat.h	/^extern template cmat operator*(const cvec &v, const cmat &m);$/;"	p	namespace:itpp	signature:(const cvec &v, const cmat &m)
itpp::operator *	/usr/include/itpp/base/mat.h	/^extern template cmat operator*(std::complex<double> t, const cmat &m);$/;"	p	namespace:itpp	signature:(std::complex<double> t, const cmat &m)
itpp::operator *	/usr/include/itpp/base/mat.h	/^extern template cvec operator*(const cmat &m, const cvec &v);$/;"	p	namespace:itpp	signature:(const cmat &m, const cvec &v)
itpp::operator *	/usr/include/itpp/base/mat.h	/^extern template imat operator*(const imat &m, int t);$/;"	p	namespace:itpp	signature:(const imat &m, int t)
itpp::operator *	/usr/include/itpp/base/mat.h	/^extern template imat operator*(const imat &m1, const imat &m2);$/;"	p	namespace:itpp	signature:(const imat &m1, const imat &m2)
itpp::operator *	/usr/include/itpp/base/mat.h	/^extern template imat operator*(const ivec &v, const imat &m);$/;"	p	namespace:itpp	signature:(const ivec &v, const imat &m)
itpp::operator *	/usr/include/itpp/base/mat.h	/^extern template imat operator*(int t, const imat &m);$/;"	p	namespace:itpp	signature:(int t, const imat &m)
itpp::operator *	/usr/include/itpp/base/mat.h	/^extern template ivec operator*(const imat &m, const ivec &v);$/;"	p	namespace:itpp	signature:(const imat &m, const ivec &v)
itpp::operator *	/usr/include/itpp/base/mat.h	/^extern template mat operator*(const mat &m, double t);$/;"	p	namespace:itpp	signature:(const mat &m, double t)
itpp::operator *	/usr/include/itpp/base/mat.h	/^extern template mat operator*(const mat &m1, const mat &m2);$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2)
itpp::operator *	/usr/include/itpp/base/mat.h	/^extern template mat operator*(const vec &v, const mat &m);$/;"	p	namespace:itpp	signature:(const vec &v, const mat &m)
itpp::operator *	/usr/include/itpp/base/mat.h	/^extern template mat operator*(double t, const mat &m);$/;"	p	namespace:itpp	signature:(double t, const mat &m)
itpp::operator *	/usr/include/itpp/base/mat.h	/^extern template smat operator*(const smat &m, short t);$/;"	p	namespace:itpp	signature:(const smat &m, short t)
itpp::operator *	/usr/include/itpp/base/mat.h	/^extern template smat operator*(const smat &m1, const smat &m2);$/;"	p	namespace:itpp	signature:(const smat &m1, const smat &m2)
itpp::operator *	/usr/include/itpp/base/mat.h	/^extern template smat operator*(const svec &v, const smat &m);$/;"	p	namespace:itpp	signature:(const svec &v, const smat &m)
itpp::operator *	/usr/include/itpp/base/mat.h	/^extern template smat operator*(short t, const smat &m);$/;"	p	namespace:itpp	signature:(short t, const smat &m)
itpp::operator *	/usr/include/itpp/base/mat.h	/^extern template svec operator*(const smat &m, const svec &v);$/;"	p	namespace:itpp	signature:(const smat &m, const svec &v)
itpp::operator *	/usr/include/itpp/base/mat.h	/^extern template vec operator*(const mat &m, const vec &v);$/;"	p	namespace:itpp	signature:(const mat &m, const vec &v)
itpp::operator *	/usr/include/itpp/base/mat.h	/^template<> cmat operator*(const cmat &m1, const cmat &m2);$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2)
itpp::operator *	/usr/include/itpp/base/mat.h	/^template<> cvec operator*(const cmat &m, const cvec &v);$/;"	p	namespace:itpp	signature:(const cmat &m, const cvec &v)
itpp::operator *	/usr/include/itpp/base/mat.h	/^template<> mat operator*(const mat &m1, const mat &m2);$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2)
itpp::operator *	/usr/include/itpp/base/mat.h	/^template<> vec operator*(const mat &m, const vec &v);$/;"	p	namespace:itpp	signature:(const mat &m, const vec &v)
itpp::operator *	/usr/include/itpp/base/operators.h	/^cmat operator*(const double &s, const cmat &m);$/;"	p	namespace:itpp	signature:(const double &s, const cmat &m)
itpp::operator *	/usr/include/itpp/base/operators.h	/^cmat operator*(const std::complex<double> &s, const mat &m);$/;"	p	namespace:itpp	signature:(const std::complex<double> &s, const mat &m)
itpp::operator *	/usr/include/itpp/base/operators.h	/^cvec operator*(const double &s, const cvec &v);$/;"	p	namespace:itpp	signature:(const double &s, const cvec &v)
itpp::operator *	/usr/include/itpp/base/operators.h	/^cvec operator*(const std::complex<double> &s, const ivec &v);$/;"	p	namespace:itpp	signature:(const std::complex<double> &s, const ivec &v)
itpp::operator *	/usr/include/itpp/base/operators.h	/^cvec operator*(const std::complex<double> &s, const vec &v);$/;"	p	namespace:itpp	signature:(const std::complex<double> &s, const vec &v)
itpp::operator *	/usr/include/itpp/base/operators.h	/^cvec operator*(const vec &v, const std::complex<double> &s);$/;"	p	namespace:itpp	signature:(const vec &v, const std::complex<double> &s)
itpp::operator *	/usr/include/itpp/base/operators.h	/^double operator*(const bvec &a, const vec &b);$/;"	p	namespace:itpp	signature:(const bvec &a, const vec &b)
itpp::operator *	/usr/include/itpp/base/operators.h	/^double operator*(const ivec &a, const vec &b);$/;"	p	namespace:itpp	signature:(const ivec &a, const vec &b)
itpp::operator *	/usr/include/itpp/base/operators.h	/^double operator*(const svec &a, const vec &b);$/;"	p	namespace:itpp	signature:(const svec &a, const vec &b)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline cmat operator*(const bmat &a, const cmat &b) {return to_cmat(a)*b;}$/;"	f	namespace:itpp	signature:(const bmat &a, const cmat &b)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline cmat operator*(const cmat &a, const bmat &b) {return a*to_cmat(b);}$/;"	f	namespace:itpp	signature:(const cmat &a, const bmat &b)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline cmat operator*(const cmat &a, const imat &b) {return a*to_cmat(b);}$/;"	f	namespace:itpp	signature:(const cmat &a, const imat &b)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline cmat operator*(const cmat &a, const mat &b) {return a*to_cmat(b);}$/;"	f	namespace:itpp	signature:(const cmat &a, const mat &b)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline cmat operator*(const cmat &a, const smat &b) {return a*to_cmat(b);}$/;"	f	namespace:itpp	signature:(const cmat &a, const smat &b)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline cmat operator*(const imat &a, const cmat &b) {return to_cmat(a)*b;}$/;"	f	namespace:itpp	signature:(const imat &a, const cmat &b)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline cmat operator*(const mat &a, const cmat &b) {return to_cmat(a)*b;}$/;"	f	namespace:itpp	signature:(const mat &a, const cmat &b)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline cmat operator*(const mat &m, const std::complex<double> &s) {return s*m;}$/;"	f	namespace:itpp	signature:(const mat &m, const std::complex<double> &s)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline cmat operator*(const smat &a, const cmat &b) {return to_cmat(a)*b;}$/;"	f	namespace:itpp	signature:(const smat &a, const cmat &b)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline cvec operator*(const cvec &v, const double &s) {return s*v;}$/;"	f	namespace:itpp	signature:(const cvec &v, const double &s)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline cvec operator*(const cvec &v, const float &s) {return s*v;}$/;"	f	namespace:itpp	signature:(const cvec &v, const float &s)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline cvec operator*(const cvec &v, const int &s) {return s*v;}$/;"	f	namespace:itpp	signature:(const cvec &v, const int &s)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline cvec operator*(const cvec &v, const short &s) {return s*v;}$/;"	f	namespace:itpp	signature:(const cvec &v, const short &s)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline cvec operator*(const float &s, const cvec &v) {return static_cast<double>(s)*v;}$/;"	f	namespace:itpp	signature:(const float &s, const cvec &v)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline cvec operator*(const int &s, const cvec &v) {return static_cast<double>(s)*v;}$/;"	f	namespace:itpp	signature:(const int &s, const cvec &v)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline cvec operator*(const ivec &v, const std::complex<double> &s) { return s*v; }$/;"	f	namespace:itpp	signature:(const ivec &v, const std::complex<double> &s)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline cvec operator*(const short &s, const cvec &v) {return static_cast<double>(s)*v;}$/;"	f	namespace:itpp	signature:(const short &s, const cvec &v)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline double operator*(const vec &a, const bvec &b) {return b*a;}$/;"	f	namespace:itpp	signature:(const vec &a, const bvec &b)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline double operator*(const vec &a, const ivec &b) {return b*a;}$/;"	f	namespace:itpp	signature:(const vec &a, const ivec &b)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline double operator*(const vec &a, const svec &b) {return b*a;}$/;"	f	namespace:itpp	signature:(const vec &a, const svec &b)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline mat operator*(const float &s, const mat &m) {return static_cast<double>(s)*m;}$/;"	f	namespace:itpp	signature:(const float &s, const mat &m)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline mat operator*(const int &s, const mat &m) {return static_cast<double>(s)*m;}$/;"	f	namespace:itpp	signature:(const int &s, const mat &m)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline mat operator*(const mat &m, const float &s) {return static_cast<double>(s)*m;}$/;"	f	namespace:itpp	signature:(const mat &m, const float &s)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline mat operator*(const mat &m, const int &s) {return static_cast<double>(s)*m;}$/;"	f	namespace:itpp	signature:(const mat &m, const int &s)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline mat operator*(const mat &m, const short &s) {return static_cast<double>(s)*m;}$/;"	f	namespace:itpp	signature:(const mat &m, const short &s)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline mat operator*(const short &s, const mat &m) {return static_cast<double>(s)*m;}$/;"	f	namespace:itpp	signature:(const short &s, const mat &m)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator*(const cvec &a, const bvec &b) {return b*a;}$/;"	f	namespace:itpp	signature:(const cvec &a, const bvec &b)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator*(const cvec &a, const ivec &b) {return b*a;}$/;"	f	namespace:itpp	signature:(const cvec &a, const ivec &b)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator*(const cvec &a, const svec &b) {return b*a;}$/;"	f	namespace:itpp	signature:(const cvec &a, const svec &b)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator*(const float &x, const std::complex<double> &y) {return std::complex<double>(x*y.real(), x*y.imag());}$/;"	f	namespace:itpp	signature:(const float &x, const std::complex<double> &y)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator*(const int &x, const std::complex<double> &y) {return std::complex<double>(x*y.real(), x*y.imag());}$/;"	f	namespace:itpp	signature:(const int &x, const std::complex<double> &y)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator*(const std::complex<double> &x, const float &y) {return std::complex<double>(x.real()*y, x.imag()*y);}$/;"	f	namespace:itpp	signature:(const std::complex<double> &x, const float &y)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator*(const std::complex<double> &x, const int &y) {return std::complex<double>(x.real()*y, x.imag()*y);}$/;"	f	namespace:itpp	signature:(const std::complex<double> &x, const int &y)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline vec operator*(const float &s, const vec &v) {return static_cast<double>(s)*v;}$/;"	f	namespace:itpp	signature:(const float &s, const vec &v)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline vec operator*(const int &s, const vec &v) {return static_cast<double>(s)*v;}$/;"	f	namespace:itpp	signature:(const int &s, const vec &v)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline vec operator*(const ivec &v, const double &s) { return s*v; }$/;"	f	namespace:itpp	signature:(const ivec &v, const double &s)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline vec operator*(const short &s, const vec &v) {return static_cast<double>(s)*v;}$/;"	f	namespace:itpp	signature:(const short &s, const vec &v)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline vec operator*(const vec &v, const float &s) {return static_cast<double>(s)*v;}$/;"	f	namespace:itpp	signature:(const vec &v, const float &s)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline vec operator*(const vec &v, const int &s) {return static_cast<double>(s)*v;}$/;"	f	namespace:itpp	signature:(const vec &v, const int &s)
itpp::operator *	/usr/include/itpp/base/operators.h	/^inline vec operator*(const vec &v, const short &s) {return static_cast<double>(s)*v;}$/;"	f	namespace:itpp	signature:(const vec &v, const short &s)
itpp::operator *	/usr/include/itpp/base/operators.h	/^std::complex<double> operator*(const bvec &a, const cvec &b);$/;"	p	namespace:itpp	signature:(const bvec &a, const cvec &b)
itpp::operator *	/usr/include/itpp/base/operators.h	/^std::complex<double> operator*(const ivec &a, const cvec &b);$/;"	p	namespace:itpp	signature:(const ivec &a, const cvec &b)
itpp::operator *	/usr/include/itpp/base/operators.h	/^std::complex<double> operator*(const svec &a, const cvec &b);$/;"	p	namespace:itpp	signature:(const svec &a, const cvec &b)
itpp::operator *	/usr/include/itpp/base/operators.h	/^vec operator*(const double &s, const ivec &v);$/;"	p	namespace:itpp	signature:(const double &s, const ivec &v)
itpp::operator *	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> operator*(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)$/;"	f	namespace:itpp	signature:(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)
itpp::operator *	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> operator*(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2);$/;"	p	namespace:itpp	signature:(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)
itpp::operator *	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> operator*(const T &c, const Sparse_Mat<T> &m)$/;"	f	namespace:itpp	signature:(const T &c, const Sparse_Mat<T> &m)
itpp::operator *	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> operator*(const T &c, const Sparse_Mat<T> &m);$/;"	p	namespace:itpp	signature:(const T &c, const Sparse_Mat<T> &m)
itpp::operator *	/usr/include/itpp/base/smat.h	/^Sparse_Vec<T> operator*(const Sparse_Mat<T> &m, const Sparse_Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Sparse_Mat<T> &m, const Sparse_Vec<T> &v)
itpp::operator *	/usr/include/itpp/base/smat.h	/^Sparse_Vec<T> operator*(const Sparse_Mat<T> &m, const Sparse_Vec<T> &v);$/;"	p	namespace:itpp	signature:(const Sparse_Mat<T> &m, const Sparse_Vec<T> &v)
itpp::operator *	/usr/include/itpp/base/smat.h	/^Vec<T> operator*(const Sparse_Mat<T> &m, const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Sparse_Mat<T> &m, const Vec<T> &v)
itpp::operator *	/usr/include/itpp/base/smat.h	/^Vec<T> operator*(const Sparse_Mat<T> &m, const Vec<T> &v);$/;"	p	namespace:itpp	signature:(const Sparse_Mat<T> &m, const Vec<T> &v)
itpp::operator *	/usr/include/itpp/base/smat.h	/^Vec<T> operator*(const Vec<T> &v, const Sparse_Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, const Sparse_Mat<T> &m)
itpp::operator *	/usr/include/itpp/base/smat.h	/^Vec<T> operator*(const Vec<T> &v, const Sparse_Mat<T> &m);$/;"	p	namespace:itpp	signature:(const Vec<T> &v, const Sparse_Mat<T> &m)
itpp::operator *	/usr/include/itpp/base/smat.h	/^extern template cvec operator*(const cvec &, const sparse_cmat &);$/;"	p	namespace:itpp	signature:(const cvec &, const sparse_cmat &)
itpp::operator *	/usr/include/itpp/base/smat.h	/^extern template cvec operator*(const sparse_cmat &, const cvec &);$/;"	p	namespace:itpp	signature:(const sparse_cmat &, const cvec &)
itpp::operator *	/usr/include/itpp/base/smat.h	/^extern template ivec operator*(const ivec &, const sparse_imat &);$/;"	p	namespace:itpp	signature:(const ivec &, const sparse_imat &)
itpp::operator *	/usr/include/itpp/base/smat.h	/^extern template ivec operator*(const sparse_imat &, const ivec &);$/;"	p	namespace:itpp	signature:(const sparse_imat &, const ivec &)
itpp::operator *	/usr/include/itpp/base/smat.h	/^extern template sparse_cmat operator*(const sparse_cmat &, const sparse_cmat &);$/;"	p	namespace:itpp	signature:(const sparse_cmat &, const sparse_cmat &)
itpp::operator *	/usr/include/itpp/base/smat.h	/^extern template sparse_imat operator*(const sparse_imat &, const sparse_imat &);$/;"	p	namespace:itpp	signature:(const sparse_imat &, const sparse_imat &)
itpp::operator *	/usr/include/itpp/base/smat.h	/^extern template sparse_mat operator*(const sparse_mat &, const sparse_mat &);$/;"	p	namespace:itpp	signature:(const sparse_mat &, const sparse_mat &)
itpp::operator *	/usr/include/itpp/base/smat.h	/^extern template vec operator*(const sparse_mat &, const vec &);$/;"	p	namespace:itpp	signature:(const sparse_mat &, const vec &)
itpp::operator *	/usr/include/itpp/base/smat.h	/^extern template vec operator*(const vec &, const sparse_mat &);$/;"	p	namespace:itpp	signature:(const vec &, const sparse_mat &)
itpp::operator *	/usr/include/itpp/base/svec.h	/^T operator*(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2)$/;"	f	namespace:itpp	signature:(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2)
itpp::operator *	/usr/include/itpp/base/svec.h	/^T operator*(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2);$/;"	p	namespace:itpp	signature:(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2)
itpp::operator *	/usr/include/itpp/base/svec.h	/^T operator*(const Sparse_Vec<T> &v1, const Vec<T> &v2)$/;"	f	namespace:itpp	signature:(const Sparse_Vec<T> &v1, const Vec<T> &v2)
itpp::operator *	/usr/include/itpp/base/svec.h	/^T operator*(const Sparse_Vec<T> &v1, const Vec<T> &v2);$/;"	p	namespace:itpp	signature:(const Sparse_Vec<T> &v1, const Vec<T> &v2)
itpp::operator *	/usr/include/itpp/base/svec.h	/^T operator*(const Vec<T> &v1, const Sparse_Vec<T> &v2)$/;"	f	namespace:itpp	signature:(const Vec<T> &v1, const Sparse_Vec<T> &v2)
itpp::operator *	/usr/include/itpp/base/svec.h	/^T operator*(const Vec<T> &v1, const Sparse_Vec<T> &v2);$/;"	p	namespace:itpp	signature:(const Vec<T> &v1, const Sparse_Vec<T> &v2)
itpp::operator *	/usr/include/itpp/base/svec.h	/^extern template double operator*(const sparse_vec &, const sparse_vec &);$/;"	p	namespace:itpp	signature:(const sparse_vec &, const sparse_vec &)
itpp::operator *	/usr/include/itpp/base/svec.h	/^extern template double operator*(const sparse_vec &, const vec &);$/;"	p	namespace:itpp	signature:(const sparse_vec &, const vec &)
itpp::operator *	/usr/include/itpp/base/svec.h	/^extern template double operator*(const vec &, const sparse_vec &);$/;"	p	namespace:itpp	signature:(const vec &, const sparse_vec &)
itpp::operator *	/usr/include/itpp/base/svec.h	/^extern template int operator*(const ivec &, const sparse_ivec &);$/;"	p	namespace:itpp	signature:(const ivec &, const sparse_ivec &)
itpp::operator *	/usr/include/itpp/base/svec.h	/^extern template int operator*(const sparse_ivec &, const ivec &);$/;"	p	namespace:itpp	signature:(const sparse_ivec &, const ivec &)
itpp::operator *	/usr/include/itpp/base/svec.h	/^extern template int operator*(const sparse_ivec &, const sparse_ivec &);$/;"	p	namespace:itpp	signature:(const sparse_ivec &, const sparse_ivec &)
itpp::operator *	/usr/include/itpp/base/svec.h	/^extern template std::complex<double> operator*(const cvec &,$/;"	p	namespace:itpp	signature:(const cvec &, const sparse_cvec &)
itpp::operator *	/usr/include/itpp/base/svec.h	/^extern template std::complex<double> operator*(const sparse_cvec &,$/;"	p	namespace:itpp	signature:(const sparse_cvec &, const cvec &)
itpp::operator *	/usr/include/itpp/base/svec.h	/^extern template std::complex<double> operator*(const sparse_cvec &,$/;"	p	namespace:itpp	signature:(const sparse_cvec &, const sparse_cvec &)
itpp::operator *	/usr/include/itpp/base/vec.h	/^Num_T operator*(const Vec<Num_T> &v1, const Vec<Num_T> &v2)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
itpp::operator *	/usr/include/itpp/base/vec.h	/^Num_T operator*(const Vec<Num_T> &v1, const Vec<Num_T> &v2);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
itpp::operator *	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator*(Num_T t, const Vec<Num_T> &v)$/;"	f	namespace:itpp	signature:(Num_T t, const Vec<Num_T> &v)
itpp::operator *	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator*(Num_T t, const Vec<Num_T> &v);$/;"	p	namespace:itpp	signature:(Num_T t, const Vec<Num_T> &v)
itpp::operator *	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator*(const Vec<Num_T> &v, Num_T t)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v, Num_T t)
itpp::operator *	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator*(const Vec<Num_T> &v, Num_T t);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v, Num_T t)
itpp::operator *	/usr/include/itpp/base/vec.h	/^extern template bin operator*(const bvec &v1, const bvec &v2);$/;"	p	namespace:itpp	signature:(const bvec &v1, const bvec &v2)
itpp::operator *	/usr/include/itpp/base/vec.h	/^extern template bvec operator*(bin t, const bvec &v);$/;"	p	namespace:itpp	signature:(bin t, const bvec &v)
itpp::operator *	/usr/include/itpp/base/vec.h	/^extern template bvec operator*(const bvec &v, bin t);$/;"	p	namespace:itpp	signature:(const bvec &v, bin t)
itpp::operator *	/usr/include/itpp/base/vec.h	/^extern template cvec operator*(const cvec &v, std::complex<double> t);$/;"	p	namespace:itpp	signature:(const cvec &v, std::complex<double> t)
itpp::operator *	/usr/include/itpp/base/vec.h	/^extern template cvec operator*(std::complex<double> t, const cvec &v);$/;"	p	namespace:itpp	signature:(std::complex<double> t, const cvec &v)
itpp::operator *	/usr/include/itpp/base/vec.h	/^extern template double operator*(const vec &v1, const vec &v2);$/;"	p	namespace:itpp	signature:(const vec &v1, const vec &v2)
itpp::operator *	/usr/include/itpp/base/vec.h	/^extern template int operator*(const ivec &v1, const ivec &v2);$/;"	p	namespace:itpp	signature:(const ivec &v1, const ivec &v2)
itpp::operator *	/usr/include/itpp/base/vec.h	/^extern template ivec operator*(const ivec &v, int t);$/;"	p	namespace:itpp	signature:(const ivec &v, int t)
itpp::operator *	/usr/include/itpp/base/vec.h	/^extern template ivec operator*(int t, const ivec &v);$/;"	p	namespace:itpp	signature:(int t, const ivec &v)
itpp::operator *	/usr/include/itpp/base/vec.h	/^extern template short operator*(const svec &v1, const svec &v2);$/;"	p	namespace:itpp	signature:(const svec &v1, const svec &v2)
itpp::operator *	/usr/include/itpp/base/vec.h	/^extern template std::complex<double> operator*(const cvec &v1,$/;"	p	namespace:itpp	signature:(const cvec &v1, const cvec &v2)
itpp::operator *	/usr/include/itpp/base/vec.h	/^extern template svec operator*(const svec &v, short t);$/;"	p	namespace:itpp	signature:(const svec &v, short t)
itpp::operator *	/usr/include/itpp/base/vec.h	/^extern template svec operator*(short t, const svec &v);$/;"	p	namespace:itpp	signature:(short t, const svec &v)
itpp::operator *	/usr/include/itpp/base/vec.h	/^extern template vec operator*(const vec &v, double t);$/;"	p	namespace:itpp	signature:(const vec &v, double t)
itpp::operator *	/usr/include/itpp/base/vec.h	/^extern template vec operator*(double t, const vec &v);$/;"	p	namespace:itpp	signature:(double t, const vec &v)
itpp::operator *	/usr/include/itpp/comm/galois.h	/^GFX  operator*(const GF &ingf, const GFX &ingfx);$/;"	p	namespace:itpp	signature:(const GF &ingf, const GFX &ingfx)
itpp::operator *	/usr/include/itpp/comm/galois.h	/^GFX  operator*(const GFX &ingfx, const GF &ingf);$/;"	p	namespace:itpp	signature:(const GFX &ingfx, const GF &ingf)
itpp::operator *	/usr/include/itpp/comm/galois.h	/^inline GFX  operator*(const GFX &ingfx, const GF &ingf)$/;"	f	namespace:itpp	signature:(const GFX &ingfx, const GF &ingf)
itpp::operator *	/usr/include/itpp/comm/galois.h	/^inline GFX operator*(const GF &ingf, const GFX &ingfx)$/;"	f	namespace:itpp	signature:(const GF &ingf, const GFX &ingfx)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator*(const CFix &x, const CFix &y);$/;"	p	namespace:itpp	signature:(const CFix &x, const CFix &y)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator*(const CFix &x, const Fix &y);$/;"	p	namespace:itpp	signature:(const CFix &x, const Fix &y)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator*(const CFix &x, const int y);$/;"	p	namespace:itpp	signature:(const CFix &x, const int y)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator*(const Fix &x, const CFix &y);$/;"	p	namespace:itpp	signature:(const Fix &x, const CFix &y)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator*(const cfixvec &a, const fixvec &b);$/;"	p	namespace:itpp	signature:(const cfixvec &a, const fixvec &b)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator*(const cfixvec &a, const ivec &b);$/;"	p	namespace:itpp	signature:(const cfixvec &a, const ivec &b)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator*(const int x, const CFix &y);$/;"	p	namespace:itpp	signature:(const int x, const CFix &y)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^Fix operator*(const Fix &x, const Fix &y);$/;"	p	namespace:itpp	signature:(const Fix &x, const Fix &y)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^Fix operator*(const Fix &x, const int y);$/;"	p	namespace:itpp	signature:(const Fix &x, const int y)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^Fix operator*(const fixvec &a, const ivec &b);$/;"	p	namespace:itpp	signature:(const fixvec &a, const ivec &b)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^Fix operator*(const int x, const Fix &y);$/;"	p	namespace:itpp	signature:(const int x, const Fix &y)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^cfixmat operator*(const cfixmat &a, const fixmat &b);$/;"	p	namespace:itpp	signature:(const cfixmat &a, const fixmat &b)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^cfixmat operator*(const cfixmat &a, const imat &b);$/;"	p	namespace:itpp	signature:(const cfixmat &a, const imat &b)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^fixmat operator*(const fixmat &a, const imat &b);$/;"	p	namespace:itpp	signature:(const fixmat &a, const imat &b)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline CFix operator*(const fixvec &a, const cfixvec &b) {return b*a;}$/;"	f	namespace:itpp	signature:(const fixvec &a, const cfixvec &b)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline CFix operator*(const ivec &a, const cfixvec &b) {return b*a;}$/;"	f	namespace:itpp	signature:(const ivec &a, const cfixvec &b)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline Fix operator*(const ivec &a, const fixvec &b) {return b*a;}$/;"	f	namespace:itpp	signature:(const ivec &a, const fixvec &b)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator*(const CFix &s, const fixmat &m) {return s * to<CFix>(m);}$/;"	f	namespace:itpp	signature:(const CFix &s, const fixmat &m)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator*(const CFix &s, const imat &m) {return s * to<CFix>(to_mat(m));}$/;"	f	namespace:itpp	signature:(const CFix &s, const imat &m)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator*(const Fix &s, const cfixmat &m) {return CFix(s) * m;}$/;"	f	namespace:itpp	signature:(const Fix &s, const cfixmat &m)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator*(const cfixmat &m, const Fix &s) {return m * CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixmat &m, const Fix &s)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator*(const cfixmat &m, const int s) {return m * CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixmat &m, const int s)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator*(const fixmat &a, const cfixmat &b) {return b*a;}$/;"	f	namespace:itpp	signature:(const fixmat &a, const cfixmat &b)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator*(const fixmat &m, const CFix &s) {return to<CFix>(m) * s;}$/;"	f	namespace:itpp	signature:(const fixmat &m, const CFix &s)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator*(const imat &a, const cfixmat &b) {return b*a;}$/;"	f	namespace:itpp	signature:(const imat &a, const cfixmat &b)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator*(const imat &m, const CFix &s) {return to<CFix>(to_mat(m)) * s;}$/;"	f	namespace:itpp	signature:(const imat &m, const CFix &s)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator*(const int s, const cfixmat &m) {return CFix(s) * m;}$/;"	f	namespace:itpp	signature:(const int s, const cfixmat &m)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator*(const CFix &s, const fixvec &v) {return s * to<CFix>(v);}$/;"	f	namespace:itpp	signature:(const CFix &s, const fixvec &v)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator*(const CFix &s, const ivec &v) {return s * to<CFix>(to_vec(v));}$/;"	f	namespace:itpp	signature:(const CFix &s, const ivec &v)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator*(const Fix &s, const cfixvec &v) {return CFix(s) * v;}$/;"	f	namespace:itpp	signature:(const Fix &s, const cfixvec &v)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator*(const cfixvec &v, const Fix &s) {return v * CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixvec &v, const Fix &s)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator*(const cfixvec &v, const int s) {return v * CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixvec &v, const int s)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator*(const fixvec &v, const CFix &s) {return to<CFix>(v) * s;}$/;"	f	namespace:itpp	signature:(const fixvec &v, const CFix &s)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator*(const int s, const cfixvec &v) {return CFix(s) * v;}$/;"	f	namespace:itpp	signature:(const int s, const cfixvec &v)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator*(const ivec &v, const CFix &s) {return to<CFix>(to_vec(v)) * s;}$/;"	f	namespace:itpp	signature:(const ivec &v, const CFix &s)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline fixmat operator*(const fixmat &v, const int s) {return v * Fix(s);}$/;"	f	namespace:itpp	signature:(const fixmat &v, const int s)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline fixmat operator*(const imat &a, const fixmat &b) {return b*a;}$/;"	f	namespace:itpp	signature:(const imat &a, const fixmat &b)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline fixmat operator*(const int s, const fixmat &v) {return Fix(s) * v;}$/;"	f	namespace:itpp	signature:(const int s, const fixmat &v)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline fixvec operator*(const fixvec &v, const int s) {return v * Fix(s);}$/;"	f	namespace:itpp	signature:(const fixvec &v, const int s)
itpp::operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline fixvec operator*(const int s, const fixvec &v) {return Fix(s) * v;}$/;"	f	namespace:itpp	signature:(const int s, const fixvec &v)
itpp::operator +	/usr/include/itpp/base/gf2mat.h	/^GF2mat operator+(const GF2mat &X, const GF2mat &Y);$/;"	p	namespace:itpp	signature:(const GF2mat &X, const GF2mat &Y)
itpp::operator +	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator+(Num_T t, const Mat<Num_T> &m)$/;"	f	namespace:itpp	signature:(Num_T t, const Mat<Num_T> &m)
itpp::operator +	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator+(Num_T t, const Mat<Num_T> &m);$/;"	p	namespace:itpp	signature:(Num_T t, const Mat<Num_T> &m)
itpp::operator +	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator+(const Mat<Num_T> &m, Num_T t)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m, Num_T t)
itpp::operator +	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator+(const Mat<Num_T> &m, Num_T t);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m, Num_T t)
itpp::operator +	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator+(const Mat<Num_T> &m1, const Mat<Num_T> &m2)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::operator +	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator+(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::operator +	/usr/include/itpp/base/mat.h	/^extern template bmat operator+(bin t, const bmat &m);$/;"	p	namespace:itpp	signature:(bin t, const bmat &m)
itpp::operator +	/usr/include/itpp/base/mat.h	/^extern template bmat operator+(const bmat &m, bin t);$/;"	p	namespace:itpp	signature:(const bmat &m, bin t)
itpp::operator +	/usr/include/itpp/base/mat.h	/^extern template bmat operator+(const bmat &m1, const bmat &m2);$/;"	p	namespace:itpp	signature:(const bmat &m1, const bmat &m2)
itpp::operator +	/usr/include/itpp/base/mat.h	/^extern template cmat operator+(const cmat &m, std::complex<double> t);$/;"	p	namespace:itpp	signature:(const cmat &m, std::complex<double> t)
itpp::operator +	/usr/include/itpp/base/mat.h	/^extern template cmat operator+(const cmat &m1, const cmat &m2);$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2)
itpp::operator +	/usr/include/itpp/base/mat.h	/^extern template cmat operator+(std::complex<double> t, const cmat &m);$/;"	p	namespace:itpp	signature:(std::complex<double> t, const cmat &m)
itpp::operator +	/usr/include/itpp/base/mat.h	/^extern template imat operator+(const imat &m, int t);$/;"	p	namespace:itpp	signature:(const imat &m, int t)
itpp::operator +	/usr/include/itpp/base/mat.h	/^extern template imat operator+(const imat &m1, const imat &m2);$/;"	p	namespace:itpp	signature:(const imat &m1, const imat &m2)
itpp::operator +	/usr/include/itpp/base/mat.h	/^extern template imat operator+(int t, const imat &m);$/;"	p	namespace:itpp	signature:(int t, const imat &m)
itpp::operator +	/usr/include/itpp/base/mat.h	/^extern template mat operator+(const mat &m, double t);$/;"	p	namespace:itpp	signature:(const mat &m, double t)
itpp::operator +	/usr/include/itpp/base/mat.h	/^extern template mat operator+(const mat &m1, const mat &m2);$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2)
itpp::operator +	/usr/include/itpp/base/mat.h	/^extern template mat operator+(double t, const mat &m);$/;"	p	namespace:itpp	signature:(double t, const mat &m)
itpp::operator +	/usr/include/itpp/base/mat.h	/^extern template smat operator+(const smat &m, short t);$/;"	p	namespace:itpp	signature:(const smat &m, short t)
itpp::operator +	/usr/include/itpp/base/mat.h	/^extern template smat operator+(const smat &m1, const smat &m2);$/;"	p	namespace:itpp	signature:(const smat &m1, const smat &m2)
itpp::operator +	/usr/include/itpp/base/mat.h	/^extern template smat operator+(short t, const smat &m);$/;"	p	namespace:itpp	signature:(short t, const smat &m)
itpp::operator +	/usr/include/itpp/base/operators.h	/^cmat operator+(const bmat &a, const cmat &b);$/;"	p	namespace:itpp	signature:(const bmat &a, const cmat &b)
itpp::operator +	/usr/include/itpp/base/operators.h	/^cmat operator+(const double &s, const cmat &m);$/;"	p	namespace:itpp	signature:(const double &s, const cmat &m)
itpp::operator +	/usr/include/itpp/base/operators.h	/^cmat operator+(const imat &a, const cmat &b);$/;"	p	namespace:itpp	signature:(const imat &a, const cmat &b)
itpp::operator +	/usr/include/itpp/base/operators.h	/^cmat operator+(const mat &a, const cmat &b);$/;"	p	namespace:itpp	signature:(const mat &a, const cmat &b)
itpp::operator +	/usr/include/itpp/base/operators.h	/^cmat operator+(const smat &a, const cmat &b);$/;"	p	namespace:itpp	signature:(const smat &a, const cmat &b)
itpp::operator +	/usr/include/itpp/base/operators.h	/^cvec operator+(const bvec &a, const cvec &b);$/;"	p	namespace:itpp	signature:(const bvec &a, const cvec &b)
itpp::operator +	/usr/include/itpp/base/operators.h	/^cvec operator+(const double &s, const cvec &v);$/;"	p	namespace:itpp	signature:(const double &s, const cvec &v)
itpp::operator +	/usr/include/itpp/base/operators.h	/^cvec operator+(const ivec &a, const cvec &b);$/;"	p	namespace:itpp	signature:(const ivec &a, const cvec &b)
itpp::operator +	/usr/include/itpp/base/operators.h	/^cvec operator+(const std::complex<double> &s, const ivec &v);$/;"	p	namespace:itpp	signature:(const std::complex<double> &s, const ivec &v)
itpp::operator +	/usr/include/itpp/base/operators.h	/^cvec operator+(const svec &a, const cvec &b);$/;"	p	namespace:itpp	signature:(const svec &a, const cvec &b)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline cmat operator+(const cmat &a, const bmat &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const cmat &a, const bmat &b)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline cmat operator+(const cmat &a, const imat &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const cmat &a, const imat &b)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline cmat operator+(const cmat &a, const mat &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const cmat &a, const mat &b)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline cmat operator+(const cmat &a, const smat &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const cmat &a, const smat &b)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline cvec operator+(const cvec &a, const bvec &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const cvec &a, const bvec &b)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline cvec operator+(const cvec &a, const ivec &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const cvec &a, const ivec &b)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline cvec operator+(const cvec &a, const svec &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const cvec &a, const svec &b)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline cvec operator+(const cvec &v, const double &s) {return s + v;}$/;"	f	namespace:itpp	signature:(const cvec &v, const double &s)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline cvec operator+(const cvec &v, const float &s) {return s + v;}$/;"	f	namespace:itpp	signature:(const cvec &v, const float &s)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline cvec operator+(const cvec &v, const int &s) {return s + v;}$/;"	f	namespace:itpp	signature:(const cvec &v, const int &s)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline cvec operator+(const cvec &v, const short &s) {return s + v;}$/;"	f	namespace:itpp	signature:(const cvec &v, const short &s)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline cvec operator+(const float &s, const cvec &v) {return static_cast<double>(s) + v;}$/;"	f	namespace:itpp	signature:(const float &s, const cvec &v)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline cvec operator+(const int &s, const cvec &v) {return static_cast<double>(s) + v;}$/;"	f	namespace:itpp	signature:(const int &s, const cvec &v)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline cvec operator+(const ivec &v, const std::complex<double> &s) { return s + v;}$/;"	f	namespace:itpp	signature:(const ivec &v, const std::complex<double> &s)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline cvec operator+(const short &s, const cvec &v) {return static_cast<double>(s) + v;}$/;"	f	namespace:itpp	signature:(const short &s, const cvec &v)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline mat operator+(const float &s, const mat &m) {return static_cast<double>(s) + m;}$/;"	f	namespace:itpp	signature:(const float &s, const mat &m)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline mat operator+(const int &s, const mat &m) {return static_cast<double>(s) + m;}$/;"	f	namespace:itpp	signature:(const int &s, const mat &m)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline mat operator+(const mat &a, const bmat &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const mat &a, const bmat &b)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline mat operator+(const mat &a, const imat &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const mat &a, const imat &b)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline mat operator+(const mat &a, const smat &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const mat &a, const smat &b)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline mat operator+(const mat &m, const float &s) {return static_cast<double>(s) + m;}$/;"	f	namespace:itpp	signature:(const mat &m, const float &s)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline mat operator+(const mat &m, const int &s) {return static_cast<double>(s) + m;}$/;"	f	namespace:itpp	signature:(const mat &m, const int &s)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline mat operator+(const mat &m, const short &s) {return static_cast<double>(s) + m;}$/;"	f	namespace:itpp	signature:(const mat &m, const short &s)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline mat operator+(const short &s, const mat &m) {return static_cast<double>(s) + m;}$/;"	f	namespace:itpp	signature:(const short &s, const mat &m)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator+(const float &x, const std::complex<double> &y) {return std::complex<double>(x + y.real(), x + y.imag());}$/;"	f	namespace:itpp	signature:(const float &x, const std::complex<double> &y)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator+(const int &x, const std::complex<double> &y) {return std::complex<double>(x + y.real(), x + y.imag());}$/;"	f	namespace:itpp	signature:(const int &x, const std::complex<double> &y)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator+(const std::complex<double> &x, const float &y) {return std::complex<double>(x.real() + y, x.imag() + y);}$/;"	f	namespace:itpp	signature:(const std::complex<double> &x, const float &y)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator+(const std::complex<double> &x, const int &y) {return std::complex<double>(x.real() + y, x.imag() + y);}$/;"	f	namespace:itpp	signature:(const std::complex<double> &x, const int &y)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline vec operator+(const float &s, const vec &v) {return static_cast<double>(s) + v;}$/;"	f	namespace:itpp	signature:(const float &s, const vec &v)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline vec operator+(const int &s, const vec &v) {return static_cast<double>(s) + v;}$/;"	f	namespace:itpp	signature:(const int &s, const vec &v)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline vec operator+(const ivec &v, const double &s) { return s + v;}$/;"	f	namespace:itpp	signature:(const ivec &v, const double &s)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline vec operator+(const short &s, const vec &v) {return static_cast<double>(s) + v;}$/;"	f	namespace:itpp	signature:(const short &s, const vec &v)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline vec operator+(const vec &a, const bvec &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const vec &a, const bvec &b)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline vec operator+(const vec &a, const ivec &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const vec &a, const ivec &b)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline vec operator+(const vec &a, const svec &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const vec &a, const svec &b)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline vec operator+(const vec &v, const float &s) {return static_cast<double>(s) + v;}$/;"	f	namespace:itpp	signature:(const vec &v, const float &s)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline vec operator+(const vec &v, const int &s) {return static_cast<double>(s) + v;}$/;"	f	namespace:itpp	signature:(const vec &v, const int &s)
itpp::operator +	/usr/include/itpp/base/operators.h	/^inline vec operator+(const vec &v, const short &s) {return static_cast<double>(s) + v;}$/;"	f	namespace:itpp	signature:(const vec &v, const short &s)
itpp::operator +	/usr/include/itpp/base/operators.h	/^mat operator+(const bmat &a, const mat &b);$/;"	p	namespace:itpp	signature:(const bmat &a, const mat &b)
itpp::operator +	/usr/include/itpp/base/operators.h	/^mat operator+(const imat &a, const mat &b);$/;"	p	namespace:itpp	signature:(const imat &a, const mat &b)
itpp::operator +	/usr/include/itpp/base/operators.h	/^mat operator+(const smat &a, const mat &b);$/;"	p	namespace:itpp	signature:(const smat &a, const mat &b)
itpp::operator +	/usr/include/itpp/base/operators.h	/^vec operator+(const bvec &a, const vec &b);$/;"	p	namespace:itpp	signature:(const bvec &a, const vec &b)
itpp::operator +	/usr/include/itpp/base/operators.h	/^vec operator+(const double &s, const ivec &v);$/;"	p	namespace:itpp	signature:(const double &s, const ivec &v)
itpp::operator +	/usr/include/itpp/base/operators.h	/^vec operator+(const ivec &a, const vec &b);$/;"	p	namespace:itpp	signature:(const ivec &a, const vec &b)
itpp::operator +	/usr/include/itpp/base/operators.h	/^vec operator+(const svec &a, const vec &b);$/;"	p	namespace:itpp	signature:(const svec &a, const vec &b)
itpp::operator +	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> operator+(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)$/;"	f	namespace:itpp	signature:(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)
itpp::operator +	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> operator+(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2);$/;"	p	namespace:itpp	signature:(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)
itpp::operator +	/usr/include/itpp/base/smat.h	/^extern template sparse_cmat operator+(const sparse_cmat &, const sparse_cmat &);$/;"	p	namespace:itpp	signature:(const sparse_cmat &, const sparse_cmat &)
itpp::operator +	/usr/include/itpp/base/smat.h	/^extern template sparse_imat operator+(const sparse_imat &, const sparse_imat &);$/;"	p	namespace:itpp	signature:(const sparse_imat &, const sparse_imat &)
itpp::operator +	/usr/include/itpp/base/smat.h	/^extern template sparse_mat operator+(const sparse_mat &, const sparse_mat &);$/;"	p	namespace:itpp	signature:(const sparse_mat &, const sparse_mat &)
itpp::operator +	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T> operator+(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2)$/;"	f	namespace:itpp	signature:(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2)
itpp::operator +	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T> operator+(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2);$/;"	p	namespace:itpp	signature:(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2)
itpp::operator +	/usr/include/itpp/base/svec.h	/^extern template sparse_cvec operator+(const sparse_cvec &,$/;"	p	namespace:itpp	signature:(const sparse_cvec &, const sparse_cvec &)
itpp::operator +	/usr/include/itpp/base/svec.h	/^extern template sparse_ivec operator+(const sparse_ivec &,$/;"	p	namespace:itpp	signature:(const sparse_ivec &, const sparse_ivec &)
itpp::operator +	/usr/include/itpp/base/svec.h	/^extern template sparse_vec operator+(const sparse_vec &,$/;"	p	namespace:itpp	signature:(const sparse_vec &, const sparse_vec &)
itpp::operator +	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator+(Num_T t, const Vec<Num_T> &v)$/;"	f	namespace:itpp	signature:(Num_T t, const Vec<Num_T> &v)
itpp::operator +	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator+(Num_T t, const Vec<Num_T> &v);$/;"	p	namespace:itpp	signature:(Num_T t, const Vec<Num_T> &v)
itpp::operator +	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator+(const Vec<Num_T> &v, Num_T t)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v, Num_T t)
itpp::operator +	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator+(const Vec<Num_T> &v, Num_T t);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v, Num_T t)
itpp::operator +	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator+(const Vec<Num_T> &v1, const Vec<Num_T> &v2)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
itpp::operator +	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator+(const Vec<Num_T> &v1, const Vec<Num_T> &v2);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
itpp::operator +	/usr/include/itpp/base/vec.h	/^extern template bvec operator+(bin t, const bvec &v1);$/;"	p	namespace:itpp	signature:(bin t, const bvec &v1)
itpp::operator +	/usr/include/itpp/base/vec.h	/^extern template bvec operator+(const bvec &v1, bin t);$/;"	p	namespace:itpp	signature:(const bvec &v1, bin t)
itpp::operator +	/usr/include/itpp/base/vec.h	/^extern template bvec operator+(const bvec &v1, const bvec &v2);$/;"	p	namespace:itpp	signature:(const bvec &v1, const bvec &v2)
itpp::operator +	/usr/include/itpp/base/vec.h	/^extern template cvec operator+(const cvec &v1, const cvec &v2);$/;"	p	namespace:itpp	signature:(const cvec &v1, const cvec &v2)
itpp::operator +	/usr/include/itpp/base/vec.h	/^extern template cvec operator+(const cvec &v1, std::complex<double> t);$/;"	p	namespace:itpp	signature:(const cvec &v1, std::complex<double> t)
itpp::operator +	/usr/include/itpp/base/vec.h	/^extern template cvec operator+(std::complex<double> t, const cvec &v1);$/;"	p	namespace:itpp	signature:(std::complex<double> t, const cvec &v1)
itpp::operator +	/usr/include/itpp/base/vec.h	/^extern template ivec operator+(const ivec &v1, const ivec &v2);$/;"	p	namespace:itpp	signature:(const ivec &v1, const ivec &v2)
itpp::operator +	/usr/include/itpp/base/vec.h	/^extern template ivec operator+(const ivec &v1, int t);$/;"	p	namespace:itpp	signature:(const ivec &v1, int t)
itpp::operator +	/usr/include/itpp/base/vec.h	/^extern template ivec operator+(int t, const ivec &v1);$/;"	p	namespace:itpp	signature:(int t, const ivec &v1)
itpp::operator +	/usr/include/itpp/base/vec.h	/^extern template svec operator+(const svec &v1, const svec &v2);$/;"	p	namespace:itpp	signature:(const svec &v1, const svec &v2)
itpp::operator +	/usr/include/itpp/base/vec.h	/^extern template svec operator+(const svec &v1, short t);$/;"	p	namespace:itpp	signature:(const svec &v1, short t)
itpp::operator +	/usr/include/itpp/base/vec.h	/^extern template svec operator+(short t, const svec &v1);$/;"	p	namespace:itpp	signature:(short t, const svec &v1)
itpp::operator +	/usr/include/itpp/base/vec.h	/^extern template vec operator+(const vec &v1, const vec &v2);$/;"	p	namespace:itpp	signature:(const vec &v1, const vec &v2)
itpp::operator +	/usr/include/itpp/base/vec.h	/^extern template vec operator+(const vec &v1, double t);$/;"	p	namespace:itpp	signature:(const vec &v1, double t)
itpp::operator +	/usr/include/itpp/base/vec.h	/^extern template vec operator+(double t, const vec &v1);$/;"	p	namespace:itpp	signature:(double t, const vec &v1)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator+(const CFix &x, const CFix &y);$/;"	p	namespace:itpp	signature:(const CFix &x, const CFix &y)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator+(const CFix &x, const Fix &y);$/;"	p	namespace:itpp	signature:(const CFix &x, const Fix &y)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator+(const CFix &x, const int y);$/;"	p	namespace:itpp	signature:(const CFix &x, const int y)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator+(const Fix &x, const CFix &y);$/;"	p	namespace:itpp	signature:(const Fix &x, const CFix &y)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator+(const int x, const CFix &y);$/;"	p	namespace:itpp	signature:(const int x, const CFix &y)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^Fix operator+(const Fix &x, const Fix &y);$/;"	p	namespace:itpp	signature:(const Fix &x, const Fix &y)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^Fix operator+(const Fix &x, const int y);$/;"	p	namespace:itpp	signature:(const Fix &x, const int y)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^Fix operator+(const int x, const Fix &y);$/;"	p	namespace:itpp	signature:(const int x, const Fix &y)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^cfixmat operator+(const cfixmat &a, const fixmat &b);$/;"	p	namespace:itpp	signature:(const cfixmat &a, const fixmat &b)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^cfixmat operator+(const cfixmat &a, const imat &b);$/;"	p	namespace:itpp	signature:(const cfixmat &a, const imat &b)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^cfixvec operator+(const cfixvec &a, const fixvec &b);$/;"	p	namespace:itpp	signature:(const cfixvec &a, const fixvec &b)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^cfixvec operator+(const cfixvec &a, const ivec &b);$/;"	p	namespace:itpp	signature:(const cfixvec &a, const ivec &b)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^fixmat operator+(const fixmat &a, const imat &b);$/;"	p	namespace:itpp	signature:(const fixmat &a, const imat &b)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^fixvec operator+(const fixvec &a, const ivec &b);$/;"	p	namespace:itpp	signature:(const fixvec &a, const ivec &b)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator+(const CFix &s, const fixmat &m) {return s + to<CFix>(m);}$/;"	f	namespace:itpp	signature:(const CFix &s, const fixmat &m)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator+(const CFix &s, const imat &m) {return s + to<CFix>(to_mat(m));}$/;"	f	namespace:itpp	signature:(const CFix &s, const imat &m)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator+(const Fix &s, const cfixmat &m) {return CFix(s) + m;}$/;"	f	namespace:itpp	signature:(const Fix &s, const cfixmat &m)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator+(const cfixmat &m, const Fix &s) {return m + CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixmat &m, const Fix &s)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator+(const cfixmat &m, const int s) {return m + CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixmat &m, const int s)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator+(const fixmat &a, const cfixmat &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const fixmat &a, const cfixmat &b)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator+(const fixmat &m, const CFix &s) {return to<CFix>(m) + s;}$/;"	f	namespace:itpp	signature:(const fixmat &m, const CFix &s)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator+(const imat &a, const cfixmat &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const imat &a, const cfixmat &b)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator+(const imat &m, const CFix &s) {return to<CFix>(to_mat(m)) + s;}$/;"	f	namespace:itpp	signature:(const imat &m, const CFix &s)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator+(const int s, const cfixmat &m) {return CFix(s) + m;}$/;"	f	namespace:itpp	signature:(const int s, const cfixmat &m)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator+(const CFix &s, const fixvec &v) {return s + to<CFix>(v);}$/;"	f	namespace:itpp	signature:(const CFix &s, const fixvec &v)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator+(const CFix &s, const ivec &v) {return s + to<CFix>(to_vec(v));}$/;"	f	namespace:itpp	signature:(const CFix &s, const ivec &v)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator+(const Fix &s, const cfixvec &v) {return CFix(s) + v;}$/;"	f	namespace:itpp	signature:(const Fix &s, const cfixvec &v)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator+(const cfixvec &v, const Fix &s) {return v + CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixvec &v, const Fix &s)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator+(const cfixvec &v, const int s) {return v + CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixvec &v, const int s)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator+(const fixvec &a, const cfixvec &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const fixvec &a, const cfixvec &b)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator+(const fixvec &v, const CFix &s) {return to<CFix>(v) + s;}$/;"	f	namespace:itpp	signature:(const fixvec &v, const CFix &s)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator+(const int s, const cfixvec &v) {return CFix(s) + v;}$/;"	f	namespace:itpp	signature:(const int s, const cfixvec &v)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator+(const ivec &a, const cfixvec &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const ivec &a, const cfixvec &b)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator+(const ivec &v, const CFix &s) {return to<CFix>(to_vec(v)) + s;}$/;"	f	namespace:itpp	signature:(const ivec &v, const CFix &s)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline fixmat operator+(const fixmat &v, const int s) {return v + Fix(s);}$/;"	f	namespace:itpp	signature:(const fixmat &v, const int s)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline fixmat operator+(const imat &a, const fixmat &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const imat &a, const fixmat &b)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline fixmat operator+(const int s, const fixmat &v) {return Fix(s) + v;}$/;"	f	namespace:itpp	signature:(const int s, const fixmat &v)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline fixvec operator+(const fixvec &v, const int s) {return v + Fix(s);}$/;"	f	namespace:itpp	signature:(const fixvec &v, const int s)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline fixvec operator+(const int s, const fixvec &v) {return Fix(s) + v;}$/;"	f	namespace:itpp	signature:(const int s, const fixvec &v)
itpp::operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline fixvec operator+(const ivec &a, const fixvec &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const ivec &a, const fixvec &b)
itpp::operator -	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator-(Num_T t, const Mat<Num_T> &m)$/;"	f	namespace:itpp	signature:(Num_T t, const Mat<Num_T> &m)
itpp::operator -	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator-(Num_T t, const Mat<Num_T> &m);$/;"	p	namespace:itpp	signature:(Num_T t, const Mat<Num_T> &m)
itpp::operator -	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator-(const Mat<Num_T> &m)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m)
itpp::operator -	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator-(const Mat<Num_T> &m);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m)
itpp::operator -	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator-(const Mat<Num_T> &m, Num_T t)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m, Num_T t)
itpp::operator -	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator-(const Mat<Num_T> &m, Num_T t);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m, Num_T t)
itpp::operator -	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator-(const Mat<Num_T> &m1, const Mat<Num_T> &m2)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::operator -	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator-(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
itpp::operator -	/usr/include/itpp/base/mat.h	/^extern template bmat operator-(bin t, const bmat &m);$/;"	p	namespace:itpp	signature:(bin t, const bmat &m)
itpp::operator -	/usr/include/itpp/base/mat.h	/^extern template bmat operator-(const bmat &m);$/;"	p	namespace:itpp	signature:(const bmat &m)
itpp::operator -	/usr/include/itpp/base/mat.h	/^extern template bmat operator-(const bmat &m, bin t);$/;"	p	namespace:itpp	signature:(const bmat &m, bin t)
itpp::operator -	/usr/include/itpp/base/mat.h	/^extern template bmat operator-(const bmat &m1, const bmat &m2);$/;"	p	namespace:itpp	signature:(const bmat &m1, const bmat &m2)
itpp::operator -	/usr/include/itpp/base/mat.h	/^extern template cmat operator-(const cmat &m);$/;"	p	namespace:itpp	signature:(const cmat &m)
itpp::operator -	/usr/include/itpp/base/mat.h	/^extern template cmat operator-(const cmat &m, std::complex<double> t);$/;"	p	namespace:itpp	signature:(const cmat &m, std::complex<double> t)
itpp::operator -	/usr/include/itpp/base/mat.h	/^extern template cmat operator-(const cmat &m1, const cmat &m2);$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2)
itpp::operator -	/usr/include/itpp/base/mat.h	/^extern template cmat operator-(std::complex<double> t, const cmat &m);$/;"	p	namespace:itpp	signature:(std::complex<double> t, const cmat &m)
itpp::operator -	/usr/include/itpp/base/mat.h	/^extern template imat operator-(const imat &m);$/;"	p	namespace:itpp	signature:(const imat &m)
itpp::operator -	/usr/include/itpp/base/mat.h	/^extern template imat operator-(const imat &m, int t);$/;"	p	namespace:itpp	signature:(const imat &m, int t)
itpp::operator -	/usr/include/itpp/base/mat.h	/^extern template imat operator-(const imat &m1, const imat &m2);$/;"	p	namespace:itpp	signature:(const imat &m1, const imat &m2)
itpp::operator -	/usr/include/itpp/base/mat.h	/^extern template imat operator-(int t, const imat &m);$/;"	p	namespace:itpp	signature:(int t, const imat &m)
itpp::operator -	/usr/include/itpp/base/mat.h	/^extern template mat operator-(const mat &m);$/;"	p	namespace:itpp	signature:(const mat &m)
itpp::operator -	/usr/include/itpp/base/mat.h	/^extern template mat operator-(const mat &m, double t);$/;"	p	namespace:itpp	signature:(const mat &m, double t)
itpp::operator -	/usr/include/itpp/base/mat.h	/^extern template mat operator-(const mat &m1, const mat &m2);$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2)
itpp::operator -	/usr/include/itpp/base/mat.h	/^extern template mat operator-(double t, const mat &m);$/;"	p	namespace:itpp	signature:(double t, const mat &m)
itpp::operator -	/usr/include/itpp/base/mat.h	/^extern template smat operator-(const smat &m);$/;"	p	namespace:itpp	signature:(const smat &m)
itpp::operator -	/usr/include/itpp/base/mat.h	/^extern template smat operator-(const smat &m, short t);$/;"	p	namespace:itpp	signature:(const smat &m, short t)
itpp::operator -	/usr/include/itpp/base/mat.h	/^extern template smat operator-(const smat &m1, const smat &m2);$/;"	p	namespace:itpp	signature:(const smat &m1, const smat &m2)
itpp::operator -	/usr/include/itpp/base/mat.h	/^extern template smat operator-(short t, const smat &m);$/;"	p	namespace:itpp	signature:(short t, const smat &m)
itpp::operator -	/usr/include/itpp/base/operators.h	/^cmat operator-(const double &s, const cmat &m);$/;"	p	namespace:itpp	signature:(const double &s, const cmat &m)
itpp::operator -	/usr/include/itpp/base/operators.h	/^cvec operator-(const double &s, const cvec &v);$/;"	p	namespace:itpp	signature:(const double &s, const cvec &v)
itpp::operator -	/usr/include/itpp/base/operators.h	/^cvec operator-(const std::complex<double> &s, const ivec &v);$/;"	p	namespace:itpp	signature:(const std::complex<double> &s, const ivec &v)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline cmat operator-(const bmat &a, const cmat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const bmat &a, const cmat &b)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline cmat operator-(const cmat &a, const bmat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const cmat &a, const bmat &b)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline cmat operator-(const cmat &a, const imat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const cmat &a, const imat &b)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline cmat operator-(const cmat &a, const mat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const cmat &a, const mat &b)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline cmat operator-(const cmat &a, const smat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const cmat &a, const smat &b)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline cmat operator-(const imat &a, const cmat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const imat &a, const cmat &b)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline cmat operator-(const mat &a, const cmat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const mat &a, const cmat &b)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline cmat operator-(const smat &a, const cmat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const smat &a, const cmat &b)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const bvec &a, const cvec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const bvec &a, const cvec &b)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const cvec &a, const bvec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const cvec &a, const bvec &b)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const cvec &a, const ivec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const cvec &a, const ivec &b)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const cvec &a, const svec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const cvec &a, const svec &b)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const cvec &v, const double &s) {return v + (-s);}$/;"	f	namespace:itpp	signature:(const cvec &v, const double &s)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const cvec &v, const float &s) {return v + (-s);}$/;"	f	namespace:itpp	signature:(const cvec &v, const float &s)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const cvec &v, const int &s) {return v + (-s);}$/;"	f	namespace:itpp	signature:(const cvec &v, const int &s)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const cvec &v, const short &s) {return v + (-s);}$/;"	f	namespace:itpp	signature:(const cvec &v, const short &s)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const float &s, const cvec &v) {return static_cast<double>(s) - v;}$/;"	f	namespace:itpp	signature:(const float &s, const cvec &v)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const int &s, const cvec &v) {return static_cast<double>(s) - v;}$/;"	f	namespace:itpp	signature:(const int &s, const cvec &v)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const ivec &a, const cvec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const ivec &a, const cvec &b)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const ivec &v, const std::complex<double> &s) { return v + (-s); }$/;"	f	namespace:itpp	signature:(const ivec &v, const std::complex<double> &s)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const short &s, const cvec &v) {return static_cast<double>(s) - v;}$/;"	f	namespace:itpp	signature:(const short &s, const cvec &v)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const svec &a, const cvec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const svec &a, const cvec &b)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline mat operator-(const bmat &a, const mat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const bmat &a, const mat &b)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline mat operator-(const float &s, const mat &m) {return static_cast<double>(s) - m;}$/;"	f	namespace:itpp	signature:(const float &s, const mat &m)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline mat operator-(const imat &a, const mat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const imat &a, const mat &b)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline mat operator-(const int &s, const mat &m) {return static_cast<double>(s) - m;}$/;"	f	namespace:itpp	signature:(const int &s, const mat &m)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline mat operator-(const mat &a, const bmat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const mat &a, const bmat &b)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline mat operator-(const mat &a, const imat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const mat &a, const imat &b)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline mat operator-(const mat &a, const smat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const mat &a, const smat &b)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline mat operator-(const mat &m, const float &s) {return m -static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const mat &m, const float &s)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline mat operator-(const mat &m, const int &s) {return m -static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const mat &m, const int &s)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline mat operator-(const mat &m, const short &s) {return m -static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const mat &m, const short &s)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline mat operator-(const short &s, const mat &m) {return static_cast<double>(s) - m;}$/;"	f	namespace:itpp	signature:(const short &s, const mat &m)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline mat operator-(const smat &a, const mat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const smat &a, const mat &b)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator-(const float &x, const std::complex<double> &y) {return std::complex<double>(x - y.real(), x - y.imag());}$/;"	f	namespace:itpp	signature:(const float &x, const std::complex<double> &y)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator-(const int &x, const std::complex<double> &y) {return std::complex<double>(x - y.real(), x - y.imag());}$/;"	f	namespace:itpp	signature:(const int &x, const std::complex<double> &y)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator-(const std::complex<double> &x, const float &y) {return std::complex<double>(x.real() - y, x.imag() - y);}$/;"	f	namespace:itpp	signature:(const std::complex<double> &x, const float &y)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator-(const std::complex<double> &x, const int &y) {return std::complex<double>(x.real() - y, x.imag() - y);}$/;"	f	namespace:itpp	signature:(const std::complex<double> &x, const int &y)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline vec operator-(const bvec &a, const vec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const bvec &a, const vec &b)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline vec operator-(const float &s, const vec &v) {return static_cast<double>(s) - v;}$/;"	f	namespace:itpp	signature:(const float &s, const vec &v)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline vec operator-(const int &s, const vec &v) {return static_cast<double>(s) - v;}$/;"	f	namespace:itpp	signature:(const int &s, const vec &v)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline vec operator-(const ivec &a, const vec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const ivec &a, const vec &b)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline vec operator-(const ivec &v, const double &s) { return v + (-s); }$/;"	f	namespace:itpp	signature:(const ivec &v, const double &s)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline vec operator-(const short &s, const vec &v) {return static_cast<double>(s) - v;}$/;"	f	namespace:itpp	signature:(const short &s, const vec &v)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline vec operator-(const svec &a, const vec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const svec &a, const vec &b)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline vec operator-(const vec &a, const bvec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const vec &a, const bvec &b)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline vec operator-(const vec &a, const ivec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const vec &a, const ivec &b)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline vec operator-(const vec &a, const svec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const vec &a, const svec &b)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline vec operator-(const vec &v, const float &s) {return v -static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const vec &v, const float &s)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline vec operator-(const vec &v, const int &s) {return v -static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const vec &v, const int &s)
itpp::operator -	/usr/include/itpp/base/operators.h	/^inline vec operator-(const vec &v, const short &s) {return v -static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const vec &v, const short &s)
itpp::operator -	/usr/include/itpp/base/operators.h	/^vec operator-(const double &s, const ivec &v);$/;"	p	namespace:itpp	signature:(const double &s, const ivec &v)
itpp::operator -	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator-(Num_T t, const Vec<Num_T> &v)$/;"	f	namespace:itpp	signature:(Num_T t, const Vec<Num_T> &v)
itpp::operator -	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator-(Num_T t, const Vec<Num_T> &v);$/;"	p	namespace:itpp	signature:(Num_T t, const Vec<Num_T> &v)
itpp::operator -	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator-(const Vec<Num_T> &v)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v)
itpp::operator -	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator-(const Vec<Num_T> &v);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v)
itpp::operator -	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator-(const Vec<Num_T> &v, Num_T t)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v, Num_T t)
itpp::operator -	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator-(const Vec<Num_T> &v, Num_T t);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v, Num_T t)
itpp::operator -	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator-(const Vec<Num_T> &v1, const Vec<Num_T> &v2)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
itpp::operator -	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator-(const Vec<Num_T> &v1, const Vec<Num_T> &v2);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
itpp::operator -	/usr/include/itpp/base/vec.h	/^extern template bvec operator-(bin t, const bvec &v);$/;"	p	namespace:itpp	signature:(bin t, const bvec &v)
itpp::operator -	/usr/include/itpp/base/vec.h	/^extern template bvec operator-(const bvec &v);$/;"	p	namespace:itpp	signature:(const bvec &v)
itpp::operator -	/usr/include/itpp/base/vec.h	/^extern template bvec operator-(const bvec &v, bin t);$/;"	p	namespace:itpp	signature:(const bvec &v, bin t)
itpp::operator -	/usr/include/itpp/base/vec.h	/^extern template bvec operator-(const bvec &v1, const bvec &v2);$/;"	p	namespace:itpp	signature:(const bvec &v1, const bvec &v2)
itpp::operator -	/usr/include/itpp/base/vec.h	/^extern template cvec operator-(const cvec &v);$/;"	p	namespace:itpp	signature:(const cvec &v)
itpp::operator -	/usr/include/itpp/base/vec.h	/^extern template cvec operator-(const cvec &v, std::complex<double> t);$/;"	p	namespace:itpp	signature:(const cvec &v, std::complex<double> t)
itpp::operator -	/usr/include/itpp/base/vec.h	/^extern template cvec operator-(const cvec &v1, const cvec &v2);$/;"	p	namespace:itpp	signature:(const cvec &v1, const cvec &v2)
itpp::operator -	/usr/include/itpp/base/vec.h	/^extern template cvec operator-(std::complex<double> t, const cvec &v);$/;"	p	namespace:itpp	signature:(std::complex<double> t, const cvec &v)
itpp::operator -	/usr/include/itpp/base/vec.h	/^extern template ivec operator-(const ivec &v);$/;"	p	namespace:itpp	signature:(const ivec &v)
itpp::operator -	/usr/include/itpp/base/vec.h	/^extern template ivec operator-(const ivec &v, int t);$/;"	p	namespace:itpp	signature:(const ivec &v, int t)
itpp::operator -	/usr/include/itpp/base/vec.h	/^extern template ivec operator-(const ivec &v1, const ivec &v2);$/;"	p	namespace:itpp	signature:(const ivec &v1, const ivec &v2)
itpp::operator -	/usr/include/itpp/base/vec.h	/^extern template ivec operator-(int t, const ivec &v);$/;"	p	namespace:itpp	signature:(int t, const ivec &v)
itpp::operator -	/usr/include/itpp/base/vec.h	/^extern template svec operator-(const svec &v);$/;"	p	namespace:itpp	signature:(const svec &v)
itpp::operator -	/usr/include/itpp/base/vec.h	/^extern template svec operator-(const svec &v, short t);$/;"	p	namespace:itpp	signature:(const svec &v, short t)
itpp::operator -	/usr/include/itpp/base/vec.h	/^extern template svec operator-(const svec &v1, const svec &v2);$/;"	p	namespace:itpp	signature:(const svec &v1, const svec &v2)
itpp::operator -	/usr/include/itpp/base/vec.h	/^extern template svec operator-(short t, const svec &v);$/;"	p	namespace:itpp	signature:(short t, const svec &v)
itpp::operator -	/usr/include/itpp/base/vec.h	/^extern template vec operator-(const vec &v);$/;"	p	namespace:itpp	signature:(const vec &v)
itpp::operator -	/usr/include/itpp/base/vec.h	/^extern template vec operator-(const vec &v, double t);$/;"	p	namespace:itpp	signature:(const vec &v, double t)
itpp::operator -	/usr/include/itpp/base/vec.h	/^extern template vec operator-(const vec &v1, const vec &v2);$/;"	p	namespace:itpp	signature:(const vec &v1, const vec &v2)
itpp::operator -	/usr/include/itpp/base/vec.h	/^extern template vec operator-(double t, const vec &v);$/;"	p	namespace:itpp	signature:(double t, const vec &v)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator-(const CFix &x, const CFix &y);$/;"	p	namespace:itpp	signature:(const CFix &x, const CFix &y)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator-(const CFix &x, const Fix &y);$/;"	p	namespace:itpp	signature:(const CFix &x, const Fix &y)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator-(const CFix &x, const int y);$/;"	p	namespace:itpp	signature:(const CFix &x, const int y)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator-(const Fix &x, const CFix &y);$/;"	p	namespace:itpp	signature:(const Fix &x, const CFix &y)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator-(const int x, const CFix &y);$/;"	p	namespace:itpp	signature:(const int x, const CFix &y)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^Fix operator-(const Fix &x, const Fix &y);$/;"	p	namespace:itpp	signature:(const Fix &x, const Fix &y)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^Fix operator-(const Fix &x, const int y);$/;"	p	namespace:itpp	signature:(const Fix &x, const int y)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^Fix operator-(const int x, const Fix &y);$/;"	p	namespace:itpp	signature:(const int x, const Fix &y)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator-(const CFix &s, const fixmat &m) {return s - to<CFix>(m);}$/;"	f	namespace:itpp	signature:(const CFix &s, const fixmat &m)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator-(const CFix &s, const imat &m) {return s - to<CFix>(to_mat(m));}$/;"	f	namespace:itpp	signature:(const CFix &s, const imat &m)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator-(const Fix &s, const cfixmat &m) {return CFix(s) - m;}$/;"	f	namespace:itpp	signature:(const Fix &s, const cfixmat &m)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator-(const cfixmat &a, const fixmat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const cfixmat &a, const fixmat &b)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator-(const cfixmat &a, const imat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const cfixmat &a, const imat &b)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator-(const cfixmat &m, const Fix &s) {return m - CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixmat &m, const Fix &s)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator-(const cfixmat &m, const int s) {return m - CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixmat &m, const int s)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator-(const fixmat &a, const cfixmat &b) {return (-b) + a;}$/;"	f	namespace:itpp	signature:(const fixmat &a, const cfixmat &b)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator-(const fixmat &m, const CFix &s) {return to<CFix>(m) - s;}$/;"	f	namespace:itpp	signature:(const fixmat &m, const CFix &s)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator-(const imat &a, const cfixmat &b) {return (-b) + a;}$/;"	f	namespace:itpp	signature:(const imat &a, const cfixmat &b)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator-(const imat &m, const CFix &s) {return to<CFix>(to_mat(m)) - s;}$/;"	f	namespace:itpp	signature:(const imat &m, const CFix &s)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator-(const int s, const cfixmat &m) {return CFix(s) - m;}$/;"	f	namespace:itpp	signature:(const int s, const cfixmat &m)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator-(const CFix &s, const fixvec &v) {return s - to<CFix>(v);}$/;"	f	namespace:itpp	signature:(const CFix &s, const fixvec &v)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator-(const CFix &s, const ivec &v) {return s - to<CFix>(to_vec(v));}$/;"	f	namespace:itpp	signature:(const CFix &s, const ivec &v)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator-(const Fix &s, const cfixvec &v) {return CFix(s) - v;}$/;"	f	namespace:itpp	signature:(const Fix &s, const cfixvec &v)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator-(const cfixvec &a, const fixvec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const cfixvec &a, const fixvec &b)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator-(const cfixvec &a, const ivec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const cfixvec &a, const ivec &b)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator-(const cfixvec &v, const Fix &s) {return v - CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixvec &v, const Fix &s)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator-(const cfixvec &v, const int s) {return v - CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixvec &v, const int s)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator-(const fixvec &a, const cfixvec &b) {return (-b) + a;}$/;"	f	namespace:itpp	signature:(const fixvec &a, const cfixvec &b)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator-(const fixvec &v, const CFix &s) {return to<CFix>(v) - s;}$/;"	f	namespace:itpp	signature:(const fixvec &v, const CFix &s)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator-(const int s, const cfixvec &v) {return CFix(s) - v;}$/;"	f	namespace:itpp	signature:(const int s, const cfixvec &v)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator-(const ivec &a, const cfixvec &b) {return (-b) + a;}$/;"	f	namespace:itpp	signature:(const ivec &a, const cfixvec &b)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator-(const ivec &v, const CFix &s) {return to<CFix>(to_vec(v)) - s;}$/;"	f	namespace:itpp	signature:(const ivec &v, const CFix &s)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline fixmat operator-(const fixmat &a, const imat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const fixmat &a, const imat &b)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline fixmat operator-(const fixmat &v, const int s) {return v - Fix(s);}$/;"	f	namespace:itpp	signature:(const fixmat &v, const int s)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline fixmat operator-(const imat &a, const fixmat &b) {return (-b) + a;}$/;"	f	namespace:itpp	signature:(const imat &a, const fixmat &b)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline fixmat operator-(const int s, const fixmat &v) {return Fix(s) - v;}$/;"	f	namespace:itpp	signature:(const int s, const fixmat &v)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline fixvec operator-(const fixvec &a, const ivec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const fixvec &a, const ivec &b)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline fixvec operator-(const fixvec &v, const int s) {return v - Fix(s);}$/;"	f	namespace:itpp	signature:(const fixvec &v, const int s)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline fixvec operator-(const int s, const fixvec &v) {return Fix(s) - v;}$/;"	f	namespace:itpp	signature:(const int s, const fixvec &v)
itpp::operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline fixvec operator-(const ivec &a, const fixvec &b) {return (-b) + a;}$/;"	f	namespace:itpp	signature:(const ivec &a, const fixvec &b)
itpp::operator /	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator\/(const Mat<Num_T> &m, Num_T t)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m, Num_T t)
itpp::operator /	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator\/(const Mat<Num_T> &m, Num_T t);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m, Num_T t)
itpp::operator /	/usr/include/itpp/base/mat.h	/^extern template bmat operator\/(const bmat &m, bin t);$/;"	p	namespace:itpp	signature:(const bmat &m, bin t)
itpp::operator /	/usr/include/itpp/base/mat.h	/^extern template cmat operator\/(const cmat &m, std::complex<double> t);$/;"	p	namespace:itpp	signature:(const cmat &m, std::complex<double> t)
itpp::operator /	/usr/include/itpp/base/mat.h	/^extern template imat operator\/(const imat &m, int t);$/;"	p	namespace:itpp	signature:(const imat &m, int t)
itpp::operator /	/usr/include/itpp/base/mat.h	/^extern template mat operator\/(const mat &m, double t);$/;"	p	namespace:itpp	signature:(const mat &m, double t)
itpp::operator /	/usr/include/itpp/base/mat.h	/^extern template smat operator\/(const smat &m, short t);$/;"	p	namespace:itpp	signature:(const smat &m, short t)
itpp::operator /	/usr/include/itpp/base/operators.h	/^cmat operator\/(const cmat &m, const double &s);$/;"	p	namespace:itpp	signature:(const cmat &m, const double &s)
itpp::operator /	/usr/include/itpp/base/operators.h	/^cvec operator\/(const cvec &v, const double &s);$/;"	p	namespace:itpp	signature:(const cvec &v, const double &s)
itpp::operator /	/usr/include/itpp/base/operators.h	/^cvec operator\/(const double &s, const cvec &v);$/;"	p	namespace:itpp	signature:(const double &s, const cvec &v)
itpp::operator /	/usr/include/itpp/base/operators.h	/^cvec operator\/(const ivec &v, const std::complex<double> &s);$/;"	p	namespace:itpp	signature:(const ivec &v, const std::complex<double> &s)
itpp::operator /	/usr/include/itpp/base/operators.h	/^cvec operator\/(const std::complex<double> &s, const ivec &v);$/;"	p	namespace:itpp	signature:(const std::complex<double> &s, const ivec &v)
itpp::operator /	/usr/include/itpp/base/operators.h	/^inline cvec operator\/(const cvec &v, const float &s) {return v \/ static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const cvec &v, const float &s)
itpp::operator /	/usr/include/itpp/base/operators.h	/^inline cvec operator\/(const cvec &v, const int &s) {return v \/ static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const cvec &v, const int &s)
itpp::operator /	/usr/include/itpp/base/operators.h	/^inline cvec operator\/(const cvec &v, const short &s) {return v \/ static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const cvec &v, const short &s)
itpp::operator /	/usr/include/itpp/base/operators.h	/^inline mat operator\/(const mat &m, const float &s) {return m \/ static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const mat &m, const float &s)
itpp::operator /	/usr/include/itpp/base/operators.h	/^inline mat operator\/(const mat &m, const int &s) {return m \/ static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const mat &m, const int &s)
itpp::operator /	/usr/include/itpp/base/operators.h	/^inline mat operator\/(const mat &m, const short &s) {return m \/ static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const mat &m, const short &s)
itpp::operator /	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator\/(const std::complex<double> &x, const float &y) {return std::complex<double>(x.real() \/ y, x.imag() \/ y);}$/;"	f	namespace:itpp	signature:(const std::complex<double> &x, const float &y)
itpp::operator /	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator\/(const std::complex<double> &x, const int &y) {return std::complex<double>(x.real() \/ y, x.imag() \/ y);}$/;"	f	namespace:itpp	signature:(const std::complex<double> &x, const int &y)
itpp::operator /	/usr/include/itpp/base/operators.h	/^inline vec operator\/(const vec &v, const float &s) {return v \/ static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const vec &v, const float &s)
itpp::operator /	/usr/include/itpp/base/operators.h	/^inline vec operator\/(const vec &v, const int &s) {return v \/ static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const vec &v, const int &s)
itpp::operator /	/usr/include/itpp/base/operators.h	/^inline vec operator\/(const vec &v, const short &s) {return v \/ static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const vec &v, const short &s)
itpp::operator /	/usr/include/itpp/base/operators.h	/^vec operator\/(const double &s, const ivec &v);$/;"	p	namespace:itpp	signature:(const double &s, const ivec &v)
itpp::operator /	/usr/include/itpp/base/operators.h	/^vec operator\/(const ivec &v, const double &s);$/;"	p	namespace:itpp	signature:(const ivec &v, const double &s)
itpp::operator /	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator\/(Num_T t, const Vec<Num_T> &v)$/;"	f	namespace:itpp	signature:(Num_T t, const Vec<Num_T> &v)
itpp::operator /	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator\/(Num_T t, const Vec<Num_T> &v);$/;"	p	namespace:itpp	signature:(Num_T t, const Vec<Num_T> &v)
itpp::operator /	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator\/(const Vec<Num_T> &v, Num_T t)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v, Num_T t)
itpp::operator /	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator\/(const Vec<Num_T> &v, Num_T t);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v, Num_T t)
itpp::operator /	/usr/include/itpp/base/vec.h	/^extern template bvec operator\/(bin t, const bvec &v);$/;"	p	namespace:itpp	signature:(bin t, const bvec &v)
itpp::operator /	/usr/include/itpp/base/vec.h	/^extern template bvec operator\/(const bvec &v, bin t);$/;"	p	namespace:itpp	signature:(const bvec &v, bin t)
itpp::operator /	/usr/include/itpp/base/vec.h	/^extern template cvec operator\/(const cvec &v, std::complex<double> t);$/;"	p	namespace:itpp	signature:(const cvec &v, std::complex<double> t)
itpp::operator /	/usr/include/itpp/base/vec.h	/^extern template cvec operator\/(std::complex<double> t, const cvec &v);$/;"	p	namespace:itpp	signature:(std::complex<double> t, const cvec &v)
itpp::operator /	/usr/include/itpp/base/vec.h	/^extern template ivec operator\/(const ivec &v, int t);$/;"	p	namespace:itpp	signature:(const ivec &v, int t)
itpp::operator /	/usr/include/itpp/base/vec.h	/^extern template ivec operator\/(int t, const ivec &v);$/;"	p	namespace:itpp	signature:(int t, const ivec &v)
itpp::operator /	/usr/include/itpp/base/vec.h	/^extern template svec operator\/(const svec &v, short t);$/;"	p	namespace:itpp	signature:(const svec &v, short t)
itpp::operator /	/usr/include/itpp/base/vec.h	/^extern template svec operator\/(short t, const svec &v);$/;"	p	namespace:itpp	signature:(short t, const svec &v)
itpp::operator /	/usr/include/itpp/base/vec.h	/^extern template vec operator\/(const vec &v, double t);$/;"	p	namespace:itpp	signature:(const vec &v, double t)
itpp::operator /	/usr/include/itpp/base/vec.h	/^extern template vec operator\/(double t, const vec &v);$/;"	p	namespace:itpp	signature:(double t, const vec &v)
itpp::operator /	/usr/include/itpp/comm/galois.h	/^GFX  operator\/(const GFX &ingfx, const GF &ingf);$/;"	p	namespace:itpp	signature:(const GFX &ingfx, const GF &ingf)
itpp::operator /	/usr/include/itpp/comm/galois.h	/^inline GFX  operator\/(const GFX &ingfx, const GF &ingf)$/;"	f	namespace:itpp	signature:(const GFX &ingfx, const GF &ingf)
itpp::operator /	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator\/(const CFix &x, const CFix &y);$/;"	p	namespace:itpp	signature:(const CFix &x, const CFix &y)
itpp::operator /	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator\/(const CFix &x, const Fix &y);$/;"	p	namespace:itpp	signature:(const CFix &x, const Fix &y)
itpp::operator /	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator\/(const CFix &x, const int y);$/;"	p	namespace:itpp	signature:(const CFix &x, const int y)
itpp::operator /	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator\/(const Fix &x, const CFix &y);$/;"	p	namespace:itpp	signature:(const Fix &x, const CFix &y)
itpp::operator /	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator\/(const int x, const CFix &y);$/;"	p	namespace:itpp	signature:(const int x, const CFix &y)
itpp::operator /	/usr/include/itpp/fixed/fix_operators.h	/^Fix operator\/(const Fix &x, const Fix &y);$/;"	p	namespace:itpp	signature:(const Fix &x, const Fix &y)
itpp::operator /	/usr/include/itpp/fixed/fix_operators.h	/^Fix operator\/(const Fix &x, const int y);$/;"	p	namespace:itpp	signature:(const Fix &x, const int y)
itpp::operator /	/usr/include/itpp/fixed/fix_operators.h	/^Fix operator\/(const int x, const Fix &y);$/;"	p	namespace:itpp	signature:(const int x, const Fix &y)
itpp::operator /	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator\/(const cfixmat &m, const Fix &s) {return m \/ CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixmat &m, const Fix &s)
itpp::operator /	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator\/(const cfixmat &m, const int s) {return m \/ CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixmat &m, const int s)
itpp::operator /	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator\/(const fixmat &m, const CFix &s) {return to<CFix>(m) \/ s;}$/;"	f	namespace:itpp	signature:(const fixmat &m, const CFix &s)
itpp::operator /	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator\/(const imat &m, const CFix &s) {return to<CFix>(to_mat(m)) \/ s;}$/;"	f	namespace:itpp	signature:(const imat &m, const CFix &s)
itpp::operator /	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator\/(const cfixvec &v, const Fix &s) {return v \/ CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixvec &v, const Fix &s)
itpp::operator /	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator\/(const cfixvec &v, const int s) {return v \/ CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixvec &v, const int s)
itpp::operator /	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator\/(const fixvec &v, const CFix &s) {return to<CFix>(v) \/ s;}$/;"	f	namespace:itpp	signature:(const fixvec &v, const CFix &s)
itpp::operator /	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator\/(const ivec &v, const CFix &s) {return to<CFix>(to_vec(v)) \/ s;}$/;"	f	namespace:itpp	signature:(const ivec &v, const CFix &s)
itpp::operator /	/usr/include/itpp/fixed/fix_operators.h	/^inline fixmat operator\/(const fixmat &v, const int s) {return v \/ Fix(s);}$/;"	f	namespace:itpp	signature:(const fixmat &v, const int s)
itpp::operator /	/usr/include/itpp/fixed/fix_operators.h	/^inline fixvec operator\/(const fixvec &v, const int s) {return v \/ Fix(s);}$/;"	f	namespace:itpp	signature:(const fixvec &v, const int s)
itpp::operator <<	/usr/include/itpp/base/array.h	/^std::ostream &operator<<(std::ostream &os, const Array<T> &a)$/;"	f	namespace:itpp	signature:(std::ostream &os, const Array<T> &a)
itpp::operator <<	/usr/include/itpp/base/binary.h	/^std::ostream &operator<<(std::ostream &output, const bin &inbin);$/;"	p	namespace:itpp	signature:(std::ostream &output, const bin &inbin)
itpp::operator <<	/usr/include/itpp/base/gf2mat.h	/^it_file &operator<<(it_file &f, const GF2mat &X);$/;"	p	namespace:itpp	signature:(it_file &f, const GF2mat &X)
itpp::operator <<	/usr/include/itpp/base/gf2mat.h	/^std::ostream &operator<<(std::ostream &os, const GF2mat &X);$/;"	p	namespace:itpp	signature:(std::ostream &os, const GF2mat &X)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^inline it_file& operator<<(it_file& f, const Name& s)$/;"	f	namespace:itpp	signature:(it_file& f, const Name& s)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^inline it_file_old& operator<<(it_file_old& f, const Name& s)$/;"	f	namespace:itpp	signature:(it_file_old& f, const Name& s)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file &f, bool x);$/;"	p	namespace:itpp	signature:(it_file &f, bool x)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, bin x);$/;"	p	namespace:itpp	signature:(it_file& f, bin x)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, char x);$/;"	p	namespace:itpp	signature:(it_file& f, char x)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<bin>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<bin>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<bmat>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<bmat>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<bvec>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<bvec>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<cmat>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<cmat>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<cvec>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<cvec>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<double>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<double>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<float>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<float>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<imat>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<imat>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<int>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<int>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<ivec>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<ivec>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<mat>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<mat>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<short>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<short>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<smat>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<smat>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<std::complex<double> >& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<std::complex<double> >& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<std::complex<float> >& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<std::complex<float> >& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<std::string>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<std::string>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<svec>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<svec>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<vec>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<vec>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const bmat& m);$/;"	p	namespace:itpp	signature:(it_file& f, const bmat& m)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const bvec& v);$/;"	p	namespace:itpp	signature:(it_file& f, const bvec& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const cmat& m);$/;"	p	namespace:itpp	signature:(it_file& f, const cmat& m)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const cvec& v);$/;"	p	namespace:itpp	signature:(it_file& f, const cvec& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const imat& m);$/;"	p	namespace:itpp	signature:(it_file& f, const imat& m)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const ivec& v);$/;"	p	namespace:itpp	signature:(it_file& f, const ivec& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const mat& m);$/;"	p	namespace:itpp	signature:(it_file& f, const mat& m)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const smat& m);$/;"	p	namespace:itpp	signature:(it_file& f, const smat& m)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const std::string& str);$/;"	p	namespace:itpp	signature:(it_file& f, const std::string& str)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const svec& v);$/;"	p	namespace:itpp	signature:(it_file& f, const svec& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const vec& v);$/;"	p	namespace:itpp	signature:(it_file& f, const vec& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, double x);$/;"	p	namespace:itpp	signature:(it_file& f, double x)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, float x);$/;"	p	namespace:itpp	signature:(it_file& f, float x)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, int x);$/;"	p	namespace:itpp	signature:(it_file& f, int x)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, short x);$/;"	p	namespace:itpp	signature:(it_file& f, short x)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, std::complex<double> x);$/;"	p	namespace:itpp	signature:(it_file& f, std::complex<double> x)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, std::complex<float> x);$/;"	p	namespace:itpp	signature:(it_file& f, std::complex<float> x)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, bin x);$/;"	p	namespace:itpp	signature:(it_file_old& f, bin x)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, char x);$/;"	p	namespace:itpp	signature:(it_file_old& f, char x)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<bin>& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<bin>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<bmat>& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<bmat>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<bvec>& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<bvec>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<cmat>& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<cmat>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<cvec>& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<cvec>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<double>& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<double>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<float>& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<float>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<imat>& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<imat>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<int>& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<int>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<ivec>& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<ivec>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<mat>& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<mat>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<std::complex<double> >& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<std::complex<double> >& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<std::complex<float> >& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<std::complex<float> >& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<std::string>& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<std::string>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<vec>& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<vec>& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const bmat& m);$/;"	p	namespace:itpp	signature:(it_file_old& f, const bmat& m)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const bvec& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const bvec& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const cmat& m);$/;"	p	namespace:itpp	signature:(it_file_old& f, const cmat& m)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const cvec& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const cvec& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const imat& m);$/;"	p	namespace:itpp	signature:(it_file_old& f, const imat& m)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const ivec& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const ivec& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const mat& m);$/;"	p	namespace:itpp	signature:(it_file_old& f, const mat& m)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const std::string& str);$/;"	p	namespace:itpp	signature:(it_file_old& f, const std::string& str)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const vec& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const vec& v)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, double x);$/;"	p	namespace:itpp	signature:(it_file_old& f, double x)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, float x);$/;"	p	namespace:itpp	signature:(it_file_old& f, float x)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, int x);$/;"	p	namespace:itpp	signature:(it_file_old& f, int x)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, short x);$/;"	p	namespace:itpp	signature:(it_file_old& f, short x)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, std::complex<double> x);$/;"	p	namespace:itpp	signature:(it_file_old& f, std::complex<double> x)
itpp::operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, std::complex<float> x);$/;"	p	namespace:itpp	signature:(it_file_old& f, std::complex<float> x)
itpp::operator <<	/usr/include/itpp/base/mat.h	/^extern template std::ostream &operator<<(std::ostream &os, const bmat  &m);$/;"	p	namespace:itpp	signature:(std::ostream &os, const bmat &m)
itpp::operator <<	/usr/include/itpp/base/mat.h	/^extern template std::ostream &operator<<(std::ostream &os, const cmat &m);$/;"	p	namespace:itpp	signature:(std::ostream &os, const cmat &m)
itpp::operator <<	/usr/include/itpp/base/mat.h	/^extern template std::ostream &operator<<(std::ostream &os, const imat  &m);$/;"	p	namespace:itpp	signature:(std::ostream &os, const imat &m)
itpp::operator <<	/usr/include/itpp/base/mat.h	/^extern template std::ostream &operator<<(std::ostream &os, const mat  &m);$/;"	p	namespace:itpp	signature:(std::ostream &os, const mat &m)
itpp::operator <<	/usr/include/itpp/base/mat.h	/^extern template std::ostream &operator<<(std::ostream &os, const smat  &m);$/;"	p	namespace:itpp	signature:(std::ostream &os, const smat &m)
itpp::operator <<	/usr/include/itpp/base/mat.h	/^std::ostream &operator<<(std::ostream &os, const Mat<Num_T> &m)$/;"	f	namespace:itpp	signature:(std::ostream &os, const Mat<Num_T> &m)
itpp::operator <<	/usr/include/itpp/base/mat.h	/^std::ostream &operator<<(std::ostream &os, const Mat<Num_T> &m);$/;"	p	namespace:itpp	signature:(std::ostream &os, const Mat<Num_T> &m)
itpp::operator <<	/usr/include/itpp/base/vec.h	/^extern template std::ostream &operator<<(std::ostream& os, const bvec &vect);$/;"	p	namespace:itpp	signature:(std::ostream& os, const bvec &vect)
itpp::operator <<	/usr/include/itpp/base/vec.h	/^extern template std::ostream &operator<<(std::ostream& os, const cvec &vect);$/;"	p	namespace:itpp	signature:(std::ostream& os, const cvec &vect)
itpp::operator <<	/usr/include/itpp/base/vec.h	/^extern template std::ostream &operator<<(std::ostream& os, const ivec &vect);$/;"	p	namespace:itpp	signature:(std::ostream& os, const ivec &vect)
itpp::operator <<	/usr/include/itpp/base/vec.h	/^extern template std::ostream &operator<<(std::ostream& os, const svec &vect);$/;"	p	namespace:itpp	signature:(std::ostream& os, const svec &vect)
itpp::operator <<	/usr/include/itpp/base/vec.h	/^extern template std::ostream &operator<<(std::ostream& os, const vec &vect);$/;"	p	namespace:itpp	signature:(std::ostream& os, const vec &vect)
itpp::operator <<	/usr/include/itpp/base/vec.h	/^std::ostream &operator<<(std::ostream &os, const Vec<Num_T> &v)$/;"	f	namespace:itpp	signature:(std::ostream &os, const Vec<Num_T> &v)
itpp::operator <<	/usr/include/itpp/base/vec.h	/^std::ostream &operator<<(std::ostream &os, const Vec<Num_T> &v);$/;"	p	namespace:itpp	signature:(std::ostream &os, const Vec<Num_T> &v)
itpp::operator <<	/usr/include/itpp/comm/ldpc.h	/^std::ostream &operator<<(std::ostream &os, const LDPC_Code &C);$/;"	p	namespace:itpp	signature:(std::ostream &os, const LDPC_Code &C)
itpp::operator <<	/usr/include/itpp/comm/llr.h	/^std::ostream &operator<<(std::ostream &os, const LLR_calc_unit &lcu);$/;"	p	namespace:itpp	signature:(std::ostream &os, const LLR_calc_unit &lcu)
itpp::operator <<	/usr/include/itpp/comm/modulator_nd.h	/^std::ostream &operator<<(std::ostream &os, const Modulator_NCD &m);$/;"	p	namespace:itpp	signature:(std::ostream &os, const Modulator_NCD &m)
itpp::operator <<	/usr/include/itpp/comm/modulator_nd.h	/^std::ostream &operator<<(std::ostream &os, const Modulator_NRD &m);$/;"	p	namespace:itpp	signature:(std::ostream &os, const Modulator_NRD &m)
itpp::operator <<	/usr/include/itpp/fixed/cfix.h	/^std::ostream &operator<<(std::ostream &os, const CFix &x);$/;"	p	namespace:itpp	signature:(std::ostream &os, const CFix &x)
itpp::operator <<	/usr/include/itpp/fixed/fix.h	/^std::ostream &operator<<(std::ostream &os, const Fix &x);$/;"	p	namespace:itpp	signature:(std::ostream &os, const Fix &x)
itpp::operator <<	/usr/include/itpp/fixed/fix_base.h	/^inline std::ostream &operator<<(std::ostream &os, const output_mode &o)$/;"	f	namespace:itpp	signature:(std::ostream &os, const output_mode &o)
itpp::operator >>	/usr/include/itpp/base/array.h	/^std::istream &operator>>(std::istream &is, Array<T> &a)$/;"	f	namespace:itpp	signature:(std::istream &is, Array<T> &a)
itpp::operator >>	/usr/include/itpp/base/binary.h	/^std::istream &operator>>(std::istream &input, bin &outbin);$/;"	p	namespace:itpp	signature:(std::istream &input, bin &outbin)
itpp::operator >>	/usr/include/itpp/base/gf2mat.h	/^it_ifile &operator>>(it_ifile &f, GF2mat &X);$/;"	p	namespace:itpp	signature:(it_ifile &f, GF2mat &X)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^inline it_ifile& operator>>(it_ifile& f, const Name& s)$/;"	f	namespace:itpp	signature:(it_ifile& f, const Name& s)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^inline it_ifile_old& operator>>(it_ifile_old& f, const Name& s)$/;"	f	namespace:itpp	signature:(it_ifile_old& f, const Name& s)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile &f, bool &v);$/;"	p	namespace:itpp	signature:(it_ifile &f, bool &v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<bin>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<bin>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<bmat>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<bmat>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<bvec>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<bvec>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<cmat>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<cmat>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<cvec>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<cvec>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<double>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<double>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<float>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<float>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<imat>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<imat>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<int>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<int>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<ivec>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<ivec>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<mat>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<mat>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<short>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<short>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<smat>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<smat>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<std::complex<double> >& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<std::complex<double> >& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<std::complex<float> >& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<std::complex<float> >& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<std::string>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<std::string>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<svec>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<svec>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<vec>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<vec>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, bin& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, bin& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, bmat& m);$/;"	p	namespace:itpp	signature:(it_ifile& f, bmat& m)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, bvec& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, bvec& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, char& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, char& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, cmat& m);$/;"	p	namespace:itpp	signature:(it_ifile& f, cmat& m)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, cvec& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, cvec& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, double& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, double& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, float& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, float& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, imat& m);$/;"	p	namespace:itpp	signature:(it_ifile& f, imat& m)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, int& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, int& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, ivec& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, ivec& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, mat& m);$/;"	p	namespace:itpp	signature:(it_ifile& f, mat& m)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, short& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, short& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, smat& m);$/;"	p	namespace:itpp	signature:(it_ifile& f, smat& m)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, std::complex<double>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, std::complex<double>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, std::complex<float>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, std::complex<float>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, std::string& str);$/;"	p	namespace:itpp	signature:(it_ifile& f, std::string& str)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, svec& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, svec& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, vec& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, vec& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<bin>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<bin>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<bmat>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<bmat>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<bvec>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<bvec>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<cmat>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<cmat>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<cvec>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<cvec>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<double>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<double>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<float>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<float>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<imat>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<imat>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<int>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<int>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<ivec>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<ivec>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<mat>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<mat>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<std::complex<double> >& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<std::complex<double> >& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<std::complex<float> >& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<std::complex<float> >& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<std::string>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<std::string>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<vec>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<vec>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, bin& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, bin& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, bmat& m);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, bmat& m)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, bvec& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, bvec& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, char& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, char& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, cmat& m);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, cmat& m)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, cvec& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, cvec& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, double& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, double& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, float& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, float& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, imat& m);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, imat& m)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, int& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, int& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, ivec& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, ivec& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, mat& m);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, mat& m)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, short& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, short& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, std::complex<double>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, std::complex<double>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, std::complex<float>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, std::complex<float>& v)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, std::string& str);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, std::string& str)
itpp::operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, vec& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, vec& v)
itpp::operator >>	/usr/include/itpp/base/mat.h	/^extern template std::istream &operator>>(std::istream &is, bmat  &m);$/;"	p	namespace:itpp	signature:(std::istream &is, bmat &m)
itpp::operator >>	/usr/include/itpp/base/mat.h	/^extern template std::istream &operator>>(std::istream &is, cmat &m);$/;"	p	namespace:itpp	signature:(std::istream &is, cmat &m)
itpp::operator >>	/usr/include/itpp/base/mat.h	/^extern template std::istream &operator>>(std::istream &is, imat  &m);$/;"	p	namespace:itpp	signature:(std::istream &is, imat &m)
itpp::operator >>	/usr/include/itpp/base/mat.h	/^extern template std::istream &operator>>(std::istream &is, mat  &m);$/;"	p	namespace:itpp	signature:(std::istream &is, mat &m)
itpp::operator >>	/usr/include/itpp/base/mat.h	/^extern template std::istream &operator>>(std::istream &is, smat  &m);$/;"	p	namespace:itpp	signature:(std::istream &is, smat &m)
itpp::operator >>	/usr/include/itpp/base/mat.h	/^std::istream &operator>>(std::istream &is, Mat<Num_T> &m)$/;"	f	namespace:itpp	signature:(std::istream &is, Mat<Num_T> &m)
itpp::operator >>	/usr/include/itpp/base/mat.h	/^std::istream &operator>>(std::istream &is, Mat<Num_T> &m);$/;"	p	namespace:itpp	signature:(std::istream &is, Mat<Num_T> &m)
itpp::operator >>	/usr/include/itpp/base/vec.h	/^extern template std::istream &operator>>(std::istream& is, bvec &vect);$/;"	p	namespace:itpp	signature:(std::istream& is, bvec &vect)
itpp::operator >>	/usr/include/itpp/base/vec.h	/^extern template std::istream &operator>>(std::istream& is, cvec &vect);$/;"	p	namespace:itpp	signature:(std::istream& is, cvec &vect)
itpp::operator >>	/usr/include/itpp/base/vec.h	/^extern template std::istream &operator>>(std::istream& is, ivec &vect);$/;"	p	namespace:itpp	signature:(std::istream& is, ivec &vect)
itpp::operator >>	/usr/include/itpp/base/vec.h	/^extern template std::istream &operator>>(std::istream& is, svec &vect);$/;"	p	namespace:itpp	signature:(std::istream& is, svec &vect)
itpp::operator >>	/usr/include/itpp/base/vec.h	/^extern template std::istream &operator>>(std::istream& is, vec &vect);$/;"	p	namespace:itpp	signature:(std::istream& is, vec &vect)
itpp::operator >>	/usr/include/itpp/base/vec.h	/^std::istream &operator>>(std::istream &is, Vec<Num_T> &v)$/;"	f	namespace:itpp	signature:(std::istream &is, Vec<Num_T> &v)
itpp::operator >>	/usr/include/itpp/base/vec.h	/^std::istream &operator>>(std::istream &is, Vec<Num_T> &v);$/;"	p	namespace:itpp	signature:(std::istream &is, Vec<Num_T> &v)
itpp::operator >>	/usr/include/itpp/fixed/cfix.h	/^std::istream &operator>>(std::istream &is, CFix &x);$/;"	p	namespace:itpp	signature:(std::istream &is, CFix &x)
itpp::operator >>	/usr/include/itpp/fixed/fix.h	/^std::istream &operator>>(std::istream &is, Fix &x);$/;"	p	namespace:itpp	signature:(std::istream &is, Fix &x)
itpp::outer_product	/usr/include/itpp/base/vec.h	/^Mat<Num_T> outer_product(const Vec<Num_T> &v1, const Vec<Num_T> &v2, bool)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2, bool)
itpp::outer_product	/usr/include/itpp/base/vec.h	/^Mat<Num_T> outer_product(const Vec<Num_T> &v1, const Vec<Num_T> &v2,$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2, bool hermitian = false)
itpp::outer_product	/usr/include/itpp/base/vec.h	/^cmat outer_product(const cvec &v1, const cvec &v2, bool hermitian)$/;"	f	namespace:itpp	signature:(const cvec &v1, const cvec &v2, bool hermitian)
itpp::outer_product	/usr/include/itpp/base/vec.h	/^extern template bmat outer_product(const bvec &v1, const bvec &v2,$/;"	p	namespace:itpp	signature:(const bvec &v1, const bvec &v2, bool hermitian)
itpp::outer_product	/usr/include/itpp/base/vec.h	/^extern template imat outer_product(const ivec &v1, const ivec &v2,$/;"	p	namespace:itpp	signature:(const ivec &v1, const ivec &v2, bool hermitian)
itpp::outer_product	/usr/include/itpp/base/vec.h	/^extern template mat outer_product(const vec &v1, const vec &v2,$/;"	p	namespace:itpp	signature:(const vec &v1, const vec &v2, bool hermitian)
itpp::outer_product	/usr/include/itpp/base/vec.h	/^extern template smat outer_product(const svec &v1, const svec &v2,$/;"	p	namespace:itpp	signature:(const svec &v1, const svec &v2, bool hermitian)
itpp::outer_product	/usr/include/itpp/base/vec.h	/^mat outer_product(const vec &v1, const vec &v2, bool)$/;"	f	namespace:itpp	signature:(const vec &v1, const vec &v2, bool)
itpp::output_mode	/usr/include/itpp/fixed/fix_base.h	/^enum output_mode {$/;"	g	namespace:itpp
itpp::pause	/usr/include/itpp/base/timing.h	/^void pause(double t = -1);$/;"	p	namespace:itpp	signature:(double t = -1)
itpp::permutation_matrix	/usr/include/itpp/base/algebra/lu.h	/^bmat permutation_matrix(const ivec &p);$/;"	p	namespace:itpp	signature:(const ivec &p)
itpp::pgm_read	/usr/include/itpp/srccode/pnm.h	/^bool pgm_read(const std::string & filename, imat & m,$/;"	p	namespace:itpp	signature:(const std::string & filename, imat & m, std::string & comments)
itpp::pgm_read	/usr/include/itpp/srccode/pnm.h	/^bool pgm_read(const std::string & filename, imat &m,$/;"	p	namespace:itpp	signature:(const std::string & filename, imat &m, int r1, int r2, int c1, int c2)
itpp::pgm_read	/usr/include/itpp/srccode/pnm.h	/^imat pgm_read(const std::string & filename);$/;"	p	namespace:itpp	signature:(const std::string & filename)
itpp::pgm_write	/usr/include/itpp/srccode/pnm.h	/^bool pgm_write(const std::string & filename,$/;"	p	namespace:itpp	signature:(const std::string & filename, const imat &m, const std::string & comments = Ó)
itpp::pi	/usr/include/itpp/base/math/misc.h	/^const double pi = 3.14159265358979323846;$/;"	m	namespace:itpp
itpp::pnm_info	/usr/include/itpp/srccode/pnm.h	/^bool pnm_info(const std::string & filename,$/;"	p	namespace:itpp	signature:(const std::string & filename, char & pnm_type, int & width, int & height, int & max_val, std::string & comments)
itpp::pnm_type	/usr/include/itpp/srccode/pnm.h	/^char pnm_type(const std::string & filename);$/;"	p	namespace:itpp	signature:(const std::string & filename)
itpp::pol2bin	/usr/include/itpp/base/converters.h	/^bvec pol2bin(const ivec &inpol);$/;"	p	namespace:itpp	signature:(const ivec &inpol)
itpp::poly	/usr/include/itpp/signal/poly.h	/^inline cvec poly(const cvec &r) { cvec temp; poly(r, temp); return temp; }$/;"	f	namespace:itpp	signature:(const cvec &r)
itpp::poly	/usr/include/itpp/signal/poly.h	/^inline vec poly(const vec &r) { vec temp; poly(r, temp); return temp; }$/;"	f	namespace:itpp	signature:(const vec &r)
itpp::poly	/usr/include/itpp/signal/poly.h	/^void poly(const cvec &r, cvec &p);$/;"	p	namespace:itpp	signature:(const cvec &r, cvec &p)
itpp::poly	/usr/include/itpp/signal/poly.h	/^void poly(const vec &r, vec &p);$/;"	p	namespace:itpp	signature:(const vec &r, vec &p)
itpp::poly2ac	/usr/include/itpp/srccode/lpcfunc.h	/^vec poly2ac(const vec &poly);$/;"	p	namespace:itpp	signature:(const vec &poly)
itpp::poly2cepstrum	/usr/include/itpp/srccode/lpcfunc.h	/^vec poly2cepstrum(const vec &a);$/;"	p	namespace:itpp	signature:(const vec &a)
itpp::poly2cepstrum	/usr/include/itpp/srccode/lpcfunc.h	/^vec poly2cepstrum(const vec &a, int num);$/;"	p	namespace:itpp	signature:(const vec &a, int num)
itpp::poly2lsf	/usr/include/itpp/srccode/lpcfunc.h	/^vec poly2lsf(const vec &poly);$/;"	p	namespace:itpp	signature:(const vec &poly)
itpp::poly2rc	/usr/include/itpp/srccode/lpcfunc.h	/^vec poly2rc(const vec &poly);$/;"	p	namespace:itpp	signature:(const vec &poly)
itpp::polystab	/usr/include/itpp/signal/filter_design.h	/^inline cvec polystab(const cvec &a) { cvec temp; polystab(a, temp); return temp; }$/;"	f	namespace:itpp	signature:(const cvec &a)
itpp::polystab	/usr/include/itpp/signal/filter_design.h	/^inline vec polystab(const vec &a) { vec temp; polystab(a, temp); return temp; }$/;"	f	namespace:itpp	signature:(const vec &a)
itpp::polystab	/usr/include/itpp/signal/filter_design.h	/^void polystab(const cvec &a, cvec &out);$/;"	p	namespace:itpp	signature:(const cvec &a, cvec &out)
itpp::polystab	/usr/include/itpp/signal/filter_design.h	/^void polystab(const vec &a, vec &out);$/;"	p	namespace:itpp	signature:(const vec &a, vec &out)
itpp::polyval	/usr/include/itpp/signal/poly.h	/^cvec polyval(const cvec &p, const cvec &x);$/;"	p	namespace:itpp	signature:(const cvec &p, const cvec &x)
itpp::polyval	/usr/include/itpp/signal/poly.h	/^cvec polyval(const cvec &p, const vec &x);$/;"	p	namespace:itpp	signature:(const cvec &p, const vec &x)
itpp::polyval	/usr/include/itpp/signal/poly.h	/^cvec polyval(const vec &p, const cvec &x);$/;"	p	namespace:itpp	signature:(const vec &p, const cvec &x)
itpp::polyval	/usr/include/itpp/signal/poly.h	/^vec polyval(const vec &p, const vec &x);$/;"	p	namespace:itpp	signature:(const vec &p, const vec &x)
itpp::pow	/usr/include/itpp/base/math/log_exp.h	/^inline mat pow(const double x, const mat &y)$/;"	f	namespace:itpp	signature:(const double x, const mat &y)
itpp::pow	/usr/include/itpp/base/math/log_exp.h	/^inline mat pow(const mat &x, const double y)$/;"	f	namespace:itpp	signature:(const mat &x, const double y)
itpp::pow	/usr/include/itpp/base/math/log_exp.h	/^inline vec pow(const double x, const vec &y)$/;"	f	namespace:itpp	signature:(const double x, const vec &y)
itpp::pow	/usr/include/itpp/base/math/log_exp.h	/^inline vec pow(const vec &x, const double y)$/;"	f	namespace:itpp	signature:(const vec &x, const double y)
itpp::pow10	/usr/include/itpp/base/math/log_exp.h	/^inline double pow10(double x) { return pow(10.0, x); }$/;"	f	namespace:itpp	signature:(double x)
itpp::pow10	/usr/include/itpp/base/math/log_exp.h	/^inline mat pow10(const mat &x)$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::pow10	/usr/include/itpp/base/math/log_exp.h	/^inline vec pow10(const vec &x)$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::pow2	/usr/include/itpp/base/math/log_exp.h	/^inline double pow2(double x) { return pow(2.0, x); }$/;"	f	namespace:itpp	signature:(double x)
itpp::pow2	/usr/include/itpp/base/math/log_exp.h	/^inline mat pow2(const mat &x)$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::pow2	/usr/include/itpp/base/math/log_exp.h	/^inline vec pow2(const vec &x)$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::pow2i	/usr/include/itpp/base/math/log_exp.h	/^inline int pow2i(int x) { return ((x < 0) ? 0 : (1 << x)); }$/;"	f	namespace:itpp	signature:(int x)
itpp::ppm_read	/usr/include/itpp/srccode/pnm.h	/^bool ppm_read(const std::string & filename,$/;"	p	namespace:itpp	signature:(const std::string & filename, imat &r, imat &g, imat &b)
itpp::ppm_read	/usr/include/itpp/srccode/pnm.h	/^bool ppm_read(const std::string & filename,$/;"	p	namespace:itpp	signature:(const std::string & filename, imat &r, imat &g, imat &b, int r1, int r2, int c1, int c2)
itpp::ppm_read	/usr/include/itpp/srccode/pnm.h	/^bool ppm_read(const std::string & filename,$/;"	p	namespace:itpp	signature:(const std::string & filename, imat &r, imat &g, imat &b, std::string & comments)
itpp::ppm_write	/usr/include/itpp/srccode/pnm.h	/^bool ppm_write(const std::string & filename,$/;"	p	namespace:itpp	signature:(const std::string & filename, const imat &r, const imat &g, const imat &b, const std::string & comments = Ó, int max_val = 255)
itpp::prod	/usr/include/itpp/base/matfunc.h	/^T prod(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
itpp::prod	/usr/include/itpp/base/matfunc.h	/^Vec<T> prod(const Mat<T> &m, int dim = 1)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, int dim = 1)
itpp::prod	/usr/include/itpp/base/matfunc.h	/^extern template bin prod(const bvec &v);$/;"	p	namespace:itpp	signature:(const bvec &v)
itpp::prod	/usr/include/itpp/base/matfunc.h	/^extern template bvec prod(const bmat &m, int dim);$/;"	p	namespace:itpp	signature:(const bmat &m, int dim)
itpp::prod	/usr/include/itpp/base/matfunc.h	/^extern template cvec prod(const cmat &v, int dim);$/;"	p	namespace:itpp	signature:(const cmat &v, int dim)
itpp::prod	/usr/include/itpp/base/matfunc.h	/^extern template double prod(const vec &v);$/;"	p	namespace:itpp	signature:(const vec &v)
itpp::prod	/usr/include/itpp/base/matfunc.h	/^extern template int prod(const ivec &v);$/;"	p	namespace:itpp	signature:(const ivec &v)
itpp::prod	/usr/include/itpp/base/matfunc.h	/^extern template ivec prod(const imat &m, int dim);$/;"	p	namespace:itpp	signature:(const imat &m, int dim)
itpp::prod	/usr/include/itpp/base/matfunc.h	/^extern template short prod(const svec &v);$/;"	p	namespace:itpp	signature:(const svec &v)
itpp::prod	/usr/include/itpp/base/matfunc.h	/^extern template std::complex<double> prod(const cvec &v);$/;"	p	namespace:itpp	signature:(const cvec &v)
itpp::prod	/usr/include/itpp/base/matfunc.h	/^extern template svec prod(const smat &m, int dim);$/;"	p	namespace:itpp	signature:(const smat &m, int dim)
itpp::prod	/usr/include/itpp/base/matfunc.h	/^extern template vec prod(const mat &m, int dim);$/;"	p	namespace:itpp	signature:(const mat &m, int dim)
itpp::q_mode	/usr/include/itpp/fixed/fix_base.h	/^enum q_mode {$/;"	g	namespace:itpp
itpp::qr	/usr/include/itpp/base/algebra/qr.h	/^bool qr(const cmat &A, cmat &Q, cmat &R);$/;"	p	namespace:itpp	signature:(const cmat &A, cmat &Q, cmat &R)
itpp::qr	/usr/include/itpp/base/algebra/qr.h	/^bool qr(const cmat &A, cmat &Q, cmat &R, bmat &P);$/;"	p	namespace:itpp	signature:(const cmat &A, cmat &Q, cmat &R, bmat &P)
itpp::qr	/usr/include/itpp/base/algebra/qr.h	/^bool qr(const mat &A, mat &Q, mat &R);$/;"	p	namespace:itpp	signature:(const mat &A, mat &Q, mat &R)
itpp::qr	/usr/include/itpp/base/algebra/qr.h	/^bool qr(const mat &A, mat &Q, mat &R, bmat &P);$/;"	p	namespace:itpp	signature:(const mat &A, mat &Q, mat &R, bmat &P)
itpp::quad	/usr/include/itpp/base/math/integration.h	/^double quad(double(*f)(double), double a, double b,$/;"	p	namespace:itpp	signature:(double(*f)(double), double a, double b, double tol = std::numeric_limits<double>::epsilon())
itpp::quadl	/usr/include/itpp/base/math/integration.h	/^double quadl(double(*f)(double), double a, double b,$/;"	p	namespace:itpp	signature:(double(*f)(double), double a, double b, double tol = std::numeric_limits<double>::epsilon())
itpp::rad_to_deg	/usr/include/itpp/base/converters.h	/^inline double rad_to_deg(double x) { return (180.0 \/ itpp::pi * x); }$/;"	f	namespace:itpp	signature:(double x)
itpp::randb	/usr/include/itpp/base/random.h	/^inline bin randb(void) { Bernoulli_RNG src; return src.sample(); }$/;"	f	namespace:itpp	signature:(void)
itpp::randb	/usr/include/itpp/base/random.h	/^inline bmat randb(int rows, int cols) { bmat temp; randb(rows, cols, temp); return temp; }$/;"	f	namespace:itpp	signature:(int rows, int cols)
itpp::randb	/usr/include/itpp/base/random.h	/^inline bvec randb(int size) { bvec temp; randb(size, temp); return temp; }$/;"	f	namespace:itpp	signature:(int size)
itpp::randb	/usr/include/itpp/base/random.h	/^inline void randb(int rows, int cols, bmat &out) { Bernoulli_RNG src; src.sample_matrix(rows, cols, out); }$/;"	f	namespace:itpp	signature:(int rows, int cols, bmat &out)
itpp::randb	/usr/include/itpp/base/random.h	/^inline void randb(int size, bvec &out) { Bernoulli_RNG src; src.sample_vector(size, out); }$/;"	f	namespace:itpp	signature:(int size, bvec &out)
itpp::randexp	/usr/include/itpp/base/random.h	/^inline vec randexp(int size, double lambda = 1.0) { Exponential_RNG src; src.setup(lambda); return src(size); }$/;"	f	namespace:itpp	signature:(int size, double lambda = 1.0)
itpp::randi	/usr/include/itpp/base/random.h	/^inline imat randi(int rows, int cols, int low, int high) { I_Uniform_RNG src; src.setup(low, high); return src(rows, cols); }$/;"	f	namespace:itpp	signature:(int rows, int cols, int low, int high)
itpp::randi	/usr/include/itpp/base/random.h	/^inline int randi(int low, int high) { I_Uniform_RNG src; src.setup(low, high); return src(); }$/;"	f	namespace:itpp	signature:(int low, int high)
itpp::randi	/usr/include/itpp/base/random.h	/^inline ivec randi(int size, int low, int high) { I_Uniform_RNG src; src.setup(low, high); return src(size); }$/;"	f	namespace:itpp	signature:(int size, int low, int high)
itpp::randn	/usr/include/itpp/base/random.h	/^inline double randn(void) { Normal_RNG src; return src.sample(); }$/;"	f	namespace:itpp	signature:(void)
itpp::randn	/usr/include/itpp/base/random.h	/^inline mat randn(int rows, int cols) { mat temp; randn(rows, cols, temp); return temp; }$/;"	f	namespace:itpp	signature:(int rows, int cols)
itpp::randn	/usr/include/itpp/base/random.h	/^inline vec randn(int size) { vec temp; randn(size, temp); return temp; }$/;"	f	namespace:itpp	signature:(int size)
itpp::randn	/usr/include/itpp/base/random.h	/^inline void randn(int rows, int cols, mat &out)  { Normal_RNG src; src.sample_matrix(rows, cols, out); }$/;"	f	namespace:itpp	signature:(int rows, int cols, mat &out)
itpp::randn	/usr/include/itpp/base/random.h	/^inline void randn(int size, vec &out) { Normal_RNG src; src.sample_vector(size, out); }$/;"	f	namespace:itpp	signature:(int size, vec &out)
itpp::randn_c	/usr/include/itpp/base/random.h	/^inline cmat randn_c(int rows, int cols) { cmat temp; randn_c(rows, cols, temp); return temp; }$/;"	f	namespace:itpp	signature:(int rows, int cols)
itpp::randn_c	/usr/include/itpp/base/random.h	/^inline cvec randn_c(int size) { cvec temp; randn_c(size, temp); return temp; }$/;"	f	namespace:itpp	signature:(int size)
itpp::randn_c	/usr/include/itpp/base/random.h	/^inline std::complex<double> randn_c(void) { Complex_Normal_RNG src; return src.sample(); }$/;"	f	namespace:itpp	signature:(void)
itpp::randn_c	/usr/include/itpp/base/random.h	/^inline void randn_c(int rows, int cols, cmat &out) { Complex_Normal_RNG src; src.sample_matrix(rows, cols, out); }$/;"	f	namespace:itpp	signature:(int rows, int cols, cmat &out)
itpp::randn_c	/usr/include/itpp/base/random.h	/^inline void randn_c(int size, cvec &out)  { Complex_Normal_RNG src; src.sample_vector(size, out); }$/;"	f	namespace:itpp	signature:(int size, cvec &out)
itpp::randray	/usr/include/itpp/base/random.h	/^inline vec randray(int size, double sigma = 1.0) { Rayleigh_RNG src; src.setup(sigma); return src(size); }$/;"	f	namespace:itpp	signature:(int size, double sigma = 1.0)
itpp::randrice	/usr/include/itpp/base/random.h	/^inline vec randrice(int size, double sigma = 1.0, double s = 1.0) { Rice_RNG src; src.setup(sigma, s); return src(size); }$/;"	f	namespace:itpp	signature:(int size, double sigma = 1.0, double s = 1.0)
itpp::randu	/usr/include/itpp/base/random.h	/^inline double randu(void) { Uniform_RNG src; return src.sample(); }$/;"	f	namespace:itpp	signature:(void)
itpp::randu	/usr/include/itpp/base/random.h	/^inline mat randu(int rows, int cols) { mat temp; randu(rows, cols, temp); return temp; }$/;"	f	namespace:itpp	signature:(int rows, int cols)
itpp::randu	/usr/include/itpp/base/random.h	/^inline vec randu(int size) { vec temp; randu(size, temp); return temp; }$/;"	f	namespace:itpp	signature:(int size)
itpp::randu	/usr/include/itpp/base/random.h	/^inline void randu(int rows, int cols, mat &out) { Uniform_RNG src; src.sample_matrix(rows, cols, out); }$/;"	f	namespace:itpp	signature:(int rows, int cols, mat &out)
itpp::randu	/usr/include/itpp/base/random.h	/^inline void randu(int size, vec &out) { Uniform_RNG src; src.sample_vector(size, out); }$/;"	f	namespace:itpp	signature:(int size, vec &out)
itpp::raw16be_read	/usr/include/itpp/srccode/audiofile.h	/^bool raw16be_read(const char *fname, vec &v);$/;"	p	namespace:itpp	signature:(const char *fname, vec &v)
itpp::raw16be_read	/usr/include/itpp/srccode/audiofile.h	/^bool raw16be_read(const char *fname, vec &v, int beg, int len);$/;"	p	namespace:itpp	signature:(const char *fname, vec &v, int beg, int len)
itpp::raw16be_write	/usr/include/itpp/srccode/audiofile.h	/^bool raw16be_write(const char *fname, const vec &v, bool append = false);$/;"	p	namespace:itpp	signature:(const char *fname, const vec &v, bool append = false)
itpp::raw16le_read	/usr/include/itpp/srccode/audiofile.h	/^bool raw16le_read(const char *fname, vec &v);$/;"	p	namespace:itpp	signature:(const char *fname, vec &v)
itpp::raw16le_read	/usr/include/itpp/srccode/audiofile.h	/^bool raw16le_read(const char *fname, vec &v, int beg, int len);$/;"	p	namespace:itpp	signature:(const char *fname, vec &v, int beg, int len)
itpp::raw16le_write	/usr/include/itpp/srccode/audiofile.h	/^bool raw16le_write(const char *fname, const vec &v, bool append = false);$/;"	p	namespace:itpp	signature:(const char *fname, const vec &v, bool append = false)
itpp::rc2ac	/usr/include/itpp/srccode/lpcfunc.h	/^vec rc2ac(const vec &rc);$/;"	p	namespace:itpp	signature:(const vec &rc)
itpp::rc2is	/usr/include/itpp/srccode/lpcfunc.h	/^vec rc2is(const vec &rc);$/;"	p	namespace:itpp	signature:(const vec &rc)
itpp::rc2lar	/usr/include/itpp/srccode/lpcfunc.h	/^vec rc2lar(const vec &rc);$/;"	p	namespace:itpp	signature:(const vec &rc)
itpp::rc2poly	/usr/include/itpp/srccode/lpcfunc.h	/^vec rc2poly(const vec &rc);$/;"	p	namespace:itpp	signature:(const vec &rc)
itpp::read_endian	/usr/include/itpp/srccode/audiofile.h	/^inline T read_endian(std::istream &s, bool switch_endian = false)$/;"	f	namespace:itpp	signature:(std::istream &s, bool switch_endian = false)
itpp::real	/usr/include/itpp/base/math/elem_math.h	/^mat real(const cmat &x);$/;"	p	namespace:itpp	signature:(const cmat &x)
itpp::real	/usr/include/itpp/base/math/elem_math.h	/^vec real(const cvec &x);$/;"	p	namespace:itpp	signature:(const cvec &x)
itpp::real	/usr/include/itpp/fixed/fix_functions.h	/^Fix real(const CFix &x);$/;"	p	namespace:itpp	signature:(const CFix &x)
itpp::rem	/usr/include/itpp/base/math/elem_math.h	/^inline double rem(double x, double y) { return fmod(x, y); }$/;"	f	namespace:itpp	signature:(double x, double y)
itpp::rem	/usr/include/itpp/base/math/elem_math.h	/^inline mat rem(const mat &x, double y)$/;"	f	namespace:itpp	signature:(const mat &x, double y)
itpp::rem	/usr/include/itpp/base/math/elem_math.h	/^inline mat rem(double x, const mat &y)$/;"	f	namespace:itpp	signature:(double x, const mat &y)
itpp::rem	/usr/include/itpp/base/math/elem_math.h	/^inline vec rem(const vec &x, double y)$/;"	f	namespace:itpp	signature:(const vec &x, double y)
itpp::rem	/usr/include/itpp/base/math/elem_math.h	/^inline vec rem(double x, const vec &y)$/;"	f	namespace:itpp	signature:(double x, const vec &y)
itpp::repeat	/usr/include/itpp/signal/resampling.h	/^Mat<T> repeat(const Mat<T> &m, int norepeats)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, int norepeats)
itpp::repeat	/usr/include/itpp/signal/resampling.h	/^Vec<T> repeat(const Vec<T> &v, int norepeats)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, int norepeats)
itpp::repeat	/usr/include/itpp/signal/resampling.h	/^extern template bmat repeat(const bmat &m, int norepeats);$/;"	p	namespace:itpp	signature:(const bmat &m, int norepeats)
itpp::repeat	/usr/include/itpp/signal/resampling.h	/^extern template bvec repeat(const bvec &v, int norepeats);$/;"	p	namespace:itpp	signature:(const bvec &v, int norepeats)
itpp::repeat	/usr/include/itpp/signal/resampling.h	/^extern template cmat repeat(const cmat &m, int norepeats);$/;"	p	namespace:itpp	signature:(const cmat &m, int norepeats)
itpp::repeat	/usr/include/itpp/signal/resampling.h	/^extern template cvec repeat(const cvec &v, int norepeats);$/;"	p	namespace:itpp	signature:(const cvec &v, int norepeats)
itpp::repeat	/usr/include/itpp/signal/resampling.h	/^extern template imat repeat(const imat &m, int norepeats);$/;"	p	namespace:itpp	signature:(const imat &m, int norepeats)
itpp::repeat	/usr/include/itpp/signal/resampling.h	/^extern template ivec repeat(const ivec &v, int norepeats);$/;"	p	namespace:itpp	signature:(const ivec &v, int norepeats)
itpp::repeat	/usr/include/itpp/signal/resampling.h	/^extern template mat repeat(const mat &m, int norepeats);$/;"	p	namespace:itpp	signature:(const mat &m, int norepeats)
itpp::repeat	/usr/include/itpp/signal/resampling.h	/^extern template smat repeat(const smat &m, int norepeats);$/;"	p	namespace:itpp	signature:(const smat &m, int norepeats)
itpp::repeat	/usr/include/itpp/signal/resampling.h	/^extern template svec repeat(const svec &v, int norepeats);$/;"	p	namespace:itpp	signature:(const svec &v, int norepeats)
itpp::repeat	/usr/include/itpp/signal/resampling.h	/^extern template vec repeat(const vec &v, int norepeats);$/;"	p	namespace:itpp	signature:(const vec &v, int norepeats)
itpp::repmat	/usr/include/itpp/base/matfunc.h	/^Mat<T> repmat(const Mat<T> &data, int m, int n)$/;"	f	namespace:itpp	signature:(const Mat<T> &data, int m, int n)
itpp::repmat	/usr/include/itpp/base/matfunc.h	/^Mat<T> repmat(const Vec<T> &v, int m, int n, bool transpose = false)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, int m, int n, bool transpose = false)
itpp::repmat	/usr/include/itpp/base/matfunc.h	/^Vec<T> repmat(const Vec<T> &v, int n)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, int n)
itpp::repmat	/usr/include/itpp/base/matfunc.h	/^extern template bmat repmat(const bmat &data, int m, int n);$/;"	p	namespace:itpp	signature:(const bmat &data, int m, int n)
itpp::repmat	/usr/include/itpp/base/matfunc.h	/^extern template bmat repmat(const bvec &v, int m, int n, bool transpose);$/;"	p	namespace:itpp	signature:(const bvec &v, int m, int n, bool transpose)
itpp::repmat	/usr/include/itpp/base/matfunc.h	/^extern template bvec repmat(const bvec &v, int n);$/;"	p	namespace:itpp	signature:(const bvec &v, int n)
itpp::repmat	/usr/include/itpp/base/matfunc.h	/^extern template cmat repmat(const cmat &data, int m, int n);$/;"	p	namespace:itpp	signature:(const cmat &data, int m, int n)
itpp::repmat	/usr/include/itpp/base/matfunc.h	/^extern template cmat repmat(const cvec &v, int m, int n, bool transpose);$/;"	p	namespace:itpp	signature:(const cvec &v, int m, int n, bool transpose)
itpp::repmat	/usr/include/itpp/base/matfunc.h	/^extern template cvec repmat(const cvec &v, int n);$/;"	p	namespace:itpp	signature:(const cvec &v, int n)
itpp::repmat	/usr/include/itpp/base/matfunc.h	/^extern template imat repmat(const imat &data, int m, int n);$/;"	p	namespace:itpp	signature:(const imat &data, int m, int n)
itpp::repmat	/usr/include/itpp/base/matfunc.h	/^extern template imat repmat(const ivec &v, int m, int n, bool transpose);$/;"	p	namespace:itpp	signature:(const ivec &v, int m, int n, bool transpose)
itpp::repmat	/usr/include/itpp/base/matfunc.h	/^extern template ivec repmat(const ivec &v, int n);$/;"	p	namespace:itpp	signature:(const ivec &v, int n)
itpp::repmat	/usr/include/itpp/base/matfunc.h	/^extern template mat repmat(const mat &data, int m, int n);$/;"	p	namespace:itpp	signature:(const mat &data, int m, int n)
itpp::repmat	/usr/include/itpp/base/matfunc.h	/^extern template mat repmat(const vec &v, int m, int n, bool transpose);$/;"	p	namespace:itpp	signature:(const vec &v, int m, int n, bool transpose)
itpp::repmat	/usr/include/itpp/base/matfunc.h	/^extern template smat repmat(const smat &data, int m, int n);$/;"	p	namespace:itpp	signature:(const smat &data, int m, int n)
itpp::repmat	/usr/include/itpp/base/matfunc.h	/^extern template smat repmat(const svec &v, int m, int n, bool transpose);$/;"	p	namespace:itpp	signature:(const svec &v, int m, int n, bool transpose)
itpp::repmat	/usr/include/itpp/base/matfunc.h	/^extern template svec repmat(const svec &v, int n);$/;"	p	namespace:itpp	signature:(const svec &v, int n)
itpp::repmat	/usr/include/itpp/base/matfunc.h	/^extern template vec repmat(const vec &v, int n);$/;"	p	namespace:itpp	signature:(const vec &v, int n)
itpp::reshape	/usr/include/itpp/base/matfunc.h	/^Mat<T> reshape(const Mat<T> &m, int rows, int cols)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, int rows, int cols)
itpp::reshape	/usr/include/itpp/base/matfunc.h	/^Mat<T> reshape(const Vec<T> &v, int rows, int cols)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, int rows, int cols)
itpp::reshape	/usr/include/itpp/base/matfunc.h	/^extern template bmat reshape(const bmat &m, int rows, int cols);$/;"	p	namespace:itpp	signature:(const bmat &m, int rows, int cols)
itpp::reshape	/usr/include/itpp/base/matfunc.h	/^extern template bmat reshape(const bvec &m, int rows, int cols);$/;"	p	namespace:itpp	signature:(const bvec &m, int rows, int cols)
itpp::reshape	/usr/include/itpp/base/matfunc.h	/^extern template cmat reshape(const cmat &m, int rows, int cols);$/;"	p	namespace:itpp	signature:(const cmat &m, int rows, int cols)
itpp::reshape	/usr/include/itpp/base/matfunc.h	/^extern template cmat reshape(const cvec &m, int rows, int cols);$/;"	p	namespace:itpp	signature:(const cvec &m, int rows, int cols)
itpp::reshape	/usr/include/itpp/base/matfunc.h	/^extern template imat reshape(const imat &m, int rows, int cols);$/;"	p	namespace:itpp	signature:(const imat &m, int rows, int cols)
itpp::reshape	/usr/include/itpp/base/matfunc.h	/^extern template imat reshape(const ivec &m, int rows, int cols);$/;"	p	namespace:itpp	signature:(const ivec &m, int rows, int cols)
itpp::reshape	/usr/include/itpp/base/matfunc.h	/^extern template mat reshape(const mat &m, int rows, int cols);$/;"	p	namespace:itpp	signature:(const mat &m, int rows, int cols)
itpp::reshape	/usr/include/itpp/base/matfunc.h	/^extern template mat reshape(const vec &m, int rows, int cols);$/;"	p	namespace:itpp	signature:(const vec &m, int rows, int cols)
itpp::reshape	/usr/include/itpp/base/matfunc.h	/^extern template smat reshape(const smat &m, int rows, int cols);$/;"	p	namespace:itpp	signature:(const smat &m, int rows, int cols)
itpp::reshape	/usr/include/itpp/base/matfunc.h	/^extern template smat reshape(const svec &m, int rows, int cols);$/;"	p	namespace:itpp	signature:(const svec &m, int rows, int cols)
itpp::reverse	/usr/include/itpp/base/matfunc.h	/^Vec<T> reverse(const Vec<T> &in)$/;"	f	namespace:itpp	signature:(const Vec<T> &in)
itpp::reverse	/usr/include/itpp/base/matfunc.h	/^extern template bvec reverse(const bvec &in);$/;"	p	namespace:itpp	signature:(const bvec &in)
itpp::reverse	/usr/include/itpp/base/matfunc.h	/^extern template cvec reverse(const cvec &in);$/;"	p	namespace:itpp	signature:(const cvec &in)
itpp::reverse	/usr/include/itpp/base/matfunc.h	/^extern template ivec reverse(const ivec &in);$/;"	p	namespace:itpp	signature:(const ivec &in)
itpp::reverse	/usr/include/itpp/base/matfunc.h	/^extern template svec reverse(const svec &in);$/;"	p	namespace:itpp	signature:(const svec &in)
itpp::reverse	/usr/include/itpp/base/matfunc.h	/^extern template vec reverse(const vec &in);$/;"	p	namespace:itpp	signature:(const vec &in)
itpp::reverse_int	/usr/include/itpp/comm/convcode.h	/^int reverse_int(int length, int in);$/;"	p	namespace:itpp	signature:(int length, int in)
itpp::roots	/usr/include/itpp/signal/poly.h	/^inline cvec roots(const cvec &p) { cvec temp; roots(p, temp); return temp; }$/;"	f	namespace:itpp	signature:(const cvec &p)
itpp::roots	/usr/include/itpp/signal/poly.h	/^inline cvec roots(const vec &p) { cvec temp; roots(p, temp); return temp; }$/;"	f	namespace:itpp	signature:(const vec &p)
itpp::roots	/usr/include/itpp/signal/poly.h	/^void roots(const cvec &p, cvec &r);$/;"	p	namespace:itpp	signature:(const cvec &p, cvec &r)
itpp::roots	/usr/include/itpp/signal/poly.h	/^void roots(const vec &p, cvec &r);$/;"	p	namespace:itpp	signature:(const vec &p, cvec &r)
itpp::rotation_matrix	/usr/include/itpp/base/specmat.h	/^mat rotation_matrix(int dim, int plane1, int plane2, double angle);$/;"	p	namespace:itpp	signature:(int dim, int plane1, int plane2, double angle)
itpp::round	/usr/include/itpp/base/converters.h	/^inline double round(double x) { return ::rint(x); }$/;"	f	namespace:itpp	signature:(double x)
itpp::round	/usr/include/itpp/base/converters.h	/^inline mat round(const mat &x) { return apply_function<double>(::rint, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::round	/usr/include/itpp/base/converters.h	/^inline vec round(const vec &x) { return apply_function<double>(::rint, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::round_i	/usr/include/itpp/base/converters.h	/^imat round_i(const mat &x);$/;"	p	namespace:itpp	signature:(const mat &x)
itpp::round_i	/usr/include/itpp/base/converters.h	/^inline int round_i(double x) { return static_cast<int>(::rint(x)); }$/;"	f	namespace:itpp	signature:(double x)
itpp::round_i	/usr/include/itpp/base/converters.h	/^ivec round_i(const vec &x);$/;"	p	namespace:itpp	signature:(const vec &x)
itpp::round_to_zero	/usr/include/itpp/base/converters.h	/^cmat round_to_zero(const cmat &x, double threshold = 1e-14);$/;"	p	namespace:itpp	signature:(const cmat &x, double threshold = 1e-14)
itpp::round_to_zero	/usr/include/itpp/base/converters.h	/^cvec round_to_zero(const cvec &x, double threshold = 1e-14);$/;"	p	namespace:itpp	signature:(const cvec &x, double threshold = 1e-14)
itpp::round_to_zero	/usr/include/itpp/base/converters.h	/^inline double round_to_zero(double x, double threshold = 1e-14)$/;"	f	namespace:itpp	signature:(double x, double threshold = 1e-14)
itpp::round_to_zero	/usr/include/itpp/base/converters.h	/^inline mat round_to_zero(const mat &x, double threshold = 1e-14)$/;"	f	namespace:itpp	signature:(const mat &x, double threshold = 1e-14)
itpp::round_to_zero	/usr/include/itpp/base/converters.h	/^inline std::complex<double> round_to_zero(const std::complex<double>& x,$/;"	f	namespace:itpp	signature:(const std::complex<double>& x, double threshold = 1e-14)
itpp::round_to_zero	/usr/include/itpp/base/converters.h	/^inline vec round_to_zero(const vec &x, double threshold = 1e-14)$/;"	f	namespace:itpp	signature:(const vec &x, double threshold = 1e-14)
itpp::rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(CFix &y, int n) {y.rshift(n);}$/;"	f	namespace:itpp	signature:(CFix &y, int n)
itpp::rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(CFix &y, int n, q_mode q) {y.rshift(n, q);}$/;"	f	namespace:itpp	signature:(CFix &y, int n, q_mode q)
itpp::rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(Fix &y, int n) {y.rshift(n);}$/;"	f	namespace:itpp	signature:(Fix &y, int n)
itpp::rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(Fix &y, int n, q_mode q) {y.rshift(n, q);}$/;"	f	namespace:itpp	signature:(Fix &y, int n, q_mode q)
itpp::rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(cfixmat &y, int n)$/;"	f	namespace:itpp	signature:(cfixmat &y, int n)
itpp::rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(cfixmat &y, int n, q_mode q)$/;"	f	namespace:itpp	signature:(cfixmat &y, int n, q_mode q)
itpp::rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(cfixvec &y, int n)$/;"	f	namespace:itpp	signature:(cfixvec &y, int n)
itpp::rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(cfixvec &y, int n, q_mode q)$/;"	f	namespace:itpp	signature:(cfixvec &y, int n, q_mode q)
itpp::rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(cmat &, int) {}$/;"	f	namespace:itpp	signature:(cmat &, int)
itpp::rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(cmat &, int, q_mode) {}$/;"	f	namespace:itpp	signature:(cmat &, int, q_mode)
itpp::rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(cvec &, int) {}$/;"	f	namespace:itpp	signature:(cvec &, int)
itpp::rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(cvec &, int, q_mode) {}$/;"	f	namespace:itpp	signature:(cvec &, int, q_mode)
itpp::rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(double &, int) {}$/;"	f	namespace:itpp	signature:(double &, int)
itpp::rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(double &, int, q_mode) {}$/;"	f	namespace:itpp	signature:(double &, int, q_mode)
itpp::rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(fixmat &y, int n)$/;"	f	namespace:itpp	signature:(fixmat &y, int n)
itpp::rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(fixmat &y, int n, q_mode q)$/;"	f	namespace:itpp	signature:(fixmat &y, int n, q_mode q)
itpp::rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(fixvec &y, int n)$/;"	f	namespace:itpp	signature:(fixvec &y, int n)
itpp::rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(fixvec &y, int n, q_mode q)$/;"	f	namespace:itpp	signature:(fixvec &y, int n, q_mode q)
itpp::rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(mat &, int) {}$/;"	f	namespace:itpp	signature:(mat &, int)
itpp::rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(mat &, int, q_mode) {}$/;"	f	namespace:itpp	signature:(mat &, int, q_mode)
itpp::rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(std::complex<double> &, int) {}$/;"	f	namespace:itpp	signature:(std::complex<double> &, int)
itpp::rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(std::complex<double> &, int, q_mode) {}$/;"	f	namespace:itpp	signature:(std::complex<double> &, int, q_mode)
itpp::rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(vec &, int) {}$/;"	f	namespace:itpp	signature:(vec &, int)
itpp::rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(vec &, int, q_mode) {}$/;"	f	namespace:itpp	signature:(vec &, int, q_mode)
itpp::rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<class T> inline void rshift_fix(Array<T> &y, int n)$/;"	f	namespace:itpp	signature:(Array<T> &y, int n)
itpp::rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<class T> inline void rshift_fix(Array<T> &y, int n, q_mode q)$/;"	f	namespace:itpp	signature:(Array<T> &y, int n, q_mode q)
itpp::rvectorize	/usr/include/itpp/base/matfunc.h	/^Vec<T> rvectorize(const Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
itpp::rvectorize	/usr/include/itpp/base/matfunc.h	/^extern template bvec rvectorize(const bmat &m);$/;"	p	namespace:itpp	signature:(const bmat &m)
itpp::rvectorize	/usr/include/itpp/base/matfunc.h	/^extern template cvec rvectorize(const cmat &m);$/;"	p	namespace:itpp	signature:(const cmat &m)
itpp::rvectorize	/usr/include/itpp/base/matfunc.h	/^extern template ivec rvectorize(const imat &m);$/;"	p	namespace:itpp	signature:(const imat &m)
itpp::rvectorize	/usr/include/itpp/base/matfunc.h	/^extern template svec rvectorize(const smat &m);$/;"	p	namespace:itpp	signature:(const smat &m)
itpp::rvectorize	/usr/include/itpp/base/matfunc.h	/^extern template vec rvectorize(const mat &m);$/;"	p	namespace:itpp	signature:(const mat &m)
itpp::scal_vector	/usr/include/itpp/base/copy_vector.h	/^inline void scal_vector(int n, double alpha, double *x)$/;"	f	namespace:itpp	signature:(int n, double alpha, double *x)
itpp::scal_vector	/usr/include/itpp/base/copy_vector.h	/^inline void scal_vector(int n, double alpha, double *x, int incx)$/;"	f	namespace:itpp	signature:(int n, double alpha, double *x, int incx)
itpp::scal_vector	/usr/include/itpp/base/copy_vector.h	/^inline void scal_vector(int n, std::complex<double> alpha,$/;"	f	namespace:itpp	signature:(int n, std::complex<double> alpha, std::complex<double> *x)
itpp::scal_vector	/usr/include/itpp/base/copy_vector.h	/^inline void scal_vector(int n, std::complex<double> alpha,$/;"	f	namespace:itpp	signature:(int n, std::complex<double> alpha, std::complex<double> *x, int incx)
itpp::scal_vector	/usr/include/itpp/base/copy_vector.h	/^void scal_vector(int n, T alpha, T *x)$/;"	f	namespace:itpp	signature:(int n, T alpha, T *x)
itpp::scal_vector	/usr/include/itpp/base/copy_vector.h	/^void scal_vector(int n, T alpha, T *x, int incx)$/;"	f	namespace:itpp	signature:(int n, T alpha, T *x, int incx)
itpp::scalar_encode	/usr/include/itpp/srccode/vq.h	/^int scalar_encode(double x, vec &Levels) ;$/;"	p	namespace:itpp	signature:(double x, vec &Levels)
itpp::scalar_encode	/usr/include/itpp/srccode/vq.h	/^ivec scalar_encode(vec &x, vec &Levels);$/;"	p	namespace:itpp	signature:(vec &x, vec &Levels)
itpp::scalar_quantize	/usr/include/itpp/srccode/vq.h	/^inline double scalar_quantize(double x, vec &Levels) { return Levels(scalar_encode(x, Levels)); }$/;"	f	namespace:itpp	signature:(double x, vec &Levels)
itpp::scalar_quantize	/usr/include/itpp/srccode/vq.h	/^inline vec scalar_quantize(vec &x, vec &Levels) { return Levels(scalar_encode(x, Levels)); }$/;"	f	namespace:itpp	signature:(vec &x, vec &Levels)
itpp::scfixed1	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<1, TC, SAT> scfixed1;$/;"	t	namespace:itpp
itpp::scfixed10	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<10, TC, SAT> scfixed10;$/;"	t	namespace:itpp
itpp::scfixed11	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<11, TC, SAT> scfixed11;$/;"	t	namespace:itpp
itpp::scfixed12	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<12, TC, SAT> scfixed12;$/;"	t	namespace:itpp
itpp::scfixed13	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<13, TC, SAT> scfixed13;$/;"	t	namespace:itpp
itpp::scfixed14	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<14, TC, SAT> scfixed14;$/;"	t	namespace:itpp
itpp::scfixed15	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<15, TC, SAT> scfixed15;$/;"	t	namespace:itpp
itpp::scfixed16	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<16, TC, SAT> scfixed16;$/;"	t	namespace:itpp
itpp::scfixed17	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<17, TC, SAT> scfixed17;$/;"	t	namespace:itpp
itpp::scfixed18	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<18, TC, SAT> scfixed18;$/;"	t	namespace:itpp
itpp::scfixed19	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<19, TC, SAT> scfixed19;$/;"	t	namespace:itpp
itpp::scfixed2	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<2, TC, SAT> scfixed2;$/;"	t	namespace:itpp
itpp::scfixed20	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<20, TC, SAT> scfixed20;$/;"	t	namespace:itpp
itpp::scfixed21	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<21, TC, SAT> scfixed21;$/;"	t	namespace:itpp
itpp::scfixed22	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<22, TC, SAT> scfixed22;$/;"	t	namespace:itpp
itpp::scfixed23	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<23, TC, SAT> scfixed23;$/;"	t	namespace:itpp
itpp::scfixed24	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<24, TC, SAT> scfixed24;$/;"	t	namespace:itpp
itpp::scfixed25	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<25, TC, SAT> scfixed25;$/;"	t	namespace:itpp
itpp::scfixed26	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<26, TC, SAT> scfixed26;$/;"	t	namespace:itpp
itpp::scfixed27	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<27, TC, SAT> scfixed27;$/;"	t	namespace:itpp
itpp::scfixed28	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<28, TC, SAT> scfixed28;$/;"	t	namespace:itpp
itpp::scfixed29	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<29, TC, SAT> scfixed29;$/;"	t	namespace:itpp
itpp::scfixed3	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<3, TC, SAT> scfixed3;$/;"	t	namespace:itpp
itpp::scfixed30	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<30, TC, SAT> scfixed30;$/;"	t	namespace:itpp
itpp::scfixed31	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<31, TC, SAT> scfixed31;$/;"	t	namespace:itpp
itpp::scfixed32	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<32, TC, SAT> scfixed32;$/;"	t	namespace:itpp
itpp::scfixed33	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<33, TC, SAT> scfixed33;$/;"	t	namespace:itpp
itpp::scfixed34	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<34, TC, SAT> scfixed34;$/;"	t	namespace:itpp
itpp::scfixed35	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<35, TC, SAT> scfixed35;$/;"	t	namespace:itpp
itpp::scfixed36	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<36, TC, SAT> scfixed36;$/;"	t	namespace:itpp
itpp::scfixed37	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<37, TC, SAT> scfixed37;$/;"	t	namespace:itpp
itpp::scfixed38	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<38, TC, SAT> scfixed38;$/;"	t	namespace:itpp
itpp::scfixed39	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<39, TC, SAT> scfixed39;$/;"	t	namespace:itpp
itpp::scfixed4	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<4, TC, SAT> scfixed4;$/;"	t	namespace:itpp
itpp::scfixed40	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<40, TC, SAT> scfixed40;$/;"	t	namespace:itpp
itpp::scfixed41	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<41, TC, SAT> scfixed41;$/;"	t	namespace:itpp
itpp::scfixed42	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<42, TC, SAT> scfixed42;$/;"	t	namespace:itpp
itpp::scfixed43	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<43, TC, SAT> scfixed43;$/;"	t	namespace:itpp
itpp::scfixed44	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<44, TC, SAT> scfixed44;$/;"	t	namespace:itpp
itpp::scfixed45	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<45, TC, SAT> scfixed45;$/;"	t	namespace:itpp
itpp::scfixed46	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<46, TC, SAT> scfixed46;$/;"	t	namespace:itpp
itpp::scfixed47	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<47, TC, SAT> scfixed47;$/;"	t	namespace:itpp
itpp::scfixed48	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<48, TC, SAT> scfixed48;$/;"	t	namespace:itpp
itpp::scfixed49	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<49, TC, SAT> scfixed49;$/;"	t	namespace:itpp
itpp::scfixed5	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<5, TC, SAT> scfixed5;$/;"	t	namespace:itpp
itpp::scfixed50	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<50, TC, SAT> scfixed50;$/;"	t	namespace:itpp
itpp::scfixed51	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<51, TC, SAT> scfixed51;$/;"	t	namespace:itpp
itpp::scfixed52	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<52, TC, SAT> scfixed52;$/;"	t	namespace:itpp
itpp::scfixed53	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<53, TC, SAT> scfixed53;$/;"	t	namespace:itpp
itpp::scfixed54	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<54, TC, SAT> scfixed54;$/;"	t	namespace:itpp
itpp::scfixed55	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<55, TC, SAT> scfixed55;$/;"	t	namespace:itpp
itpp::scfixed56	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<56, TC, SAT> scfixed56;$/;"	t	namespace:itpp
itpp::scfixed57	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<57, TC, SAT> scfixed57;$/;"	t	namespace:itpp
itpp::scfixed58	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<58, TC, SAT> scfixed58;$/;"	t	namespace:itpp
itpp::scfixed59	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<59, TC, SAT> scfixed59;$/;"	t	namespace:itpp
itpp::scfixed6	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<6, TC, SAT> scfixed6;$/;"	t	namespace:itpp
itpp::scfixed60	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<60, TC, SAT> scfixed60;$/;"	t	namespace:itpp
itpp::scfixed61	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<61, TC, SAT> scfixed61;$/;"	t	namespace:itpp
itpp::scfixed62	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<62, TC, SAT> scfixed62;$/;"	t	namespace:itpp
itpp::scfixed63	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<63, TC, SAT> scfixed63;$/;"	t	namespace:itpp
itpp::scfixed64	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<64, TC, SAT> scfixed64;$/;"	t	namespace:itpp
itpp::scfixed7	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<7, TC, SAT> scfixed7;$/;"	t	namespace:itpp
itpp::scfixed8	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<8, TC, SAT> scfixed8;$/;"	t	namespace:itpp
itpp::scfixed9	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<9, TC, SAT> scfixed9;$/;"	t	namespace:itpp
itpp::schur	/usr/include/itpp/base/algebra/schur.h	/^bool schur(const cmat &A, cmat &U, cmat &T);$/;"	p	namespace:itpp	signature:(const cmat &A, cmat &U, cmat &T)
itpp::schur	/usr/include/itpp/base/algebra/schur.h	/^bool schur(const mat &A, mat &U, mat &T);$/;"	p	namespace:itpp	signature:(const mat &A, mat &U, mat &T)
itpp::schur	/usr/include/itpp/base/algebra/schur.h	/^cmat schur(const cmat &A);$/;"	p	namespace:itpp	signature:(const cmat &A)
itpp::schur	/usr/include/itpp/base/algebra/schur.h	/^mat schur(const mat &A);$/;"	p	namespace:itpp	signature:(const mat &A)
itpp::schurrc	/usr/include/itpp/srccode/lpcfunc.h	/^vec schurrc(const vec &R, int order);$/;"	p	namespace:itpp	signature:(const vec &R, int order)
itpp::sd	/usr/include/itpp/srccode/lpcfunc.h	/^double sd(const vec &In1, const vec &In2);$/;"	p	namespace:itpp	signature:(const vec &In1, const vec &In2)
itpp::sd	/usr/include/itpp/srccode/lpcfunc.h	/^double sd(const vec &In1, const vec &In2, double highestfreq);$/;"	p	namespace:itpp	signature:(const vec &In1, const vec &In2, double highestfreq)
itpp::self_dht	/usr/include/itpp/signal/transforms.h	/^extern template void self_dht(cvec &v);$/;"	p	namespace:itpp	signature:(cvec &v)
itpp::self_dht	/usr/include/itpp/signal/transforms.h	/^extern template void self_dht(vec &v);$/;"	p	namespace:itpp	signature:(vec &v)
itpp::self_dht	/usr/include/itpp/signal/transforms.h	/^template <class T> void self_dht(Vec<T> &v);$/;"	p	namespace:itpp	signature:(Vec<T> &v)
itpp::self_dht	/usr/include/itpp/signal/transforms.h	/^void self_dht(Vec<T> &v)$/;"	f	namespace:itpp	signature:(Vec<T> &v)
itpp::self_dwht	/usr/include/itpp/signal/transforms.h	/^extern template void self_dwht(cvec &v);$/;"	p	namespace:itpp	signature:(cvec &v)
itpp::self_dwht	/usr/include/itpp/signal/transforms.h	/^extern template void self_dwht(vec &v);$/;"	p	namespace:itpp	signature:(vec &v)
itpp::self_dwht	/usr/include/itpp/signal/transforms.h	/^template <class T> void self_dwht(Vec<T> &v);$/;"	p	namespace:itpp	signature:(Vec<T> &v)
itpp::self_dwht	/usr/include/itpp/signal/transforms.h	/^void self_dwht(Vec<T> &v)$/;"	f	namespace:itpp	signature:(Vec<T> &v)
itpp::set_array	/usr/include/itpp/base/array.h	/^void set_array(Array<T> &a, const char *values)$/;"	f	namespace:itpp	signature:(Array<T> &a, const char *values)
itpp::set_array	/usr/include/itpp/base/array.h	/^void set_array(Array<T> &a, const std::string &str)$/;"	f	namespace:itpp	signature:(Array<T> &a, const std::string &str)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(CFix &y, double real, double imag, int n) {y.set(real, imag, n);}$/;"	f	namespace:itpp	signature:(CFix &y, double real, double imag, int n)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(CFix &y, double real, double imag, int n, q_mode q) {y.set(real, imag, n, q);}$/;"	f	namespace:itpp	signature:(CFix &y, double real, double imag, int n, q_mode q)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(CFix &y, std::complex<double> x, int n) {y.set(x, n);}$/;"	f	namespace:itpp	signature:(CFix &y, std::complex<double> x, int n)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(CFix &y, std::complex<double> x, int n, q_mode q) {y.set(x, n, q);}$/;"	f	namespace:itpp	signature:(CFix &y, std::complex<double> x, int n, q_mode q)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(Fix &y, double x, int n) {y.set(x, n);}$/;"	f	namespace:itpp	signature:(Fix &y, double x, int n)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(Fix &y, double x, int n, q_mode q) {y.set(x, n, q);}$/;"	f	namespace:itpp	signature:(Fix &y, double x, int n, q_mode q)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cfixmat &y, const cmat &x, int n)$/;"	f	namespace:itpp	signature:(cfixmat &y, const cmat &x, int n)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cfixmat &y, const cmat &x, int n, q_mode q)$/;"	f	namespace:itpp	signature:(cfixmat &y, const cmat &x, int n, q_mode q)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cfixmat &y, const mat &real, const mat &imag, int n)$/;"	f	namespace:itpp	signature:(cfixmat &y, const mat &real, const mat &imag, int n)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cfixmat &y, const mat &real, const mat &imag, int n, q_mode q)$/;"	f	namespace:itpp	signature:(cfixmat &y, const mat &real, const mat &imag, int n, q_mode q)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cfixvec &y, const cvec &x, int n)$/;"	f	namespace:itpp	signature:(cfixvec &y, const cvec &x, int n)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cfixvec &y, const cvec &x, int n, q_mode q)$/;"	f	namespace:itpp	signature:(cfixvec &y, const cvec &x, int n, q_mode q)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cfixvec &y, const vec &real, const vec &imag, int n)$/;"	f	namespace:itpp	signature:(cfixvec &y, const vec &real, const vec &imag, int n)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cfixvec &y, const vec &real, const vec &imag, int n, q_mode q)$/;"	f	namespace:itpp	signature:(cfixvec &y, const vec &real, const vec &imag, int n, q_mode q)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cmat &y, const cmat &x, int) {y = x;}$/;"	f	namespace:itpp	signature:(cmat &y, const cmat &x, int)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cmat &y, const cmat &x, int, q_mode) {y = x;}$/;"	f	namespace:itpp	signature:(cmat &y, const cmat &x, int, q_mode)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cmat &y, const mat &real, const mat &imag, int) {y = to_cmat(real, imag);}$/;"	f	namespace:itpp	signature:(cmat &y, const mat &real, const mat &imag, int)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cmat &y, const mat &real, const mat &imag, int, q_mode) {y = to_cmat(real, imag);}$/;"	f	namespace:itpp	signature:(cmat &y, const mat &real, const mat &imag, int, q_mode)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cvec &y, const cvec &x, int) {y = x;}$/;"	f	namespace:itpp	signature:(cvec &y, const cvec &x, int)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cvec &y, const cvec &x, int, q_mode) {y = x;}$/;"	f	namespace:itpp	signature:(cvec &y, const cvec &x, int, q_mode)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cvec &y, const vec &real, const vec &imag, int) {y = to_cvec(real, imag);}$/;"	f	namespace:itpp	signature:(cvec &y, const vec &real, const vec &imag, int)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cvec &y, const vec &real, const vec &imag, int, q_mode) {y = to_cvec(real, imag);}$/;"	f	namespace:itpp	signature:(cvec &y, const vec &real, const vec &imag, int, q_mode)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(double &y, double x, int) {y = x;}$/;"	f	namespace:itpp	signature:(double &y, double x, int)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(double &y, double x, int, q_mode) {y = x;}$/;"	f	namespace:itpp	signature:(double &y, double x, int, q_mode)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(fixmat &y, const mat &x, int n)$/;"	f	namespace:itpp	signature:(fixmat &y, const mat &x, int n)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(fixmat &y, const mat &x, int n, q_mode q)$/;"	f	namespace:itpp	signature:(fixmat &y, const mat &x, int n, q_mode q)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(fixvec &y, const vec &x, int n)$/;"	f	namespace:itpp	signature:(fixvec &y, const vec &x, int n)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(fixvec &y, const vec &x, int n, q_mode q)$/;"	f	namespace:itpp	signature:(fixvec &y, const vec &x, int n, q_mode q)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(mat &y, const mat &x, int) {y = x;}$/;"	f	namespace:itpp	signature:(mat &y, const mat &x, int)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(mat &y, const mat &x, int, q_mode) {y = x;}$/;"	f	namespace:itpp	signature:(mat &y, const mat &x, int, q_mode)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(std::complex<double> &y, const std::complex<double> &x, int) {y = x;}$/;"	f	namespace:itpp	signature:(std::complex<double> &y, const std::complex<double> &x, int)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(std::complex<double> &y, const std::complex<double> &x, int, q_mode) {y = x;}$/;"	f	namespace:itpp	signature:(std::complex<double> &y, const std::complex<double> &x, int, q_mode)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(std::complex<double> &y, double real, double imag, int) {y = std::complex<double>(real, imag);}$/;"	f	namespace:itpp	signature:(std::complex<double> &y, double real, double imag, int)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(std::complex<double> &y, double real, double imag, int, q_mode) {y = std::complex<double>(real, imag);}$/;"	f	namespace:itpp	signature:(std::complex<double> &y, double real, double imag, int, q_mode)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(vec &y, const vec &x, int) {y = x;}$/;"	f	namespace:itpp	signature:(vec &y, const vec &x, int)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(vec &y, const vec &x, int, q_mode) {y = x;}$/;"	f	namespace:itpp	signature:(vec &y, const vec &x, int, q_mode)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<class T1, class T2> inline void set_fix(Array<T1> &y, const Array<T2> &real, const Array<T2> &imag, int n)$/;"	f	namespace:itpp	signature:(Array<T1> &y, const Array<T2> &real, const Array<T2> &imag, int n)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<class T1, class T2> inline void set_fix(Array<T1> &y, const Array<T2> &real, const Array<T2> &imag, int n, q_mode q)$/;"	f	namespace:itpp	signature:(Array<T1> &y, const Array<T2> &real, const Array<T2> &imag, int n, q_mode q)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<class T1, class T2> inline void set_fix(Array<T1> &y, const Array<T2> &x, int n)$/;"	f	namespace:itpp	signature:(Array<T1> &y, const Array<T2> &x, int n)
itpp::set_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<class T1, class T2> inline void set_fix(Array<T1> &y, const Array<T2> &x, int n, q_mode q)$/;"	f	namespace:itpp	signature:(Array<T1> &y, const Array<T2> &x, int n, q_mode q)
itpp::sfixed1	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<1, TC, SAT> sfixed1;$/;"	t	namespace:itpp
itpp::sfixed10	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<10, TC, SAT> sfixed10;$/;"	t	namespace:itpp
itpp::sfixed11	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<11, TC, SAT> sfixed11;$/;"	t	namespace:itpp
itpp::sfixed12	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<12, TC, SAT> sfixed12;$/;"	t	namespace:itpp
itpp::sfixed13	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<13, TC, SAT> sfixed13;$/;"	t	namespace:itpp
itpp::sfixed14	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<14, TC, SAT> sfixed14;$/;"	t	namespace:itpp
itpp::sfixed15	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<15, TC, SAT> sfixed15;$/;"	t	namespace:itpp
itpp::sfixed16	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<16, TC, SAT> sfixed16;$/;"	t	namespace:itpp
itpp::sfixed17	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<17, TC, SAT> sfixed17;$/;"	t	namespace:itpp
itpp::sfixed18	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<18, TC, SAT> sfixed18;$/;"	t	namespace:itpp
itpp::sfixed19	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<19, TC, SAT> sfixed19;$/;"	t	namespace:itpp
itpp::sfixed2	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<2, TC, SAT> sfixed2;$/;"	t	namespace:itpp
itpp::sfixed20	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<20, TC, SAT> sfixed20;$/;"	t	namespace:itpp
itpp::sfixed21	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<21, TC, SAT> sfixed21;$/;"	t	namespace:itpp
itpp::sfixed22	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<22, TC, SAT> sfixed22;$/;"	t	namespace:itpp
itpp::sfixed23	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<23, TC, SAT> sfixed23;$/;"	t	namespace:itpp
itpp::sfixed24	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<24, TC, SAT> sfixed24;$/;"	t	namespace:itpp
itpp::sfixed25	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<25, TC, SAT> sfixed25;$/;"	t	namespace:itpp
itpp::sfixed26	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<26, TC, SAT> sfixed26;$/;"	t	namespace:itpp
itpp::sfixed27	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<27, TC, SAT> sfixed27;$/;"	t	namespace:itpp
itpp::sfixed28	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<28, TC, SAT> sfixed28;$/;"	t	namespace:itpp
itpp::sfixed29	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<29, TC, SAT> sfixed29;$/;"	t	namespace:itpp
itpp::sfixed3	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<3, TC, SAT> sfixed3;$/;"	t	namespace:itpp
itpp::sfixed30	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<30, TC, SAT> sfixed30;$/;"	t	namespace:itpp
itpp::sfixed31	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<31, TC, SAT> sfixed31;$/;"	t	namespace:itpp
itpp::sfixed32	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<32, TC, SAT> sfixed32;$/;"	t	namespace:itpp
itpp::sfixed33	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<33, TC, SAT> sfixed33;$/;"	t	namespace:itpp
itpp::sfixed34	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<34, TC, SAT> sfixed34;$/;"	t	namespace:itpp
itpp::sfixed35	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<35, TC, SAT> sfixed35;$/;"	t	namespace:itpp
itpp::sfixed36	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<36, TC, SAT> sfixed36;$/;"	t	namespace:itpp
itpp::sfixed37	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<37, TC, SAT> sfixed37;$/;"	t	namespace:itpp
itpp::sfixed38	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<38, TC, SAT> sfixed38;$/;"	t	namespace:itpp
itpp::sfixed39	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<39, TC, SAT> sfixed39;$/;"	t	namespace:itpp
itpp::sfixed4	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<4, TC, SAT> sfixed4;$/;"	t	namespace:itpp
itpp::sfixed40	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<40, TC, SAT> sfixed40;$/;"	t	namespace:itpp
itpp::sfixed41	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<41, TC, SAT> sfixed41;$/;"	t	namespace:itpp
itpp::sfixed42	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<42, TC, SAT> sfixed42;$/;"	t	namespace:itpp
itpp::sfixed43	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<43, TC, SAT> sfixed43;$/;"	t	namespace:itpp
itpp::sfixed44	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<44, TC, SAT> sfixed44;$/;"	t	namespace:itpp
itpp::sfixed45	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<45, TC, SAT> sfixed45;$/;"	t	namespace:itpp
itpp::sfixed46	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<46, TC, SAT> sfixed46;$/;"	t	namespace:itpp
itpp::sfixed47	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<47, TC, SAT> sfixed47;$/;"	t	namespace:itpp
itpp::sfixed48	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<48, TC, SAT> sfixed48;$/;"	t	namespace:itpp
itpp::sfixed49	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<49, TC, SAT> sfixed49;$/;"	t	namespace:itpp
itpp::sfixed5	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<5, TC, SAT> sfixed5;$/;"	t	namespace:itpp
itpp::sfixed50	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<50, TC, SAT> sfixed50;$/;"	t	namespace:itpp
itpp::sfixed51	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<51, TC, SAT> sfixed51;$/;"	t	namespace:itpp
itpp::sfixed52	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<52, TC, SAT> sfixed52;$/;"	t	namespace:itpp
itpp::sfixed53	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<53, TC, SAT> sfixed53;$/;"	t	namespace:itpp
itpp::sfixed54	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<54, TC, SAT> sfixed54;$/;"	t	namespace:itpp
itpp::sfixed55	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<55, TC, SAT> sfixed55;$/;"	t	namespace:itpp
itpp::sfixed56	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<56, TC, SAT> sfixed56;$/;"	t	namespace:itpp
itpp::sfixed57	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<57, TC, SAT> sfixed57;$/;"	t	namespace:itpp
itpp::sfixed58	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<58, TC, SAT> sfixed58;$/;"	t	namespace:itpp
itpp::sfixed59	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<59, TC, SAT> sfixed59;$/;"	t	namespace:itpp
itpp::sfixed6	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<6, TC, SAT> sfixed6;$/;"	t	namespace:itpp
itpp::sfixed60	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<60, TC, SAT> sfixed60;$/;"	t	namespace:itpp
itpp::sfixed61	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<61, TC, SAT> sfixed61;$/;"	t	namespace:itpp
itpp::sfixed62	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<62, TC, SAT> sfixed62;$/;"	t	namespace:itpp
itpp::sfixed63	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<63, TC, SAT> sfixed63;$/;"	t	namespace:itpp
itpp::sfixed64	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<64, TC, SAT> sfixed64;$/;"	t	namespace:itpp
itpp::sfixed7	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<7, TC, SAT> sfixed7;$/;"	t	namespace:itpp
itpp::sfixed8	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<8, TC, SAT> sfixed8;$/;"	t	namespace:itpp
itpp::sfixed9	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<9, TC, SAT> sfixed9;$/;"	t	namespace:itpp
itpp::sgn	/usr/include/itpp/base/math/elem_math.h	/^inline double sgn(double x) { return sign(x); }$/;"	f	namespace:itpp	signature:(double x)
itpp::sgn	/usr/include/itpp/base/math/elem_math.h	/^inline mat sgn(const mat &x) { return apply_function<double>(sign, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::sgn	/usr/include/itpp/base/math/elem_math.h	/^inline vec sgn(const vec &x) { return apply_function<double>(sign, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::sgn_i	/usr/include/itpp/base/math/elem_math.h	/^inline imat sgn_i(const imat &x) { return apply_function<int>(sign_i, x); }$/;"	f	namespace:itpp	signature:(const imat &x)
itpp::sgn_i	/usr/include/itpp/base/math/elem_math.h	/^inline int sgn_i(int x) { return sign_i(x); }$/;"	f	namespace:itpp	signature:(int x)
itpp::sgn_i	/usr/include/itpp/base/math/elem_math.h	/^inline ivec sgn_i(const ivec &x) { return apply_function<int>(sign_i, x); }$/;"	f	namespace:itpp	signature:(const ivec &x)
itpp::short2mxArray	/usr/include/itpp/itmex.h	/^void short2mxArray(const short &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const short &in, mxArray *out)
itpp::sign	/usr/include/itpp/base/math/elem_math.h	/^inline double sign(double x)$/;"	f	namespace:itpp	signature:(double x)
itpp::sign	/usr/include/itpp/base/math/elem_math.h	/^inline mat sign(const mat &x) { return apply_function<double>(sign, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::sign	/usr/include/itpp/base/math/elem_math.h	/^inline vec sign(const vec &x) { return apply_function<double>(sign, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::sign_i	/usr/include/itpp/base/math/elem_math.h	/^inline imat sign_i(const imat &x) { return apply_function<int>(sign_i, x); }$/;"	f	namespace:itpp	signature:(const imat &x)
itpp::sign_i	/usr/include/itpp/base/math/elem_math.h	/^inline int sign_i(double x)$/;"	f	namespace:itpp	signature:(double x)
itpp::sign_i	/usr/include/itpp/base/math/elem_math.h	/^inline int sign_i(int x)$/;"	f	namespace:itpp	signature:(int x)
itpp::sign_i	/usr/include/itpp/base/math/elem_math.h	/^inline ivec sign_i(const ivec &x) { return apply_function<int>(sign_i, x); }$/;"	f	namespace:itpp	signature:(const ivec &x)
itpp::sin	/usr/include/itpp/base/math/trig_hyp.h	/^inline mat sin(const mat &x) { return apply_function<double>(std::sin, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::sin	/usr/include/itpp/base/math/trig_hyp.h	/^inline vec sin(const vec &x) { return apply_function<double>(std::sin, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::sinc	/usr/include/itpp/base/math/trig_hyp.h	/^inline double sinc(double x)$/;"	f	namespace:itpp	signature:(double x)
itpp::sinc	/usr/include/itpp/base/math/trig_hyp.h	/^inline mat sinc(const mat &x) { return apply_function<double>(sinc, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::sinc	/usr/include/itpp/base/math/trig_hyp.h	/^inline vec sinc(const vec &x) { return apply_function<double>(sinc, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::sinh	/usr/include/itpp/base/math/trig_hyp.h	/^inline mat sinh(const mat &x) { return apply_function<double>(std::sinh, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::sinh	/usr/include/itpp/base/math/trig_hyp.h	/^inline vec sinh(const vec &x) { return apply_function<double>(std::sinh, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::size	/usr/include/itpp/base/matfunc.h	/^int size(const Vec<T> &v) { return v.length(); }$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
itpp::skewness	/usr/include/itpp/stat/misc_stat.h	/^double skewness(const vec &x);$/;"	p	namespace:itpp	signature:(const vec &x)
itpp::smat	/usr/include/itpp/base/mat.h	/^typedef Mat<short int> smat;$/;"	t	namespace:itpp
itpp::smat2mxArray	/usr/include/itpp/itmex.h	/^void smat2mxArray(const smat &in, mxArray *out)$/;"	f	namespace:itpp	signature:(const smat &in, mxArray *out)
itpp::smat2mxArray	/usr/include/itpp/itmex.h	/^void smat2mxArray(const smat &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const smat &in, mxArray *out)
itpp::snd_read	/usr/include/itpp/srccode/audiofile.h	/^bool snd_read(const char *fname, vec &v);$/;"	p	namespace:itpp	signature:(const char *fname, vec &v)
itpp::snd_read	/usr/include/itpp/srccode/audiofile.h	/^bool snd_read(const char *fname, vec &v, int beg, int len);$/;"	p	namespace:itpp	signature:(const char *fname, vec &v, int beg, int len)
itpp::snd_write	/usr/include/itpp/srccode/audiofile.h	/^bool snd_write(const char *fname, const vec &v, int rate = 8000,$/;"	p	namespace:itpp	signature:(const char *fname, const vec &v, int rate = 8000, SND_Format::data_encoding e = SND_Format::enc_linear16)
itpp::sort	/usr/include/itpp/base/sort.h	/^void sort(Vec<T> &data, SORTING_METHOD method = INTROSORT)$/;"	f	namespace:itpp	signature:(Vec<T> &data, SORTING_METHOD method = INTROSORT)
itpp::sort_index	/usr/include/itpp/base/sort.h	/^ivec sort_index(const Vec<T> &data, SORTING_METHOD method = INTROSORT)$/;"	f	namespace:itpp	signature:(const Vec<T> &data, SORTING_METHOD method = INTROSORT)
itpp::sparse	/usr/include/itpp/base/smat.h	/^inline Sparse_Mat<T> sparse(const Mat<T> &m, T epsilon)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, T epsilon)
itpp::sparse	/usr/include/itpp/base/svec.h	/^inline Sparse_Vec<T> sparse(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
itpp::sparse	/usr/include/itpp/base/svec.h	/^inline Sparse_Vec<T> sparse(const Vec<T> &v, T epsilon)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, T epsilon)
itpp::sparse_cmat	/usr/include/itpp/base/smat.h	/^typedef Sparse_Mat<std::complex<double> > sparse_cmat;$/;"	t	namespace:itpp
itpp::sparse_cvec	/usr/include/itpp/base/svec.h	/^typedef Sparse_Vec<std::complex<double> > sparse_cvec;$/;"	t	namespace:itpp
itpp::sparse_imat	/usr/include/itpp/base/smat.h	/^typedef Sparse_Mat<int> sparse_imat;$/;"	t	namespace:itpp
itpp::sparse_ivec	/usr/include/itpp/base/svec.h	/^typedef Sparse_Vec<int> sparse_ivec;$/;"	t	namespace:itpp
itpp::sparse_mat	/usr/include/itpp/base/smat.h	/^typedef Sparse_Mat<double> sparse_mat;$/;"	t	namespace:itpp
itpp::sparse_vec	/usr/include/itpp/base/svec.h	/^typedef Sparse_Vec<double> sparse_vec;$/;"	t	namespace:itpp
itpp::spectrum	/usr/include/itpp/signal/sigfun.h	/^vec spectrum(const vec &v, const vec &w, int noverlap = 0);$/;"	p	namespace:itpp	signature:(const vec &v, const vec &w, int noverlap = 0)
itpp::spectrum	/usr/include/itpp/signal/sigfun.h	/^vec spectrum(const vec &v, int nfft = 256, int noverlap = 0);$/;"	p	namespace:itpp	signature:(const vec &v, int nfft = 256, int noverlap = 0)
itpp::sqr	/usr/include/itpp/base/math/elem_math.h	/^inline double sqr(const std::complex<double>& x)$/;"	f	namespace:itpp	signature:(const std::complex<double>& x)
itpp::sqr	/usr/include/itpp/base/math/elem_math.h	/^inline double sqr(double x) { return (x * x); }$/;"	f	namespace:itpp	signature:(double x)
itpp::sqr	/usr/include/itpp/base/math/elem_math.h	/^inline mat sqr(const mat &x) { return apply_function<double>(sqr, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::sqr	/usr/include/itpp/base/math/elem_math.h	/^inline vec sqr(const vec &x) { return apply_function<double>(sqr, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::sqr	/usr/include/itpp/base/math/elem_math.h	/^mat sqr(const cmat &x);$/;"	p	namespace:itpp	signature:(const cmat &x)
itpp::sqr	/usr/include/itpp/base/math/elem_math.h	/^vec sqr(const cvec &x);$/;"	p	namespace:itpp	signature:(const cvec &x)
itpp::sqrt	/usr/include/itpp/base/math/elem_math.h	/^inline mat sqrt(const mat &x) { return apply_function<double>(std::sqrt, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::sqrt	/usr/include/itpp/base/math/elem_math.h	/^inline vec sqrt(const vec &x) { return apply_function<double>(std::sqrt, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::sqrt_win	/usr/include/itpp/signal/window.h	/^vec sqrt_win(int n);$/;"	p	namespace:itpp	signature:(int n)
itpp::sqrtm	/usr/include/itpp/base/matfunc.h	/^cmat sqrtm(const cmat& A);$/;"	p	namespace:itpp	signature:(const cmat& A)
itpp::sqrtm	/usr/include/itpp/base/matfunc.h	/^cmat sqrtm(const mat& A);$/;"	p	namespace:itpp	signature:(const mat& A)
itpp::sqtrain	/usr/include/itpp/srccode/vqtrain.h	/^vec sqtrain(const vec &inDB, int SIZE);$/;"	p	namespace:itpp	signature:(const vec &inDB, int SIZE)
itpp::string2mxArray	/usr/include/itpp/itmex.h	/^void string2mxArray(const std::string &in, mxArray* &out)$/;"	f	namespace:itpp	signature:(const std::string &in, mxArray* &out)
itpp::string2mxArray	/usr/include/itpp/itmex.h	/^void string2mxArray(const std::string &in, mxArray* &out);$/;"	p	namespace:itpp	signature:(const std::string &in, mxArray* &out)
itpp::sub_m_v_vT	/usr/include/itpp/base/fastmath.h	/^void sub_m_v_vT(mat &m, const vec &v);$/;"	p	namespace:itpp	signature:(mat &m, const vec &v)
itpp::sub_v_vT_m	/usr/include/itpp/base/fastmath.h	/^void sub_v_vT_m(mat &m, const vec &v);$/;"	p	namespace:itpp	signature:(mat &m, const vec &v)
itpp::sufixed1	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<1, US, SAT> sufixed1;$/;"	t	namespace:itpp
itpp::sufixed10	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<10, US, SAT> sufixed10;$/;"	t	namespace:itpp
itpp::sufixed11	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<11, US, SAT> sufixed11;$/;"	t	namespace:itpp
itpp::sufixed12	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<12, US, SAT> sufixed12;$/;"	t	namespace:itpp
itpp::sufixed13	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<13, US, SAT> sufixed13;$/;"	t	namespace:itpp
itpp::sufixed14	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<14, US, SAT> sufixed14;$/;"	t	namespace:itpp
itpp::sufixed15	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<15, US, SAT> sufixed15;$/;"	t	namespace:itpp
itpp::sufixed16	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<16, US, SAT> sufixed16;$/;"	t	namespace:itpp
itpp::sufixed17	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<17, US, SAT> sufixed17;$/;"	t	namespace:itpp
itpp::sufixed18	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<18, US, SAT> sufixed18;$/;"	t	namespace:itpp
itpp::sufixed19	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<19, US, SAT> sufixed19;$/;"	t	namespace:itpp
itpp::sufixed2	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<2, US, SAT> sufixed2;$/;"	t	namespace:itpp
itpp::sufixed20	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<20, US, SAT> sufixed20;$/;"	t	namespace:itpp
itpp::sufixed21	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<21, US, SAT> sufixed21;$/;"	t	namespace:itpp
itpp::sufixed22	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<22, US, SAT> sufixed22;$/;"	t	namespace:itpp
itpp::sufixed23	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<23, US, SAT> sufixed23;$/;"	t	namespace:itpp
itpp::sufixed24	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<24, US, SAT> sufixed24;$/;"	t	namespace:itpp
itpp::sufixed25	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<25, US, SAT> sufixed25;$/;"	t	namespace:itpp
itpp::sufixed26	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<26, US, SAT> sufixed26;$/;"	t	namespace:itpp
itpp::sufixed27	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<27, US, SAT> sufixed27;$/;"	t	namespace:itpp
itpp::sufixed28	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<28, US, SAT> sufixed28;$/;"	t	namespace:itpp
itpp::sufixed29	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<29, US, SAT> sufixed29;$/;"	t	namespace:itpp
itpp::sufixed3	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<3, US, SAT> sufixed3;$/;"	t	namespace:itpp
itpp::sufixed30	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<30, US, SAT> sufixed30;$/;"	t	namespace:itpp
itpp::sufixed31	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<31, US, SAT> sufixed31;$/;"	t	namespace:itpp
itpp::sufixed32	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<32, US, SAT> sufixed32;$/;"	t	namespace:itpp
itpp::sufixed33	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<33, US, SAT> sufixed33;$/;"	t	namespace:itpp
itpp::sufixed34	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<34, US, SAT> sufixed34;$/;"	t	namespace:itpp
itpp::sufixed35	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<35, US, SAT> sufixed35;$/;"	t	namespace:itpp
itpp::sufixed36	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<36, US, SAT> sufixed36;$/;"	t	namespace:itpp
itpp::sufixed37	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<37, US, SAT> sufixed37;$/;"	t	namespace:itpp
itpp::sufixed38	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<38, US, SAT> sufixed38;$/;"	t	namespace:itpp
itpp::sufixed39	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<39, US, SAT> sufixed39;$/;"	t	namespace:itpp
itpp::sufixed4	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<4, US, SAT> sufixed4;$/;"	t	namespace:itpp
itpp::sufixed40	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<40, US, SAT> sufixed40;$/;"	t	namespace:itpp
itpp::sufixed41	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<41, US, SAT> sufixed41;$/;"	t	namespace:itpp
itpp::sufixed42	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<42, US, SAT> sufixed42;$/;"	t	namespace:itpp
itpp::sufixed43	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<43, US, SAT> sufixed43;$/;"	t	namespace:itpp
itpp::sufixed44	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<44, US, SAT> sufixed44;$/;"	t	namespace:itpp
itpp::sufixed45	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<45, US, SAT> sufixed45;$/;"	t	namespace:itpp
itpp::sufixed46	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<46, US, SAT> sufixed46;$/;"	t	namespace:itpp
itpp::sufixed47	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<47, US, SAT> sufixed47;$/;"	t	namespace:itpp
itpp::sufixed48	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<48, US, SAT> sufixed48;$/;"	t	namespace:itpp
itpp::sufixed49	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<49, US, SAT> sufixed49;$/;"	t	namespace:itpp
itpp::sufixed5	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<5, US, SAT> sufixed5;$/;"	t	namespace:itpp
itpp::sufixed50	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<50, US, SAT> sufixed50;$/;"	t	namespace:itpp
itpp::sufixed51	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<51, US, SAT> sufixed51;$/;"	t	namespace:itpp
itpp::sufixed52	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<52, US, SAT> sufixed52;$/;"	t	namespace:itpp
itpp::sufixed53	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<53, US, SAT> sufixed53;$/;"	t	namespace:itpp
itpp::sufixed54	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<54, US, SAT> sufixed54;$/;"	t	namespace:itpp
itpp::sufixed55	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<55, US, SAT> sufixed55;$/;"	t	namespace:itpp
itpp::sufixed56	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<56, US, SAT> sufixed56;$/;"	t	namespace:itpp
itpp::sufixed57	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<57, US, SAT> sufixed57;$/;"	t	namespace:itpp
itpp::sufixed58	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<58, US, SAT> sufixed58;$/;"	t	namespace:itpp
itpp::sufixed59	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<59, US, SAT> sufixed59;$/;"	t	namespace:itpp
itpp::sufixed6	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<6, US, SAT> sufixed6;$/;"	t	namespace:itpp
itpp::sufixed60	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<60, US, SAT> sufixed60;$/;"	t	namespace:itpp
itpp::sufixed61	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<61, US, SAT> sufixed61;$/;"	t	namespace:itpp
itpp::sufixed62	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<62, US, SAT> sufixed62;$/;"	t	namespace:itpp
itpp::sufixed63	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<63, US, SAT> sufixed63;$/;"	t	namespace:itpp
itpp::sufixed64	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<64, US, SAT> sufixed64;$/;"	t	namespace:itpp
itpp::sufixed7	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<7, US, SAT> sufixed7;$/;"	t	namespace:itpp
itpp::sufixed8	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<8, US, SAT> sufixed8;$/;"	t	namespace:itpp
itpp::sufixed9	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<9, US, SAT> sufixed9;$/;"	t	namespace:itpp
itpp::sum	/usr/include/itpp/base/matfunc.h	/^T sum(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
itpp::sum	/usr/include/itpp/base/matfunc.h	/^Vec<T> sum(const Mat<T> &m, int dim = 1)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, int dim = 1)
itpp::sum	/usr/include/itpp/base/matfunc.h	/^extern template bin sum(const bvec &v);$/;"	p	namespace:itpp	signature:(const bvec &v)
itpp::sum	/usr/include/itpp/base/matfunc.h	/^extern template bvec sum(const bmat &m, int dim);$/;"	p	namespace:itpp	signature:(const bmat &m, int dim)
itpp::sum	/usr/include/itpp/base/matfunc.h	/^extern template cvec sum(const cmat &m, int dim);$/;"	p	namespace:itpp	signature:(const cmat &m, int dim)
itpp::sum	/usr/include/itpp/base/matfunc.h	/^extern template double sum(const vec &v);$/;"	p	namespace:itpp	signature:(const vec &v)
itpp::sum	/usr/include/itpp/base/matfunc.h	/^extern template int sum(const ivec &v);$/;"	p	namespace:itpp	signature:(const ivec &v)
itpp::sum	/usr/include/itpp/base/matfunc.h	/^extern template ivec sum(const imat &m, int dim);$/;"	p	namespace:itpp	signature:(const imat &m, int dim)
itpp::sum	/usr/include/itpp/base/matfunc.h	/^extern template short sum(const svec &v);$/;"	p	namespace:itpp	signature:(const svec &v)
itpp::sum	/usr/include/itpp/base/matfunc.h	/^extern template std::complex<double> sum(const cvec &v);$/;"	p	namespace:itpp	signature:(const cvec &v)
itpp::sum	/usr/include/itpp/base/matfunc.h	/^extern template svec sum(const smat &m, int dim);$/;"	p	namespace:itpp	signature:(const smat &m, int dim)
itpp::sum	/usr/include/itpp/base/matfunc.h	/^extern template vec sum(const mat &m, int dim);$/;"	p	namespace:itpp	signature:(const mat &m, int dim)
itpp::sum_sqr	/usr/include/itpp/base/matfunc.h	/^T sum_sqr(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
itpp::sum_sqr	/usr/include/itpp/base/matfunc.h	/^Vec<T> sum_sqr(const Mat<T> &m, int dim = 1)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, int dim = 1)
itpp::sum_sqr	/usr/include/itpp/base/matfunc.h	/^extern template bin sum_sqr(const bvec &v);$/;"	p	namespace:itpp	signature:(const bvec &v)
itpp::sum_sqr	/usr/include/itpp/base/matfunc.h	/^extern template bvec sum_sqr(const bmat &m, int dim);$/;"	p	namespace:itpp	signature:(const bmat &m, int dim)
itpp::sum_sqr	/usr/include/itpp/base/matfunc.h	/^extern template cvec sum_sqr(const cmat &m, int dim);$/;"	p	namespace:itpp	signature:(const cmat &m, int dim)
itpp::sum_sqr	/usr/include/itpp/base/matfunc.h	/^extern template double sum_sqr(const vec &v);$/;"	p	namespace:itpp	signature:(const vec &v)
itpp::sum_sqr	/usr/include/itpp/base/matfunc.h	/^extern template int sum_sqr(const ivec &v);$/;"	p	namespace:itpp	signature:(const ivec &v)
itpp::sum_sqr	/usr/include/itpp/base/matfunc.h	/^extern template ivec sum_sqr(const imat &m, int dim);$/;"	p	namespace:itpp	signature:(const imat &m, int dim)
itpp::sum_sqr	/usr/include/itpp/base/matfunc.h	/^extern template short sum_sqr(const svec &v);$/;"	p	namespace:itpp	signature:(const svec &v)
itpp::sum_sqr	/usr/include/itpp/base/matfunc.h	/^extern template std::complex<double> sum_sqr(const cvec &v);$/;"	p	namespace:itpp	signature:(const cvec &v)
itpp::sum_sqr	/usr/include/itpp/base/matfunc.h	/^extern template svec sum_sqr(const smat &m, int dim);$/;"	p	namespace:itpp	signature:(const smat &m, int dim)
itpp::sum_sqr	/usr/include/itpp/base/matfunc.h	/^extern template vec sum_sqr(const mat & m, int dim);$/;"	p	namespace:itpp	signature:(const mat & m, int dim)
itpp::sumsum	/usr/include/itpp/base/matfunc.h	/^T sumsum(const Mat<T> &X)$/;"	f	namespace:itpp	signature:(const Mat<T> &X)
itpp::sumsum	/usr/include/itpp/base/matfunc.h	/^extern template bin sumsum(const bmat &X);$/;"	p	namespace:itpp	signature:(const bmat &X)
itpp::sumsum	/usr/include/itpp/base/matfunc.h	/^extern template double sumsum(const mat &X);$/;"	p	namespace:itpp	signature:(const mat &X)
itpp::sumsum	/usr/include/itpp/base/matfunc.h	/^extern template int sumsum(const imat &X);$/;"	p	namespace:itpp	signature:(const imat &X)
itpp::sumsum	/usr/include/itpp/base/matfunc.h	/^extern template short sumsum(const smat &X);$/;"	p	namespace:itpp	signature:(const smat &X)
itpp::sumsum	/usr/include/itpp/base/matfunc.h	/^extern template std::complex<double> sumsum(const cmat &X);$/;"	p	namespace:itpp	signature:(const cmat &X)
itpp::svd	/usr/include/itpp/base/algebra/svd.h	/^bool svd(const cmat &A, cmat &U, vec &s, cmat &V);$/;"	p	namespace:itpp	signature:(const cmat &A, cmat &U, vec &s, cmat &V)
itpp::svd	/usr/include/itpp/base/algebra/svd.h	/^bool svd(const cmat &A, vec &s);$/;"	p	namespace:itpp	signature:(const cmat &A, vec &s)
itpp::svd	/usr/include/itpp/base/algebra/svd.h	/^bool svd(const mat &A, mat &U, vec &s, mat &V);$/;"	p	namespace:itpp	signature:(const mat &A, mat &U, vec &s, mat &V)
itpp::svd	/usr/include/itpp/base/algebra/svd.h	/^bool svd(const mat &A, vec &s);$/;"	p	namespace:itpp	signature:(const mat &A, vec &s)
itpp::svd	/usr/include/itpp/base/algebra/svd.h	/^vec svd(const cmat &A);$/;"	p	namespace:itpp	signature:(const cmat &A)
itpp::svd	/usr/include/itpp/base/algebra/svd.h	/^vec svd(const mat &A);$/;"	p	namespace:itpp	signature:(const mat &A)
itpp::svec	/usr/include/itpp/base/vec.h	/^typedef Vec<short int> svec;$/;"	t	namespace:itpp
itpp::svec2mxArray	/usr/include/itpp/itmex.h	/^void svec2mxArray(const svec &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const svec &in, mxArray *out)
itpp::swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, bin *x, bin *y) { for (int i = 0; i < n; i++) std::swap(x[i], y[i]); }$/;"	f	namespace:itpp	signature:(const int n, bin *x, bin *y)
itpp::swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, bin *x, const int incx, bin *y, const int incy) { for (int i = 0; i < n; i++) std::swap(x[i*incx], y[i*incy]); }$/;"	f	namespace:itpp	signature:(const int n, bin *x, const int incx, bin *y, const int incy)
itpp::swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, double *x, const int incx, double *y, const int incy) { for (int i = 0; i < n; i++) std::swap(x[i*incx], y[i*incy]); }$/;"	f	namespace:itpp	signature:(const int n, double *x, const int incx, double *y, const int incy)
itpp::swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, double *x, const int incx, double *y,$/;"	f	namespace:itpp	signature:(const int n, double *x, const int incx, double *y, const int incy)
itpp::swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, double *x, double *y) { for (int i = 0; i < n; i++) std::swap(x[i], y[i]); }$/;"	f	namespace:itpp	signature:(const int n, double *x, double *y)
itpp::swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, double *x, double *y)$/;"	f	namespace:itpp	signature:(const int n, double *x, double *y)
itpp::swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, float *x, const int incx, float *y, const int incy) { for (int i = 0; i < n; i++) std::swap(x[i*incx], y[i*incy]); }$/;"	f	namespace:itpp	signature:(const int n, float *x, const int incx, float *y, const int incy)
itpp::swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, float *x, float *y) { for (int i = 0; i < n; i++) std::swap(x[i], y[i]); }$/;"	f	namespace:itpp	signature:(const int n, float *x, float *y)
itpp::swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, int *x, const int incx, int *y, const int incy) { for (int i = 0; i < n; i++) std::swap(x[i*incx], y[i*incy]); }$/;"	f	namespace:itpp	signature:(const int n, int *x, const int incx, int *y, const int incy)
itpp::swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, int *x, int *y) { for (int i = 0; i < n; i++) std::swap(x[i], y[i]); }$/;"	f	namespace:itpp	signature:(const int n, int *x, int *y)
itpp::swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, short *x, const int incx, short *y, const int incy) { for (int i = 0; i < n; i++) std::swap(x[i*incx], y[i*incy]); }$/;"	f	namespace:itpp	signature:(const int n, short *x, const int incx, short *y, const int incy)
itpp::swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, short *x, short *y) { for (int i = 0; i < n; i++) std::swap(x[i], y[i]); }$/;"	f	namespace:itpp	signature:(const int n, short *x, short *y)
itpp::swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, std::complex<double> *x, const int incx, std::complex<double> *y, const int incy) { for (int i = 0; i < n; i++) std::swap(x[i*incx], y[i*incy]); }$/;"	f	namespace:itpp	signature:(const int n, std::complex<double> *x, const int incx, std::complex<double> *y, const int incy)
itpp::swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, std::complex<double> *x, const int incx,$/;"	f	namespace:itpp	signature:(const int n, std::complex<double> *x, const int incx, std::complex<double> *y, const int incy)
itpp::swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, std::complex<double> *x, std::complex<double> *y) { for (int i = 0; i < n; i++) std::swap(x[i], y[i]); }$/;"	f	namespace:itpp	signature:(const int n, std::complex<double> *x, std::complex<double> *y)
itpp::swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, std::complex<double> *x,$/;"	f	namespace:itpp	signature:(const int n, std::complex<double> *x, std::complex<double> *y)
itpp::swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, std::complex<float> *x, const int incx, std::complex<float> *y, const int incy) { for (int i = 0; i < n; i++) std::swap(x[i*incx], y[i*incy]); }$/;"	f	namespace:itpp	signature:(const int n, std::complex<float> *x, const int incx, std::complex<float> *y, const int incy)
itpp::swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, std::complex<float> *x, std::complex<float> *y) { for (int i = 0; i < n; i++) std::swap(x[i], y[i]); }$/;"	f	namespace:itpp	signature:(const int n, std::complex<float> *x, std::complex<float> *y)
itpp::swap_vector	/usr/include/itpp/base/copy_vector.h	/^void swap_vector(const int n, T *x, T *y)$/;"	f	namespace:itpp	signature:(const int n, T *x, T *y)
itpp::swap_vector	/usr/include/itpp/base/copy_vector.h	/^void swap_vector(const int n, T *x, const int incx, T *y, const int incy)$/;"	f	namespace:itpp	signature:(const int n, T *x, const int incx, T *y, const int incy)
itpp::tan	/usr/include/itpp/base/math/trig_hyp.h	/^inline mat tan(const mat &x) { return apply_function<double>(std::tan, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::tan	/usr/include/itpp/base/math/trig_hyp.h	/^inline vec tan(const vec &x) { return apply_function<double>(std::tan, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::tanh	/usr/include/itpp/base/math/trig_hyp.h	/^inline mat tanh(const mat &x) { return apply_function<double>(std::tanh, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::tanh	/usr/include/itpp/base/math/trig_hyp.h	/^inline vec tanh(const vec &x) { return apply_function<double>(std::tanh, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::tic	/usr/include/itpp/base/timing.h	/^void tic();$/;"	p	namespace:itpp	signature:()
itpp::to	/usr/include/itpp/fixed/fix_functions.h	/^Array<typename ConvertU2T<T, U>::result> to(const Array<U> &real, const Array<U> &imag)$/;"	f	namespace:itpp	signature:(const Array<U> &real, const Array<U> &imag)
itpp::to	/usr/include/itpp/fixed/fix_functions.h	/^Array<typename ConvertU2T<T, U>::result> to(const Array<U> &x)$/;"	f	namespace:itpp	signature:(const Array<U> &x)
itpp::to	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline cfixmat to<CFix>(const cfixmat &x) {return x;}$/;"	f	namespace:itpp	signature:(const cfixmat &x)
itpp::to	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline cfixvec to<CFix>(const cfixvec &x) {return x;}$/;"	f	namespace:itpp	signature:(const cfixvec &x)
itpp::to	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline cmat to<std::complex<double> >(const cmat &x) {return x;}$/;"	f	namespace:itpp	signature:(const cmat &x)
itpp::to	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline cvec to<std::complex<double> >(const cvec &x) {return x;}$/;"	f	namespace:itpp	signature:(const cvec &x)
itpp::to	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline fixmat to<Fix>(const fixmat &x) {return x;}$/;"	f	namespace:itpp	signature:(const fixmat &x)
itpp::to	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline fixvec to<Fix>(const fixvec &x) {return x;}$/;"	f	namespace:itpp	signature:(const fixvec &x)
itpp::to	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline mat to<double>(const mat &x) {return x;}$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::to	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline vec to<double>(const vec &x) {return x;}$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::to	/usr/include/itpp/fixed/fix_functions.h	/^template<class T, class U> Mat<T> to(const Mat<U> &real, const Mat<U> &imag)$/;"	f	namespace:itpp	signature:(const Mat<U> &real, const Mat<U> &imag)
itpp::to	/usr/include/itpp/fixed/fix_functions.h	/^template<class T, class U> Mat<T> to(const Mat<U> &x)$/;"	f	namespace:itpp	signature:(const Mat<U> &x)
itpp::to	/usr/include/itpp/fixed/fix_functions.h	/^template<class T, class U> Vec<T> to(const Vec<U> &real, const Vec<U> &imag)$/;"	f	namespace:itpp	signature:(const Vec<U> &real, const Vec<U> &imag)
itpp::to	/usr/include/itpp/fixed/fix_functions.h	/^template<class T, class U> Vec<T> to(const Vec<U> &x)$/;"	f	namespace:itpp	signature:(const Vec<U> &x)
itpp::to	/usr/include/itpp/fixed/fix_functions.h	/^template<class T> inline T to(const CFix &x) {return T(x);}$/;"	f	namespace:itpp	signature:(const CFix &x)
itpp::to	/usr/include/itpp/fixed/fix_functions.h	/^template<class T> inline T to(const Fix &real, const Fix &imag) {return T(real, imag);}$/;"	f	namespace:itpp	signature:(const Fix &real, const Fix &imag)
itpp::to	/usr/include/itpp/fixed/fix_functions.h	/^template<class T> inline T to(const Fix &x) {return T(x);}$/;"	f	namespace:itpp	signature:(const Fix &x)
itpp::to	/usr/include/itpp/fixed/fix_functions.h	/^template<class T> inline T to(const std::complex<double> &x) {return T(x);}$/;"	f	namespace:itpp	signature:(const std::complex<double> &x)
itpp::to	/usr/include/itpp/fixed/fix_functions.h	/^template<class T> inline T to(double real, double imag) {return T(real, imag);}$/;"	f	namespace:itpp	signature:(double real, double imag)
itpp::to	/usr/include/itpp/fixed/fix_functions.h	/^template<class T> inline T to(double x) {return T(x);}$/;"	f	namespace:itpp	signature:(double x)
itpp::to_bmat	/usr/include/itpp/base/converters.h	/^bmat to_bmat(const Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
itpp::to_bmat	/usr/include/itpp/base/converters.h	/^extern template bmat to_bmat(const imat &m);$/;"	p	namespace:itpp	signature:(const imat &m)
itpp::to_bmat	/usr/include/itpp/base/converters.h	/^extern template bmat to_bmat(const smat &m);$/;"	p	namespace:itpp	signature:(const smat &m)
itpp::to_bvec	/usr/include/itpp/base/converters.h	/^bvec to_bvec(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
itpp::to_bvec	/usr/include/itpp/base/converters.h	/^extern template bvec to_bvec(const ivec &v);$/;"	p	namespace:itpp	signature:(const ivec &v)
itpp::to_bvec	/usr/include/itpp/base/converters.h	/^extern template bvec to_bvec(const svec &v);$/;"	p	namespace:itpp	signature:(const svec &v)
itpp::to_cmat	/usr/include/itpp/base/converters.h	/^cmat to_cmat(const Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
itpp::to_cmat	/usr/include/itpp/base/converters.h	/^cmat to_cmat(const Mat<T> &real, const Mat<T> &imag)$/;"	f	namespace:itpp	signature:(const Mat<T> &real, const Mat<T> &imag)
itpp::to_cmat	/usr/include/itpp/base/converters.h	/^cmat to_cmat(const cmat& m)$/;"	f	namespace:itpp	signature:(const cmat& m)
itpp::to_cmat	/usr/include/itpp/base/converters.h	/^extern template cmat to_cmat(const bmat &m);$/;"	p	namespace:itpp	signature:(const bmat &m)
itpp::to_cmat	/usr/include/itpp/base/converters.h	/^extern template cmat to_cmat(const bmat &real, const bmat &imag);$/;"	p	namespace:itpp	signature:(const bmat &real, const bmat &imag)
itpp::to_cmat	/usr/include/itpp/base/converters.h	/^extern template cmat to_cmat(const imat &m);$/;"	p	namespace:itpp	signature:(const imat &m)
itpp::to_cmat	/usr/include/itpp/base/converters.h	/^extern template cmat to_cmat(const imat &real, const imat &imag);$/;"	p	namespace:itpp	signature:(const imat &real, const imat &imag)
itpp::to_cmat	/usr/include/itpp/base/converters.h	/^extern template cmat to_cmat(const mat &m);$/;"	p	namespace:itpp	signature:(const mat &m)
itpp::to_cmat	/usr/include/itpp/base/converters.h	/^extern template cmat to_cmat(const mat &real, const mat &imag);$/;"	p	namespace:itpp	signature:(const mat &real, const mat &imag)
itpp::to_cmat	/usr/include/itpp/base/converters.h	/^extern template cmat to_cmat(const smat &m);$/;"	p	namespace:itpp	signature:(const smat &m)
itpp::to_cmat	/usr/include/itpp/base/converters.h	/^extern template cmat to_cmat(const smat &real, const smat &imag);$/;"	p	namespace:itpp	signature:(const smat &real, const smat &imag)
itpp::to_cmat	/usr/include/itpp/fixed/fix_functions.h	/^cmat to_cmat(const cfixmat &m);$/;"	p	namespace:itpp	signature:(const cfixmat &m)
itpp::to_cvec	/usr/include/itpp/base/converters.h	/^cvec to_cvec(const Vec<T> &real, const Vec<T> &imag)$/;"	f	namespace:itpp	signature:(const Vec<T> &real, const Vec<T> &imag)
itpp::to_cvec	/usr/include/itpp/base/converters.h	/^cvec to_cvec(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
itpp::to_cvec	/usr/include/itpp/base/converters.h	/^cvec to_cvec(const cvec& v)$/;"	f	namespace:itpp	signature:(const cvec& v)
itpp::to_cvec	/usr/include/itpp/base/converters.h	/^cvec to_cvec(double real, double imag);$/;"	p	namespace:itpp	signature:(double real, double imag)
itpp::to_cvec	/usr/include/itpp/base/converters.h	/^extern template cvec to_cvec(const bvec &real, const bvec &imag);$/;"	p	namespace:itpp	signature:(const bvec &real, const bvec &imag)
itpp::to_cvec	/usr/include/itpp/base/converters.h	/^extern template cvec to_cvec(const bvec &v);$/;"	p	namespace:itpp	signature:(const bvec &v)
itpp::to_cvec	/usr/include/itpp/base/converters.h	/^extern template cvec to_cvec(const ivec &real, const ivec &imag);$/;"	p	namespace:itpp	signature:(const ivec &real, const ivec &imag)
itpp::to_cvec	/usr/include/itpp/base/converters.h	/^extern template cvec to_cvec(const ivec &v);$/;"	p	namespace:itpp	signature:(const ivec &v)
itpp::to_cvec	/usr/include/itpp/base/converters.h	/^extern template cvec to_cvec(const svec &real, const svec &imag);$/;"	p	namespace:itpp	signature:(const svec &real, const svec &imag)
itpp::to_cvec	/usr/include/itpp/base/converters.h	/^extern template cvec to_cvec(const svec &v);$/;"	p	namespace:itpp	signature:(const svec &v)
itpp::to_cvec	/usr/include/itpp/base/converters.h	/^extern template cvec to_cvec(const vec &real, const vec &imag);$/;"	p	namespace:itpp	signature:(const vec &real, const vec &imag)
itpp::to_cvec	/usr/include/itpp/base/converters.h	/^extern template cvec to_cvec(const vec &v);$/;"	p	namespace:itpp	signature:(const vec &v)
itpp::to_cvec	/usr/include/itpp/fixed/fix_functions.h	/^cvec to_cvec(const cfixvec &v);$/;"	p	namespace:itpp	signature:(const cfixvec &v)
itpp::to_imat	/usr/include/itpp/base/converters.h	/^extern template imat to_imat(const bmat &m);$/;"	p	namespace:itpp	signature:(const bmat &m)
itpp::to_imat	/usr/include/itpp/base/converters.h	/^extern template imat to_imat(const mat &m);$/;"	p	namespace:itpp	signature:(const mat &m)
itpp::to_imat	/usr/include/itpp/base/converters.h	/^extern template imat to_imat(const smat &m);$/;"	p	namespace:itpp	signature:(const smat &m)
itpp::to_imat	/usr/include/itpp/base/converters.h	/^imat to_imat(const Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
itpp::to_ivec	/usr/include/itpp/base/converters.h	/^extern template ivec to_ivec(const bvec &v);$/;"	p	namespace:itpp	signature:(const bvec &v)
itpp::to_ivec	/usr/include/itpp/base/converters.h	/^extern template ivec to_ivec(const svec &v);$/;"	p	namespace:itpp	signature:(const svec &v)
itpp::to_ivec	/usr/include/itpp/base/converters.h	/^extern template ivec to_ivec(const vec &v);$/;"	p	namespace:itpp	signature:(const vec &v)
itpp::to_ivec	/usr/include/itpp/base/converters.h	/^ivec to_ivec(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
itpp::to_ivec	/usr/include/itpp/base/converters.h	/^ivec to_ivec(int s);$/;"	p	namespace:itpp	signature:(int s)
itpp::to_mat	/usr/include/itpp/base/converters.h	/^extern template mat to_mat(const bmat &m);$/;"	p	namespace:itpp	signature:(const bmat &m)
itpp::to_mat	/usr/include/itpp/base/converters.h	/^extern template mat to_mat(const imat &m);$/;"	p	namespace:itpp	signature:(const imat &m)
itpp::to_mat	/usr/include/itpp/base/converters.h	/^extern template mat to_mat(const smat &m);$/;"	p	namespace:itpp	signature:(const smat &m)
itpp::to_mat	/usr/include/itpp/base/converters.h	/^mat to_mat(const Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
itpp::to_mat	/usr/include/itpp/fixed/fix_functions.h	/^mat to_mat(const fixmat &m);$/;"	p	namespace:itpp	signature:(const fixmat &m)
itpp::to_smat	/usr/include/itpp/base/converters.h	/^extern template smat to_smat(const bmat &m);$/;"	p	namespace:itpp	signature:(const bmat &m)
itpp::to_smat	/usr/include/itpp/base/converters.h	/^extern template smat to_smat(const imat &m);$/;"	p	namespace:itpp	signature:(const imat &m)
itpp::to_smat	/usr/include/itpp/base/converters.h	/^extern template smat to_smat(const mat &m);$/;"	p	namespace:itpp	signature:(const mat &m)
itpp::to_smat	/usr/include/itpp/base/converters.h	/^smat to_smat(const Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
itpp::to_str	/usr/include/itpp/base/converters.h	/^std::string to_str(const T &i)$/;"	f	namespace:itpp	signature:(const T &i)
itpp::to_str	/usr/include/itpp/base/converters.h	/^std::string to_str(const T &i);$/;"	p	namespace:itpp	signature:(const T &i)
itpp::to_str	/usr/include/itpp/base/converters.h	/^std::string to_str(const double &i, const int precision);$/;"	p	namespace:itpp	signature:(const double &i, const int precision)
itpp::to_svec	/usr/include/itpp/base/converters.h	/^extern template svec to_svec(const bvec &v);$/;"	p	namespace:itpp	signature:(const bvec &v)
itpp::to_svec	/usr/include/itpp/base/converters.h	/^extern template svec to_svec(const ivec &v);$/;"	p	namespace:itpp	signature:(const ivec &v)
itpp::to_svec	/usr/include/itpp/base/converters.h	/^extern template svec to_svec(const vec &v);$/;"	p	namespace:itpp	signature:(const vec &v)
itpp::to_svec	/usr/include/itpp/base/converters.h	/^svec to_svec(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
itpp::to_vec	/usr/include/itpp/base/converters.h	/^extern template vec to_vec(const bvec &v);$/;"	p	namespace:itpp	signature:(const bvec &v)
itpp::to_vec	/usr/include/itpp/base/converters.h	/^extern template vec to_vec(const ivec &v);$/;"	p	namespace:itpp	signature:(const ivec &v)
itpp::to_vec	/usr/include/itpp/base/converters.h	/^extern template vec to_vec(const svec &v);$/;"	p	namespace:itpp	signature:(const svec &v)
itpp::to_vec	/usr/include/itpp/base/converters.h	/^vec to_vec(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
itpp::to_vec	/usr/include/itpp/base/converters.h	/^vec to_vec(double s);$/;"	p	namespace:itpp	signature:(double s)
itpp::to_vec	/usr/include/itpp/fixed/fix_functions.h	/^vec to_vec(const fixvec &v);$/;"	p	namespace:itpp	signature:(const fixvec &v)
itpp::toc	/usr/include/itpp/base/timing.h	/^double toc();$/;"	p	namespace:itpp	signature:()
itpp::toc_print	/usr/include/itpp/base/timing.h	/^void toc_print();$/;"	p	namespace:itpp	signature:()
itpp::toeplitz	/usr/include/itpp/base/specmat.h	/^const Mat<Num_T> toeplitz(const Vec<Num_T> &c)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &c)
itpp::toeplitz	/usr/include/itpp/base/specmat.h	/^const Mat<Num_T> toeplitz(const Vec<Num_T> &c, const Vec<Num_T> &r)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &c, const Vec<Num_T> &r)
itpp::toeplitz	/usr/include/itpp/base/specmat.h	/^const cmat toeplitz(const cvec &c);$/;"	p	namespace:itpp	signature:(const cvec &c)
itpp::trace	/usr/include/itpp/base/matfunc.h	/^T trace(const Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
itpp::trace	/usr/include/itpp/base/matfunc.h	/^extern template bin trace(const bmat &in);$/;"	p	namespace:itpp	signature:(const bmat &in)
itpp::trace	/usr/include/itpp/base/matfunc.h	/^extern template double trace(const mat &in);$/;"	p	namespace:itpp	signature:(const mat &in)
itpp::trace	/usr/include/itpp/base/matfunc.h	/^extern template int trace(const imat &in);$/;"	p	namespace:itpp	signature:(const imat &in)
itpp::trace	/usr/include/itpp/base/matfunc.h	/^extern template short trace(const smat &in);$/;"	p	namespace:itpp	signature:(const smat &in)
itpp::trace	/usr/include/itpp/base/matfunc.h	/^extern template std::complex<double> trace(const cmat &in);$/;"	p	namespace:itpp	signature:(const cmat &in)
itpp::trans_mult	/usr/include/itpp/base/smat.h	/^Mat<T> trans_mult(const Sparse_Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Sparse_Mat<T> &m)
itpp::trans_mult	/usr/include/itpp/base/smat.h	/^Mat<T> trans_mult(const Sparse_Mat<T> &m);$/;"	p	namespace:itpp	signature:(const Sparse_Mat<T> &m)
itpp::trans_mult	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> trans_mult(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)$/;"	f	namespace:itpp	signature:(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)
itpp::trans_mult	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> trans_mult(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2);$/;"	p	namespace:itpp	signature:(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)
itpp::trans_mult	/usr/include/itpp/base/smat.h	/^Vec<T> trans_mult(const Sparse_Mat<T> &m, const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Sparse_Mat<T> &m, const Vec<T> &v)
itpp::trans_mult	/usr/include/itpp/base/smat.h	/^Vec<T> trans_mult(const Sparse_Mat<T> &m, const Vec<T> &v);$/;"	p	namespace:itpp	signature:(const Sparse_Mat<T> &m, const Vec<T> &v)
itpp::trans_mult	/usr/include/itpp/base/smat.h	/^extern template cmat trans_mult(const sparse_cmat &);$/;"	p	namespace:itpp	signature:(const sparse_cmat &)
itpp::trans_mult	/usr/include/itpp/base/smat.h	/^extern template cvec trans_mult(const sparse_cmat &, const cvec &);$/;"	p	namespace:itpp	signature:(const sparse_cmat &, const cvec &)
itpp::trans_mult	/usr/include/itpp/base/smat.h	/^extern template imat trans_mult(const sparse_imat &);$/;"	p	namespace:itpp	signature:(const sparse_imat &)
itpp::trans_mult	/usr/include/itpp/base/smat.h	/^extern template ivec trans_mult(const sparse_imat &, const ivec &);$/;"	p	namespace:itpp	signature:(const sparse_imat &, const ivec &)
itpp::trans_mult	/usr/include/itpp/base/smat.h	/^extern template mat trans_mult(const sparse_mat &);$/;"	p	namespace:itpp	signature:(const sparse_mat &)
itpp::trans_mult	/usr/include/itpp/base/smat.h	/^extern template sparse_cmat trans_mult(const sparse_cmat &, const sparse_cmat &);$/;"	p	namespace:itpp	signature:(const sparse_cmat &, const sparse_cmat &)
itpp::trans_mult	/usr/include/itpp/base/smat.h	/^extern template sparse_imat trans_mult(const sparse_imat &, const sparse_imat &);$/;"	p	namespace:itpp	signature:(const sparse_imat &, const sparse_imat &)
itpp::trans_mult	/usr/include/itpp/base/smat.h	/^extern template sparse_mat trans_mult(const sparse_mat &, const sparse_mat &);$/;"	p	namespace:itpp	signature:(const sparse_mat &, const sparse_mat &)
itpp::trans_mult	/usr/include/itpp/base/smat.h	/^extern template vec trans_mult(const sparse_mat &, const vec &);$/;"	p	namespace:itpp	signature:(const sparse_mat &, const vec &)
itpp::trans_mult_s	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> trans_mult_s(const Sparse_Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Sparse_Mat<T> &m)
itpp::trans_mult_s	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> trans_mult_s(const Sparse_Mat<T> &m);$/;"	p	namespace:itpp	signature:(const Sparse_Mat<T> &m)
itpp::trans_mult_s	/usr/include/itpp/base/smat.h	/^extern template sparse_cmat trans_mult_s(const sparse_cmat &);$/;"	p	namespace:itpp	signature:(const sparse_cmat &)
itpp::trans_mult_s	/usr/include/itpp/base/smat.h	/^extern template sparse_imat trans_mult_s(const sparse_imat &);$/;"	p	namespace:itpp	signature:(const sparse_imat &)
itpp::trans_mult_s	/usr/include/itpp/base/smat.h	/^extern template sparse_mat trans_mult_s(const sparse_mat &);$/;"	p	namespace:itpp	signature:(const sparse_mat &)
itpp::transpose	/usr/include/itpp/base/matfunc.h	/^Mat<T> transpose(const Mat<T> &m) { return m.T(); }$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
itpp::transpose	/usr/include/itpp/base/matfunc.h	/^extern template bmat transpose(const bmat &m);$/;"	p	namespace:itpp	signature:(const bmat &m)
itpp::transpose	/usr/include/itpp/base/matfunc.h	/^extern template cmat transpose(const cmat &m);$/;"	p	namespace:itpp	signature:(const cmat &m)
itpp::transpose	/usr/include/itpp/base/matfunc.h	/^extern template imat transpose(const imat &m);$/;"	p	namespace:itpp	signature:(const imat &m)
itpp::transpose	/usr/include/itpp/base/matfunc.h	/^extern template mat transpose(const mat &m);$/;"	p	namespace:itpp	signature:(const mat &m)
itpp::transpose	/usr/include/itpp/base/matfunc.h	/^extern template smat transpose(const smat &m);$/;"	p	namespace:itpp	signature:(const smat &m)
itpp::transpose	/usr/include/itpp/base/matfunc.h	/^extern template void transpose(const bmat &m, bmat &out);$/;"	p	namespace:itpp	signature:(const bmat &m, bmat &out)
itpp::transpose	/usr/include/itpp/base/matfunc.h	/^extern template void transpose(const cmat &m, cmat &out);$/;"	p	namespace:itpp	signature:(const cmat &m, cmat &out)
itpp::transpose	/usr/include/itpp/base/matfunc.h	/^extern template void transpose(const imat &m, imat &out);$/;"	p	namespace:itpp	signature:(const imat &m, imat &out)
itpp::transpose	/usr/include/itpp/base/matfunc.h	/^extern template void transpose(const mat &m, mat &out);$/;"	p	namespace:itpp	signature:(const mat &m, mat &out)
itpp::transpose	/usr/include/itpp/base/matfunc.h	/^extern template void transpose(const smat &m, smat &out);$/;"	p	namespace:itpp	signature:(const smat &m, smat &out)
itpp::transpose	/usr/include/itpp/base/matfunc.h	/^void transpose(const Mat<T> &m, Mat<T> &out) { out = m.T(); }$/;"	f	namespace:itpp	signature:(const Mat<T> &m, Mat<T> &out)
itpp::transpose	/usr/include/itpp/base/smat.h	/^inline Sparse_Mat<T> transpose(const Sparse_Mat<T> &s)$/;"	f	namespace:itpp	signature:(const Sparse_Mat<T> &s)
itpp::triang	/usr/include/itpp/signal/window.h	/^vec triang(int n);$/;"	p	namespace:itpp	signature:(int n)
itpp::tridiag	/usr/include/itpp/base/matfunc.h	/^Mat<T> tridiag(const Vec<T> &main, const Vec<T> &sup, const Vec<T> &sub)$/;"	f	namespace:itpp	signature:(const Vec<T> &main, const Vec<T> &sup, const Vec<T> &sub)
itpp::tridiag	/usr/include/itpp/base/matfunc.h	/^extern template cmat tridiag(const cvec &main, const cvec &, const cvec &);$/;"	p	namespace:itpp	signature:(const cvec &main, const cvec &, const cvec &)
itpp::tridiag	/usr/include/itpp/base/matfunc.h	/^extern template mat tridiag(const vec &main, const vec &, const vec &);$/;"	p	namespace:itpp	signature:(const vec &main, const vec &, const vec &)
itpp::tridiag	/usr/include/itpp/base/matfunc.h	/^extern template void tridiag(const cmat &m, cvec &, cvec &, cvec &);$/;"	p	namespace:itpp	signature:(const cmat &m, cvec &, cvec &, cvec &)
itpp::tridiag	/usr/include/itpp/base/matfunc.h	/^extern template void tridiag(const cvec &main, const cvec &, const cvec &, cmat &);$/;"	p	namespace:itpp	signature:(const cvec &main, const cvec &, const cvec &, cmat &)
itpp::tridiag	/usr/include/itpp/base/matfunc.h	/^extern template void tridiag(const mat &m, vec &, vec &, vec &);$/;"	p	namespace:itpp	signature:(const mat &m, vec &, vec &, vec &)
itpp::tridiag	/usr/include/itpp/base/matfunc.h	/^extern template void tridiag(const vec &main, const vec &, const vec &, mat &);$/;"	p	namespace:itpp	signature:(const vec &main, const vec &, const vec &, mat &)
itpp::tridiag	/usr/include/itpp/base/matfunc.h	/^void tridiag(const Mat<T> &m, Vec<T> &main, Vec<T> &sup, Vec<T> &sub)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, Vec<T> &main, Vec<T> &sup, Vec<T> &sub)
itpp::tridiag	/usr/include/itpp/base/matfunc.h	/^void tridiag(const Vec<T> &main, const Vec<T> &sup, const Vec<T> &sub, Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Vec<T> &main, const Vec<T> &sup, const Vec<T> &sub, Mat<T> &m)
itpp::trunc_exp	/usr/include/itpp/base/math/log_exp.h	/^inline double trunc_exp(double x)$/;"	f	namespace:itpp	signature:(double x)
itpp::trunc_log	/usr/include/itpp/base/math/log_exp.h	/^inline double trunc_log(double x)$/;"	f	namespace:itpp	signature:(double x)
itpp::ufixed1	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<1, US, WRAP> ufixed1;$/;"	t	namespace:itpp
itpp::ufixed10	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<10, US, WRAP> ufixed10;$/;"	t	namespace:itpp
itpp::ufixed11	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<11, US, WRAP> ufixed11;$/;"	t	namespace:itpp
itpp::ufixed12	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<12, US, WRAP> ufixed12;$/;"	t	namespace:itpp
itpp::ufixed13	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<13, US, WRAP> ufixed13;$/;"	t	namespace:itpp
itpp::ufixed14	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<14, US, WRAP> ufixed14;$/;"	t	namespace:itpp
itpp::ufixed15	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<15, US, WRAP> ufixed15;$/;"	t	namespace:itpp
itpp::ufixed16	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<16, US, WRAP> ufixed16;$/;"	t	namespace:itpp
itpp::ufixed17	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<17, US, WRAP> ufixed17;$/;"	t	namespace:itpp
itpp::ufixed18	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<18, US, WRAP> ufixed18;$/;"	t	namespace:itpp
itpp::ufixed19	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<19, US, WRAP> ufixed19;$/;"	t	namespace:itpp
itpp::ufixed2	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<2, US, WRAP> ufixed2;$/;"	t	namespace:itpp
itpp::ufixed20	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<20, US, WRAP> ufixed20;$/;"	t	namespace:itpp
itpp::ufixed21	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<21, US, WRAP> ufixed21;$/;"	t	namespace:itpp
itpp::ufixed22	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<22, US, WRAP> ufixed22;$/;"	t	namespace:itpp
itpp::ufixed23	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<23, US, WRAP> ufixed23;$/;"	t	namespace:itpp
itpp::ufixed24	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<24, US, WRAP> ufixed24;$/;"	t	namespace:itpp
itpp::ufixed25	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<25, US, WRAP> ufixed25;$/;"	t	namespace:itpp
itpp::ufixed26	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<26, US, WRAP> ufixed26;$/;"	t	namespace:itpp
itpp::ufixed27	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<27, US, WRAP> ufixed27;$/;"	t	namespace:itpp
itpp::ufixed28	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<28, US, WRAP> ufixed28;$/;"	t	namespace:itpp
itpp::ufixed29	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<29, US, WRAP> ufixed29;$/;"	t	namespace:itpp
itpp::ufixed3	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<3, US, WRAP> ufixed3;$/;"	t	namespace:itpp
itpp::ufixed30	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<30, US, WRAP> ufixed30;$/;"	t	namespace:itpp
itpp::ufixed31	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<31, US, WRAP> ufixed31;$/;"	t	namespace:itpp
itpp::ufixed32	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<32, US, WRAP> ufixed32;$/;"	t	namespace:itpp
itpp::ufixed33	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<33, US, WRAP> ufixed33;$/;"	t	namespace:itpp
itpp::ufixed34	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<34, US, WRAP> ufixed34;$/;"	t	namespace:itpp
itpp::ufixed35	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<35, US, WRAP> ufixed35;$/;"	t	namespace:itpp
itpp::ufixed36	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<36, US, WRAP> ufixed36;$/;"	t	namespace:itpp
itpp::ufixed37	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<37, US, WRAP> ufixed37;$/;"	t	namespace:itpp
itpp::ufixed38	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<38, US, WRAP> ufixed38;$/;"	t	namespace:itpp
itpp::ufixed39	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<39, US, WRAP> ufixed39;$/;"	t	namespace:itpp
itpp::ufixed4	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<4, US, WRAP> ufixed4;$/;"	t	namespace:itpp
itpp::ufixed40	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<40, US, WRAP> ufixed40;$/;"	t	namespace:itpp
itpp::ufixed41	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<41, US, WRAP> ufixed41;$/;"	t	namespace:itpp
itpp::ufixed42	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<42, US, WRAP> ufixed42;$/;"	t	namespace:itpp
itpp::ufixed43	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<43, US, WRAP> ufixed43;$/;"	t	namespace:itpp
itpp::ufixed44	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<44, US, WRAP> ufixed44;$/;"	t	namespace:itpp
itpp::ufixed45	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<45, US, WRAP> ufixed45;$/;"	t	namespace:itpp
itpp::ufixed46	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<46, US, WRAP> ufixed46;$/;"	t	namespace:itpp
itpp::ufixed47	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<47, US, WRAP> ufixed47;$/;"	t	namespace:itpp
itpp::ufixed48	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<48, US, WRAP> ufixed48;$/;"	t	namespace:itpp
itpp::ufixed49	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<49, US, WRAP> ufixed49;$/;"	t	namespace:itpp
itpp::ufixed5	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<5, US, WRAP> ufixed5;$/;"	t	namespace:itpp
itpp::ufixed50	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<50, US, WRAP> ufixed50;$/;"	t	namespace:itpp
itpp::ufixed51	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<51, US, WRAP> ufixed51;$/;"	t	namespace:itpp
itpp::ufixed52	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<52, US, WRAP> ufixed52;$/;"	t	namespace:itpp
itpp::ufixed53	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<53, US, WRAP> ufixed53;$/;"	t	namespace:itpp
itpp::ufixed54	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<54, US, WRAP> ufixed54;$/;"	t	namespace:itpp
itpp::ufixed55	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<55, US, WRAP> ufixed55;$/;"	t	namespace:itpp
itpp::ufixed56	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<56, US, WRAP> ufixed56;$/;"	t	namespace:itpp
itpp::ufixed57	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<57, US, WRAP> ufixed57;$/;"	t	namespace:itpp
itpp::ufixed58	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<58, US, WRAP> ufixed58;$/;"	t	namespace:itpp
itpp::ufixed59	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<59, US, WRAP> ufixed59;$/;"	t	namespace:itpp
itpp::ufixed6	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<6, US, WRAP> ufixed6;$/;"	t	namespace:itpp
itpp::ufixed60	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<60, US, WRAP> ufixed60;$/;"	t	namespace:itpp
itpp::ufixed61	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<61, US, WRAP> ufixed61;$/;"	t	namespace:itpp
itpp::ufixed62	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<62, US, WRAP> ufixed62;$/;"	t	namespace:itpp
itpp::ufixed63	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<63, US, WRAP> ufixed63;$/;"	t	namespace:itpp
itpp::ufixed64	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<64, US, WRAP> ufixed64;$/;"	t	namespace:itpp
itpp::ufixed7	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<7, US, WRAP> ufixed7;$/;"	t	namespace:itpp
itpp::ufixed8	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<8, US, WRAP> ufixed8;$/;"	t	namespace:itpp
itpp::ufixed9	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<9, US, WRAP> ufixed9;$/;"	t	namespace:itpp
itpp::unfix	/usr/include/itpp/fixed/fix_functions.h	/^Array<typename Convert<T>::to_double> unfix(const Array<T> &x)$/;"	f	namespace:itpp	signature:(const Array<T> &x)
itpp::unfix	/usr/include/itpp/fixed/fix_functions.h	/^inline cmat unfix(const cfixmat &x) {return to_cmat(x);}$/;"	f	namespace:itpp	signature:(const cfixmat &x)
itpp::unfix	/usr/include/itpp/fixed/fix_functions.h	/^inline cmat unfix(const cmat &x) {return x;}$/;"	f	namespace:itpp	signature:(const cmat &x)
itpp::unfix	/usr/include/itpp/fixed/fix_functions.h	/^inline cvec unfix(const cfixvec &x) {return to_cvec(x);}$/;"	f	namespace:itpp	signature:(const cfixvec &x)
itpp::unfix	/usr/include/itpp/fixed/fix_functions.h	/^inline cvec unfix(const cvec &x) {return x;}$/;"	f	namespace:itpp	signature:(const cvec &x)
itpp::unfix	/usr/include/itpp/fixed/fix_functions.h	/^inline double unfix(const Fix &x) {return x.unfix();}$/;"	f	namespace:itpp	signature:(const Fix &x)
itpp::unfix	/usr/include/itpp/fixed/fix_functions.h	/^inline double unfix(double x) {return x;}$/;"	f	namespace:itpp	signature:(double x)
itpp::unfix	/usr/include/itpp/fixed/fix_functions.h	/^inline mat unfix(const fixmat &x) {return to_mat(x);}$/;"	f	namespace:itpp	signature:(const fixmat &x)
itpp::unfix	/usr/include/itpp/fixed/fix_functions.h	/^inline mat unfix(const mat &x) {return x;}$/;"	f	namespace:itpp	signature:(const mat &x)
itpp::unfix	/usr/include/itpp/fixed/fix_functions.h	/^inline std::complex<double> unfix(const CFix &x) {return x.unfix();}$/;"	f	namespace:itpp	signature:(const CFix &x)
itpp::unfix	/usr/include/itpp/fixed/fix_functions.h	/^inline std::complex<double> unfix(const std::complex<double> &x) {return x;}$/;"	f	namespace:itpp	signature:(const std::complex<double> &x)
itpp::unfix	/usr/include/itpp/fixed/fix_functions.h	/^inline vec unfix(const fixvec &x) {return to_vec(x);}$/;"	f	namespace:itpp	signature:(const fixvec &x)
itpp::unfix	/usr/include/itpp/fixed/fix_functions.h	/^inline vec unfix(const vec &x) {return x;}$/;"	f	namespace:itpp	signature:(const vec &x)
itpp::upsample	/usr/include/itpp/signal/resampling.h	/^Mat<T> upsample(const Mat<T> &v, int usf)$/;"	f	namespace:itpp	signature:(const Mat<T> &v, int usf)
itpp::upsample	/usr/include/itpp/signal/resampling.h	/^Vec<T> upsample(const Vec<T> &v, int usf)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, int usf)
itpp::upsample	/usr/include/itpp/signal/resampling.h	/^extern template bmat upsample(const bmat &v, int usf);$/;"	p	namespace:itpp	signature:(const bmat &v, int usf)
itpp::upsample	/usr/include/itpp/signal/resampling.h	/^extern template bvec upsample(const bvec &v, int usf);$/;"	p	namespace:itpp	signature:(const bvec &v, int usf)
itpp::upsample	/usr/include/itpp/signal/resampling.h	/^extern template cmat upsample(const cmat &v, int usf);$/;"	p	namespace:itpp	signature:(const cmat &v, int usf)
itpp::upsample	/usr/include/itpp/signal/resampling.h	/^extern template cvec upsample(const cvec &v, int usf);$/;"	p	namespace:itpp	signature:(const cvec &v, int usf)
itpp::upsample	/usr/include/itpp/signal/resampling.h	/^extern template imat upsample(const imat &v, int usf);$/;"	p	namespace:itpp	signature:(const imat &v, int usf)
itpp::upsample	/usr/include/itpp/signal/resampling.h	/^extern template ivec upsample(const ivec &v, int usf);$/;"	p	namespace:itpp	signature:(const ivec &v, int usf)
itpp::upsample	/usr/include/itpp/signal/resampling.h	/^extern template mat upsample(const mat &v, int usf);$/;"	p	namespace:itpp	signature:(const mat &v, int usf)
itpp::upsample	/usr/include/itpp/signal/resampling.h	/^extern template smat upsample(const smat &v, int usf);$/;"	p	namespace:itpp	signature:(const smat &v, int usf)
itpp::upsample	/usr/include/itpp/signal/resampling.h	/^extern template svec upsample(const svec &v, int usf);$/;"	p	namespace:itpp	signature:(const svec &v, int usf)
itpp::upsample	/usr/include/itpp/signal/resampling.h	/^extern template vec upsample(const vec &v, int usf);$/;"	p	namespace:itpp	signature:(const vec &v, int usf)
itpp::upsample	/usr/include/itpp/signal/resampling.h	/^extern template void upsample(const bmat &v, int usf,  bmat &u);$/;"	p	namespace:itpp	signature:(const bmat &v, int usf, bmat &u)
itpp::upsample	/usr/include/itpp/signal/resampling.h	/^extern template void upsample(const bvec &v, int usf,  bvec &u);$/;"	p	namespace:itpp	signature:(const bvec &v, int usf, bvec &u)
itpp::upsample	/usr/include/itpp/signal/resampling.h	/^extern template void upsample(const cmat &v, int usf,  cmat &u);$/;"	p	namespace:itpp	signature:(const cmat &v, int usf, cmat &u)
itpp::upsample	/usr/include/itpp/signal/resampling.h	/^extern template void upsample(const cvec &v, int usf,  cvec &u);$/;"	p	namespace:itpp	signature:(const cvec &v, int usf, cvec &u)
itpp::upsample	/usr/include/itpp/signal/resampling.h	/^extern template void upsample(const imat &v, int usf,  imat &u);$/;"	p	namespace:itpp	signature:(const imat &v, int usf, imat &u)
itpp::upsample	/usr/include/itpp/signal/resampling.h	/^extern template void upsample(const ivec &v, int usf,  ivec &u);$/;"	p	namespace:itpp	signature:(const ivec &v, int usf, ivec &u)
itpp::upsample	/usr/include/itpp/signal/resampling.h	/^extern template void upsample(const mat &v, int usf,  mat &u);$/;"	p	namespace:itpp	signature:(const mat &v, int usf, mat &u)
itpp::upsample	/usr/include/itpp/signal/resampling.h	/^extern template void upsample(const smat &v, int usf,  smat &u);$/;"	p	namespace:itpp	signature:(const smat &v, int usf, smat &u)
itpp::upsample	/usr/include/itpp/signal/resampling.h	/^extern template void upsample(const svec &v, int usf,  svec &u);$/;"	p	namespace:itpp	signature:(const svec &v, int usf, svec &u)
itpp::upsample	/usr/include/itpp/signal/resampling.h	/^extern template void upsample(const vec &v, int usf,  vec &u);$/;"	p	namespace:itpp	signature:(const vec &v, int usf, vec &u)
itpp::upsample	/usr/include/itpp/signal/resampling.h	/^void upsample(const Mat<T> &v, int usf, Mat<T> &u)$/;"	f	namespace:itpp	signature:(const Mat<T> &v, int usf, Mat<T> &u)
itpp::upsample	/usr/include/itpp/signal/resampling.h	/^void upsample(const Vec<T> &v, int usf, Vec<T> &u)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, int usf, Vec<T> &u)
itpp::variance	/usr/include/itpp/stat/misc_stat.h	/^double variance(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
itpp::variance	/usr/include/itpp/stat/misc_stat.h	/^double variance(const cvec &v);$/;"	p	namespace:itpp	signature:(const cvec &v)
itpp::vec	/usr/include/itpp/base/vec.h	/^typedef Vec<double> vec;$/;"	t	namespace:itpp
itpp::vec2mxArray	/usr/include/itpp/itmex.h	/^void vec2mxArray(const vec &in, mxArray *out)$/;"	f	namespace:itpp	signature:(const vec &in, mxArray *out)
itpp::vec2mxArray	/usr/include/itpp/itmex.h	/^void vec2mxArray(const vec &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const vec &in, mxArray *out)
itpp::vec_1	/usr/include/itpp/base/specmat.h	/^Vec<T> vec_1(T v0)$/;"	f	namespace:itpp	signature:(T v0)
itpp::vec_2	/usr/include/itpp/base/specmat.h	/^Vec<T> vec_2(T v0, T v1)$/;"	f	namespace:itpp	signature:(T v0, T v1)
itpp::vec_3	/usr/include/itpp/base/specmat.h	/^Vec<T> vec_3(T v0, T v1, T v2)$/;"	f	namespace:itpp	signature:(T v0, T v1, T v2)
itpp::vqtrain	/usr/include/itpp/srccode/vqtrain.h	/^mat vqtrain(Array<vec> &DB, int SIZE, int NOITER, double STARTSTEP = 0.2, bool VERBOSE = true);$/;"	p	namespace:itpp	signature:(Array<vec> &DB, int SIZE, int NOITER, double STARTSTEP = 0.2, bool VERBOSE = true)
itpp::waterfilling	/usr/include/itpp/comm/commfunc.h	/^vec waterfilling(const vec& alpha, double P);$/;"	p	namespace:itpp	signature:(const vec& alpha, double P)
itpp::wcdma_spreading_codes	/usr/include/itpp/comm/sequence.h	/^smat wcdma_spreading_codes(int SF);$/;"	p	namespace:itpp	signature:(int SF)
itpp::wcdma_turbo_interleaver_sequence	/usr/include/itpp/comm/turbo.h	/^ivec wcdma_turbo_interleaver_sequence(int interleaver_size);$/;"	p	namespace:itpp	signature:(int interleaver_size)
itpp::weight	/usr/include/itpp/comm/commfunc.h	/^int weight(const bvec &a);$/;"	p	namespace:itpp	signature:(const bvec &a)
itpp::weight_int	/usr/include/itpp/comm/convcode.h	/^int weight_int(int length, int in);$/;"	p	namespace:itpp	signature:(int length, int in)
itpp::within_tolerance	/usr/include/itpp/stat/misc_stat.h	/^inline bool within_tolerance(const cmat &X, const cmat &Xref, double tol = 1e-14)$/;"	f	namespace:itpp	signature:(const cmat &X, const cmat &Xref, double tol = 1e-14)
itpp::within_tolerance	/usr/include/itpp/stat/misc_stat.h	/^inline bool within_tolerance(const cvec &x, const cvec &xref, double tol = 1e-14)$/;"	f	namespace:itpp	signature:(const cvec &x, const cvec &xref, double tol = 1e-14)
itpp::within_tolerance	/usr/include/itpp/stat/misc_stat.h	/^inline bool within_tolerance(const mat &X, const mat &Xref, double tol = 1e-14)$/;"	f	namespace:itpp	signature:(const mat &X, const mat &Xref, double tol = 1e-14)
itpp::within_tolerance	/usr/include/itpp/stat/misc_stat.h	/^inline bool within_tolerance(const vec &x, const vec &xref, double tol = 1e-14)$/;"	f	namespace:itpp	signature:(const vec &x, const vec &xref, double tol = 1e-14)
itpp::within_tolerance	/usr/include/itpp/stat/misc_stat.h	/^inline bool within_tolerance(double x, double xref, double tol = 1e-14)$/;"	f	namespace:itpp	signature:(double x, double xref, double tol = 1e-14)
itpp::within_tolerance	/usr/include/itpp/stat/misc_stat.h	/^inline bool within_tolerance(std::complex<double> x, std::complex<double> xref, double tol = 1e-14)$/;"	f	namespace:itpp	signature:(std::complex<double> x, std::complex<double> xref, double tol = 1e-14)
itpp::write_endian	/usr/include/itpp/srccode/audiofile.h	/^inline void write_endian(std::ostream &s, T data, bool switch_endian = false)$/;"	f	namespace:itpp	signature:(std::ostream &s, T data, bool switch_endian = false)
itpp::xcorr	/usr/include/itpp/signal/sigfun.h	/^cvec xcorr(const cvec &x, const cvec &y, const int max_lag = -1, const std::string scaleopt = "none");$/;"	p	namespace:itpp	signature:(const cvec &x, const cvec &y, const int max_lag = -1, const std::string scaleopt = Ó)
itpp::xcorr	/usr/include/itpp/signal/sigfun.h	/^cvec xcorr(const cvec &x, const int max_lag = -1, const std::string scaleopt = "none");$/;"	p	namespace:itpp	signature:(const cvec &x, const int max_lag = -1, const std::string scaleopt = Ó)
itpp::xcorr	/usr/include/itpp/signal/sigfun.h	/^vec xcorr(const vec &x, const int max_lag = -1, const std::string scaleopt = "none");$/;"	p	namespace:itpp	signature:(const vec &x, const int max_lag = -1, const std::string scaleopt = Ó)
itpp::xcorr	/usr/include/itpp/signal/sigfun.h	/^vec xcorr(const vec &x, const vec &y, const int max_lag = -1, const std::string scaleopt = "none");$/;"	p	namespace:itpp	signature:(const vec &x, const vec &y, const int max_lag = -1, const std::string scaleopt = Ó)
itpp::xcorr	/usr/include/itpp/signal/sigfun.h	/^void xcorr(const cvec &x, const cvec &y, cvec &out, const int max_lag = -1, const std::string scaleopt = "none",$/;"	p	namespace:itpp	signature:(const cvec &x, const cvec &y, cvec &out, const int max_lag = -1, const std::string scaleopt = Ó, bool autoflag = true)
itpp::xcorr	/usr/include/itpp/signal/sigfun.h	/^void xcorr(const vec &x, const vec &y, vec &out, const int max_lag = -1, const std::string scaleopt = "none");$/;"	p	namespace:itpp	signature:(const vec &x, const vec &y, vec &out, const int max_lag = -1, const std::string scaleopt = Ó)
itpp::xcorr_old	/usr/include/itpp/signal/sigfun.h	/^vec xcorr_old(const vec &x, const int max_lag = -1, const std::string scaleopt = "none");$/;"	p	namespace:itpp	signature:(const vec &x, const int max_lag = -1, const std::string scaleopt = Ó)
itpp::xcorr_old	/usr/include/itpp/signal/sigfun.h	/^vec xcorr_old(const vec &x, const vec &y, const int max_lag = -1, const std::string scaleopt = "none");$/;"	p	namespace:itpp	signature:(const vec &x, const vec &y, const int max_lag = -1, const std::string scaleopt = Ó)
itpp::xcorr_old	/usr/include/itpp/signal/sigfun.h	/^void xcorr_old(const vec &x, const vec &y, vec &out, const int max_lag = -1, const std::string scaleopt = "none");$/;"	p	namespace:itpp	signature:(const vec &x, const vec &y, vec &out, const int max_lag = -1, const std::string scaleopt = Ó)
itpp::yulewalk	/usr/include/itpp/signal/filter_design.h	/^void yulewalk(const int N, const vec &f, const vec &m, vec &b, vec &a);$/;"	p	namespace:itpp	signature:(const int N, const vec &f, const vec &m, vec &b, vec &a)
itpp::zero_pad	/usr/include/itpp/base/matfunc.h	/^Mat<T> zero_pad(const Mat<T> &m, int rows, int cols)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, int rows, int cols)
itpp::zero_pad	/usr/include/itpp/base/matfunc.h	/^Vec<T> zero_pad(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
itpp::zero_pad	/usr/include/itpp/base/matfunc.h	/^Vec<T> zero_pad(const Vec<T> &v, int n)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, int n)
itpp::zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template bmat zero_pad(const bmat &, int, int);$/;"	p	namespace:itpp	signature:(const bmat &, int, int)
itpp::zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template bvec zero_pad(const bvec &v);$/;"	p	namespace:itpp	signature:(const bvec &v)
itpp::zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template bvec zero_pad(const bvec &v, int n);$/;"	p	namespace:itpp	signature:(const bvec &v, int n)
itpp::zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template cmat zero_pad(const cmat &, int, int);$/;"	p	namespace:itpp	signature:(const cmat &, int, int)
itpp::zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template cvec zero_pad(const cvec &v);$/;"	p	namespace:itpp	signature:(const cvec &v)
itpp::zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template cvec zero_pad(const cvec &v, int n);$/;"	p	namespace:itpp	signature:(const cvec &v, int n)
itpp::zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template imat zero_pad(const imat &, int, int);$/;"	p	namespace:itpp	signature:(const imat &, int, int)
itpp::zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template ivec zero_pad(const ivec &v);$/;"	p	namespace:itpp	signature:(const ivec &v)
itpp::zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template ivec zero_pad(const ivec &v, int n);$/;"	p	namespace:itpp	signature:(const ivec &v, int n)
itpp::zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template mat zero_pad(const mat &, int, int);$/;"	p	namespace:itpp	signature:(const mat &, int, int)
itpp::zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template smat zero_pad(const smat &, int, int);$/;"	p	namespace:itpp	signature:(const smat &, int, int)
itpp::zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template svec zero_pad(const svec &v);$/;"	p	namespace:itpp	signature:(const svec &v)
itpp::zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template svec zero_pad(const svec &v, int n);$/;"	p	namespace:itpp	signature:(const svec &v, int n)
itpp::zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template vec zero_pad(const vec &v);$/;"	p	namespace:itpp	signature:(const vec &v)
itpp::zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template vec zero_pad(const vec &v, int n);$/;"	p	namespace:itpp	signature:(const vec &v, int n)
itpp::zeros	/usr/include/itpp/base/specmat.h	/^mat zeros(int rows, int cols);$/;"	p	namespace:itpp	signature:(int rows, int cols)
itpp::zeros	/usr/include/itpp/base/specmat.h	/^vec zeros(int size);$/;"	p	namespace:itpp	signature:(int size)
itpp::zeros_b	/usr/include/itpp/base/specmat.h	/^bmat zeros_b(int rows, int cols);$/;"	p	namespace:itpp	signature:(int rows, int cols)
itpp::zeros_b	/usr/include/itpp/base/specmat.h	/^bvec zeros_b(int size);$/;"	p	namespace:itpp	signature:(int size)
itpp::zeros_c	/usr/include/itpp/base/specmat.h	/^cmat zeros_c(int rows, int cols);$/;"	p	namespace:itpp	signature:(int rows, int cols)
itpp::zeros_c	/usr/include/itpp/base/specmat.h	/^cvec zeros_c(int size);$/;"	p	namespace:itpp	signature:(int size)
itpp::zeros_i	/usr/include/itpp/base/specmat.h	/^imat zeros_i(int rows, int cols);$/;"	p	namespace:itpp	signature:(int rows, int cols)
itpp::zeros_i	/usr/include/itpp/base/specmat.h	/^ivec zeros_i(int size);$/;"	p	namespace:itpp	signature:(int size)
itpp::zigzag_space	/usr/include/itpp/base/specmat.h	/^vec zigzag_space(double t0, double t1, int K = 5);$/;"	p	namespace:itpp	signature:(double t0, double t1, int K = 5)
itpp_version	/usr/include/itpp/base/math/misc.h	/^std::string itpp_version();$/;"	p	namespace:itpp	signature:()
ivec	/usr/include/itpp/base/vec.h	/^typedef Vec<int> ivec;$/;"	t	namespace:itpp
ivec2mxArray	/usr/include/itpp/itmex.h	/^void ivec2mxArray(const ivec &in, mxArray *out)$/;"	f	namespace:itpp	signature:(const ivec &in, mxArray *out)
ivec2mxArray	/usr/include/itpp/itmex.h	/^void ivec2mxArray(const ivec &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const ivec &in, mxArray *out)
j0	/usr/include/itpp/config.h	250;"	d
j1	/usr/include/itpp/config.h	252;"	d
jaclog	/usr/include/itpp/comm/llr.h	/^  inline QLLR jaclog(QLLR a, QLLR b) const;$/;"	p	class:itpp::LLR_calc_unit	access:public	signature:(QLLR a, QLLR b) const
jaclog	/usr/include/itpp/comm/llr.h	/^inline QLLR LLR_calc_unit::jaclog(QLLR a, QLLR b) const$/;"	f	class:itpp::LLR_calc_unit	signature:(QLLR a, QLLR b) const
jacobsthal	/usr/include/itpp/base/specmat.h	/^imat jacobsthal(int p);$/;"	p	namespace:itpp	signature:(int p)
jind	/usr/include/itpp/comm/ldpc.h	/^  ivec C, V, sumX1, sumX2, iind, jind;$/;"	m	class:itpp::LDPC_Code	access:private
jn	/usr/include/itpp/config.h	246;"	d
join	/usr/include/itpp/srccode/gmm.h	/^  void join(const GMM &newgmm);$/;"	p	class:itpp::GMM	access:public	signature:(const GMM &newgmm)
join	/usr/include/itpp/stat/mog_generic.h	/^  virtual void join(const MOG_generic &B_in);$/;"	p	class:itpp::MOG_generic	access:public	signature:(const MOG_generic &B_in)
k	/usr/include/itpp/comm/bch.h	/^  int n, k, t;$/;"	m	class:itpp::BCH	access:private
k	/usr/include/itpp/comm/hammcode.h	/^  short n, k;$/;"	m	class:itpp::Hamming_Code	access:private
k	/usr/include/itpp/comm/modulator.h	/^  int k;$/;"	m	class:itpp::Modulator	access:protected
k	/usr/include/itpp/comm/modulator_nd.h	/^  ivec k;$/;"	m	class:itpp::Modulator_ND	access:protected
k	/usr/include/itpp/comm/reedsolomon.h	/^  int m, t, k, n, q;$/;"	m	class:itpp::Reed_Solomon	access:protected
k	/usr/include/itpp/protocol/packet_channel.h	/^  int k, K, L;$/;"	m	class:itpp::ACK_Channel	access:private
k	/usr/include/itpp/protocol/packet_channel.h	/^  int k, K, L;$/;"	m	class:itpp::Packet_Channel	access:private
kNewReno	/usr/include/itpp/protocol/tcp.h	/^  enum eTCPVersion {kTahoe, kReno, kNewReno};$/;"	e	enum:itpp::TCP_Sender::eTCPVersion
kReno	/usr/include/itpp/protocol/tcp.h	/^  enum eTCPVersion {kTahoe, kReno, kNewReno};$/;"	e	enum:itpp::TCP_Sender::eTCPVersion
kTahoe	/usr/include/itpp/protocol/tcp.h	/^  enum eTCPVersion {kTahoe, kReno, kNewReno};$/;"	e	enum:itpp::TCP_Sender::eTCPVersion
keep_running	/usr/include/itpp/protocol/events.h	/^  static bool keep_running;$/;"	m	class:itpp::Event_Queue	access:private
keep_running	/usr/include/itpp/protocol/packet_channel.h	/^  bool keep_running;$/;"	m	class:itpp::Packet_Channel	access:private
keep_running	/usr/include/itpp/protocol/packet_generator.h	/^  bool keep_running;$/;"	m	class:itpp::Packet_Generator	access:private
kmeans	/usr/include/itpp/srccode/vqtrain.h	/^mat kmeans(Array<vec> &DB, int SIZE, int NOITER = 9999, bool VERBOSE = true);$/;"	p	namespace:itpp	signature:(Array<vec> &DB, int SIZE, int NOITER = 9999, bool VERBOSE = true)
kmeansiter	/usr/include/itpp/srccode/vqtrain.h	/^double kmeansiter(Array<vec> &DB, mat &codebook);$/;"	p	namespace:itpp	signature:(Array<vec> &DB, mat &codebook)
kron	/usr/include/itpp/base/matfunc.h	/^Mat<Num_T> kron(const Mat<Num_T>& X, const Mat<Num_T>& Y)$/;"	f	namespace:itpp	signature:(const Mat<Num_T>& X, const Mat<Num_T>& Y)
kron	/usr/include/itpp/base/matfunc.h	/^extern template bmat kron(const bmat &X, const bmat &Y);$/;"	p	namespace:itpp	signature:(const bmat &X, const bmat &Y)
kron	/usr/include/itpp/base/matfunc.h	/^extern template cmat kron(const cmat &X, const cmat &Y);$/;"	p	namespace:itpp	signature:(const cmat &X, const cmat &Y)
kron	/usr/include/itpp/base/matfunc.h	/^extern template imat kron(const imat &X, const imat &Y);$/;"	p	namespace:itpp	signature:(const imat &X, const imat &Y)
kron	/usr/include/itpp/base/matfunc.h	/^extern template mat kron(const mat &X, const mat &Y);$/;"	p	namespace:itpp	signature:(const mat &X, const mat &Y)
kron	/usr/include/itpp/base/matfunc.h	/^extern template smat kron(const smat &X, const smat &Y);$/;"	p	namespace:itpp	signature:(const smat &X, const smat &Y)
ktab	/usr/include/itpp/base/random.h	/^  static const unsigned int ktab[128];$/;"	m	class:itpp::Normal_RNG	access:private
kurtosis	/usr/include/itpp/stat/misc_stat.h	/^inline double kurtosis(const vec &x) {return kurtosisexcess(x) + 3;}$/;"	f	namespace:itpp	signature:(const vec &x)
kurtosisexcess	/usr/include/itpp/stat/misc_stat.h	/^double kurtosisexcess(const vec &x);$/;"	p	namespace:itpp	signature:(const vec &x)
l	/usr/include/itpp/base/random.h	/^  double l, b;$/;"	m	class:itpp::Weibull_RNG	access:private
l	/usr/include/itpp/base/random.h	/^  double l;$/;"	m	class:itpp::Exponential_RNG	access:private
l3_pkt_info_p	/usr/include/itpp/protocol/packet.h	/^  L3_Packet_Info *l3_pkt_info_p;$/;"	m	class:itpp::Link_Packet	access:public
l_endian	/usr/include/itpp/base/binfile.h	/^  enum endian { l_endian, b_endian };$/;"	e	enum:itpp::bfstream_base::endian
lar2rc	/usr/include/itpp/srccode/lpcfunc.h	/^vec lar2rc(const vec &lar);$/;"	p	namespace:itpp	signature:(const vec &lar)
lastEig	/usr/include/itpp/signal/fastica.h	/^  int firstEig, lastEig;$/;"	m	class:itpp::Fast_ICA	access:private
last_byte	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number last_byte() const;       \/**< \\brief highest byte received (+1) *\/$/;"	p	class:itpp::TCP_Receiver_Buffer	access:public	signature:() const
last_byte	/usr/include/itpp/protocol/tcp.h	/^inline Sequence_Number TCP_Receiver_Buffer::last_byte() const$/;"	f	class:itpp::TCP_Receiver_Buffer	signature:() const
last_seed	/usr/include/itpp/base/random.h	/^  unsigned int last_seed;$/;"	m	class:itpp::Random_Generator	access:private
latest_distortion	/usr/include/itpp/srccode/vq.h	/^  double latest_distortion();$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:()
latest_distortion	/usr/include/itpp/srccode/vq.h	/^inline double Vector_Quantizer::latest_distortion() { return LatestDist; }$/;"	f	class:itpp::Vector_Quantizer	signature:()
lbg	/usr/include/itpp/srccode/vqtrain.h	/^mat lbg(Array<vec> &DB, int SIZE, int NOITER = 9999, bool VERBOSE = true);$/;"	p	namespace:itpp	signature:(Array<vec> &DB, int SIZE, int NOITER = 9999, bool VERBOSE = true)
left	/usr/include/itpp/base/array.h	/^  Array<T> left(int n) const;$/;"	p	class:itpp::Array	access:public	signature:(int n) const
left	/usr/include/itpp/base/array.h	/^Array<T> Array<T>::left(int n) const$/;"	f	class:itpp::Array	signature:(int n) const
left	/usr/include/itpp/base/random.h	/^  static int left;$/;"	m	class:itpp::Random_Generator	access:private
left	/usr/include/itpp/base/vec.h	/^  Vec<Num_T> left(int nr) const;$/;"	p	class:itpp::Vec	access:public	signature:(int nr) const
left	/usr/include/itpp/base/vec.h	/^Vec<Num_T> Vec<Num_T>::left(int nr) const$/;"	f	class:itpp::Vec	signature:(int nr) const
left_overs	/usr/include/itpp/comm/channel.h	/^  cvec left_overs; \/\/!< Left-overs from upsampling$/;"	m	class:itpp::FIR_Fading_Generator	access:protected
length	/usr/include/itpp/base/array.h	/^  int length() const { return ndata; }$/;"	f	class:itpp::Array	access:public	signature:() const
length	/usr/include/itpp/base/binfile.h	/^  int length();$/;"	p	class:itpp::bfstream	access:public	signature:()
length	/usr/include/itpp/base/binfile.h	/^  int length();$/;"	p	class:itpp::bifstream	access:public	signature:()
length	/usr/include/itpp/base/matfunc.h	/^extern template int length(const bvec &v);$/;"	p	namespace:itpp	signature:(const bvec &v)
length	/usr/include/itpp/base/matfunc.h	/^extern template int length(const cvec &v);$/;"	p	namespace:itpp	signature:(const cvec &v)
length	/usr/include/itpp/base/matfunc.h	/^extern template int length(const ivec &v);$/;"	p	namespace:itpp	signature:(const ivec &v)
length	/usr/include/itpp/base/matfunc.h	/^extern template int length(const svec &v);$/;"	p	namespace:itpp	signature:(const svec &v)
length	/usr/include/itpp/base/matfunc.h	/^extern template int length(const vec &v);$/;"	p	namespace:itpp	signature:(const vec &v)
length	/usr/include/itpp/base/matfunc.h	/^int length(const Vec<T> &v) { return v.length(); }$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
length	/usr/include/itpp/base/vec.h	/^  int length() const { return datasize; }$/;"	f	class:itpp::Vec	access:public	signature:() const
length	/usr/include/itpp/protocol/tcp.h	/^  unsigned length() const;$/;"	p	class:itpp::TCP_Segment	access:public	signature:() const
length	/usr/include/itpp/protocol/tcp.h	/^inline unsigned TCP_Segment::length() const$/;"	f	class:itpp::TCP_Segment	signature:() const
lerouxguegenrc	/usr/include/itpp/srccode/lpcfunc.h	/^vec lerouxguegenrc(const vec &R, int order);$/;"	p	namespace:itpp	signature:(const vec &R, int order)
levels2bits	/usr/include/itpp/base/math/log_exp.h	/^inline int levels2bits(int n)$/;"	f	namespace:itpp	signature:(int n)
levels2bits	/usr/include/itpp/base/math/log_exp.h	/^inline ivec levels2bits(const ivec& v)$/;"	f	namespace:itpp	signature:(const ivec& v)
levinson	/usr/include/itpp/srccode/lpcfunc.h	/^vec levinson(const vec &R2, int order);$/;"	p	namespace:itpp	signature:(const vec &R2, int order)
lgamma	/usr/include/itpp/base/math/elem_math.h	/^double lgamma(double x);$/;"	p	signature:(double x)
lhood	/usr/include/itpp/stat/mog_diag.h	/^  double lhood(const double * c_x_in);$/;"	p	class:itpp::MOG_diag	access:public	signature:(const double * c_x_in)
lhood	/usr/include/itpp/stat/mog_diag.h	/^  double lhood(const vec &x_in);$/;"	p	class:itpp::MOG_diag	access:public	signature:(const vec &x_in)
lhood	/usr/include/itpp/stat/mog_generic.h	/^  virtual double lhood(const vec &x_in);$/;"	p	class:itpp::MOG_generic	access:public	signature:(const vec &x_in)
lhood_internal	/usr/include/itpp/stat/mog_diag.h	/^  double lhood_internal(const double * c_x_in);$/;"	p	class:itpp::MOG_diag	access:protected	signature:(const double * c_x_in)
lhood_internal	/usr/include/itpp/stat/mog_diag.h	/^  double lhood_internal(const vec &x_in);$/;"	p	class:itpp::MOG_diag	access:protected	signature:(const vec &x_in)
lhood_internal	/usr/include/itpp/stat/mog_generic.h	/^  virtual double lhood_internal(const vec &x_in);$/;"	p	class:itpp::MOG_generic	access:protected	signature:(const vec &x_in)
likelihood	/usr/include/itpp/srccode/gmm.h	/^  double likelihood(const vec &x);$/;"	p	class:itpp::GMM	access:public	signature:(const vec &x)
likelihood_aposteriori	/usr/include/itpp/srccode/gmm.h	/^  double likelihood_aposteriori(const vec &x, int mixture);$/;"	p	class:itpp::GMM	access:public	signature:(const vec &x, int mixture)
likelihood_aposteriori	/usr/include/itpp/srccode/gmm.h	/^  vec likelihood_aposteriori(const vec &x);$/;"	p	class:itpp::GMM	access:public	signature:(const vec &x)
lininterp	/usr/include/itpp/signal/resampling.h	/^Mat<T> lininterp(const Mat<T> &m, double f_base, double f_ups,$/;"	f	namespace:itpp	signature:(const Mat<T> &m, double f_base, double f_ups, int nrof_samples, double t_start = 0)
lininterp	/usr/include/itpp/signal/resampling.h	/^Mat<T> lininterp(const Mat<T> &m, int usf)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, int usf)
lininterp	/usr/include/itpp/signal/resampling.h	/^Vec<T> lininterp(const Vec<T> &v, double f_base, double f_ups,$/;"	f	namespace:itpp	signature:(const Vec<T> &v, double f_base, double f_ups, int nrof_samples, double t_start = 0)
lininterp	/usr/include/itpp/signal/resampling.h	/^Vec<T> lininterp(const Vec<T> &v, int usf)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, int usf)
lininterp	/usr/include/itpp/signal/resampling.h	/^extern template cmat lininterp(const cmat &m, double f_base, double f_ups, int nrof_samples, double t_start);$/;"	p	namespace:itpp	signature:(const cmat &m, double f_base, double f_ups, int nrof_samples, double t_start)
lininterp	/usr/include/itpp/signal/resampling.h	/^extern template cmat lininterp(const cmat &v, int usf);$/;"	p	namespace:itpp	signature:(const cmat &v, int usf)
lininterp	/usr/include/itpp/signal/resampling.h	/^extern template cvec lininterp(const cvec &v, double f_base, double f_ups, int nrof_samples, double t_start);$/;"	p	namespace:itpp	signature:(const cvec &v, double f_base, double f_ups, int nrof_samples, double t_start)
lininterp	/usr/include/itpp/signal/resampling.h	/^extern template cvec lininterp(const cvec &v, int usf);$/;"	p	namespace:itpp	signature:(const cvec &v, int usf)
lininterp	/usr/include/itpp/signal/resampling.h	/^extern template mat lininterp(const mat &m, double f_base, double f_ups, int nrof_samples, double t_start);$/;"	p	namespace:itpp	signature:(const mat &m, double f_base, double f_ups, int nrof_samples, double t_start)
lininterp	/usr/include/itpp/signal/resampling.h	/^extern template mat lininterp(const mat &v, int usf);$/;"	p	namespace:itpp	signature:(const mat &v, int usf)
lininterp	/usr/include/itpp/signal/resampling.h	/^extern template vec lininterp(const vec &v, double f_base, double f_ups, int nrof_samples, double t_start);$/;"	p	namespace:itpp	signature:(const vec &v, double f_base, double f_ups, int nrof_samples, double t_start)
lininterp	/usr/include/itpp/signal/resampling.h	/^extern template vec lininterp(const vec &v, int usf);$/;"	p	namespace:itpp	signature:(const vec &v, int usf)
lininterp	/usr/include/itpp/signal/resampling.h	/^extern template void lininterp(const cmat &v, int usf,  cmat &u);$/;"	p	namespace:itpp	signature:(const cmat &v, int usf, cmat &u)
lininterp	/usr/include/itpp/signal/resampling.h	/^extern template void lininterp(const cvec &v, int usf,  cvec &u);$/;"	p	namespace:itpp	signature:(const cvec &v, int usf, cvec &u)
lininterp	/usr/include/itpp/signal/resampling.h	/^extern template void lininterp(const mat &v, int usf,  mat &u);$/;"	p	namespace:itpp	signature:(const mat &v, int usf, mat &u)
lininterp	/usr/include/itpp/signal/resampling.h	/^extern template void lininterp(const vec &v, int usf,  vec &u);$/;"	p	namespace:itpp	signature:(const vec &v, int usf, vec &u)
lininterp	/usr/include/itpp/signal/resampling.h	/^void lininterp(const Mat<T> &m, int usf, Mat<T> &u)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, int usf, Mat<T> &u)
lininterp	/usr/include/itpp/signal/resampling.h	/^void lininterp(const Vec<T> &v, int usf, Vec<T> &u)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, int usf, Vec<T> &u)
link_packet_id	/usr/include/itpp/protocol/packet.h	/^  unsigned long int link_packet_id;$/;"	m	class:itpp::Link_Packet	access:public
link_packet_size	/usr/include/itpp/protocol/selective_repeat.h	/^  int link_packet_size;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
link_packets_buffered	/usr/include/itpp/protocol/selective_repeat.h	/^  int link_packets_buffered();$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:public	signature:()
link_packets_max_queuing_time	/usr/include/itpp/protocol/selective_repeat.h	/^  Ttype link_packets_max_queuing_time();$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:public	signature:()
link_packets_queued_waiting_for_transmission	/usr/include/itpp/protocol/selective_repeat.h	/^  int link_packets_queued_waiting_for_transmission();$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:public	signature:()
linspace	/usr/include/itpp/base/specmat.h	/^vec linspace(double from, double to, int length = 100);$/;"	p	namespace:itpp	signature:(double from, double to, int length = 100)
llrcalc	/usr/include/itpp/comm/ldpc.h	/^  LLR_calc_unit llrcalc; \/\/!< LLR calculation unit$/;"	m	class:itpp::LDPC_Code	access:protected
llrcalc	/usr/include/itpp/comm/modulator_nd.h	/^  LLR_calc_unit llrcalc;$/;"	m	class:itpp::Modulator_ND	access:protected
llrcalc	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  LLR_calc_unit llrcalc;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
ln2	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  double ln2;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
lo	/usr/include/itpp/base/random.h	/^  int lo;$/;"	m	class:itpp::I_Uniform_RNG	access:private
loBit	/usr/include/itpp/base/random.h	/^  unsigned int loBit(const unsigned int& u) const { return u & 0x00000001U; }$/;"	f	class:itpp::Random_Generator	access:private	signature:(const unsigned int& u) const
loBits	/usr/include/itpp/base/random.h	/^  unsigned int loBits(const unsigned int& u) const { return u & 0x7fffffffU; }$/;"	f	class:itpp::Random_Generator	access:private	signature:(const unsigned int& u) const
lo_bound	/usr/include/itpp/base/random.h	/^  double lo_bound, hi_bound;$/;"	m	class:itpp::Uniform_RNG	access:private
lo_vals	/usr/include/itpp/stat/histogram.h	/^  Vec<Num_T> lo_vals;$/;"	m	class:itpp::Histogram	access:private
load	/usr/include/itpp/comm/ldpc.h	/^  virtual void load(const std::string& filename) = 0;$/;"	p	class:itpp::LDPC_Generator	access:protected	signature:(const std::string& filename)
load	/usr/include/itpp/comm/ldpc.h	/^  virtual void load(const std::string& filename);$/;"	p	class:itpp::LDPC_Generator_Systematic	access:protected	signature:(const std::string& filename)
load	/usr/include/itpp/comm/ldpc.h	/^  void load(const std::string &filename);$/;"	p	class:itpp::BLDPC_Generator	access:protected	signature:(const std::string &filename)
load	/usr/include/itpp/srccode/gmm.h	/^  void load(std::string filename);$/;"	p	class:itpp::GMM	access:public	signature:(std::string filename)
load	/usr/include/itpp/srccode/vq.h	/^  void load(const char *Name);$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:(const char *Name)
load	/usr/include/itpp/stat/mog_diag.h	/^  void load(const std::string &name_in);$/;"	p	class:itpp::MOG_diag	access:public	signature:(const std::string &name_in)
load	/usr/include/itpp/stat/mog_generic.h	/^  virtual void load(const std::string &name_in);$/;"	p	class:itpp::MOG_generic	access:public	signature:(const std::string &name_in)
load_alist	/usr/include/itpp/comm/ldpc.h	/^  void load_alist(const std::string& alist_file);$/;"	p	class:itpp::LDPC_Parity	access:public	signature:(const std::string& alist_file)
load_base_matrix	/usr/include/itpp/comm/ldpc.h	/^  void load_base_matrix(const std::string &filename);$/;"	p	class:itpp::BLDPC_Parity	access:public	signature:(const std::string &filename)
load_code	/usr/include/itpp/comm/ldpc.h	/^  void load_code(const std::string& filename, LDPC_Generator* const G = 0);$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const std::string& filename, LDPC_Generator* const G = 0)
log	/usr/include/itpp/base/math/log_exp.h	/^inline cmat log(const cmat &x)$/;"	f	namespace:itpp	signature:(const cmat &x)
log	/usr/include/itpp/base/math/log_exp.h	/^inline cvec log(const cvec &x)$/;"	f	namespace:itpp	signature:(const cvec &x)
log	/usr/include/itpp/base/math/log_exp.h	/^inline mat log(const mat &x)$/;"	f	namespace:itpp	signature:(const mat &x)
log	/usr/include/itpp/base/math/log_exp.h	/^inline vec log(const vec &x)$/;"	f	namespace:itpp	signature:(const vec &x)
log10	/usr/include/itpp/base/math/log_exp.h	/^inline mat log10(const mat &x)$/;"	f	namespace:itpp	signature:(const mat &x)
log10	/usr/include/itpp/base/math/log_exp.h	/^inline vec log10(const vec &x)$/;"	f	namespace:itpp	signature:(const vec &x)
log1p	/usr/include/itpp/base/math/log_exp.h	/^inline double log1p(double x) { return std::log(1.0 + x); }$/;"	f	signature:(double x)
log2	/usr/include/itpp/base/math/log_exp.h	/^inline double log2(double x)$/;"	f	signature:(double x)
log2	/usr/include/itpp/base/math/log_exp.h	/^inline mat log2(const mat &x)$/;"	f	namespace:itpp	signature:(const mat &x)
log2	/usr/include/itpp/base/math/log_exp.h	/^inline vec log2(const vec &x)$/;"	f	namespace:itpp	signature:(const vec &x)
log2	/usr/include/itpp/base/math/log_exp.h	55;"	d
log_add	/usr/include/itpp/base/math/log_exp.h	/^inline double log_add(double log_a, double log_b)$/;"	f	namespace:itpp	signature:(double log_a, double log_b)
log_binom	/usr/include/itpp/base/math/elem_math.h	/^double log_binom(int n, int k);$/;"	p	namespace:itpp	signature:(int n, int k)
log_decode	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  virtual void log_decode(const QLLRvec &rec_systematic,$/;"	p	class:itpp::Rec_Syst_Conv_Code	access:public	signature:(const QLLRvec &rec_systematic, const QLLRmat &rec_parity, const QLLRvec &extrinsic_input, QLLRvec &extrinsic_output, bool set_terminated = false)
log_decode	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  virtual void log_decode(const vec &rec_systematic, const mat &rec_parity, const vec &extrinsic_input,$/;"	p	class:itpp::Rec_Syst_Conv_Code	access:public	signature:(const vec &rec_systematic, const mat &rec_parity, const vec &extrinsic_input, vec &extrinsic_output, bool set_terminated = false, std::string metric = Ó)
log_decode_n2	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  virtual void log_decode_n2(const QLLRvec &rec_systematic,$/;"	p	class:itpp::Rec_Syst_Conv_Code	access:public	signature:(const QLLRvec &rec_systematic, const QLLRvec &rec_parity, const QLLRvec &extrinsic_input, QLLRvec &extrinsic_output, bool set_terminated = false)
log_decode_n2	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  virtual void log_decode_n2(const vec &rec_systematic,$/;"	p	class:itpp::Rec_Syst_Conv_Code	access:public	signature:(const vec &rec_systematic, const vec &rec_parity, const vec &extrinsic_input, vec &extrinsic_output, bool set_terminated = false, std::string metric = Ó)
log_det_etc	/usr/include/itpp/stat/mog_generic.h	/^  vec log_det_etc;$/;"	m	class:itpp::MOG_generic	access:protected
log_double_max	/usr/include/itpp/base/math/log_exp.h	/^const double log_double_max = std::log(std::numeric_limits<double>::max());$/;"	m	namespace:itpp
log_double_min	/usr/include/itpp/base/math/log_exp.h	/^const double log_double_min = std::log(std::numeric_limits<double>::min());$/;"	m	namespace:itpp
log_lhood	/usr/include/itpp/stat/mog_diag.h	/^  double log_lhood(const double * c_x_in);$/;"	p	class:itpp::MOG_diag	access:public	signature:(const double * c_x_in)
log_lhood	/usr/include/itpp/stat/mog_diag.h	/^  double log_lhood(const vec &x_in);$/;"	p	class:itpp::MOG_diag	access:public	signature:(const vec &x_in)
log_lhood	/usr/include/itpp/stat/mog_generic.h	/^  virtual double log_lhood(const vec &x_in);$/;"	p	class:itpp::MOG_generic	access:public	signature:(const vec &x_in)
log_lhood_internal	/usr/include/itpp/stat/mog_diag.h	/^  double log_lhood_internal(const double * c_x_in);$/;"	p	class:itpp::MOG_diag	access:protected	signature:(const double * c_x_in)
log_lhood_internal	/usr/include/itpp/stat/mog_diag.h	/^  double log_lhood_internal(const vec &x_in);$/;"	p	class:itpp::MOG_diag	access:protected	signature:(const vec &x_in)
log_lhood_internal	/usr/include/itpp/stat/mog_generic.h	/^  virtual double log_lhood_internal(const vec &x_in);$/;"	p	class:itpp::MOG_generic	access:protected	signature:(const vec &x_in)
log_lhood_single_gaus	/usr/include/itpp/stat/mog_diag.h	/^  double log_lhood_single_gaus(const double * c_x_in, const int k) const;$/;"	p	class:itpp::MOG_diag	access:public	signature:(const double * c_x_in, const int k) const
log_lhood_single_gaus	/usr/include/itpp/stat/mog_diag.h	/^  double log_lhood_single_gaus(const vec &x_in, const int k) const;$/;"	p	class:itpp::MOG_diag	access:public	signature:(const vec &x_in, const int k) const
log_lhood_single_gaus	/usr/include/itpp/stat/mog_generic.h	/^  virtual double log_lhood_single_gaus(const vec &x_in, const int k);$/;"	p	class:itpp::MOG_generic	access:public	signature:(const vec &x_in, const int k)
log_lhood_single_gaus_internal	/usr/include/itpp/stat/mog_diag.h	/^  double log_lhood_single_gaus_internal(const double * c_x_in, const int k) const;$/;"	p	class:itpp::MOG_diag	access:protected	signature:(const double * c_x_in, const int k) const
log_lhood_single_gaus_internal	/usr/include/itpp/stat/mog_diag.h	/^  double log_lhood_single_gaus_internal(const vec &x_in, const int k) const;$/;"	p	class:itpp::MOG_diag	access:protected	signature:(const vec &x_in, const int k) const
log_lhood_single_gaus_internal	/usr/include/itpp/stat/mog_generic.h	/^  virtual double log_lhood_single_gaus_internal(const vec &x_in, const int k);$/;"	p	class:itpp::MOG_generic	access:protected	signature:(const vec &x_in, const int k)
log_max_K	/usr/include/itpp/stat/mog_generic.h	/^  double log_max_K;$/;"	m	class:itpp::MOG_generic	access:protected
log_weights	/usr/include/itpp/stat/mog_generic.h	/^  vec log_weights;$/;"	m	class:itpp::MOG_generic	access:protected
logalpha	/usr/include/itpp/comm/galois.h	/^  static Array<Array<int> > alphapow, logalpha;$/;"	m	class:itpp::GF	access:private
logb	/usr/include/itpp/base/math/log_exp.h	/^inline double logb(double b, double x)$/;"	f	namespace:itpp	signature:(double b, double x)
logb	/usr/include/itpp/base/math/log_exp.h	/^inline mat logb(double b, const mat &x)$/;"	f	namespace:itpp	signature:(double b, const mat &x)
logb	/usr/include/itpp/base/math/log_exp.h	/^inline vec logb(double b, const vec &x)$/;"	f	namespace:itpp	signature:(double b, const vec &x)
logexp	/usr/include/itpp/comm/llr.h	/^  inline QLLR logexp(QLLR x) const;$/;"	p	class:itpp::LLR_calc_unit	access:public	signature:(QLLR x) const
logexp	/usr/include/itpp/comm/llr.h	/^inline QLLR LLR_calc_unit::logexp(QLLR x) const$/;"	f	class:itpp::LLR_calc_unit	signature:(QLLR x) const
logexp_table	/usr/include/itpp/comm/llr.h	/^  ivec logexp_table;$/;"	m	class:itpp::LLR_calc_unit	access:private
logmax_scale_factor	/usr/include/itpp/comm/turbo.h	/^  double Ec, N0, Lc, R, logmax_scale_factor;$/;"	m	class:itpp::Turbo_Codec	access:private
los_diffuse	/usr/include/itpp/comm/channel.h	/^  double los_diffuse; \/\/!< Diffuse component: sqrt(1 \/ (1 + los_power))$/;"	m	class:itpp::Fading_Generator	access:protected
los_direct	/usr/include/itpp/comm/channel.h	/^  double los_direct; \/\/!< Direct component: sqrt(los_power \/ (1 + los_power))$/;"	m	class:itpp::Fading_Generator	access:protected
los_dopp	/usr/include/itpp/comm/channel.h	/^  double los_dopp; \/\/!< Relative Doppler on LOS component (0.7 by default)$/;"	m	class:itpp::Correlated_Fading_Generator	access:protected
los_dopp	/usr/include/itpp/comm/channel.h	/^  vec los_dopp; \/\/!< Relative LOS Doppler for each Rice component$/;"	m	class:itpp::TDL_Channel	access:protected
los_dopp	/usr/include/itpp/comm/channel.h	/^  vec los_dopp; \/\/!< Relative Rice Doppler for each Rice component$/;"	m	class:itpp::Channel_Specification	access:protected
los_power	/usr/include/itpp/comm/channel.h	/^  double los_power; \/\/!< Relative power of LOS component compared to diffuse component (K factor)$/;"	m	class:itpp::Fading_Generator	access:protected
los_power	/usr/include/itpp/comm/channel.h	/^  vec los_power; \/\/!< Relative power for each Rice component$/;"	m	class:itpp::Channel_Specification	access:protected
los_power	/usr/include/itpp/comm/channel.h	/^  vec los_power; \/\/!< Relative power for each Rice component$/;"	m	class:itpp::TDL_Channel	access:protected
lose	/usr/include/itpp/protocol/packet_channel.h	/^  bool lose;$/;"	m	class:itpp::ACK_Channel	access:private
lose	/usr/include/itpp/protocol/packet_channel.h	/^  bool lose;$/;"	m	class:itpp::Packet_Channel	access:private
lost	/usr/include/itpp/protocol/packet_channel.h	/^  ivec lost;$/;"	m	class:itpp::ACK_Channel	access:private
lost	/usr/include/itpp/protocol/packet_channel.h	/^  ivec lost;$/;"	m	class:itpp::Packet_Channel	access:private
low_level	/usr/include/itpp/base/itfile.h	/^  bfstream& low_level() { return s; }$/;"	f	class:itpp::it_file	access:public	signature:()
low_level	/usr/include/itpp/base/itfile.h	/^  bfstream& low_level() { return s; }$/;"	f	class:itpp::it_file_old	access:public	signature:()
low_level	/usr/include/itpp/base/itfile.h	/^  bfstream& low_level() { return s; }$/;"	f	class:itpp::it_ifile	access:public	signature:()
low_level	/usr/include/itpp/base/itfile.h	/^  bfstream& low_level() { return s; }$/;"	f	class:itpp::it_ifile_old	access:public	signature:()
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(Array<bin>& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(Array<bin>& v)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(Array<bin>& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(Array<bin>& v)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(Array<float>& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(Array<float>& v)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(Array<int>& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(Array<int>& v)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(Array<int>& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(Array<int>& v)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(Array<short>& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(Array<short>& v)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(Array<std::complex<float> >& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(Array<std::complex<float> >& v)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(bin& x);$/;"	p	class:itpp::it_ifile	access:public	signature:(bin& x)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(bin& x);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(bin& x)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(bmat& m);$/;"	p	class:itpp::it_ifile	access:public	signature:(bmat& m)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(bmat& m);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(bmat& m)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(bool &x);$/;"	p	class:itpp::it_ifile	access:public	signature:(bool &x)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(bvec& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(bvec& v)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(bvec& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(bvec& v)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(char& x);$/;"	p	class:itpp::it_ifile	access:public	signature:(char& x)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(char& x);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(char& x)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(double& x);$/;"	p	class:itpp::it_ifile	access:public	signature:(double& x)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(double& x);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(double& x)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(float& x);$/;"	p	class:itpp::it_ifile	access:public	signature:(float& x)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(float& x);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(float& x)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(imat& m);$/;"	p	class:itpp::it_ifile	access:public	signature:(imat& m)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(imat& m);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(imat& m)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(int& x);$/;"	p	class:itpp::it_ifile	access:public	signature:(int& x)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(int& x);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(int& x)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(ivec& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(ivec& v)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(ivec& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(ivec& v)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(short& x);$/;"	p	class:itpp::it_ifile	access:public	signature:(short& x)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(short& x);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(short& x)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(smat& m);$/;"	p	class:itpp::it_ifile	access:public	signature:(smat& m)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(std::complex<double>& x);$/;"	p	class:itpp::it_ifile	access:public	signature:(std::complex<double>& x)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(std::complex<double>& x);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(std::complex<double>& x)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(std::complex<float>& x);$/;"	p	class:itpp::it_ifile	access:public	signature:(std::complex<float>& x)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(std::complex<float>& x);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(std::complex<float>& x)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(std::string& str);$/;"	p	class:itpp::it_ifile	access:public	signature:(std::string& str)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(std::string& str);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(std::string& str)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(svec& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(svec& v)
low_level_read	/usr/include/itpp/base/itfile.h	/^  void low_level_read(uint64_t& x);$/;"	p	class:itpp::it_ifile	access:public	signature:(uint64_t& x)
low_level_read_hi	/usr/include/itpp/base/itfile.h	/^  void low_level_read_hi(Array<double>& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(Array<double>& v)
low_level_read_hi	/usr/include/itpp/base/itfile.h	/^  void low_level_read_hi(Array<double>& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(Array<double>& v)
low_level_read_hi	/usr/include/itpp/base/itfile.h	/^  void low_level_read_hi(Array<std::complex<double> >& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(Array<std::complex<double> >& v)
low_level_read_hi	/usr/include/itpp/base/itfile.h	/^  void low_level_read_hi(Array<std::complex<double> >& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(Array<std::complex<double> >& v)
low_level_read_hi	/usr/include/itpp/base/itfile.h	/^  void low_level_read_hi(cmat& m);$/;"	p	class:itpp::it_ifile	access:public	signature:(cmat& m)
low_level_read_hi	/usr/include/itpp/base/itfile.h	/^  void low_level_read_hi(cmat& m);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(cmat& m)
low_level_read_hi	/usr/include/itpp/base/itfile.h	/^  void low_level_read_hi(cvec& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(cvec& v)
low_level_read_hi	/usr/include/itpp/base/itfile.h	/^  void low_level_read_hi(cvec& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(cvec& v)
low_level_read_hi	/usr/include/itpp/base/itfile.h	/^  void low_level_read_hi(mat& m);$/;"	p	class:itpp::it_ifile	access:public	signature:(mat& m)
low_level_read_hi	/usr/include/itpp/base/itfile.h	/^  void low_level_read_hi(mat& m);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(mat& m)
low_level_read_hi	/usr/include/itpp/base/itfile.h	/^  void low_level_read_hi(vec& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(vec& v)
low_level_read_hi	/usr/include/itpp/base/itfile.h	/^  void low_level_read_hi(vec& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(vec& v)
low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(Array<double>& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(Array<double>& v)
low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(Array<double>& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(Array<double>& v)
low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(Array<float>& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(Array<float>& v)
low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(Array<std::complex<double> >& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(Array<std::complex<double> >& v)
low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(Array<std::complex<double> >& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(Array<std::complex<double> >& v)
low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(Array<std::complex<float> >& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(Array<std::complex<float> >& v)
low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(cmat& m);$/;"	p	class:itpp::it_ifile	access:public	signature:(cmat& m)
low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(cmat& m);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(cmat& m)
low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(cvec& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(cvec& v)
low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(cvec& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(cvec& v)
low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(mat& m);$/;"	p	class:itpp::it_ifile	access:public	signature:(mat& m)
low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(mat& m);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(mat& m)
low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(vec& v);$/;"	p	class:itpp::it_ifile	access:public	signature:(vec& v)
low_level_read_lo	/usr/include/itpp/base/itfile.h	/^  void low_level_read_lo(vec& v);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(vec& v)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(bin x);$/;"	p	class:itpp::it_file	access:public	signature:(bin x)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(bin x);$/;"	p	class:itpp::it_file_old	access:public	signature:(bin x)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(bool x);$/;"	p	class:itpp::it_file	access:public	signature:(bool x)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(char x);$/;"	p	class:itpp::it_file	access:public	signature:(char x)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(char x);$/;"	p	class:itpp::it_file_old	access:public	signature:(char x)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const Array<bin>& v);$/;"	p	class:itpp::it_file	access:public	signature:(const Array<bin>& v)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const Array<bin>& v);$/;"	p	class:itpp::it_file_old	access:public	signature:(const Array<bin>& v)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const Array<double>& v);$/;"	p	class:itpp::it_file	access:public	signature:(const Array<double>& v)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const Array<double>& v);$/;"	p	class:itpp::it_file_old	access:public	signature:(const Array<double>& v)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const Array<float>& v);$/;"	p	class:itpp::it_file	access:public	signature:(const Array<float>& v)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const Array<float>& v);$/;"	p	class:itpp::it_file_old	access:public	signature:(const Array<float>& v)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const Array<int>& v);$/;"	p	class:itpp::it_file	access:public	signature:(const Array<int>& v)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const Array<int>& v);$/;"	p	class:itpp::it_file_old	access:public	signature:(const Array<int>& v)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const Array<short>& v);$/;"	p	class:itpp::it_file	access:public	signature:(const Array<short>& v)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const Array<std::complex<double> >& v);$/;"	p	class:itpp::it_file	access:public	signature:(const Array<std::complex<double> >& v)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const Array<std::complex<double> >& v);$/;"	p	class:itpp::it_file_old	access:public	signature:(const Array<std::complex<double> >& v)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const Array<std::complex<float> >& v);$/;"	p	class:itpp::it_file	access:public	signature:(const Array<std::complex<float> >& v)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const Array<std::complex<float> >& v);$/;"	p	class:itpp::it_file_old	access:public	signature:(const Array<std::complex<float> >& v)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const bmat& m);$/;"	p	class:itpp::it_file	access:public	signature:(const bmat& m)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const bmat& m);$/;"	p	class:itpp::it_file_old	access:public	signature:(const bmat& m)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const bvec& v);$/;"	p	class:itpp::it_file	access:public	signature:(const bvec& v)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const bvec& v);$/;"	p	class:itpp::it_file_old	access:public	signature:(const bvec& v)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const cmat& m);$/;"	p	class:itpp::it_file	access:public	signature:(const cmat& m)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const cmat& m);$/;"	p	class:itpp::it_file_old	access:public	signature:(const cmat& m)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const cvec& v);$/;"	p	class:itpp::it_file	access:public	signature:(const cvec& v)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const cvec& v);$/;"	p	class:itpp::it_file_old	access:public	signature:(const cvec& v)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const imat& m);$/;"	p	class:itpp::it_file	access:public	signature:(const imat& m)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const imat& m);$/;"	p	class:itpp::it_file_old	access:public	signature:(const imat& m)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const ivec& v);$/;"	p	class:itpp::it_file	access:public	signature:(const ivec& v)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const ivec& v);$/;"	p	class:itpp::it_file_old	access:public	signature:(const ivec& v)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const mat& m);$/;"	p	class:itpp::it_file	access:public	signature:(const mat& m)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const mat& m);$/;"	p	class:itpp::it_file_old	access:public	signature:(const mat& m)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const smat& m);$/;"	p	class:itpp::it_file	access:public	signature:(const smat& m)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const std::complex<double>& x);$/;"	p	class:itpp::it_file	access:public	signature:(const std::complex<double>& x)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const std::complex<double>& x);$/;"	p	class:itpp::it_file_old	access:public	signature:(const std::complex<double>& x)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const std::complex<float>& x);$/;"	p	class:itpp::it_file	access:public	signature:(const std::complex<float>& x)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const std::complex<float>& x);$/;"	p	class:itpp::it_file_old	access:public	signature:(const std::complex<float>& x)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const std::string& str);$/;"	p	class:itpp::it_file	access:public	signature:(const std::string& str)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const std::string& str);$/;"	p	class:itpp::it_file_old	access:public	signature:(const std::string& str)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const svec& v);$/;"	p	class:itpp::it_file	access:public	signature:(const svec& v)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const vec& v);$/;"	p	class:itpp::it_file	access:public	signature:(const vec& v)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(const vec& v);$/;"	p	class:itpp::it_file_old	access:public	signature:(const vec& v)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(double x);$/;"	p	class:itpp::it_file	access:public	signature:(double x)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(double x);$/;"	p	class:itpp::it_file_old	access:public	signature:(double x)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(float x);$/;"	p	class:itpp::it_file	access:public	signature:(float x)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(float x);$/;"	p	class:itpp::it_file_old	access:public	signature:(float x)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(int x);$/;"	p	class:itpp::it_file	access:public	signature:(int x)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(int x);$/;"	p	class:itpp::it_file_old	access:public	signature:(int x)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(short x);$/;"	p	class:itpp::it_file	access:public	signature:(short x)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(short x);$/;"	p	class:itpp::it_file_old	access:public	signature:(short x)
low_level_write	/usr/include/itpp/base/itfile.h	/^  void low_level_write(uint64_t x);$/;"	p	class:itpp::it_file	access:public	signature:(uint64_t x)
low_prec	/usr/include/itpp/base/itfile.h	/^  bool low_prec;$/;"	m	class:itpp::it_file	access:protected
low_prec	/usr/include/itpp/base/itfile.h	/^  bool low_prec;$/;"	m	class:itpp::it_file_old	access:protected
lpc	/usr/include/itpp/srccode/lpcfunc.h	/^vec lpc(const vec &x, int order);$/;"	p	namespace:itpp	signature:(const vec &x, int order)
ls_solve	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve(const cmat &A, const cmat &B, cmat &X);$/;"	p	namespace:itpp	signature:(const cmat &A, const cmat &B, cmat &X)
ls_solve	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve(const cmat &A, const cvec &b, cvec &x);$/;"	p	namespace:itpp	signature:(const cmat &A, const cvec &b, cvec &x)
ls_solve	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve(const mat &A, const mat &B, mat &X);$/;"	p	namespace:itpp	signature:(const mat &A, const mat &B, mat &X)
ls_solve	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve(const mat &A, const vec &b, vec &x);$/;"	p	namespace:itpp	signature:(const mat &A, const vec &b, vec &x)
ls_solve	/usr/include/itpp/base/algebra/ls_solve.h	/^cmat ls_solve(const cmat &A, const cmat &B);$/;"	p	namespace:itpp	signature:(const cmat &A, const cmat &B)
ls_solve	/usr/include/itpp/base/algebra/ls_solve.h	/^cvec ls_solve(const cmat &A, const cvec &b);$/;"	p	namespace:itpp	signature:(const cmat &A, const cvec &b)
ls_solve	/usr/include/itpp/base/algebra/ls_solve.h	/^mat ls_solve(const mat &A, const mat &B);$/;"	p	namespace:itpp	signature:(const mat &A, const mat &B)
ls_solve	/usr/include/itpp/base/algebra/ls_solve.h	/^vec ls_solve(const mat &A, const vec &b);$/;"	p	namespace:itpp	signature:(const mat &A, const vec &b)
ls_solve_chol	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve_chol(const cmat &A, const cmat &B, cmat &X);$/;"	p	namespace:itpp	signature:(const cmat &A, const cmat &B, cmat &X)
ls_solve_chol	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve_chol(const cmat &A, const cvec &b, cvec &x);$/;"	p	namespace:itpp	signature:(const cmat &A, const cvec &b, cvec &x)
ls_solve_chol	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve_chol(const mat &A, const mat &B, mat &X);$/;"	p	namespace:itpp	signature:(const mat &A, const mat &B, mat &X)
ls_solve_chol	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve_chol(const mat &A, const vec &b, vec &x);$/;"	p	namespace:itpp	signature:(const mat &A, const vec &b, vec &x)
ls_solve_chol	/usr/include/itpp/base/algebra/ls_solve.h	/^cmat ls_solve_chol(const cmat &A, const cmat &B);$/;"	p	namespace:itpp	signature:(const cmat &A, const cmat &B)
ls_solve_chol	/usr/include/itpp/base/algebra/ls_solve.h	/^cvec ls_solve_chol(const cmat &A, const cvec &b);$/;"	p	namespace:itpp	signature:(const cmat &A, const cvec &b)
ls_solve_chol	/usr/include/itpp/base/algebra/ls_solve.h	/^mat ls_solve_chol(const mat &A, const mat &B);$/;"	p	namespace:itpp	signature:(const mat &A, const mat &B)
ls_solve_chol	/usr/include/itpp/base/algebra/ls_solve.h	/^vec ls_solve_chol(const mat &A, const vec &b);$/;"	p	namespace:itpp	signature:(const mat &A, const vec &b)
ls_solve_od	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve_od(const cmat &A, const cmat &B, cmat &X);$/;"	p	namespace:itpp	signature:(const cmat &A, const cmat &B, cmat &X)
ls_solve_od	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve_od(const cmat &A, const cvec &b, cvec &x);$/;"	p	namespace:itpp	signature:(const cmat &A, const cvec &b, cvec &x)
ls_solve_od	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve_od(const mat &A, const mat &B, mat &X);$/;"	p	namespace:itpp	signature:(const mat &A, const mat &B, mat &X)
ls_solve_od	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve_od(const mat &A, const vec &b, vec &x);$/;"	p	namespace:itpp	signature:(const mat &A, const vec &b, vec &x)
ls_solve_od	/usr/include/itpp/base/algebra/ls_solve.h	/^cmat ls_solve_od(const cmat &A, const cmat &B);$/;"	p	namespace:itpp	signature:(const cmat &A, const cmat &B)
ls_solve_od	/usr/include/itpp/base/algebra/ls_solve.h	/^cvec ls_solve_od(const cmat &A, const cvec &b);$/;"	p	namespace:itpp	signature:(const cmat &A, const cvec &b)
ls_solve_od	/usr/include/itpp/base/algebra/ls_solve.h	/^mat ls_solve_od(const mat &A, const mat &B);$/;"	p	namespace:itpp	signature:(const mat &A, const mat &B)
ls_solve_od	/usr/include/itpp/base/algebra/ls_solve.h	/^vec ls_solve_od(const mat &A, const vec &b);$/;"	p	namespace:itpp	signature:(const mat &A, const vec &b)
ls_solve_ud	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve_ud(const cmat &A, const cmat &B, cmat &X);$/;"	p	namespace:itpp	signature:(const cmat &A, const cmat &B, cmat &X)
ls_solve_ud	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve_ud(const cmat &A, const cvec &b, cvec &x);$/;"	p	namespace:itpp	signature:(const cmat &A, const cvec &b, cvec &x)
ls_solve_ud	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve_ud(const mat &A, const mat &B, mat &X);$/;"	p	namespace:itpp	signature:(const mat &A, const mat &B, mat &X)
ls_solve_ud	/usr/include/itpp/base/algebra/ls_solve.h	/^bool ls_solve_ud(const mat &A, const vec &b, vec &x);$/;"	p	namespace:itpp	signature:(const mat &A, const vec &b, vec &x)
ls_solve_ud	/usr/include/itpp/base/algebra/ls_solve.h	/^cmat ls_solve_ud(const cmat &A, const cmat &B);$/;"	p	namespace:itpp	signature:(const cmat &A, const cmat &B)
ls_solve_ud	/usr/include/itpp/base/algebra/ls_solve.h	/^cvec ls_solve_ud(const cmat &A, const cvec &b);$/;"	p	namespace:itpp	signature:(const cmat &A, const cvec &b)
ls_solve_ud	/usr/include/itpp/base/algebra/ls_solve.h	/^mat ls_solve_ud(const mat &A, const mat &B);$/;"	p	namespace:itpp	signature:(const mat &A, const mat &B)
ls_solve_ud	/usr/include/itpp/base/algebra/ls_solve.h	/^vec ls_solve_ud(const mat &A, const vec &b);$/;"	p	namespace:itpp	signature:(const mat &A, const vec &b)
lsf2poly	/usr/include/itpp/srccode/lpcfunc.h	/^vec lsf2poly(const vec &lsf);$/;"	p	namespace:itpp	signature:(const vec &lsf)
lshift	/usr/include/itpp/fixed/cfix.h	/^  void lshift(int n);$/;"	p	class:itpp::CFix	access:public	signature:(int n)
lshift	/usr/include/itpp/fixed/fix.h	/^  void lshift(int n);$/;"	p	class:itpp::Fix	access:public	signature:(int n)
lshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void lshift_fix(CFix &y, int n) {y.lshift(n);}$/;"	f	namespace:itpp	signature:(CFix &y, int n)
lshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void lshift_fix(Fix &y, int n) {y.lshift(n);}$/;"	f	namespace:itpp	signature:(Fix &y, int n)
lshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void lshift_fix(cfixmat &y, int n)$/;"	f	namespace:itpp	signature:(cfixmat &y, int n)
lshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void lshift_fix(cfixvec &y, int n)$/;"	f	namespace:itpp	signature:(cfixvec &y, int n)
lshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void lshift_fix(cmat &, int) {}$/;"	f	namespace:itpp	signature:(cmat &, int)
lshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void lshift_fix(cvec &, int) {}$/;"	f	namespace:itpp	signature:(cvec &, int)
lshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void lshift_fix(double &, int) {}$/;"	f	namespace:itpp	signature:(double &, int)
lshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void lshift_fix(fixmat &y, int n)$/;"	f	namespace:itpp	signature:(fixmat &y, int n)
lshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void lshift_fix(fixvec &y, int n)$/;"	f	namespace:itpp	signature:(fixvec &y, int n)
lshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void lshift_fix(mat &, int) {}$/;"	f	namespace:itpp	signature:(mat &, int)
lshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void lshift_fix(std::complex<double> &, int) {}$/;"	f	namespace:itpp	signature:(std::complex<double> &, int)
lshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void lshift_fix(vec &, int) {}$/;"	f	namespace:itpp	signature:(vec &, int)
lshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<class T> inline void lshift_fix(Array<T> &y, int n)$/;"	f	namespace:itpp	signature:(Array<T> &y, int n)
lu	/usr/include/itpp/base/algebra/lu.h	/^bool lu(const cmat &X, cmat &L, cmat &U, ivec &p);$/;"	p	namespace:itpp	signature:(const cmat &X, cmat &L, cmat &U, ivec &p)
lu	/usr/include/itpp/base/algebra/lu.h	/^bool lu(const mat &X, mat &L, mat &U, ivec &p);$/;"	p	namespace:itpp	signature:(const mat &X, mat &L, mat &U, ivec &p)
m	/usr/include/itpp/base/random.h	/^  std::complex<double> m;$/;"	m	class:itpp::Complex_Normal_RNG	access:private
m	/usr/include/itpp/comm/convcode.h	/^  int m;$/;"	m	class:itpp::Convolutional_Code	access:protected
m	/usr/include/itpp/comm/galois.h	/^  char m;$/;"	m	class:itpp::GF	access:private
m	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  int n, K, m;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
m	/usr/include/itpp/comm/reedsolomon.h	/^  int m, t, k, n, q;$/;"	m	class:itpp::Reed_Solomon	access:protected
m	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Sawtooth_Source	access:private
m	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Sine_Source	access:private
m	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Square_Source	access:private
m	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Triangle_Source	access:private
m	/usr/include/itpp/srccode/gmm.h	/^  vec   m, sigma, w;$/;"	m	class:itpp::GMM	access:protected
m_2pi	/usr/include/itpp/base/math/misc.h	/^const double m_2pi = 2 * pi;$/;"	m	namespace:itpp
m_tail	/usr/include/itpp/comm/turbo.h	/^  int m_tail, n1, n2, n_tot, iterations;$/;"	m	class:itpp::Turbo_Codec	access:private
magic	/usr/include/itpp/base/itfile.h	/^    char magic[4];$/;"	m	struct:itpp::it_file_base::file_header	access:public
magic	/usr/include/itpp/base/itfile.h	/^    char magic[4];$/;"	m	struct:itpp::it_file_base_old::file_header	access:public
magic	/usr/include/itpp/srccode/audiofile.h	/^    unsigned magic;$/;"	m	struct:itpp::SND_Format::__anon1	access:public
map	/usr/include/itpp/stat/mog_diag_em.h	/^  void map(MOG_diag &model_in, MOG_diag &prior_model, Array<vec> &X_in, int max_iter_in = 10, double alpha_in = 0.5, double var_floor_in = 0.0, double weight_floor_in = 0.0, bool verbose_in = false);$/;"	p	class:itpp::MOG_diag_EM_sup	access:public	signature:(MOG_diag &model_in, MOG_diag &prior_model, Array<vec> &X_in, int max_iter_in = 10, double alpha_in = 0.5, double var_floor_in = 0.0, double weight_floor_in = 0.0, bool verbose_in = false)
map_decode	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  virtual void map_decode(const vec &rec_systematic, const mat &rec_parity, const vec &extrinsic_input, vec &extrinsic_output,$/;"	p	class:itpp::Rec_Syst_Conv_Code	access:public	signature:(const vec &rec_systematic, const mat &rec_parity, const vec &extrinsic_input, vec &extrinsic_output, bool set_terminated = false)
marginalize	/usr/include/itpp/srccode/gmm.h	/^  void marginalize(int d_new);$/;"	p	class:itpp::GMM	access:public	signature:(int d_new)
mat	/usr/include/itpp/base/mat.h	/^typedef Mat<double> mat;$/;"	t	namespace:itpp
mat2mxArray	/usr/include/itpp/itmex.h	/^void mat2mxArray(const mat &in, mxArray *out)$/;"	f	namespace:itpp	signature:(const mat &in, mxArray *out)
mat2mxArray	/usr/include/itpp/itmex.h	/^void mat2mxArray(const mat &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const mat &in, mxArray *out)
mat_1x1	/usr/include/itpp/base/specmat.h	/^Mat<T> mat_1x1(T m00)$/;"	f	namespace:itpp	signature:(T m00)
mat_1x2	/usr/include/itpp/base/specmat.h	/^Mat<T> mat_1x2(T m00, T m01)$/;"	f	namespace:itpp	signature:(T m00, T m01)
mat_1x3	/usr/include/itpp/base/specmat.h	/^Mat<T> mat_1x3(T m00, T m01, T m02)$/;"	f	namespace:itpp	signature:(T m00, T m01, T m02)
mat_2x1	/usr/include/itpp/base/specmat.h	/^Mat<T> mat_2x1(T m00,$/;"	f	namespace:itpp	signature:(T m00, T m10)
mat_2x2	/usr/include/itpp/base/specmat.h	/^Mat<T> mat_2x2(T m00, T m01,$/;"	f	namespace:itpp	signature:(T m00, T m01, T m10, T m11)
mat_2x3	/usr/include/itpp/base/specmat.h	/^Mat<T> mat_2x3(T m00, T m01, T m02,$/;"	f	namespace:itpp	signature:(T m00, T m01, T m02, T m10, T m11, T m12)
mat_3x1	/usr/include/itpp/base/specmat.h	/^Mat<T> mat_3x1(T m00,$/;"	f	namespace:itpp	signature:(T m00, T m10, T m20)
mat_3x2	/usr/include/itpp/base/specmat.h	/^Mat<T> mat_3x2(T m00, T m01,$/;"	f	namespace:itpp	signature:(T m00, T m01, T m10, T m11, T m20, T m21)
mat_3x3	/usr/include/itpp/base/specmat.h	/^Mat<T> mat_3x3(T m00, T m01, T m02,$/;"	f	namespace:itpp	signature:(T m00, T m01, T m02, T m10, T m11, T m12, T m20, T m21, T m22)
max	/usr/include/itpp/base/math/min_max.h	/^T max(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
max	/usr/include/itpp/base/math/min_max.h	/^T max(const Vec<T> &v, int& index)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, int& index)
max	/usr/include/itpp/base/math/min_max.h	/^Vec<T> max(const Mat<T> &m, int dim = 1)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, int dim = 1)
max	/usr/include/itpp/base/math/min_max.h	/^Vec<T> max(const Mat<T> &m, ivec &index, int dim = 1)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, ivec &index, int dim = 1)
max	/usr/include/itpp/fixed/fix_base.h	/^  fixrep max;$/;"	m	class:itpp::Fix_Base	access:protected
max	/usr/include/itpp/protocol/tcp.h	/^inline const Sequence_Number & max(const Sequence_Number &n1, const Sequence_Number &n2) { return (n1 > n2) ? n1 : n2; }$/;"	f	namespace:itpp	signature:(const Sequence_Number &n1, const Sequence_Number &n2)
max	/usr/include/itpp/stat/misc_stat.h	/^  double max() const {return _max;}$/;"	f	class:itpp::Stat	access:public	signature:() const
maxFineTune	/usr/include/itpp/signal/fastica.h	/^  int maxNumIterations, maxFineTune;$/;"	m	class:itpp::Fast_ICA	access:private
maxNumIterations	/usr/include/itpp/signal/fastica.h	/^  int maxNumIterations, maxFineTune;$/;"	m	class:itpp::Fast_ICA	access:private
max_byte_size	/usr/include/itpp/protocol/front_drop_queue.h	/^  int max_byte_size() { return max_bytes_in_queue; }$/;"	f	class:itpp::Front_Drop_Queue	access:public	signature:()
max_bytes_in_queue	/usr/include/itpp/protocol/front_drop_queue.h	/^  int max_bytes_in_queue;$/;"	m	class:itpp::Front_Drop_Queue	access:private
max_evaluations	/usr/include/itpp/optim/newton_search.h	/^  int max_evaluations; \/\/ opts(4)$/;"	m	class:itpp::Newton_Search	access:private
max_index	/usr/include/itpp/base/math/min_max.h	/^int max_index(const Vec<T> &in)$/;"	f	namespace:itpp	signature:(const Vec<T> &in)
max_index	/usr/include/itpp/base/math/min_max.h	/^void max_index(const Mat<T> &m, int &row, int &col)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, int &row, int &col)
max_iter	/usr/include/itpp/stat/mog_diag_em.h	/^  int max_iter;$/;"	m	class:itpp::MOG_diag_EM_sup	access:protected
max_iter	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  int max_iter;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:protected
max_iterations	/usr/include/itpp/optim/newton_search.h	/^  int max_iterations; \/\/ opts(4)$/;"	m	class:itpp::Line_Search	access:private
max_iters	/usr/include/itpp/comm/ldpc.h	/^  int max_iters;  \/\/!< Maximum number of iterations$/;"	m	class:itpp::LDPC_Code	access:protected
max_num_m	/usr/include/itpp/base/gf2mat.h	/^  int max_num_m;$/;"	m	class:itpp::GF2mat_sparse_alist	access:protected
max_num_n	/usr/include/itpp/base/gf2mat.h	/^  int max_num_n;$/;"	m	class:itpp::GF2mat_sparse_alist	access:protected
max_packets	/usr/include/itpp/protocol/packet_generator.h	/^  unsigned long int max_packets;$/;"	m	class:itpp::Packet_Generator	access:private
max_packets	/usr/include/itpp/protocol/packet_generator.h	/^  unsigned long int max_packets;$/;"	m	class:itpp::Sink	access:private
max_slots	/usr/include/itpp/protocol/packet_channel.h	/^  int max_slots;$/;"	m	class:itpp::Packet_Channel	access:private
max_stepsize	/usr/include/itpp/optim/newton_search.h	/^  double max_stepsize; \/\/ opts(5)$/;"	m	class:itpp::Line_Search	access:private
mcspreadI	/usr/include/itpp/comm/spread.h	/^  Multicode_Spread_1d mcspreadI, mcspreadQ;$/;"	m	class:itpp::Multicode_Spread_2d	access:protected
mcspreadQ	/usr/include/itpp/comm/spread.h	/^  Multicode_Spread_1d mcspreadI, mcspreadQ;$/;"	m	class:itpp::Multicode_Spread_2d	access:protected
mcv	/usr/include/itpp/comm/ldpc.h	/^  QLLRvec mvc, mcv;$/;"	m	class:itpp::LDPC_Code	access:private
mean	/usr/include/itpp/base/random.h	/^  double mean, sigma;$/;"	m	class:itpp::Normal_RNG	access:private
mean	/usr/include/itpp/base/random.h	/^  double mean, var, sqrt_12var;$/;"	m	class:itpp::Laplace_RNG	access:private
mean	/usr/include/itpp/base/random.h	/^  double mean, var;$/;"	m	class:itpp::Weibull_RNG	access:private
mean	/usr/include/itpp/base/random.h	/^  double mem, r, factr, mean, var, r1, r2;$/;"	m	class:itpp::AR1_Normal_RNG	access:private
mean	/usr/include/itpp/signal/source.h	/^  double mean, var;$/;"	m	class:itpp::Pattern_Source	access:private
mean	/usr/include/itpp/stat/misc_stat.h	/^double mean(const imat &m);$/;"	p	namespace:itpp	signature:(const imat &m)
mean	/usr/include/itpp/stat/misc_stat.h	/^double mean(const ivec &v);$/;"	p	namespace:itpp	signature:(const ivec &v)
mean	/usr/include/itpp/stat/misc_stat.h	/^double mean(const mat &m);$/;"	p	namespace:itpp	signature:(const mat &m)
mean	/usr/include/itpp/stat/misc_stat.h	/^double mean(const smat &m);$/;"	p	namespace:itpp	signature:(const smat &m)
mean	/usr/include/itpp/stat/misc_stat.h	/^double mean(const svec &v);$/;"	p	namespace:itpp	signature:(const svec &v)
mean	/usr/include/itpp/stat/misc_stat.h	/^double mean(const vec &v);$/;"	p	namespace:itpp	signature:(const vec &v)
mean	/usr/include/itpp/stat/misc_stat.h	/^std::complex<double> mean(const cmat &m);$/;"	p	namespace:itpp	signature:(const cmat &m)
mean	/usr/include/itpp/stat/misc_stat.h	/^std::complex<double> mean(const cvec &v);$/;"	p	namespace:itpp	signature:(const cvec &v)
means	/usr/include/itpp/stat/mog_generic.h	/^  Array<vec> means;$/;"	m	class:itpp::MOG_generic	access:protected
means_old	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  Array<vec> means_old;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:protected
measure_change	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  double measure_change() const;$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:protected	signature:() const
median	/usr/include/itpp/stat/misc_stat.h	/^double median(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
mem	/usr/include/itpp/base/random.h	/^  double mem, r, factr, mean, var, r1, r2;$/;"	m	class:itpp::AR1_Normal_RNG	access:private
mem	/usr/include/itpp/signal/filter.h	/^  Vec<T3> mem;$/;"	m	class:itpp::ARMA_Filter	access:private
mem	/usr/include/itpp/signal/filter.h	/^  Vec<T3> mem;$/;"	m	class:itpp::AR_Filter	access:private
mem	/usr/include/itpp/signal/filter.h	/^  Vec<T3> mem;$/;"	m	class:itpp::MA_Filter	access:private
memory	/usr/include/itpp/comm/sequence.h	/^  bvec memory, Connections;$/;"	m	class:itpp::LFSR	access:private
method	/usr/include/itpp/comm/channel.h	/^  CORRELATED_METHOD method; \/\/!< Correlated fading generation method: Rice_MEDS (default), IFFT or FIR$/;"	m	class:itpp::TDL_Channel	access:protected
method	/usr/include/itpp/optim/newton_search.h	/^  Line_Search_Method method;$/;"	m	class:itpp::Line_Search	access:private
method	/usr/include/itpp/optim/newton_search.h	/^  Newton_Search_Method method;$/;"	m	class:itpp::Newton_Search	access:private
metric	/usr/include/itpp/comm/turbo.h	/^  std::string metric;$/;"	m	class:itpp::Turbo_Codec	access:private
mid	/usr/include/itpp/base/array.h	/^  Array<T> mid(int pos, int n) const;$/;"	p	class:itpp::Array	access:public	signature:(int pos, int n) const
mid	/usr/include/itpp/base/array.h	/^Array<T> Array<T>::mid(int pos, int n) const$/;"	f	class:itpp::Array	signature:(int pos, int n) const
mid	/usr/include/itpp/base/vec.h	/^  Vec<Num_T> mid(int start, int nr) const;$/;"	p	class:itpp::Vec	access:public	signature:(int start, int nr) const
mid	/usr/include/itpp/base/vec.h	/^Vec<Num_T> Vec<Num_T>::mid(int start, int nr) const$/;"	f	class:itpp::Vec	signature:(int start, int nr) const
min	/usr/include/itpp/base/math/min_max.h	/^T min(const Vec<T> &in)$/;"	f	namespace:itpp	signature:(const Vec<T> &in)
min	/usr/include/itpp/base/math/min_max.h	/^T min(const Vec<T> &in, int& index)$/;"	f	namespace:itpp	signature:(const Vec<T> &in, int& index)
min	/usr/include/itpp/base/math/min_max.h	/^Vec<T> min(const Mat<T> &m,  ivec &index, int dim = 1)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, ivec &index, int dim = 1)
min	/usr/include/itpp/base/math/min_max.h	/^Vec<T> min(const Mat<T> &m, int dim = 1)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, int dim = 1)
min	/usr/include/itpp/fixed/fix_base.h	/^  fixrep min;$/;"	m	class:itpp::Fix_Base	access:protected
min	/usr/include/itpp/protocol/tcp.h	/^inline const Sequence_Number & min(const Sequence_Number &n1, const Sequence_Number &n2) { return (n1 < n2) ? n1 : n2; }$/;"	f	namespace:itpp	signature:(const Sequence_Number &n1, const Sequence_Number &n2)
min	/usr/include/itpp/stat/misc_stat.h	/^  double min() const {return _min;}$/;"	f	class:itpp::Stat	access:public	signature:() const
min_index	/usr/include/itpp/base/math/min_max.h	/^int min_index(const Vec<T> &in)$/;"	f	namespace:itpp	signature:(const Vec<T> &in)
min_index	/usr/include/itpp/base/math/min_max.h	/^void min_index(const Mat<T> &m, int &row, int &col)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, int &row, int &col)
mixBits	/usr/include/itpp/base/random.h	/^  unsigned int mixBits(const unsigned int& u, const unsigned int& v) const$/;"	f	class:itpp::Random_Generator	access:private	signature:(const unsigned int& u, const unsigned int& v) const
mixedSig	/usr/include/itpp/signal/fastica.h	/^  mat mixedSig, A, W, icasig;$/;"	m	class:itpp::Fast_ICA	access:private
ml	/usr/include/itpp/stat/mog_diag_em.h	/^  void ml(MOG_diag &model_in, Array<vec> &X_in, int max_iter_in = 10, double var_floor_in = 0.0, double weight_floor_in = 0.0, bool verbose_in = false);$/;"	p	class:itpp::MOG_diag_EM_sup	access:public	signature:(MOG_diag &model_in, Array<vec> &X_in, int max_iter_in = 10, double var_floor_in = 0.0, double weight_floor_in = 0.0, bool verbose_in = false)
ml_iterate	/usr/include/itpp/stat/mog_diag_em.h	/^  void ml_iterate();$/;"	p	class:itpp::MOG_diag_EM_sup	access:protected	signature:()
ml_update_params	/usr/include/itpp/stat/mog_diag_em.h	/^  double ml_update_params();$/;"	p	class:itpp::MOG_diag_EM_sup	access:protected	signature:()
mlist	/usr/include/itpp/base/gf2mat.h	/^  imat mlist;$/;"	m	class:itpp::GF2mat_sparse_alist	access:protected
mod	/usr/include/itpp/base/math/elem_math.h	/^inline int mod(int k, int n)$/;"	f	namespace:itpp	signature:(int k, int n)
modgfx	/usr/include/itpp/comm/galois.h	/^GFX modgfx(const GFX &a, const GFX &b);$/;"	p	namespace:itpp	signature:(const GFX &a, const GFX &b)
modified_yule_walker	/usr/include/itpp/signal/filter_design.h	/^void modified_yule_walker(const int m, const int n, const int N, const vec &R, vec &a);$/;"	p	namespace:itpp	signature:(const int m, const int n, const int N, const vec &R, vec &a)
modify_codevector	/usr/include/itpp/srccode/vq.h	/^  void modify_codevector(int no, double mul, const vec &add);$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:(int no, double mul, const vec &add)
modulate	/usr/include/itpp/comm/modulator.h	/^  virtual Vec<T> modulate(const ivec& symbolnumbers) const;$/;"	p	class:itpp::Modulator	access:public	signature:(const ivec& symbolnumbers) const
modulate	/usr/include/itpp/comm/modulator.h	/^  virtual void modulate(const ivec& symbolnumbers, Vec<T>& output) const;$/;"	p	class:itpp::Modulator	access:public	signature:(const ivec& symbolnumbers, Vec<T>& output) const
modulate	/usr/include/itpp/comm/modulator.h	/^Vec<T> Modulator<T>::modulate(const ivec &symbolnumbers) const$/;"	f	class:itpp::Modulator	signature:(const ivec &symbolnumbers) const
modulate	/usr/include/itpp/comm/modulator.h	/^void Modulator<T>::modulate(const ivec &symbolnumbers, Vec<T>& output) const$/;"	f	class:itpp::Modulator	signature:(const ivec &symbolnumbers, Vec<T>& output) const
modulate	/usr/include/itpp/comm/ofdm.h	/^  cvec modulate(const cvec &input);$/;"	p	class:itpp::OFDM	access:public	signature:(const cvec &input)
modulate	/usr/include/itpp/comm/ofdm.h	/^  void modulate(const cvec &input, cvec &output);$/;"	p	class:itpp::OFDM	access:public	signature:(const cvec &input, cvec &output)
modulate_bits	/usr/include/itpp/comm/modulator.h	/^  cvec modulate_bits(const bvec& bits) const;$/;"	p	class:itpp::BPSK_c	access:public	signature:(const bvec& bits) const
modulate_bits	/usr/include/itpp/comm/modulator.h	/^  vec modulate_bits(const bvec& bits) const;$/;"	p	class:itpp::BPSK	access:public	signature:(const bvec& bits) const
modulate_bits	/usr/include/itpp/comm/modulator.h	/^  virtual Vec<T> modulate_bits(const bvec& bits) const;$/;"	p	class:itpp::Modulator	access:public	signature:(const bvec& bits) const
modulate_bits	/usr/include/itpp/comm/modulator.h	/^  virtual void modulate_bits(const bvec& bits, Vec<T>& output) const;$/;"	p	class:itpp::Modulator	access:public	signature:(const bvec& bits, Vec<T>& output) const
modulate_bits	/usr/include/itpp/comm/modulator.h	/^  void modulate_bits(const bvec& bits, cvec& output) const;$/;"	p	class:itpp::BPSK_c	access:public	signature:(const bvec& bits, cvec& output) const
modulate_bits	/usr/include/itpp/comm/modulator.h	/^  void modulate_bits(const bvec& bits, vec& output) const;$/;"	p	class:itpp::BPSK	access:public	signature:(const bvec& bits, vec& output) const
modulate_bits	/usr/include/itpp/comm/modulator.h	/^Vec<T> Modulator<T>::modulate_bits(const bvec &bits) const$/;"	f	class:itpp::Modulator	signature:(const bvec &bits) const
modulate_bits	/usr/include/itpp/comm/modulator.h	/^void Modulator<T>::modulate_bits(const bvec &bits, Vec<T> &output) const$/;"	f	class:itpp::Modulator	signature:(const bvec &bits, Vec<T> &output) const
modulate_bits	/usr/include/itpp/comm/modulator_nd.h	/^  cvec modulate_bits(const bvec &bits) const;$/;"	p	class:itpp::Modulator_NCD	access:public	signature:(const bvec &bits) const
modulate_bits	/usr/include/itpp/comm/modulator_nd.h	/^  vec modulate_bits(const bvec &bits) const;$/;"	p	class:itpp::Modulator_NRD	access:public	signature:(const bvec &bits) const
modulate_bits	/usr/include/itpp/comm/modulator_nd.h	/^  void modulate_bits(const bvec &bits, cvec &symbols) const;$/;"	p	class:itpp::Modulator_NCD	access:public	signature:(const bvec &bits, cvec &symbols) const
modulate_bits	/usr/include/itpp/comm/modulator_nd.h	/^  void modulate_bits(const bvec &bits, vec &symbols) const;$/;"	p	class:itpp::Modulator_NRD	access:public	signature:(const bvec &bits, vec &symbols) const
moment	/usr/include/itpp/stat/misc_stat.h	/^double moment(const vec &x, const int r);$/;"	p	namespace:itpp	signature:(const vec &x, const int r)
mseq1	/usr/include/itpp/comm/sequence.h	/^  LFSR mseq1, mseq2;$/;"	m	class:itpp::Gold	access:private
mseq2	/usr/include/itpp/comm/sequence.h	/^  LFSR mseq1, mseq2;$/;"	m	class:itpp::Gold	access:private
mu	/usr/include/itpp/signal/fastica.h	/^  double a1, a2, mu, epsilon, sampleSize;$/;"	m	class:itpp::Fast_ICA	access:private
mult_trans	/usr/include/itpp/base/gf2mat.h	/^  friend GF2mat mult_trans(const GF2mat &X, const GF2mat &Y);$/;"	p	class:itpp::GF2mat	access:friend	signature:(const GF2mat &X, const GF2mat &Y)
mult_trans	/usr/include/itpp/base/gf2mat.h	/^GF2mat mult_trans(const GF2mat &X, const GF2mat &Y);$/;"	p	namespace:itpp	signature:(const GF2mat &X, const GF2mat &Y)
mult_trans	/usr/include/itpp/base/smat.h	/^  friend Sparse_Mat<T> mult_trans <>(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2);$/;"	p	class:itpp::Sparse_Mat	access:friend	signature:(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)
mult_trans	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> mult_trans(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)$/;"	f	namespace:itpp	signature:(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)
mult_trans	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> mult_trans(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2);$/;"	p	namespace:itpp	signature:(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)
mult_trans	/usr/include/itpp/base/smat.h	/^extern template sparse_cmat mult_trans(const sparse_cmat &, const sparse_cmat &);$/;"	p	namespace:itpp	signature:(const sparse_cmat &, const sparse_cmat &)
mult_trans	/usr/include/itpp/base/smat.h	/^extern template sparse_imat mult_trans(const sparse_imat &, const sparse_imat &);$/;"	p	namespace:itpp	signature:(const sparse_imat &, const sparse_imat &)
mult_trans	/usr/include/itpp/base/smat.h	/^extern template sparse_mat mult_trans(const sparse_mat &, const sparse_mat &);$/;"	p	namespace:itpp	signature:(const sparse_mat &, const sparse_mat &)
mvc	/usr/include/itpp/comm/ldpc.h	/^  QLLRvec mvc, mcv;$/;"	m	class:itpp::LDPC_Code	access:private
mxArray2Ccmat	/usr/include/itpp/itmex.h	/^void mxArray2Ccmat(const mxArray *in, double **out_real, double **out_imag)$/;"	f	namespace:itpp	signature:(const mxArray *in, double **out_real, double **out_imag)
mxArray2Ccmat	/usr/include/itpp/itmex.h	/^void mxArray2Ccmat(const mxArray *in, double **out_real, double **out_imag);$/;"	p	namespace:itpp	signature:(const mxArray *in, double **out_real, double **out_imag)
mxArray2Ccvec	/usr/include/itpp/itmex.h	/^void mxArray2Ccvec(const mxArray *in, double *out_real, double *out_imag)$/;"	f	namespace:itpp	signature:(const mxArray *in, double *out_real, double *out_imag)
mxArray2Ccvec	/usr/include/itpp/itmex.h	/^void mxArray2Ccvec(const mxArray *in, double *out_real, double *out_imag);$/;"	p	namespace:itpp	signature:(const mxArray *in, double *out_real, double *out_imag)
mxArray2Cimat	/usr/include/itpp/itmex.h	/^void mxArray2Cimat(const mxArray *in, int **out)$/;"	f	namespace:itpp	signature:(const mxArray *in, int **out)
mxArray2Cimat	/usr/include/itpp/itmex.h	/^void mxArray2Cimat(const mxArray *in, int **out);$/;"	p	namespace:itpp	signature:(const mxArray *in, int **out)
mxArray2Civec	/usr/include/itpp/itmex.h	/^void mxArray2Civec(const mxArray *in, int *out)$/;"	f	namespace:itpp	signature:(const mxArray *in, int *out)
mxArray2Civec	/usr/include/itpp/itmex.h	/^void mxArray2Civec(const mxArray *in, int *out);$/;"	p	namespace:itpp	signature:(const mxArray *in, int *out)
mxArray2Cmat	/usr/include/itpp/itmex.h	/^void mxArray2Cmat(const mxArray *in, double **out)$/;"	f	namespace:itpp	signature:(const mxArray *in, double **out)
mxArray2Cmat	/usr/include/itpp/itmex.h	/^void mxArray2Cmat(const mxArray *in, double **out);$/;"	p	namespace:itpp	signature:(const mxArray *in, double **out)
mxArray2Csmat	/usr/include/itpp/itmex.h	/^void mxArray2Csmat(const mxArray *in, short **out)$/;"	f	namespace:itpp	signature:(const mxArray *in, short **out)
mxArray2Csmat	/usr/include/itpp/itmex.h	/^void mxArray2Csmat(const mxArray *in, short **out);$/;"	p	namespace:itpp	signature:(const mxArray *in, short **out)
mxArray2Csvec	/usr/include/itpp/itmex.h	/^void mxArray2Csvec(const mxArray *in, short *out)$/;"	f	namespace:itpp	signature:(const mxArray *in, short *out)
mxArray2Csvec	/usr/include/itpp/itmex.h	/^void mxArray2Csvec(const mxArray *in, short *out);$/;"	p	namespace:itpp	signature:(const mxArray *in, short *out)
mxArray2Cvec	/usr/include/itpp/itmex.h	/^void mxArray2Cvec(const mxArray *in, double *out)$/;"	f	namespace:itpp	signature:(const mxArray *in, double *out)
mxArray2Cvec	/usr/include/itpp/itmex.h	/^void mxArray2Cvec(const mxArray *in, double *out);$/;"	p	namespace:itpp	signature:(const mxArray *in, double *out)
mxArray2bin	/usr/include/itpp/itmex.h	/^bin mxArray2bin(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
mxArray2bin	/usr/include/itpp/itmex.h	/^bin mxArray2bin(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
mxArray2bmat	/usr/include/itpp/itmex.h	/^bmat mxArray2bmat(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
mxArray2bmat	/usr/include/itpp/itmex.h	/^bmat mxArray2bmat(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
mxArray2bvec	/usr/include/itpp/itmex.h	/^bvec mxArray2bvec(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
mxArray2bvec	/usr/include/itpp/itmex.h	/^bvec mxArray2bvec(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
mxArray2cmat	/usr/include/itpp/itmex.h	/^cmat mxArray2cmat(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
mxArray2cmat	/usr/include/itpp/itmex.h	/^cmat mxArray2cmat(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
mxArray2cvec	/usr/include/itpp/itmex.h	/^cvec mxArray2cvec(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
mxArray2cvec	/usr/include/itpp/itmex.h	/^cvec mxArray2cvec(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
mxArray2double	/usr/include/itpp/itmex.h	/^double mxArray2double(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
mxArray2double	/usr/include/itpp/itmex.h	/^double mxArray2double(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
mxArray2double_complex	/usr/include/itpp/itmex.h	/^std::complex<double> mxArray2double_complex(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
mxArray2double_complex	/usr/include/itpp/itmex.h	/^std::complex<double> mxArray2double_complex(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
mxArray2imat	/usr/include/itpp/itmex.h	/^imat mxArray2imat(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
mxArray2imat	/usr/include/itpp/itmex.h	/^imat mxArray2imat(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
mxArray2int	/usr/include/itpp/itmex.h	/^int mxArray2int(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
mxArray2int	/usr/include/itpp/itmex.h	/^int mxArray2int(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
mxArray2ivec	/usr/include/itpp/itmex.h	/^ivec mxArray2ivec(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
mxArray2ivec	/usr/include/itpp/itmex.h	/^ivec mxArray2ivec(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
mxArray2mat	/usr/include/itpp/itmex.h	/^mat mxArray2mat(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
mxArray2mat	/usr/include/itpp/itmex.h	/^mat mxArray2mat(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
mxArray2short	/usr/include/itpp/itmex.h	/^short mxArray2short(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
mxArray2short	/usr/include/itpp/itmex.h	/^short mxArray2short(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
mxArray2smat	/usr/include/itpp/itmex.h	/^smat mxArray2smat(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
mxArray2smat	/usr/include/itpp/itmex.h	/^smat mxArray2smat(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
mxArray2string	/usr/include/itpp/itmex.h	/^std::string mxArray2string(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
mxArray2string	/usr/include/itpp/itmex.h	/^std::string mxArray2string(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
mxArray2svec	/usr/include/itpp/itmex.h	/^svec mxArray2svec(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
mxArray2svec	/usr/include/itpp/itmex.h	/^svec mxArray2svec(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
mxArray2vec	/usr/include/itpp/itmex.h	/^vec mxArray2vec(const mxArray *in)$/;"	f	namespace:itpp	signature:(const mxArray *in)
mxArray2vec	/usr/include/itpp/itmex.h	/^vec mxArray2vec(const mxArray *in);$/;"	p	namespace:itpp	signature:(const mxArray *in)
n	/usr/include/itpp/comm/bch.h	/^  int n, k, t;$/;"	m	class:itpp::BCH	access:private
n	/usr/include/itpp/comm/convcode.h	/^  int n;$/;"	m	class:itpp::Convolutional_Code	access:protected
n	/usr/include/itpp/comm/hammcode.h	/^  short n, k;$/;"	m	class:itpp::Hamming_Code	access:private
n	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  int n, K, m;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
n	/usr/include/itpp/comm/reedsolomon.h	/^  int m, t, k, n, q;$/;"	m	class:itpp::Reed_Solomon	access:protected
n	/usr/include/itpp/optim/newton_search.h	/^  int n; \/\/ dimension of problem, size(x)$/;"	m	class:itpp::Line_Search	access:private
n	/usr/include/itpp/optim/newton_search.h	/^  int n; \/\/ dimension of problem, size(x)$/;"	m	class:itpp::Newton_Search	access:private
n1	/usr/include/itpp/comm/turbo.h	/^  int m_tail, n1, n2, n_tot, iterations;$/;"	m	class:itpp::Turbo_Codec	access:private
n2	/usr/include/itpp/comm/turbo.h	/^  int m_tail, n1, n2, n_tot, iterations;$/;"	m	class:itpp::Turbo_Codec	access:private
nRNG	/usr/include/itpp/base/random.h	/^  Normal_RNG nRNG;$/;"	m	class:itpp::Complex_Normal_RNG	access:private
nRNG	/usr/include/itpp/base/random.h	/^  Normal_RNG nRNG;$/;"	m	class:itpp::Rayleigh_RNG	access:private
nRNG	/usr/include/itpp/base/random.h	/^  Normal_RNG nRNG;$/;"	m	class:itpp::Rice_RNG	access:private
n_cols	/usr/include/itpp/base/smat.h	/^  int n_rows, n_cols;$/;"	m	class:itpp::Sparse_Mat	access:private
n_dopp	/usr/include/itpp/comm/channel.h	/^  double n_dopp; \/\/!< Normalized Doppler of the correlated fading$/;"	m	class:itpp::TDL_Channel	access:protected
n_dopp	/usr/include/itpp/comm/channel.h	/^  double n_dopp; \/\/!< Normalized maximum Doppler frequency$/;"	m	class:itpp::Correlated_Fading_Generator	access:protected
n_overflows	/usr/include/itpp/stat/misc_stat.h	/^  int n_overflows() const {return _n_overflows;}$/;"	f	class:itpp::Stat	access:public	signature:() const
n_rows	/usr/include/itpp/base/smat.h	/^  int n_rows, n_cols;$/;"	m	class:itpp::Sparse_Mat	access:private
n_samples	/usr/include/itpp/stat/misc_stat.h	/^  int n_samples() const {return _n_samples;}$/;"	f	class:itpp::Stat	access:public	signature:() const
n_tot	/usr/include/itpp/comm/turbo.h	/^  int m_tail, n1, n2, n_tot, iterations;$/;"	m	class:itpp::Turbo_Codec	access:private
n_unused_bits	/usr/include/itpp/fixed/fix_base.h	/^  int n_unused_bits;$/;"	m	class:itpp::Fix_Base	access:protected
n_zeros	/usr/include/itpp/stat/misc_stat.h	/^  int n_zeros() const {return _n_zeros;}$/;"	f	class:itpp::Stat	access:public	signature:() const
name	/usr/include/itpp/base/itfile.h	/^    std::string name;$/;"	m	struct:itpp::it_file_base::data_header	access:public
name	/usr/include/itpp/base/itfile.h	/^    std::string name;$/;"	m	struct:itpp::it_file_base_old::data_header	access:public
name	/usr/include/itpp/base/itfile.h	/^  const std::string& name;$/;"	m	class:itpp::Name	access:public
name	/usr/include/itpp/protocol/signals_slots.h	/^  std::string name;$/;"	m	class:itpp::ATimer	access:protected
name	/usr/include/itpp/protocol/signals_slots.h	/^  std::string name;$/;"	m	class:itpp::Base_Slot	access:protected
name	/usr/include/itpp/protocol/signals_slots.h	/^  std::string name;$/;"	m	class:itpp::Signal	access:protected
native_endianity	/usr/include/itpp/base/binfile.h	/^  endian native_endianity;$/;"	m	class:itpp::bfstream_base	access:protected
nbr_bytes_received	/usr/include/itpp/protocol/tcp_client_server.h	/^  unsigned nbr_bytes_received;$/;"	m	class:itpp::TCP_Client_Application	access:private
nbr_bytes_to_receive	/usr/include/itpp/protocol/tcp_client_server.h	/^  unsigned nbr_bytes_to_receive;$/;"	m	class:itpp::TCP_Client_Application	access:private
ncheck	/usr/include/itpp/comm/ldpc.h	/^  int ncheck;   \/\/!< Number of check nodes$/;"	m	class:itpp::LDPC_Code	access:protected
ncheck	/usr/include/itpp/comm/ldpc.h	/^  int ncheck;$/;"	m	class:itpp::LDPC_Parity	access:protected
ncols	/usr/include/itpp/base/gf2mat.h	/^  int nrows, ncols;            \/\/ number of rows and columns of matrix$/;"	m	class:itpp::GF2mat	access:private
ndata	/usr/include/itpp/base/array.h	/^  int ndata;$/;"	m	class:itpp::Array	access:protected
ndata	/usr/include/itpp/base/stack.h	/^  int ndata;$/;"	m	class:itpp::Stack	access:private
needed_bits	/usr/include/itpp/base/math/log_exp.h	/^inline int needed_bits(int n)$/;"	f	namespace:itpp	signature:(int n)
needed_bits	/usr/include/itpp/base/math/log_exp.h	/^inline ivec needed_bits(const ivec& v)$/;"	f	namespace:itpp	signature:(const ivec& v)
next	/usr/include/itpp/protocol/packet_generator.h	/^  Slot<Packet_Generator, Packet*> next;$/;"	m	class:itpp::Packet_Generator	access:private
next_desc	/usr/include/itpp/base/itfile.h	/^  std::string next_desc;$/;"	m	class:itpp::it_file	access:protected
next_expected	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number next_expected() const;   \/**< \\brief first byte missing *\/$/;"	p	class:itpp::TCP_Receiver_Buffer	access:public	signature:() const
next_expected	/usr/include/itpp/protocol/tcp.h	/^inline Sequence_Number TCP_Receiver_Buffer::next_expected() const$/;"	f	class:itpp::TCP_Receiver_Buffer	signature:() const
next_name	/usr/include/itpp/base/itfile.h	/^  std::string next_name;$/;"	m	class:itpp::it_file	access:protected
next_name	/usr/include/itpp/base/itfile.h	/^  std::string next_name;$/;"	m	class:itpp::it_file_old	access:protected
next_state	/usr/include/itpp/comm/convcode.h	/^  int next_state(const int instate, const int input) {$/;"	f	class:itpp::Convolutional_Code	access:protected	signature:(const int instate, const int input)
ng	/usr/include/itpp/optim/newton_search.h	/^  double F, ng, nh; \/\/ function value, stop_1, stop_2 values at solution point$/;"	m	class:itpp::Newton_Search	access:private
ng_values	/usr/include/itpp/optim/newton_search.h	/^  vec F_values, ng_values, Delta_values;$/;"	m	class:itpp::Newton_Search	access:private
nh	/usr/include/itpp/optim/newton_search.h	/^  double F, ng, nh; \/\/ function value, stop_1, stop_2 values at solution point$/;"	m	class:itpp::Newton_Search	access:private
nlist	/usr/include/itpp/base/gf2mat.h	/^  imat nlist;$/;"	m	class:itpp::GF2mat_sparse_alist	access:protected
nnz	/usr/include/itpp/base/smat.h	/^  int nnz();$/;"	p	class:itpp::Sparse_Mat	access:public	signature:()
nnz	/usr/include/itpp/base/smat.h	/^int Sparse_Mat<T>::nnz()$/;"	f	class:itpp::Sparse_Mat	signature:()
nnz	/usr/include/itpp/base/svec.h	/^  inline int nnz() {$/;"	f	class:itpp::Sparse_Vec	access:public	signature:()
no_carriers	/usr/include/itpp/comm/ofdm.h	/^  int no_carriers() {return Nfft;}$/;"	f	class:itpp::OFDM	access:public	signature:()
no_cols	/usr/include/itpp/base/mat.h	/^  int datasize, no_rows, no_cols;$/;"	m	class:itpp::Mat	access:protected
no_elements	/usr/include/itpp/base/stack.h	/^  int no_elements() const { return valptr; }$/;"	f	class:itpp::Stack	access:public	signature:() const
no_feval	/usr/include/itpp/optim/newton_search.h	/^  int no_feval; \/\/ info(3)$/;"	m	class:itpp::Line_Search	access:private
no_feval	/usr/include/itpp/optim/newton_search.h	/^  int no_feval; \/\/ number of function evaluations$/;"	m	class:itpp::Newton_Search	access:private
no_iter	/usr/include/itpp/optim/newton_search.h	/^  int no_iter; \/\/ number of iterations$/;"	m	class:itpp::Newton_Search	access:private
no_parity	/usr/include/itpp/comm/crc.h	/^  int no_parity;$/;"	m	class:itpp::CRC_Code	access:private
no_retransmit	/usr/include/itpp/protocol/selective_repeat.h	/^  int no_retransmit;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
no_rows	/usr/include/itpp/base/mat.h	/^  int datasize, no_rows, no_cols;$/;"	m	class:itpp::Mat	access:protected
no_states	/usr/include/itpp/comm/convcode.h	/^  int no_states;$/;"	m	class:itpp::Convolutional_Code	access:protected
nobits	/usr/include/itpp/srccode/vq.h	/^  int nobits() const;$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:() const
nobits	/usr/include/itpp/srccode/vq.h	/^inline int Vector_Quantizer::nobits() const { return levels2bits(Size); }$/;"	f	class:itpp::Vector_Quantizer	signature:() const
nof_inputs	/usr/include/itpp/protocol/packet_channel.h	/^  Slot<Packet_Channel, int> nof_inputs;$/;"	m	class:itpp::Packet_Channel	access:public
nof_ready_link_packets	/usr/include/itpp/protocol/selective_repeat.h	/^  int nof_ready_link_packets();$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:public	signature:()
nof_ready_packets	/usr/include/itpp/protocol/selective_repeat.h	/^  Signal<int> nof_ready_packets;         \/\/!< Delivers no ready packets.$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:public
norm	/usr/include/itpp/stat/misc_stat.h	/^double norm(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
norm	/usr/include/itpp/stat/misc_stat.h	/^double norm(const Vec<T> &v, const std::string &s)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, const std::string &s)
norm	/usr/include/itpp/stat/misc_stat.h	/^double norm(const Vec<T> &v, int p)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, int p)
norm	/usr/include/itpp/stat/misc_stat.h	/^double norm(const cmat &m, const std::string &s);$/;"	p	namespace:itpp	signature:(const cmat &m, const std::string &s)
norm	/usr/include/itpp/stat/misc_stat.h	/^double norm(const cmat &m, int p = 2);$/;"	p	namespace:itpp	signature:(const cmat &m, int p = 2)
norm	/usr/include/itpp/stat/misc_stat.h	/^double norm(const cvec &v);$/;"	p	namespace:itpp	signature:(const cvec &v)
norm	/usr/include/itpp/stat/misc_stat.h	/^double norm(const cvec &v, const std::string &s);$/;"	p	namespace:itpp	signature:(const cvec &v, const std::string &s)
norm	/usr/include/itpp/stat/misc_stat.h	/^double norm(const cvec &v, int p);$/;"	p	namespace:itpp	signature:(const cvec &v, int p)
norm	/usr/include/itpp/stat/misc_stat.h	/^double norm(const mat &m, const std::string &s);$/;"	p	namespace:itpp	signature:(const mat &m, const std::string &s)
norm	/usr/include/itpp/stat/misc_stat.h	/^double norm(const mat &m, int p = 2);$/;"	p	namespace:itpp	signature:(const mat &m, int p = 2)
norm_factor	/usr/include/itpp/base/random.h	/^  const double norm_factor;$/;"	m	class:itpp::Complex_Normal_RNG	access:private
norm_factor	/usr/include/itpp/comm/ofdm.h	/^  double norm_factor;$/;"	m	class:itpp::OFDM	access:private
norm_mu	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  vec norm_mu;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:private
norm_sd	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  vec norm_sd;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:private
normalise_vectors	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  void normalise_vectors();$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:protected	signature:()
normexp	/usr/include/itpp/srccode/gmm.h	/^  vec   normweight, normexp;$/;"	m	class:itpp::GMM	access:private
normweight	/usr/include/itpp/srccode/gmm.h	/^  vec   normweight, normexp;$/;"	m	class:itpp::GMM	access:private
now	/usr/include/itpp/protocol/events.h	/^  static Ttype now() {return t;}$/;"	f	class:itpp::Event_Queue	access:public	signature:()
nrof_elements	/usr/include/itpp/base/circular_buffer.h	/^  int nrof_elements() const { return _rw_dist; }$/;"	f	class:itpp::Circular_Buffer	access:public	signature:() const
nrof_freq	/usr/include/itpp/comm/channel.h	/^  int nrof_freq; \/\/!< Number of sine frequencies in the Rice MEDS fading generator$/;"	m	class:itpp::TDL_Channel	access:protected
nrows	/usr/include/itpp/base/gf2mat.h	/^  int nrows, ncols;            \/\/ number of rows and columns of matrix$/;"	m	class:itpp::GF2mat	access:private
nt	/usr/include/itpp/comm/modulator_nd.h	/^  int nt;$/;"	m	class:itpp::Modulator_ND	access:protected
numOfIC	/usr/include/itpp/signal/fastica.h	/^  int approach, numOfIC, g, initState;$/;"	m	class:itpp::Fast_ICA	access:private
num_bins	/usr/include/itpp/stat/histogram.h	/^  int num_bins;$/;"	m	class:itpp::Histogram	access:private
num_mlist	/usr/include/itpp/base/gf2mat.h	/^  ivec num_mlist;$/;"	m	class:itpp::GF2mat_sparse_alist	access:protected
num_nlist	/usr/include/itpp/base/gf2mat.h	/^  ivec num_nlist;$/;"	m	class:itpp::GF2mat_sparse_alist	access:protected
nvar	/usr/include/itpp/comm/ldpc.h	/^  int nvar;   \/\/!< Number of variable nodes$/;"	m	class:itpp::LDPC_Code	access:protected
nvar	/usr/include/itpp/comm/ldpc.h	/^  int nvar;$/;"	m	class:itpp::LDPC_Parity	access:protected
nwords	/usr/include/itpp/base/gf2mat.h	/^  int nwords;                  \/\/ number of bytes used$/;"	m	class:itpp::GF2mat	access:private
o_mode	/usr/include/itpp/fixed/fix_base.h	/^enum o_mode {$/;"	g	namespace:itpp
oct2bin	/usr/include/itpp/base/converters.h	/^bvec oct2bin(const ivec &octalindex, short keepzeros = 0);$/;"	p	namespace:itpp	signature:(const ivec &octalindex, short keepzeros = 0)
odd	/usr/include/itpp/base/random.h	/^  bool odd;$/;"	m	class:itpp::AR1_Normal_RNG	access:private
old_data	/usr/include/itpp/signal/freq_filt.h	/^  Vec<Num_T> old_data;$/;"	m	class:itpp::Freq_Filt	access:private
omode	/usr/include/itpp/fixed/fix_base.h	/^  o_mode omode;$/;"	m	class:itpp::Fix_Base	access:protected
omode	/usr/include/itpp/fixed/fix_factory.h	/^  o_mode omode;$/;"	m	class:itpp::Fix_Factory	access:protected
ones	/usr/include/itpp/base/mat.h	/^  void ones();$/;"	p	class:itpp::Mat	access:public	signature:()
ones	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::ones()$/;"	f	class:itpp::Mat	signature:()
ones	/usr/include/itpp/base/specmat.h	/^mat ones(int rows, int cols);$/;"	p	namespace:itpp	signature:(int rows, int cols)
ones	/usr/include/itpp/base/specmat.h	/^vec ones(int size);$/;"	p	namespace:itpp	signature:(int size)
ones	/usr/include/itpp/base/vec.h	/^  void ones();$/;"	p	class:itpp::Vec	access:public	signature:()
ones	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::ones()$/;"	f	class:itpp::Vec	signature:()
ones_b	/usr/include/itpp/base/specmat.h	/^bmat ones_b(int rows, int cols);$/;"	p	namespace:itpp	signature:(int rows, int cols)
ones_b	/usr/include/itpp/base/specmat.h	/^bvec ones_b(int size);$/;"	p	namespace:itpp	signature:(int size)
ones_c	/usr/include/itpp/base/specmat.h	/^cmat ones_c(int rows, int cols);$/;"	p	namespace:itpp	signature:(int rows, int cols)
ones_c	/usr/include/itpp/base/specmat.h	/^cvec ones_c(int size);$/;"	p	namespace:itpp	signature:(int size)
ones_i	/usr/include/itpp/base/specmat.h	/^imat ones_i(int rows, int cols);$/;"	p	namespace:itpp	signature:(int rows, int cols)
ones_i	/usr/include/itpp/base/specmat.h	/^ivec ones_i(int size);$/;"	p	namespace:itpp	signature:(int size)
open	/usr/include/itpp/base/binfile.h	/^  void open(const std::string& name, bool trunc = false, endian e = b_endian);$/;"	p	class:itpp::bfstream	access:public	signature:(const std::string& name, bool trunc = false, endian e = b_endian)
open	/usr/include/itpp/base/binfile.h	/^  void open(const std::string& name, endian e = b_endian);$/;"	p	class:itpp::bifstream	access:public	signature:(const std::string& name, endian e = b_endian)
open	/usr/include/itpp/base/binfile.h	/^  void open(const std::string& name, endian e = b_endian);$/;"	p	class:itpp::bofstream	access:public	signature:(const std::string& name, endian e = b_endian)
open	/usr/include/itpp/base/itfile.h	/^  void open(const std::string& filename);$/;"	p	class:itpp::it_ifile	access:public	signature:(const std::string& filename)
open	/usr/include/itpp/base/itfile.h	/^  void open(const std::string& filename, bool trunc = false);$/;"	p	class:itpp::it_file	access:public	signature:(const std::string& filename, bool trunc = false)
open	/usr/include/itpp/base/itfile.h	/^  void open(const std::string& name);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(const std::string& name)
open	/usr/include/itpp/base/itfile.h	/^  void open(const std::string& name, bool trunc = false);$/;"	p	class:itpp::it_file_old	access:public	signature:(const std::string& name, bool trunc = false)
open	/usr/include/itpp/srccode/audiofile.h	/^  bool open(const char *fname, int rate = 8000, data_encoding e = enc_linear16);$/;"	p	class:itpp::SND_Out_File	access:public	signature:(const char *fname, int rate = 8000, data_encoding e = enc_linear16)
open	/usr/include/itpp/srccode/audiofile.h	/^  virtual bool open(const char *fname);$/;"	p	class:itpp::SND_IO_File	access:public	signature:(const char *fname)
open	/usr/include/itpp/srccode/audiofile.h	/^  virtual bool open(const char *fname);$/;"	p	class:itpp::SND_In_File	access:public	signature:(const char *fname)
open_readonly	/usr/include/itpp/base/binfile.h	/^  void open_readonly(const std::string& name, endian e = b_endian);$/;"	p	class:itpp::bfstream	access:public	signature:(const std::string& name, endian e = b_endian)
operator !	/usr/include/itpp/base/binary.h	/^  bin operator!(void) const { return bin(b ^ 1); }$/;"	f	class:itpp::bin	access:public	signature:(void) const
operator !=	/usr/include/itpp/base/binary.h	/^  bool operator!=(const bin &inbin) const { return b != inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin) const
operator !=	/usr/include/itpp/base/binary.h	/^  bool operator!=(const int &i) const { return b != i; }$/;"	f	class:itpp::bin	access:public	signature:(const int &i) const
operator !=	/usr/include/itpp/base/mat.h	/^  bool operator!=(const Mat<Num_T> &m) const;$/;"	p	class:itpp::Mat	access:public	signature:(const Mat<Num_T> &m) const
operator !=	/usr/include/itpp/base/mat.h	/^bool Mat<Num_T>::operator!=(const Mat<Num_T> &m) const$/;"	f	class:itpp::Mat	signature:(const Mat<Num_T> &m) const
operator !=	/usr/include/itpp/base/vec.h	/^  Vec<bin> operator!=(Num_T t) const;$/;"	p	class:itpp::Vec	access:public	signature:(Num_T t) const
operator !=	/usr/include/itpp/base/vec.h	/^  bool operator!=(const Vec<Num_T> &v) const;$/;"	p	class:itpp::Vec	access:public	signature:(const Vec<Num_T> &v) const
operator !=	/usr/include/itpp/base/vec.h	/^bool Vec<Num_T>::operator!=(const Vec<Num_T> &invector) const$/;"	f	class:itpp::Vec	signature:(const Vec<Num_T> &invector) const
operator !=	/usr/include/itpp/base/vec.h	/^bvec Vec<Num_T>::operator!=(Num_T t) const$/;"	f	class:itpp::Vec	signature:(Num_T t) const
operator !=	/usr/include/itpp/base/vec.h	/^bvec Vec<std::complex<double> >::operator!=(std::complex<double>) const;$/;"	p	class:itpp::Vec	signature:(std::complex<double>) const
operator !=	/usr/include/itpp/comm/galois.h	/^  int operator!=(const GF &ingf) const;$/;"	p	class:itpp::GF	access:public	signature:(const GF &ingf) const
operator !=	/usr/include/itpp/comm/galois.h	/^inline int GF::operator!=(const GF &ingf) const$/;"	f	class:itpp::GF	signature:(const GF &ingf) const
operator !=	/usr/include/itpp/protocol/tcp.h	/^  bool operator!=(const Sequence_Number &n) const { return seq != n.seq; }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const Sequence_Number &n) const
operator !=	/usr/include/itpp/protocol/tcp.h	/^  bool operator!=(const TCP_Segment &segment) const;$/;"	p	class:itpp::TCP_Segment	access:public	signature:(const TCP_Segment &segment) const
operator !=	/usr/include/itpp/protocol/tcp.h	/^inline bool TCP_Segment::operator!=(const TCP_Segment &segment) const$/;"	f	class:itpp::TCP_Segment	signature:(const TCP_Segment &segment) const
operator &	/usr/include/itpp/base/binary.h	/^  bin operator&(const bin &inbin) const { return bin(b & inbin.b); }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin) const
operator &=	/usr/include/itpp/base/binary.h	/^  void operator&=(const bin &inbin) { b &= inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin)
operator ()	/usr/include/itpp/base/array.h	/^  T &operator()(int i);$/;"	p	class:itpp::Array	access:public	signature:(int i)
operator ()	/usr/include/itpp/base/array.h	/^  const Array<T> operator()(const Array<int> &indices) const;$/;"	p	class:itpp::Array	access:public	signature:(const Array<int> &indices) const
operator ()	/usr/include/itpp/base/array.h	/^  const Array<T> operator()(int i1, int i2) const;$/;"	p	class:itpp::Array	access:public	signature:(int i1, int i2) const
operator ()	/usr/include/itpp/base/array.h	/^  const T &operator()(int i) const;$/;"	p	class:itpp::Array	access:public	signature:(int i) const
operator ()	/usr/include/itpp/base/array.h	/^T& Array<T>::operator()(int i)$/;"	f	class:itpp::Array	signature:(int i)
operator ()	/usr/include/itpp/base/array.h	/^const Array<T> Array<T>::operator()(const Array<int> &indices) const$/;"	f	class:itpp::Array	signature:(const Array<int> &indices) const
operator ()	/usr/include/itpp/base/array.h	/^const Array<T> Array<T>::operator()(int i1, int i2) const$/;"	f	class:itpp::Array	signature:(int i1, int i2) const
operator ()	/usr/include/itpp/base/array.h	/^const T& Array<T>::operator()(int i) const$/;"	f	class:itpp::Array	signature:(int i) const
operator ()	/usr/include/itpp/base/gf2mat.h	/^  inline bin operator()(int i, int j) const { return get(i, j); };$/;"	f	class:itpp::GF2mat	access:public	signature:(int i, int j) const
operator ()	/usr/include/itpp/base/mat.h	/^  Mat<Num_T> operator()(int r1, int r2, int c1, int c2) const;$/;"	p	class:itpp::Mat	access:public	signature:(int r1, int r2, int c1, int c2) const
operator ()	/usr/include/itpp/base/mat.h	/^  Num_T &operator()(int i);$/;"	p	class:itpp::Mat	access:public	signature:(int i)
operator ()	/usr/include/itpp/base/mat.h	/^  Num_T &operator()(int r, int c);$/;"	p	class:itpp::Mat	access:public	signature:(int r, int c)
operator ()	/usr/include/itpp/base/mat.h	/^  const Num_T &operator()(int i) const;$/;"	p	class:itpp::Mat	access:public	signature:(int i) const
operator ()	/usr/include/itpp/base/mat.h	/^  const Num_T &operator()(int r, int c) const;$/;"	p	class:itpp::Mat	access:public	signature:(int r, int c) const
operator ()	/usr/include/itpp/base/mat.h	/^Mat<Num_T> Mat<Num_T>::operator()(int r1, int r2, int c1, int c2) const$/;"	f	class:itpp::Mat	signature:(int r1, int r2, int c1, int c2) const
operator ()	/usr/include/itpp/base/mat.h	/^Num_T& Mat<Num_T>::operator()(int i)$/;"	f	class:itpp::Mat	signature:(int i)
operator ()	/usr/include/itpp/base/mat.h	/^Num_T& Mat<Num_T>::operator()(int r, int c)$/;"	f	class:itpp::Mat	signature:(int r, int c)
operator ()	/usr/include/itpp/base/mat.h	/^const Num_T& Mat<Num_T>::operator()(int i) const$/;"	f	class:itpp::Mat	signature:(int i) const
operator ()	/usr/include/itpp/base/mat.h	/^const Num_T& Mat<Num_T>::operator()(int r, int c) const$/;"	f	class:itpp::Mat	signature:(int r, int c) const
operator ()	/usr/include/itpp/base/random.h	/^  bin operator()() { return sample(); }$/;"	f	class:itpp::Bernoulli_RNG	access:public	signature:()
operator ()	/usr/include/itpp/base/random.h	/^  bmat operator()(int h, int w) { bmat temp(h, w); sample_matrix(h, w, temp); return temp; }$/;"	f	class:itpp::Bernoulli_RNG	access:public	signature:(int h, int w)
operator ()	/usr/include/itpp/base/random.h	/^  bvec operator()(int n) { bvec temp(n); sample_vector(n, temp); return temp; }$/;"	f	class:itpp::Bernoulli_RNG	access:public	signature:(int n)
operator ()	/usr/include/itpp/base/random.h	/^  cmat operator()(int h, int w) {$/;"	f	class:itpp::Complex_Normal_RNG	access:public	signature:(int h, int w)
operator ()	/usr/include/itpp/base/random.h	/^  cvec operator()(int n) {$/;"	f	class:itpp::Complex_Normal_RNG	access:public	signature:(int n)
operator ()	/usr/include/itpp/base/random.h	/^  double operator()() { return (sample() * (hi_bound - lo_bound) + lo_bound); }$/;"	f	class:itpp::Uniform_RNG	access:public	signature:()
operator ()	/usr/include/itpp/base/random.h	/^  double operator()() { return (sigma*sample() + mean); }$/;"	f	class:itpp::Normal_RNG	access:public	signature:()
operator ()	/usr/include/itpp/base/random.h	/^  double operator()() { return sample(); }$/;"	f	class:itpp::AR1_Normal_RNG	access:public	signature:()
operator ()	/usr/include/itpp/base/random.h	/^  double operator()() { return sample(); }$/;"	f	class:itpp::Exponential_RNG	access:public	signature:()
operator ()	/usr/include/itpp/base/random.h	/^  double operator()() { return sample(); }$/;"	f	class:itpp::Laplace_RNG	access:public	signature:()
operator ()	/usr/include/itpp/base/random.h	/^  double operator()() { return sample(); }$/;"	f	class:itpp::Rayleigh_RNG	access:public	signature:()
operator ()	/usr/include/itpp/base/random.h	/^  double operator()() { return sample(); }$/;"	f	class:itpp::Rice_RNG	access:public	signature:()
operator ()	/usr/include/itpp/base/random.h	/^  double operator()() { return sample(); }$/;"	f	class:itpp::Weibull_RNG	access:public	signature:()
operator ()	/usr/include/itpp/base/random.h	/^  imat operator()(int h, int w);$/;"	p	class:itpp::I_Uniform_RNG	access:public	signature:(int h, int w)
operator ()	/usr/include/itpp/base/random.h	/^  int operator()() { return sample(); }$/;"	f	class:itpp::I_Uniform_RNG	access:public	signature:()
operator ()	/usr/include/itpp/base/random.h	/^  ivec operator()(int n);$/;"	p	class:itpp::I_Uniform_RNG	access:public	signature:(int n)
operator ()	/usr/include/itpp/base/random.h	/^  mat operator()(int h, int w) {$/;"	f	class:itpp::Normal_RNG	access:public	signature:(int h, int w)
operator ()	/usr/include/itpp/base/random.h	/^  mat operator()(int h, int w) {$/;"	f	class:itpp::Uniform_RNG	access:public	signature:(int h, int w)
operator ()	/usr/include/itpp/base/random.h	/^  mat operator()(int h, int w);$/;"	p	class:itpp::AR1_Normal_RNG	access:public	signature:(int h, int w)
operator ()	/usr/include/itpp/base/random.h	/^  mat operator()(int h, int w);$/;"	p	class:itpp::Exponential_RNG	access:public	signature:(int h, int w)
operator ()	/usr/include/itpp/base/random.h	/^  mat operator()(int h, int w);$/;"	p	class:itpp::Laplace_RNG	access:public	signature:(int h, int w)
operator ()	/usr/include/itpp/base/random.h	/^  mat operator()(int h, int w);$/;"	p	class:itpp::Rayleigh_RNG	access:public	signature:(int h, int w)
operator ()	/usr/include/itpp/base/random.h	/^  mat operator()(int h, int w);$/;"	p	class:itpp::Rice_RNG	access:public	signature:(int h, int w)
operator ()	/usr/include/itpp/base/random.h	/^  mat operator()(int h, int w);$/;"	p	class:itpp::Weibull_RNG	access:public	signature:(int h, int w)
operator ()	/usr/include/itpp/base/random.h	/^  std::complex<double> operator()() { return sigma*sample() + m; }$/;"	f	class:itpp::Complex_Normal_RNG	access:public	signature:()
operator ()	/usr/include/itpp/base/random.h	/^  vec operator()(int n) {$/;"	f	class:itpp::Normal_RNG	access:public	signature:(int n)
operator ()	/usr/include/itpp/base/random.h	/^  vec operator()(int n) {$/;"	f	class:itpp::Uniform_RNG	access:public	signature:(int n)
operator ()	/usr/include/itpp/base/random.h	/^  vec operator()(int n);$/;"	p	class:itpp::AR1_Normal_RNG	access:public	signature:(int n)
operator ()	/usr/include/itpp/base/random.h	/^  vec operator()(int n);$/;"	p	class:itpp::Exponential_RNG	access:public	signature:(int n)
operator ()	/usr/include/itpp/base/random.h	/^  vec operator()(int n);$/;"	p	class:itpp::Laplace_RNG	access:public	signature:(int n)
operator ()	/usr/include/itpp/base/random.h	/^  vec operator()(int n);$/;"	p	class:itpp::Rayleigh_RNG	access:public	signature:(int n)
operator ()	/usr/include/itpp/base/random.h	/^  vec operator()(int n);$/;"	p	class:itpp::Rice_RNG	access:public	signature:(int n)
operator ()	/usr/include/itpp/base/random.h	/^  vec operator()(int n);$/;"	p	class:itpp::Weibull_RNG	access:public	signature:(int n)
operator ()	/usr/include/itpp/base/smat.h	/^  T operator()(int r, int c) const;$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(int r, int c) const
operator ()	/usr/include/itpp/base/smat.h	/^T Sparse_Mat<T>::operator()(int r, int c) const$/;"	f	class:itpp::Sparse_Mat	signature:(int r, int c) const
operator ()	/usr/include/itpp/base/svec.h	/^  T operator()(int i) const;$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(int i) const
operator ()	/usr/include/itpp/base/svec.h	/^T Sparse_Vec<T>::operator()(int i) const$/;"	f	class:itpp::Sparse_Vec	signature:(int i) const
operator ()	/usr/include/itpp/base/vec.h	/^  Num_T &operator()(int i);$/;"	p	class:itpp::Vec	access:public	signature:(int i)
operator ()	/usr/include/itpp/base/vec.h	/^  const Num_T &operator()(int i) const;$/;"	p	class:itpp::Vec	access:public	signature:(int i) const
operator ()	/usr/include/itpp/base/vec.h	/^  const Vec<Num_T> operator()(const Vec<int> &indexlist) const;$/;"	p	class:itpp::Vec	access:public	signature:(const Vec<int> &indexlist) const
operator ()	/usr/include/itpp/base/vec.h	/^  const Vec<Num_T> operator()(int i1, int i2) const;$/;"	p	class:itpp::Vec	access:public	signature:(int i1, int i2) const
operator ()	/usr/include/itpp/base/vec.h	/^Num_T& Vec<Num_T>::operator()(int i)$/;"	f	class:itpp::Vec	signature:(int i)
operator ()	/usr/include/itpp/base/vec.h	/^const Num_T& Vec<Num_T>::operator()(int i) const$/;"	f	class:itpp::Vec	signature:(int i) const
operator ()	/usr/include/itpp/base/vec.h	/^const Vec<Num_T> Vec<Num_T>::operator()(const Vec<int> &indexlist) const$/;"	f	class:itpp::Vec	signature:(const Vec<int> &indexlist) const
operator ()	/usr/include/itpp/base/vec.h	/^const Vec<Num_T> Vec<Num_T>::operator()(int i1, int i2) const$/;"	f	class:itpp::Vec	signature:(int i1, int i2) const
operator ()	/usr/include/itpp/comm/channel.h	/^  bvec operator()(const bvec &input);$/;"	p	class:itpp::BSC	access:public	signature:(const bvec &input)
operator ()	/usr/include/itpp/comm/channel.h	/^  cvec operator()(const cvec &input);$/;"	p	class:itpp::AWGN_Channel	access:public	signature:(const cvec &input)
operator ()	/usr/include/itpp/comm/channel.h	/^  cvec operator()(const cvec &input);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cvec &input)
operator ()	/usr/include/itpp/comm/channel.h	/^  cvec operator()(const cvec &input, Array<cvec> &channel_coeff);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cvec &input, Array<cvec> &channel_coeff)
operator ()	/usr/include/itpp/comm/channel.h	/^  cvec operator()(const cvec &input, cmat &channel_coeff);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cvec &input, cmat &channel_coeff)
operator ()	/usr/include/itpp/comm/channel.h	/^  vec operator()(const vec &input);$/;"	p	class:itpp::AWGN_Channel	access:public	signature:(const vec &input)
operator ()	/usr/include/itpp/comm/channel.h	/^  void operator()(const cvec &input, cvec &output, Array<cvec> &channel_coeff);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cvec &input, cvec &output, Array<cvec> &channel_coeff)
operator ()	/usr/include/itpp/comm/channel.h	/^  void operator()(const cvec &input, cvec &output, cmat &channel_coeff);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const cvec &input, cvec &output, cmat &channel_coeff)
operator ()	/usr/include/itpp/comm/galois.h	/^  GF operator()(const GF &ingf);$/;"	p	class:itpp::GFX	access:public	signature:(const GF &ingf)
operator ()	/usr/include/itpp/comm/galois.h	/^inline GF GFX::operator()(const GF &ingf)$/;"	f	class:itpp::GFX	signature:(const GF &ingf)
operator ()	/usr/include/itpp/comm/ldpc.h	/^  bin operator()(int i, int j) const {$/;"	f	class:itpp::LDPC_Parity	access:public	signature:(int i, int j) const
operator ()	/usr/include/itpp/protocol/events.h	/^  bool operator()(Base_Event *event1, Base_Event *event2) {$/;"	f	struct:itpp::Compare_Base_Event_Times	access:public	signature:(Base_Event *event1, Base_Event *event2)
operator ()	/usr/include/itpp/protocol/signals_slots.h	/^  Base_Event* operator()(DataType signal, const Ttype delta_time = 0);$/;"	p	class:itpp::Signal	access:public	signature:(DataType signal, const Ttype delta_time = 0)
operator ()	/usr/include/itpp/protocol/signals_slots.h	/^  virtual void operator()(DataType signal) = 0;$/;"	p	class:itpp::Base_Slot	access:public	signature:(DataType signal)
operator ()	/usr/include/itpp/protocol/signals_slots.h	/^  void operator()(DataType u);$/;"	p	class:itpp::Slot	access:public	signature:(DataType u)
operator ()	/usr/include/itpp/protocol/signals_slots.h	/^Base_Event* Signal<DataType>::operator()(DataType signal, const Ttype delta_time)$/;"	f	class:itpp::Signal	signature:(DataType signal, const Ttype delta_time)
operator ()	/usr/include/itpp/protocol/signals_slots.h	/^void Slot<ObjectType, DataType>::operator()(DataType signal)$/;"	f	class:itpp::Slot	signature:(DataType signal)
operator ()	/usr/include/itpp/signal/filter.h	/^  virtual T3 operator()(const T1 Sample) { return filter(Sample); }$/;"	f	class:itpp::Filter	access:public	signature:(const T1 Sample)
operator ()	/usr/include/itpp/signal/filter.h	/^  virtual Vec<T3> operator()(const Vec<T1> &v);$/;"	p	class:itpp::Filter	access:public	signature:(const Vec<T1> &v)
operator ()	/usr/include/itpp/signal/filter.h	/^Vec<T3> Filter<T1, T2, T3>::operator()(const Vec<T1> &x)$/;"	f	class:itpp::Filter	signature:(const Vec<T1> &x)
operator ()	/usr/include/itpp/signal/source.h	/^  double operator()() { return sample(); }$/;"	f	class:itpp::Impulse_Source	access:public	signature:()
operator ()	/usr/include/itpp/signal/source.h	/^  double operator()() { return sample(); }$/;"	f	class:itpp::Pattern_Source	access:public	signature:()
operator ()	/usr/include/itpp/signal/source.h	/^  double operator()() { return sample(); }$/;"	f	class:itpp::Sawtooth_Source	access:public	signature:()
operator ()	/usr/include/itpp/signal/source.h	/^  double operator()() { return sample(); }$/;"	f	class:itpp::Sine_Source	access:public	signature:()
operator ()	/usr/include/itpp/signal/source.h	/^  double operator()() { return sample(); }$/;"	f	class:itpp::Square_Source	access:public	signature:()
operator ()	/usr/include/itpp/signal/source.h	/^  double operator()() { return sample(); }$/;"	f	class:itpp::Triangle_Source	access:public	signature:()
operator ()	/usr/include/itpp/signal/source.h	/^  mat operator()(int h, int w);$/;"	p	class:itpp::Impulse_Source	access:public	signature:(int h, int w)
operator ()	/usr/include/itpp/signal/source.h	/^  mat operator()(int h, int w);$/;"	p	class:itpp::Pattern_Source	access:public	signature:(int h, int w)
operator ()	/usr/include/itpp/signal/source.h	/^  mat operator()(int h, int w);$/;"	p	class:itpp::Sawtooth_Source	access:public	signature:(int h, int w)
operator ()	/usr/include/itpp/signal/source.h	/^  mat operator()(int h, int w);$/;"	p	class:itpp::Sine_Source	access:public	signature:(int h, int w)
operator ()	/usr/include/itpp/signal/source.h	/^  mat operator()(int h, int w);$/;"	p	class:itpp::Square_Source	access:public	signature:(int h, int w)
operator ()	/usr/include/itpp/signal/source.h	/^  mat operator()(int h, int w);$/;"	p	class:itpp::Triangle_Source	access:public	signature:(int h, int w)
operator ()	/usr/include/itpp/signal/source.h	/^  vec operator()(int n);$/;"	p	class:itpp::Impulse_Source	access:public	signature:(int n)
operator ()	/usr/include/itpp/signal/source.h	/^  vec operator()(int n);$/;"	p	class:itpp::Pattern_Source	access:public	signature:(int n)
operator ()	/usr/include/itpp/signal/source.h	/^  vec operator()(int n);$/;"	p	class:itpp::Sawtooth_Source	access:public	signature:(int n)
operator ()	/usr/include/itpp/signal/source.h	/^  vec operator()(int n);$/;"	p	class:itpp::Sine_Source	access:public	signature:(int n)
operator ()	/usr/include/itpp/signal/source.h	/^  vec operator()(int n);$/;"	p	class:itpp::Square_Source	access:public	signature:(int n)
operator ()	/usr/include/itpp/signal/source.h	/^  vec operator()(int n);$/;"	p	class:itpp::Triangle_Source	access:public	signature:(int n)
operator ()	/usr/include/itpp/srccode/vq.h	/^  double operator()(double x) const;$/;"	p	class:itpp::Scalar_Quantizer	access:public	signature:(double x) const
operator ()	/usr/include/itpp/srccode/vq.h	/^  vec operator()(const vec &x) const;$/;"	p	class:itpp::Scalar_Quantizer	access:public	signature:(const vec &x) const
operator ()	/usr/include/itpp/srccode/vq.h	/^  vec operator()(const vec &x);$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:(const vec &x)
operator ()	/usr/include/itpp/srccode/vq.h	/^inline double Scalar_Quantizer::operator()(double x) const { return Q(x); }$/;"	f	class:itpp::Scalar_Quantizer	signature:(double x) const
operator ()	/usr/include/itpp/srccode/vq.h	/^inline vec Scalar_Quantizer::operator()(const vec &x)  const { return Q(x); }$/;"	f	class:itpp::Scalar_Quantizer	signature:(const vec &x) const
operator ()	/usr/include/itpp/srccode/vq.h	/^inline vec Vector_Quantizer::operator()(const vec &x) { return Q(x); }$/;"	f	class:itpp::Vector_Quantizer	signature:(const vec &x)
operator *	/usr/include/itpp/base/binary.h	/^  bin operator*(const bin &inbin) const { return bin(b & inbin.b); }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin) const
operator *	/usr/include/itpp/base/gf2mat.h	/^  friend GF2mat operator*(const GF2mat &X, const GF2mat &Y);$/;"	p	class:itpp::GF2mat	access:friend	signature:(const GF2mat &X, const GF2mat &Y)
operator *	/usr/include/itpp/base/gf2mat.h	/^  friend bvec operator*(const GF2mat &X, const bvec &y);$/;"	p	class:itpp::GF2mat	access:friend	signature:(const GF2mat &X, const bvec &y)
operator *	/usr/include/itpp/base/gf2mat.h	/^GF2mat operator*(const GF2mat &X, const GF2mat &Y);$/;"	p	namespace:itpp	signature:(const GF2mat &X, const GF2mat &Y)
operator *	/usr/include/itpp/base/gf2mat.h	/^bvec operator*(const GF2mat &X, const bvec &y);$/;"	p	namespace:itpp	signature:(const GF2mat &X, const bvec &y)
operator *	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator*(Num_T t, const Mat<Num_T> &m)$/;"	f	namespace:itpp	signature:(Num_T t, const Mat<Num_T> &m)
operator *	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator*(Num_T t, const Mat<Num_T> &m);$/;"	p	namespace:itpp	signature:(Num_T t, const Mat<Num_T> &m)
operator *	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator*(const Mat<Num_T> &m, Num_T t)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m, Num_T t)
operator *	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator*(const Mat<Num_T> &m, Num_T t);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m, Num_T t)
operator *	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator*(const Mat<Num_T> &m1, const Mat<Num_T> &m2)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
operator *	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator*(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
operator *	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator*(const Vec<Num_T> &v, const Mat<Num_T> &m)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v, const Mat<Num_T> &m)
operator *	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator*(const Vec<Num_T> &v, const Mat<Num_T> &m);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v, const Mat<Num_T> &m)
operator *	/usr/include/itpp/base/mat.h	/^Vec<Num_T> operator*(const Mat<Num_T> &m, const Vec<Num_T> &v)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m, const Vec<Num_T> &v)
operator *	/usr/include/itpp/base/mat.h	/^Vec<Num_T> operator*(const Mat<Num_T> &m, const Vec<Num_T> &v);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m, const Vec<Num_T> &v)
operator *	/usr/include/itpp/base/mat.h	/^extern template bmat operator*(bin t, const bmat &m);$/;"	p	namespace:itpp	signature:(bin t, const bmat &m)
operator *	/usr/include/itpp/base/mat.h	/^extern template bmat operator*(const bmat &m, bin t);$/;"	p	namespace:itpp	signature:(const bmat &m, bin t)
operator *	/usr/include/itpp/base/mat.h	/^extern template bmat operator*(const bmat &m1, const bmat &m2);$/;"	p	namespace:itpp	signature:(const bmat &m1, const bmat &m2)
operator *	/usr/include/itpp/base/mat.h	/^extern template bmat operator*(const bvec &v, const bmat &m);$/;"	p	namespace:itpp	signature:(const bvec &v, const bmat &m)
operator *	/usr/include/itpp/base/mat.h	/^extern template bvec operator*(const bmat &m, const bvec &v);$/;"	p	namespace:itpp	signature:(const bmat &m, const bvec &v)
operator *	/usr/include/itpp/base/mat.h	/^extern template cmat operator*(const cmat &m, std::complex<double> t);$/;"	p	namespace:itpp	signature:(const cmat &m, std::complex<double> t)
operator *	/usr/include/itpp/base/mat.h	/^extern template cmat operator*(const cmat &m1, const cmat &m2);$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2)
operator *	/usr/include/itpp/base/mat.h	/^extern template cmat operator*(const cvec &v, const cmat &m);$/;"	p	namespace:itpp	signature:(const cvec &v, const cmat &m)
operator *	/usr/include/itpp/base/mat.h	/^extern template cmat operator*(std::complex<double> t, const cmat &m);$/;"	p	namespace:itpp	signature:(std::complex<double> t, const cmat &m)
operator *	/usr/include/itpp/base/mat.h	/^extern template cvec operator*(const cmat &m, const cvec &v);$/;"	p	namespace:itpp	signature:(const cmat &m, const cvec &v)
operator *	/usr/include/itpp/base/mat.h	/^extern template imat operator*(const imat &m, int t);$/;"	p	namespace:itpp	signature:(const imat &m, int t)
operator *	/usr/include/itpp/base/mat.h	/^extern template imat operator*(const imat &m1, const imat &m2);$/;"	p	namespace:itpp	signature:(const imat &m1, const imat &m2)
operator *	/usr/include/itpp/base/mat.h	/^extern template imat operator*(const ivec &v, const imat &m);$/;"	p	namespace:itpp	signature:(const ivec &v, const imat &m)
operator *	/usr/include/itpp/base/mat.h	/^extern template imat operator*(int t, const imat &m);$/;"	p	namespace:itpp	signature:(int t, const imat &m)
operator *	/usr/include/itpp/base/mat.h	/^extern template ivec operator*(const imat &m, const ivec &v);$/;"	p	namespace:itpp	signature:(const imat &m, const ivec &v)
operator *	/usr/include/itpp/base/mat.h	/^extern template mat operator*(const mat &m, double t);$/;"	p	namespace:itpp	signature:(const mat &m, double t)
operator *	/usr/include/itpp/base/mat.h	/^extern template mat operator*(const mat &m1, const mat &m2);$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2)
operator *	/usr/include/itpp/base/mat.h	/^extern template mat operator*(const vec &v, const mat &m);$/;"	p	namespace:itpp	signature:(const vec &v, const mat &m)
operator *	/usr/include/itpp/base/mat.h	/^extern template mat operator*(double t, const mat &m);$/;"	p	namespace:itpp	signature:(double t, const mat &m)
operator *	/usr/include/itpp/base/mat.h	/^extern template smat operator*(const smat &m, short t);$/;"	p	namespace:itpp	signature:(const smat &m, short t)
operator *	/usr/include/itpp/base/mat.h	/^extern template smat operator*(const smat &m1, const smat &m2);$/;"	p	namespace:itpp	signature:(const smat &m1, const smat &m2)
operator *	/usr/include/itpp/base/mat.h	/^extern template smat operator*(const svec &v, const smat &m);$/;"	p	namespace:itpp	signature:(const svec &v, const smat &m)
operator *	/usr/include/itpp/base/mat.h	/^extern template smat operator*(short t, const smat &m);$/;"	p	namespace:itpp	signature:(short t, const smat &m)
operator *	/usr/include/itpp/base/mat.h	/^extern template svec operator*(const smat &m, const svec &v);$/;"	p	namespace:itpp	signature:(const smat &m, const svec &v)
operator *	/usr/include/itpp/base/mat.h	/^extern template vec operator*(const mat &m, const vec &v);$/;"	p	namespace:itpp	signature:(const mat &m, const vec &v)
operator *	/usr/include/itpp/base/mat.h	/^template<> cmat operator*(const cmat &m1, const cmat &m2);$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2)
operator *	/usr/include/itpp/base/mat.h	/^template<> cvec operator*(const cmat &m, const cvec &v);$/;"	p	namespace:itpp	signature:(const cmat &m, const cvec &v)
operator *	/usr/include/itpp/base/mat.h	/^template<> mat operator*(const mat &m1, const mat &m2);$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2)
operator *	/usr/include/itpp/base/mat.h	/^template<> vec operator*(const mat &m, const vec &v);$/;"	p	namespace:itpp	signature:(const mat &m, const vec &v)
operator *	/usr/include/itpp/base/operators.h	/^cmat operator*(const double &s, const cmat &m);$/;"	p	namespace:itpp	signature:(const double &s, const cmat &m)
operator *	/usr/include/itpp/base/operators.h	/^cmat operator*(const std::complex<double> &s, const mat &m);$/;"	p	namespace:itpp	signature:(const std::complex<double> &s, const mat &m)
operator *	/usr/include/itpp/base/operators.h	/^cvec operator*(const double &s, const cvec &v);$/;"	p	namespace:itpp	signature:(const double &s, const cvec &v)
operator *	/usr/include/itpp/base/operators.h	/^cvec operator*(const std::complex<double> &s, const ivec &v);$/;"	p	namespace:itpp	signature:(const std::complex<double> &s, const ivec &v)
operator *	/usr/include/itpp/base/operators.h	/^cvec operator*(const std::complex<double> &s, const vec &v);$/;"	p	namespace:itpp	signature:(const std::complex<double> &s, const vec &v)
operator *	/usr/include/itpp/base/operators.h	/^cvec operator*(const vec &v, const std::complex<double> &s);$/;"	p	namespace:itpp	signature:(const vec &v, const std::complex<double> &s)
operator *	/usr/include/itpp/base/operators.h	/^double operator*(const bvec &a, const vec &b);$/;"	p	namespace:itpp	signature:(const bvec &a, const vec &b)
operator *	/usr/include/itpp/base/operators.h	/^double operator*(const ivec &a, const vec &b);$/;"	p	namespace:itpp	signature:(const ivec &a, const vec &b)
operator *	/usr/include/itpp/base/operators.h	/^double operator*(const svec &a, const vec &b);$/;"	p	namespace:itpp	signature:(const svec &a, const vec &b)
operator *	/usr/include/itpp/base/operators.h	/^inline cmat operator*(const bmat &a, const cmat &b) {return to_cmat(a)*b;}$/;"	f	namespace:itpp	signature:(const bmat &a, const cmat &b)
operator *	/usr/include/itpp/base/operators.h	/^inline cmat operator*(const cmat &a, const bmat &b) {return a*to_cmat(b);}$/;"	f	namespace:itpp	signature:(const cmat &a, const bmat &b)
operator *	/usr/include/itpp/base/operators.h	/^inline cmat operator*(const cmat &a, const imat &b) {return a*to_cmat(b);}$/;"	f	namespace:itpp	signature:(const cmat &a, const imat &b)
operator *	/usr/include/itpp/base/operators.h	/^inline cmat operator*(const cmat &a, const mat &b) {return a*to_cmat(b);}$/;"	f	namespace:itpp	signature:(const cmat &a, const mat &b)
operator *	/usr/include/itpp/base/operators.h	/^inline cmat operator*(const cmat &a, const smat &b) {return a*to_cmat(b);}$/;"	f	namespace:itpp	signature:(const cmat &a, const smat &b)
operator *	/usr/include/itpp/base/operators.h	/^inline cmat operator*(const imat &a, const cmat &b) {return to_cmat(a)*b;}$/;"	f	namespace:itpp	signature:(const imat &a, const cmat &b)
operator *	/usr/include/itpp/base/operators.h	/^inline cmat operator*(const mat &a, const cmat &b) {return to_cmat(a)*b;}$/;"	f	namespace:itpp	signature:(const mat &a, const cmat &b)
operator *	/usr/include/itpp/base/operators.h	/^inline cmat operator*(const mat &m, const std::complex<double> &s) {return s*m;}$/;"	f	namespace:itpp	signature:(const mat &m, const std::complex<double> &s)
operator *	/usr/include/itpp/base/operators.h	/^inline cmat operator*(const smat &a, const cmat &b) {return to_cmat(a)*b;}$/;"	f	namespace:itpp	signature:(const smat &a, const cmat &b)
operator *	/usr/include/itpp/base/operators.h	/^inline cvec operator*(const cvec &v, const double &s) {return s*v;}$/;"	f	namespace:itpp	signature:(const cvec &v, const double &s)
operator *	/usr/include/itpp/base/operators.h	/^inline cvec operator*(const cvec &v, const float &s) {return s*v;}$/;"	f	namespace:itpp	signature:(const cvec &v, const float &s)
operator *	/usr/include/itpp/base/operators.h	/^inline cvec operator*(const cvec &v, const int &s) {return s*v;}$/;"	f	namespace:itpp	signature:(const cvec &v, const int &s)
operator *	/usr/include/itpp/base/operators.h	/^inline cvec operator*(const cvec &v, const short &s) {return s*v;}$/;"	f	namespace:itpp	signature:(const cvec &v, const short &s)
operator *	/usr/include/itpp/base/operators.h	/^inline cvec operator*(const float &s, const cvec &v) {return static_cast<double>(s)*v;}$/;"	f	namespace:itpp	signature:(const float &s, const cvec &v)
operator *	/usr/include/itpp/base/operators.h	/^inline cvec operator*(const int &s, const cvec &v) {return static_cast<double>(s)*v;}$/;"	f	namespace:itpp	signature:(const int &s, const cvec &v)
operator *	/usr/include/itpp/base/operators.h	/^inline cvec operator*(const ivec &v, const std::complex<double> &s) { return s*v; }$/;"	f	namespace:itpp	signature:(const ivec &v, const std::complex<double> &s)
operator *	/usr/include/itpp/base/operators.h	/^inline cvec operator*(const short &s, const cvec &v) {return static_cast<double>(s)*v;}$/;"	f	namespace:itpp	signature:(const short &s, const cvec &v)
operator *	/usr/include/itpp/base/operators.h	/^inline double operator*(const vec &a, const bvec &b) {return b*a;}$/;"	f	namespace:itpp	signature:(const vec &a, const bvec &b)
operator *	/usr/include/itpp/base/operators.h	/^inline double operator*(const vec &a, const ivec &b) {return b*a;}$/;"	f	namespace:itpp	signature:(const vec &a, const ivec &b)
operator *	/usr/include/itpp/base/operators.h	/^inline double operator*(const vec &a, const svec &b) {return b*a;}$/;"	f	namespace:itpp	signature:(const vec &a, const svec &b)
operator *	/usr/include/itpp/base/operators.h	/^inline mat operator*(const float &s, const mat &m) {return static_cast<double>(s)*m;}$/;"	f	namespace:itpp	signature:(const float &s, const mat &m)
operator *	/usr/include/itpp/base/operators.h	/^inline mat operator*(const int &s, const mat &m) {return static_cast<double>(s)*m;}$/;"	f	namespace:itpp	signature:(const int &s, const mat &m)
operator *	/usr/include/itpp/base/operators.h	/^inline mat operator*(const mat &m, const float &s) {return static_cast<double>(s)*m;}$/;"	f	namespace:itpp	signature:(const mat &m, const float &s)
operator *	/usr/include/itpp/base/operators.h	/^inline mat operator*(const mat &m, const int &s) {return static_cast<double>(s)*m;}$/;"	f	namespace:itpp	signature:(const mat &m, const int &s)
operator *	/usr/include/itpp/base/operators.h	/^inline mat operator*(const mat &m, const short &s) {return static_cast<double>(s)*m;}$/;"	f	namespace:itpp	signature:(const mat &m, const short &s)
operator *	/usr/include/itpp/base/operators.h	/^inline mat operator*(const short &s, const mat &m) {return static_cast<double>(s)*m;}$/;"	f	namespace:itpp	signature:(const short &s, const mat &m)
operator *	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator*(const cvec &a, const bvec &b) {return b*a;}$/;"	f	namespace:itpp	signature:(const cvec &a, const bvec &b)
operator *	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator*(const cvec &a, const ivec &b) {return b*a;}$/;"	f	namespace:itpp	signature:(const cvec &a, const ivec &b)
operator *	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator*(const cvec &a, const svec &b) {return b*a;}$/;"	f	namespace:itpp	signature:(const cvec &a, const svec &b)
operator *	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator*(const float &x, const std::complex<double> &y) {return std::complex<double>(x*y.real(), x*y.imag());}$/;"	f	namespace:itpp	signature:(const float &x, const std::complex<double> &y)
operator *	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator*(const int &x, const std::complex<double> &y) {return std::complex<double>(x*y.real(), x*y.imag());}$/;"	f	namespace:itpp	signature:(const int &x, const std::complex<double> &y)
operator *	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator*(const std::complex<double> &x, const float &y) {return std::complex<double>(x.real()*y, x.imag()*y);}$/;"	f	namespace:itpp	signature:(const std::complex<double> &x, const float &y)
operator *	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator*(const std::complex<double> &x, const int &y) {return std::complex<double>(x.real()*y, x.imag()*y);}$/;"	f	namespace:itpp	signature:(const std::complex<double> &x, const int &y)
operator *	/usr/include/itpp/base/operators.h	/^inline vec operator*(const float &s, const vec &v) {return static_cast<double>(s)*v;}$/;"	f	namespace:itpp	signature:(const float &s, const vec &v)
operator *	/usr/include/itpp/base/operators.h	/^inline vec operator*(const int &s, const vec &v) {return static_cast<double>(s)*v;}$/;"	f	namespace:itpp	signature:(const int &s, const vec &v)
operator *	/usr/include/itpp/base/operators.h	/^inline vec operator*(const ivec &v, const double &s) { return s*v; }$/;"	f	namespace:itpp	signature:(const ivec &v, const double &s)
operator *	/usr/include/itpp/base/operators.h	/^inline vec operator*(const short &s, const vec &v) {return static_cast<double>(s)*v;}$/;"	f	namespace:itpp	signature:(const short &s, const vec &v)
operator *	/usr/include/itpp/base/operators.h	/^inline vec operator*(const vec &v, const float &s) {return static_cast<double>(s)*v;}$/;"	f	namespace:itpp	signature:(const vec &v, const float &s)
operator *	/usr/include/itpp/base/operators.h	/^inline vec operator*(const vec &v, const int &s) {return static_cast<double>(s)*v;}$/;"	f	namespace:itpp	signature:(const vec &v, const int &s)
operator *	/usr/include/itpp/base/operators.h	/^inline vec operator*(const vec &v, const short &s) {return static_cast<double>(s)*v;}$/;"	f	namespace:itpp	signature:(const vec &v, const short &s)
operator *	/usr/include/itpp/base/operators.h	/^std::complex<double> operator*(const bvec &a, const cvec &b);$/;"	p	namespace:itpp	signature:(const bvec &a, const cvec &b)
operator *	/usr/include/itpp/base/operators.h	/^std::complex<double> operator*(const ivec &a, const cvec &b);$/;"	p	namespace:itpp	signature:(const ivec &a, const cvec &b)
operator *	/usr/include/itpp/base/operators.h	/^std::complex<double> operator*(const svec &a, const cvec &b);$/;"	p	namespace:itpp	signature:(const svec &a, const cvec &b)
operator *	/usr/include/itpp/base/operators.h	/^vec operator*(const double &s, const ivec &v);$/;"	p	namespace:itpp	signature:(const double &s, const ivec &v)
operator *	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> operator*(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)$/;"	f	namespace:itpp	signature:(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)
operator *	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> operator*(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2);$/;"	p	namespace:itpp	signature:(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)
operator *	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> operator*(const T &c, const Sparse_Mat<T> &m)$/;"	f	namespace:itpp	signature:(const T &c, const Sparse_Mat<T> &m)
operator *	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> operator*(const T &c, const Sparse_Mat<T> &m);$/;"	p	namespace:itpp	signature:(const T &c, const Sparse_Mat<T> &m)
operator *	/usr/include/itpp/base/smat.h	/^Sparse_Vec<T> operator*(const Sparse_Mat<T> &m, const Sparse_Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Sparse_Mat<T> &m, const Sparse_Vec<T> &v)
operator *	/usr/include/itpp/base/smat.h	/^Sparse_Vec<T> operator*(const Sparse_Mat<T> &m, const Sparse_Vec<T> &v);$/;"	p	namespace:itpp	signature:(const Sparse_Mat<T> &m, const Sparse_Vec<T> &v)
operator *	/usr/include/itpp/base/smat.h	/^Vec<T> operator*(const Sparse_Mat<T> &m, const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Sparse_Mat<T> &m, const Vec<T> &v)
operator *	/usr/include/itpp/base/smat.h	/^Vec<T> operator*(const Sparse_Mat<T> &m, const Vec<T> &v);$/;"	p	namespace:itpp	signature:(const Sparse_Mat<T> &m, const Vec<T> &v)
operator *	/usr/include/itpp/base/smat.h	/^Vec<T> operator*(const Vec<T> &v, const Sparse_Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, const Sparse_Mat<T> &m)
operator *	/usr/include/itpp/base/smat.h	/^Vec<T> operator*(const Vec<T> &v, const Sparse_Mat<T> &m);$/;"	p	namespace:itpp	signature:(const Vec<T> &v, const Sparse_Mat<T> &m)
operator *	/usr/include/itpp/base/smat.h	/^extern template cvec operator*(const cvec &, const sparse_cmat &);$/;"	p	namespace:itpp	signature:(const cvec &, const sparse_cmat &)
operator *	/usr/include/itpp/base/smat.h	/^extern template cvec operator*(const sparse_cmat &, const cvec &);$/;"	p	namespace:itpp	signature:(const sparse_cmat &, const cvec &)
operator *	/usr/include/itpp/base/smat.h	/^extern template ivec operator*(const ivec &, const sparse_imat &);$/;"	p	namespace:itpp	signature:(const ivec &, const sparse_imat &)
operator *	/usr/include/itpp/base/smat.h	/^extern template ivec operator*(const sparse_imat &, const ivec &);$/;"	p	namespace:itpp	signature:(const sparse_imat &, const ivec &)
operator *	/usr/include/itpp/base/smat.h	/^extern template sparse_cmat operator*(const sparse_cmat &, const sparse_cmat &);$/;"	p	namespace:itpp	signature:(const sparse_cmat &, const sparse_cmat &)
operator *	/usr/include/itpp/base/smat.h	/^extern template sparse_imat operator*(const sparse_imat &, const sparse_imat &);$/;"	p	namespace:itpp	signature:(const sparse_imat &, const sparse_imat &)
operator *	/usr/include/itpp/base/smat.h	/^extern template sparse_mat operator*(const sparse_mat &, const sparse_mat &);$/;"	p	namespace:itpp	signature:(const sparse_mat &, const sparse_mat &)
operator *	/usr/include/itpp/base/smat.h	/^extern template vec operator*(const sparse_mat &, const vec &);$/;"	p	namespace:itpp	signature:(const sparse_mat &, const vec &)
operator *	/usr/include/itpp/base/smat.h	/^extern template vec operator*(const vec &, const sparse_mat &);$/;"	p	namespace:itpp	signature:(const vec &, const sparse_mat &)
operator *	/usr/include/itpp/base/svec.h	/^T operator*(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2)$/;"	f	namespace:itpp	signature:(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2)
operator *	/usr/include/itpp/base/svec.h	/^T operator*(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2);$/;"	p	namespace:itpp	signature:(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2)
operator *	/usr/include/itpp/base/svec.h	/^T operator*(const Sparse_Vec<T> &v1, const Vec<T> &v2)$/;"	f	namespace:itpp	signature:(const Sparse_Vec<T> &v1, const Vec<T> &v2)
operator *	/usr/include/itpp/base/svec.h	/^T operator*(const Sparse_Vec<T> &v1, const Vec<T> &v2);$/;"	p	namespace:itpp	signature:(const Sparse_Vec<T> &v1, const Vec<T> &v2)
operator *	/usr/include/itpp/base/svec.h	/^T operator*(const Vec<T> &v1, const Sparse_Vec<T> &v2)$/;"	f	namespace:itpp	signature:(const Vec<T> &v1, const Sparse_Vec<T> &v2)
operator *	/usr/include/itpp/base/svec.h	/^T operator*(const Vec<T> &v1, const Sparse_Vec<T> &v2);$/;"	p	namespace:itpp	signature:(const Vec<T> &v1, const Sparse_Vec<T> &v2)
operator *	/usr/include/itpp/base/svec.h	/^extern template double operator*(const sparse_vec &, const sparse_vec &);$/;"	p	namespace:itpp	signature:(const sparse_vec &, const sparse_vec &)
operator *	/usr/include/itpp/base/svec.h	/^extern template double operator*(const sparse_vec &, const vec &);$/;"	p	namespace:itpp	signature:(const sparse_vec &, const vec &)
operator *	/usr/include/itpp/base/svec.h	/^extern template double operator*(const vec &, const sparse_vec &);$/;"	p	namespace:itpp	signature:(const vec &, const sparse_vec &)
operator *	/usr/include/itpp/base/svec.h	/^extern template int operator*(const ivec &, const sparse_ivec &);$/;"	p	namespace:itpp	signature:(const ivec &, const sparse_ivec &)
operator *	/usr/include/itpp/base/svec.h	/^extern template int operator*(const sparse_ivec &, const ivec &);$/;"	p	namespace:itpp	signature:(const sparse_ivec &, const ivec &)
operator *	/usr/include/itpp/base/svec.h	/^extern template int operator*(const sparse_ivec &, const sparse_ivec &);$/;"	p	namespace:itpp	signature:(const sparse_ivec &, const sparse_ivec &)
operator *	/usr/include/itpp/base/svec.h	/^extern template std::complex<double> operator*(const cvec &,$/;"	p	namespace:itpp	signature:(const cvec &, const sparse_cvec &)
operator *	/usr/include/itpp/base/svec.h	/^extern template std::complex<double> operator*(const sparse_cvec &,$/;"	p	namespace:itpp	signature:(const sparse_cvec &, const cvec &)
operator *	/usr/include/itpp/base/svec.h	/^extern template std::complex<double> operator*(const sparse_cvec &,$/;"	p	namespace:itpp	signature:(const sparse_cvec &, const sparse_cvec &)
operator *	/usr/include/itpp/base/vec.h	/^Num_T operator*(const Vec<Num_T> &v1, const Vec<Num_T> &v2)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
operator *	/usr/include/itpp/base/vec.h	/^Num_T operator*(const Vec<Num_T> &v1, const Vec<Num_T> &v2);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
operator *	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator*(Num_T t, const Vec<Num_T> &v)$/;"	f	namespace:itpp	signature:(Num_T t, const Vec<Num_T> &v)
operator *	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator*(Num_T t, const Vec<Num_T> &v);$/;"	p	namespace:itpp	signature:(Num_T t, const Vec<Num_T> &v)
operator *	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator*(const Vec<Num_T> &v, Num_T t)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v, Num_T t)
operator *	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator*(const Vec<Num_T> &v, Num_T t);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v, Num_T t)
operator *	/usr/include/itpp/base/vec.h	/^extern template bin operator*(const bvec &v1, const bvec &v2);$/;"	p	namespace:itpp	signature:(const bvec &v1, const bvec &v2)
operator *	/usr/include/itpp/base/vec.h	/^extern template bvec operator*(bin t, const bvec &v);$/;"	p	namespace:itpp	signature:(bin t, const bvec &v)
operator *	/usr/include/itpp/base/vec.h	/^extern template bvec operator*(const bvec &v, bin t);$/;"	p	namespace:itpp	signature:(const bvec &v, bin t)
operator *	/usr/include/itpp/base/vec.h	/^extern template cvec operator*(const cvec &v, std::complex<double> t);$/;"	p	namespace:itpp	signature:(const cvec &v, std::complex<double> t)
operator *	/usr/include/itpp/base/vec.h	/^extern template cvec operator*(std::complex<double> t, const cvec &v);$/;"	p	namespace:itpp	signature:(std::complex<double> t, const cvec &v)
operator *	/usr/include/itpp/base/vec.h	/^extern template double operator*(const vec &v1, const vec &v2);$/;"	p	namespace:itpp	signature:(const vec &v1, const vec &v2)
operator *	/usr/include/itpp/base/vec.h	/^extern template int operator*(const ivec &v1, const ivec &v2);$/;"	p	namespace:itpp	signature:(const ivec &v1, const ivec &v2)
operator *	/usr/include/itpp/base/vec.h	/^extern template ivec operator*(const ivec &v, int t);$/;"	p	namespace:itpp	signature:(const ivec &v, int t)
operator *	/usr/include/itpp/base/vec.h	/^extern template ivec operator*(int t, const ivec &v);$/;"	p	namespace:itpp	signature:(int t, const ivec &v)
operator *	/usr/include/itpp/base/vec.h	/^extern template short operator*(const svec &v1, const svec &v2);$/;"	p	namespace:itpp	signature:(const svec &v1, const svec &v2)
operator *	/usr/include/itpp/base/vec.h	/^extern template std::complex<double> operator*(const cvec &v1,$/;"	p	namespace:itpp	signature:(const cvec &v1, const cvec &v2)
operator *	/usr/include/itpp/base/vec.h	/^extern template svec operator*(const svec &v, short t);$/;"	p	namespace:itpp	signature:(const svec &v, short t)
operator *	/usr/include/itpp/base/vec.h	/^extern template svec operator*(short t, const svec &v);$/;"	p	namespace:itpp	signature:(short t, const svec &v)
operator *	/usr/include/itpp/base/vec.h	/^extern template vec operator*(const vec &v, double t);$/;"	p	namespace:itpp	signature:(const vec &v, double t)
operator *	/usr/include/itpp/base/vec.h	/^extern template vec operator*(double t, const vec &v);$/;"	p	namespace:itpp	signature:(double t, const vec &v)
operator *	/usr/include/itpp/comm/galois.h	/^  GF operator*(const GF &ingf) const;$/;"	p	class:itpp::GF	access:public	signature:(const GF &ingf) const
operator *	/usr/include/itpp/comm/galois.h	/^  GFX operator*(const GFX &ingfx) const;$/;"	p	class:itpp::GFX	access:public	signature:(const GFX &ingfx) const
operator *	/usr/include/itpp/comm/galois.h	/^  friend GFX  operator*(const GF &ingf, const GFX &ingfx);$/;"	p	class:itpp::GFX	access:friend	signature:(const GF &ingf, const GFX &ingfx)
operator *	/usr/include/itpp/comm/galois.h	/^  friend GFX  operator*(const GFX &ingfx, const GF &ingf);$/;"	p	class:itpp::GFX	access:friend	signature:(const GFX &ingfx, const GF &ingf)
operator *	/usr/include/itpp/comm/galois.h	/^GFX  operator*(const GF &ingf, const GFX &ingfx);$/;"	p	namespace:itpp	signature:(const GF &ingf, const GFX &ingfx)
operator *	/usr/include/itpp/comm/galois.h	/^GFX  operator*(const GFX &ingfx, const GF &ingf);$/;"	p	namespace:itpp	signature:(const GFX &ingfx, const GF &ingf)
operator *	/usr/include/itpp/comm/galois.h	/^inline GF GF::operator*(const GF &ingf) const$/;"	f	class:itpp::GF	signature:(const GF &ingf) const
operator *	/usr/include/itpp/comm/galois.h	/^inline GFX  operator*(const GFX &ingfx, const GF &ingf)$/;"	f	namespace:itpp	signature:(const GFX &ingfx, const GF &ingf)
operator *	/usr/include/itpp/comm/galois.h	/^inline GFX GFX::operator*(const GFX &ingfx) const$/;"	f	class:itpp::GFX	signature:(const GFX &ingfx) const
operator *	/usr/include/itpp/comm/galois.h	/^inline GFX operator*(const GF &ingf, const GFX &ingfx)$/;"	f	namespace:itpp	signature:(const GF &ingf, const GFX &ingfx)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator*(const CFix &x, const CFix &y);$/;"	p	namespace:itpp	signature:(const CFix &x, const CFix &y)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator*(const CFix &x, const Fix &y);$/;"	p	namespace:itpp	signature:(const CFix &x, const Fix &y)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator*(const CFix &x, const int y);$/;"	p	namespace:itpp	signature:(const CFix &x, const int y)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator*(const Fix &x, const CFix &y);$/;"	p	namespace:itpp	signature:(const Fix &x, const CFix &y)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator*(const cfixvec &a, const fixvec &b);$/;"	p	namespace:itpp	signature:(const cfixvec &a, const fixvec &b)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator*(const cfixvec &a, const ivec &b);$/;"	p	namespace:itpp	signature:(const cfixvec &a, const ivec &b)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator*(const int x, const CFix &y);$/;"	p	namespace:itpp	signature:(const int x, const CFix &y)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^Fix operator*(const Fix &x, const Fix &y);$/;"	p	namespace:itpp	signature:(const Fix &x, const Fix &y)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^Fix operator*(const Fix &x, const int y);$/;"	p	namespace:itpp	signature:(const Fix &x, const int y)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^Fix operator*(const fixvec &a, const ivec &b);$/;"	p	namespace:itpp	signature:(const fixvec &a, const ivec &b)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^Fix operator*(const int x, const Fix &y);$/;"	p	namespace:itpp	signature:(const int x, const Fix &y)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^cfixmat operator*(const cfixmat &a, const fixmat &b);$/;"	p	namespace:itpp	signature:(const cfixmat &a, const fixmat &b)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^cfixmat operator*(const cfixmat &a, const imat &b);$/;"	p	namespace:itpp	signature:(const cfixmat &a, const imat &b)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^fixmat operator*(const fixmat &a, const imat &b);$/;"	p	namespace:itpp	signature:(const fixmat &a, const imat &b)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline CFix operator*(const fixvec &a, const cfixvec &b) {return b*a;}$/;"	f	namespace:itpp	signature:(const fixvec &a, const cfixvec &b)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline CFix operator*(const ivec &a, const cfixvec &b) {return b*a;}$/;"	f	namespace:itpp	signature:(const ivec &a, const cfixvec &b)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline Fix operator*(const ivec &a, const fixvec &b) {return b*a;}$/;"	f	namespace:itpp	signature:(const ivec &a, const fixvec &b)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator*(const CFix &s, const fixmat &m) {return s * to<CFix>(m);}$/;"	f	namespace:itpp	signature:(const CFix &s, const fixmat &m)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator*(const CFix &s, const imat &m) {return s * to<CFix>(to_mat(m));}$/;"	f	namespace:itpp	signature:(const CFix &s, const imat &m)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator*(const Fix &s, const cfixmat &m) {return CFix(s) * m;}$/;"	f	namespace:itpp	signature:(const Fix &s, const cfixmat &m)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator*(const cfixmat &m, const Fix &s) {return m * CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixmat &m, const Fix &s)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator*(const cfixmat &m, const int s) {return m * CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixmat &m, const int s)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator*(const fixmat &a, const cfixmat &b) {return b*a;}$/;"	f	namespace:itpp	signature:(const fixmat &a, const cfixmat &b)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator*(const fixmat &m, const CFix &s) {return to<CFix>(m) * s;}$/;"	f	namespace:itpp	signature:(const fixmat &m, const CFix &s)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator*(const imat &a, const cfixmat &b) {return b*a;}$/;"	f	namespace:itpp	signature:(const imat &a, const cfixmat &b)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator*(const imat &m, const CFix &s) {return to<CFix>(to_mat(m)) * s;}$/;"	f	namespace:itpp	signature:(const imat &m, const CFix &s)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator*(const int s, const cfixmat &m) {return CFix(s) * m;}$/;"	f	namespace:itpp	signature:(const int s, const cfixmat &m)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator*(const CFix &s, const fixvec &v) {return s * to<CFix>(v);}$/;"	f	namespace:itpp	signature:(const CFix &s, const fixvec &v)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator*(const CFix &s, const ivec &v) {return s * to<CFix>(to_vec(v));}$/;"	f	namespace:itpp	signature:(const CFix &s, const ivec &v)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator*(const Fix &s, const cfixvec &v) {return CFix(s) * v;}$/;"	f	namespace:itpp	signature:(const Fix &s, const cfixvec &v)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator*(const cfixvec &v, const Fix &s) {return v * CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixvec &v, const Fix &s)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator*(const cfixvec &v, const int s) {return v * CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixvec &v, const int s)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator*(const fixvec &v, const CFix &s) {return to<CFix>(v) * s;}$/;"	f	namespace:itpp	signature:(const fixvec &v, const CFix &s)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator*(const int s, const cfixvec &v) {return CFix(s) * v;}$/;"	f	namespace:itpp	signature:(const int s, const cfixvec &v)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator*(const ivec &v, const CFix &s) {return to<CFix>(to_vec(v)) * s;}$/;"	f	namespace:itpp	signature:(const ivec &v, const CFix &s)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline fixmat operator*(const fixmat &v, const int s) {return v * Fix(s);}$/;"	f	namespace:itpp	signature:(const fixmat &v, const int s)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline fixmat operator*(const imat &a, const fixmat &b) {return b*a;}$/;"	f	namespace:itpp	signature:(const imat &a, const fixmat &b)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline fixmat operator*(const int s, const fixmat &v) {return Fix(s) * v;}$/;"	f	namespace:itpp	signature:(const int s, const fixmat &v)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline fixvec operator*(const fixvec &v, const int s) {return v * Fix(s);}$/;"	f	namespace:itpp	signature:(const fixvec &v, const int s)
operator *	/usr/include/itpp/fixed/fix_operators.h	/^inline fixvec operator*(const int s, const fixvec &v) {return Fix(s) * v;}$/;"	f	namespace:itpp	signature:(const int s, const fixvec &v)
operator *<>	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> operator*<>(Num_T t, const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:friend	signature:(Num_T t, const Mat<Num_T> &m)
operator *<>	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> operator*<>(const Mat<Num_T> &m, Num_T t);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m, Num_T t)
operator *<>	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> operator*<>(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
operator *<>	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> operator*<>(const Vec<Num_T> &v, const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:friend	signature:(const Vec<Num_T> &v, const Mat<Num_T> &m)
operator *<>	/usr/include/itpp/base/mat.h	/^  friend Vec<Num_T> operator*<>(const Mat<Num_T> &m, const Vec<Num_T> &v);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m, const Vec<Num_T> &v)
operator *<>	/usr/include/itpp/base/smat.h	/^  friend Sparse_Mat<T> operator*<>(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2);$/;"	p	class:itpp::Sparse_Mat	access:friend	signature:(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)
operator *<>	/usr/include/itpp/base/smat.h	/^  friend Sparse_Mat<T> operator*<>(const T &c, const Sparse_Mat<T> &m);$/;"	p	class:itpp::Sparse_Mat	access:friend	signature:(const T &c, const Sparse_Mat<T> &m)
operator *<>	/usr/include/itpp/base/smat.h	/^  friend Sparse_Vec<T> operator*<>(const Sparse_Mat<T> &m, const Sparse_Vec<T> &v);$/;"	p	class:itpp::Sparse_Mat	access:friend	signature:(const Sparse_Mat<T> &m, const Sparse_Vec<T> &v)
operator *<>	/usr/include/itpp/base/smat.h	/^  friend Vec<T> operator*<>(const Sparse_Mat<T> &m, const Vec<T> &v);$/;"	p	class:itpp::Sparse_Mat	access:friend	signature:(const Sparse_Mat<T> &m, const Vec<T> &v)
operator *<>	/usr/include/itpp/base/smat.h	/^  friend Vec<T> operator*<>(const Vec<T> &v, const Sparse_Mat<T> &m);$/;"	p	class:itpp::Sparse_Mat	access:friend	signature:(const Vec<T> &v, const Sparse_Mat<T> &m)
operator *<>	/usr/include/itpp/base/svec.h	/^  friend T operator*<>(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2);$/;"	p	class:itpp::Sparse_Vec	access:friend	signature:(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2)
operator *<>	/usr/include/itpp/base/svec.h	/^  friend T operator*<>(const Sparse_Vec<T> &v1, const Vec<T> &v2);$/;"	p	class:itpp::Sparse_Vec	access:friend	signature:(const Sparse_Vec<T> &v1, const Vec<T> &v2)
operator *<>	/usr/include/itpp/base/svec.h	/^  friend T operator*<>(const Vec<T> &v1, const Sparse_Vec<T> &v2);$/;"	p	class:itpp::Sparse_Vec	access:friend	signature:(const Vec<T> &v1, const Sparse_Vec<T> &v2)
operator *<>	/usr/include/itpp/base/vec.h	/^  friend Num_T operator*<>(const Vec<Num_T> &v1, const Vec<Num_T> &v2);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
operator *<>	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> operator*<>(Num_T t, const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:friend	signature:(Num_T t, const Vec<Num_T> &v)
operator *<>	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> operator*<>(const Vec<Num_T> &v, Num_T t);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v, Num_T t)
operator *=	/usr/include/itpp/base/binary.h	/^  void operator*=(const bin &inbin) { b &= inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin)
operator *=	/usr/include/itpp/base/mat.h	/^  Mat<Num_T>& operator*=(Num_T t);$/;"	p	class:itpp::Mat	access:public	signature:(Num_T t)
operator *=	/usr/include/itpp/base/mat.h	/^  Mat<Num_T>& operator*=(const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:public	signature:(const Mat<Num_T> &m)
operator *=	/usr/include/itpp/base/mat.h	/^Mat<Num_T>& Mat<Num_T>::operator*=(Num_T t)$/;"	f	class:itpp::Mat	signature:(Num_T t)
operator *=	/usr/include/itpp/base/mat.h	/^Mat<Num_T>& Mat<Num_T>::operator*=(const Mat<Num_T> &m)$/;"	f	class:itpp::Mat	signature:(const Mat<Num_T> &m)
operator *=	/usr/include/itpp/base/mat.h	/^template<> cmat& cmat::operator*=(const cmat &m);$/;"	p	class:itpp::cmat	signature:(const cmat &m)
operator *=	/usr/include/itpp/base/mat.h	/^template<> mat& mat::operator*=(const mat &m);$/;"	p	class:itpp::mat	signature:(const mat &m)
operator *=	/usr/include/itpp/base/smat.h	/^  void operator*=(const T &v);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const T &v)
operator *=	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::operator*=(const T &m)$/;"	f	class:itpp::Sparse_Mat	signature:(const T &m)
operator *=	/usr/include/itpp/base/svec.h	/^  void operator*=(const T &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const T &v)
operator *=	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::operator*=(const T &v)$/;"	f	class:itpp::Sparse_Vec	signature:(const T &v)
operator *=	/usr/include/itpp/base/vec.h	/^  Vec<Num_T>& operator*=(Num_T t);$/;"	p	class:itpp::Vec	access:public	signature:(Num_T t)
operator *=	/usr/include/itpp/base/vec.h	/^Vec<Num_T>& Vec<Num_T>::operator*=(Num_T t)$/;"	f	class:itpp::Vec	signature:(Num_T t)
operator *=	/usr/include/itpp/comm/galois.h	/^  void operator*=(const GF &ingf);$/;"	p	class:itpp::GF	access:public	signature:(const GF &ingf)
operator *=	/usr/include/itpp/comm/galois.h	/^  void operator*=(const GFX &ingfx);$/;"	p	class:itpp::GFX	access:public	signature:(const GFX &ingfx)
operator *=	/usr/include/itpp/comm/galois.h	/^inline void GF::operator*=(const GF &ingf)$/;"	f	class:itpp::GF	signature:(const GF &ingf)
operator *=	/usr/include/itpp/comm/galois.h	/^inline void GFX::operator*=(const GFX &ingfx)$/;"	f	class:itpp::GFX	signature:(const GFX &ingfx)
operator *=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator*=(const CFix &x);$/;"	p	class:itpp::CFix	access:public	signature:(const CFix &x)
operator *=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator*=(const Fix &x);$/;"	p	class:itpp::CFix	access:public	signature:(const Fix &x)
operator *=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator*=(const int x);$/;"	p	class:itpp::CFix	access:public	signature:(const int x)
operator *=	/usr/include/itpp/fixed/fix.h	/^  Fix& operator*=(const Fix &x);$/;"	p	class:itpp::Fix	access:public	signature:(const Fix &x)
operator *=	/usr/include/itpp/fixed/fix.h	/^  Fix& operator*=(const int x);$/;"	p	class:itpp::Fix	access:public	signature:(const int x)
operator +	/usr/include/itpp/base/binary.h	/^  bin operator+(const bin &inbin) const { return bin(b ^ inbin.b); }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin) const
operator +	/usr/include/itpp/base/gf2mat.h	/^  friend GF2mat operator+(const GF2mat &X, const GF2mat &Y);$/;"	p	class:itpp::GF2mat	access:friend	signature:(const GF2mat &X, const GF2mat &Y)
operator +	/usr/include/itpp/base/gf2mat.h	/^GF2mat operator+(const GF2mat &X, const GF2mat &Y);$/;"	p	namespace:itpp	signature:(const GF2mat &X, const GF2mat &Y)
operator +	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator+(Num_T t, const Mat<Num_T> &m)$/;"	f	namespace:itpp	signature:(Num_T t, const Mat<Num_T> &m)
operator +	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator+(Num_T t, const Mat<Num_T> &m);$/;"	p	namespace:itpp	signature:(Num_T t, const Mat<Num_T> &m)
operator +	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator+(const Mat<Num_T> &m, Num_T t)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m, Num_T t)
operator +	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator+(const Mat<Num_T> &m, Num_T t);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m, Num_T t)
operator +	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator+(const Mat<Num_T> &m1, const Mat<Num_T> &m2)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
operator +	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator+(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
operator +	/usr/include/itpp/base/mat.h	/^extern template bmat operator+(bin t, const bmat &m);$/;"	p	namespace:itpp	signature:(bin t, const bmat &m)
operator +	/usr/include/itpp/base/mat.h	/^extern template bmat operator+(const bmat &m, bin t);$/;"	p	namespace:itpp	signature:(const bmat &m, bin t)
operator +	/usr/include/itpp/base/mat.h	/^extern template bmat operator+(const bmat &m1, const bmat &m2);$/;"	p	namespace:itpp	signature:(const bmat &m1, const bmat &m2)
operator +	/usr/include/itpp/base/mat.h	/^extern template cmat operator+(const cmat &m, std::complex<double> t);$/;"	p	namespace:itpp	signature:(const cmat &m, std::complex<double> t)
operator +	/usr/include/itpp/base/mat.h	/^extern template cmat operator+(const cmat &m1, const cmat &m2);$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2)
operator +	/usr/include/itpp/base/mat.h	/^extern template cmat operator+(std::complex<double> t, const cmat &m);$/;"	p	namespace:itpp	signature:(std::complex<double> t, const cmat &m)
operator +	/usr/include/itpp/base/mat.h	/^extern template imat operator+(const imat &m, int t);$/;"	p	namespace:itpp	signature:(const imat &m, int t)
operator +	/usr/include/itpp/base/mat.h	/^extern template imat operator+(const imat &m1, const imat &m2);$/;"	p	namespace:itpp	signature:(const imat &m1, const imat &m2)
operator +	/usr/include/itpp/base/mat.h	/^extern template imat operator+(int t, const imat &m);$/;"	p	namespace:itpp	signature:(int t, const imat &m)
operator +	/usr/include/itpp/base/mat.h	/^extern template mat operator+(const mat &m, double t);$/;"	p	namespace:itpp	signature:(const mat &m, double t)
operator +	/usr/include/itpp/base/mat.h	/^extern template mat operator+(const mat &m1, const mat &m2);$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2)
operator +	/usr/include/itpp/base/mat.h	/^extern template mat operator+(double t, const mat &m);$/;"	p	namespace:itpp	signature:(double t, const mat &m)
operator +	/usr/include/itpp/base/mat.h	/^extern template smat operator+(const smat &m, short t);$/;"	p	namespace:itpp	signature:(const smat &m, short t)
operator +	/usr/include/itpp/base/mat.h	/^extern template smat operator+(const smat &m1, const smat &m2);$/;"	p	namespace:itpp	signature:(const smat &m1, const smat &m2)
operator +	/usr/include/itpp/base/mat.h	/^extern template smat operator+(short t, const smat &m);$/;"	p	namespace:itpp	signature:(short t, const smat &m)
operator +	/usr/include/itpp/base/operators.h	/^cmat operator+(const bmat &a, const cmat &b);$/;"	p	namespace:itpp	signature:(const bmat &a, const cmat &b)
operator +	/usr/include/itpp/base/operators.h	/^cmat operator+(const double &s, const cmat &m);$/;"	p	namespace:itpp	signature:(const double &s, const cmat &m)
operator +	/usr/include/itpp/base/operators.h	/^cmat operator+(const imat &a, const cmat &b);$/;"	p	namespace:itpp	signature:(const imat &a, const cmat &b)
operator +	/usr/include/itpp/base/operators.h	/^cmat operator+(const mat &a, const cmat &b);$/;"	p	namespace:itpp	signature:(const mat &a, const cmat &b)
operator +	/usr/include/itpp/base/operators.h	/^cmat operator+(const smat &a, const cmat &b);$/;"	p	namespace:itpp	signature:(const smat &a, const cmat &b)
operator +	/usr/include/itpp/base/operators.h	/^cvec operator+(const bvec &a, const cvec &b);$/;"	p	namespace:itpp	signature:(const bvec &a, const cvec &b)
operator +	/usr/include/itpp/base/operators.h	/^cvec operator+(const double &s, const cvec &v);$/;"	p	namespace:itpp	signature:(const double &s, const cvec &v)
operator +	/usr/include/itpp/base/operators.h	/^cvec operator+(const ivec &a, const cvec &b);$/;"	p	namespace:itpp	signature:(const ivec &a, const cvec &b)
operator +	/usr/include/itpp/base/operators.h	/^cvec operator+(const std::complex<double> &s, const ivec &v);$/;"	p	namespace:itpp	signature:(const std::complex<double> &s, const ivec &v)
operator +	/usr/include/itpp/base/operators.h	/^cvec operator+(const svec &a, const cvec &b);$/;"	p	namespace:itpp	signature:(const svec &a, const cvec &b)
operator +	/usr/include/itpp/base/operators.h	/^inline cmat operator+(const cmat &a, const bmat &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const cmat &a, const bmat &b)
operator +	/usr/include/itpp/base/operators.h	/^inline cmat operator+(const cmat &a, const imat &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const cmat &a, const imat &b)
operator +	/usr/include/itpp/base/operators.h	/^inline cmat operator+(const cmat &a, const mat &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const cmat &a, const mat &b)
operator +	/usr/include/itpp/base/operators.h	/^inline cmat operator+(const cmat &a, const smat &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const cmat &a, const smat &b)
operator +	/usr/include/itpp/base/operators.h	/^inline cvec operator+(const cvec &a, const bvec &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const cvec &a, const bvec &b)
operator +	/usr/include/itpp/base/operators.h	/^inline cvec operator+(const cvec &a, const ivec &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const cvec &a, const ivec &b)
operator +	/usr/include/itpp/base/operators.h	/^inline cvec operator+(const cvec &a, const svec &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const cvec &a, const svec &b)
operator +	/usr/include/itpp/base/operators.h	/^inline cvec operator+(const cvec &v, const double &s) {return s + v;}$/;"	f	namespace:itpp	signature:(const cvec &v, const double &s)
operator +	/usr/include/itpp/base/operators.h	/^inline cvec operator+(const cvec &v, const float &s) {return s + v;}$/;"	f	namespace:itpp	signature:(const cvec &v, const float &s)
operator +	/usr/include/itpp/base/operators.h	/^inline cvec operator+(const cvec &v, const int &s) {return s + v;}$/;"	f	namespace:itpp	signature:(const cvec &v, const int &s)
operator +	/usr/include/itpp/base/operators.h	/^inline cvec operator+(const cvec &v, const short &s) {return s + v;}$/;"	f	namespace:itpp	signature:(const cvec &v, const short &s)
operator +	/usr/include/itpp/base/operators.h	/^inline cvec operator+(const float &s, const cvec &v) {return static_cast<double>(s) + v;}$/;"	f	namespace:itpp	signature:(const float &s, const cvec &v)
operator +	/usr/include/itpp/base/operators.h	/^inline cvec operator+(const int &s, const cvec &v) {return static_cast<double>(s) + v;}$/;"	f	namespace:itpp	signature:(const int &s, const cvec &v)
operator +	/usr/include/itpp/base/operators.h	/^inline cvec operator+(const ivec &v, const std::complex<double> &s) { return s + v;}$/;"	f	namespace:itpp	signature:(const ivec &v, const std::complex<double> &s)
operator +	/usr/include/itpp/base/operators.h	/^inline cvec operator+(const short &s, const cvec &v) {return static_cast<double>(s) + v;}$/;"	f	namespace:itpp	signature:(const short &s, const cvec &v)
operator +	/usr/include/itpp/base/operators.h	/^inline mat operator+(const float &s, const mat &m) {return static_cast<double>(s) + m;}$/;"	f	namespace:itpp	signature:(const float &s, const mat &m)
operator +	/usr/include/itpp/base/operators.h	/^inline mat operator+(const int &s, const mat &m) {return static_cast<double>(s) + m;}$/;"	f	namespace:itpp	signature:(const int &s, const mat &m)
operator +	/usr/include/itpp/base/operators.h	/^inline mat operator+(const mat &a, const bmat &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const mat &a, const bmat &b)
operator +	/usr/include/itpp/base/operators.h	/^inline mat operator+(const mat &a, const imat &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const mat &a, const imat &b)
operator +	/usr/include/itpp/base/operators.h	/^inline mat operator+(const mat &a, const smat &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const mat &a, const smat &b)
operator +	/usr/include/itpp/base/operators.h	/^inline mat operator+(const mat &m, const float &s) {return static_cast<double>(s) + m;}$/;"	f	namespace:itpp	signature:(const mat &m, const float &s)
operator +	/usr/include/itpp/base/operators.h	/^inline mat operator+(const mat &m, const int &s) {return static_cast<double>(s) + m;}$/;"	f	namespace:itpp	signature:(const mat &m, const int &s)
operator +	/usr/include/itpp/base/operators.h	/^inline mat operator+(const mat &m, const short &s) {return static_cast<double>(s) + m;}$/;"	f	namespace:itpp	signature:(const mat &m, const short &s)
operator +	/usr/include/itpp/base/operators.h	/^inline mat operator+(const short &s, const mat &m) {return static_cast<double>(s) + m;}$/;"	f	namespace:itpp	signature:(const short &s, const mat &m)
operator +	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator+(const float &x, const std::complex<double> &y) {return std::complex<double>(x + y.real(), x + y.imag());}$/;"	f	namespace:itpp	signature:(const float &x, const std::complex<double> &y)
operator +	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator+(const int &x, const std::complex<double> &y) {return std::complex<double>(x + y.real(), x + y.imag());}$/;"	f	namespace:itpp	signature:(const int &x, const std::complex<double> &y)
operator +	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator+(const std::complex<double> &x, const float &y) {return std::complex<double>(x.real() + y, x.imag() + y);}$/;"	f	namespace:itpp	signature:(const std::complex<double> &x, const float &y)
operator +	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator+(const std::complex<double> &x, const int &y) {return std::complex<double>(x.real() + y, x.imag() + y);}$/;"	f	namespace:itpp	signature:(const std::complex<double> &x, const int &y)
operator +	/usr/include/itpp/base/operators.h	/^inline vec operator+(const float &s, const vec &v) {return static_cast<double>(s) + v;}$/;"	f	namespace:itpp	signature:(const float &s, const vec &v)
operator +	/usr/include/itpp/base/operators.h	/^inline vec operator+(const int &s, const vec &v) {return static_cast<double>(s) + v;}$/;"	f	namespace:itpp	signature:(const int &s, const vec &v)
operator +	/usr/include/itpp/base/operators.h	/^inline vec operator+(const ivec &v, const double &s) { return s + v;}$/;"	f	namespace:itpp	signature:(const ivec &v, const double &s)
operator +	/usr/include/itpp/base/operators.h	/^inline vec operator+(const short &s, const vec &v) {return static_cast<double>(s) + v;}$/;"	f	namespace:itpp	signature:(const short &s, const vec &v)
operator +	/usr/include/itpp/base/operators.h	/^inline vec operator+(const vec &a, const bvec &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const vec &a, const bvec &b)
operator +	/usr/include/itpp/base/operators.h	/^inline vec operator+(const vec &a, const ivec &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const vec &a, const ivec &b)
operator +	/usr/include/itpp/base/operators.h	/^inline vec operator+(const vec &a, const svec &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const vec &a, const svec &b)
operator +	/usr/include/itpp/base/operators.h	/^inline vec operator+(const vec &v, const float &s) {return static_cast<double>(s) + v;}$/;"	f	namespace:itpp	signature:(const vec &v, const float &s)
operator +	/usr/include/itpp/base/operators.h	/^inline vec operator+(const vec &v, const int &s) {return static_cast<double>(s) + v;}$/;"	f	namespace:itpp	signature:(const vec &v, const int &s)
operator +	/usr/include/itpp/base/operators.h	/^inline vec operator+(const vec &v, const short &s) {return static_cast<double>(s) + v;}$/;"	f	namespace:itpp	signature:(const vec &v, const short &s)
operator +	/usr/include/itpp/base/operators.h	/^mat operator+(const bmat &a, const mat &b);$/;"	p	namespace:itpp	signature:(const bmat &a, const mat &b)
operator +	/usr/include/itpp/base/operators.h	/^mat operator+(const imat &a, const mat &b);$/;"	p	namespace:itpp	signature:(const imat &a, const mat &b)
operator +	/usr/include/itpp/base/operators.h	/^mat operator+(const smat &a, const mat &b);$/;"	p	namespace:itpp	signature:(const smat &a, const mat &b)
operator +	/usr/include/itpp/base/operators.h	/^vec operator+(const bvec &a, const vec &b);$/;"	p	namespace:itpp	signature:(const bvec &a, const vec &b)
operator +	/usr/include/itpp/base/operators.h	/^vec operator+(const double &s, const ivec &v);$/;"	p	namespace:itpp	signature:(const double &s, const ivec &v)
operator +	/usr/include/itpp/base/operators.h	/^vec operator+(const ivec &a, const vec &b);$/;"	p	namespace:itpp	signature:(const ivec &a, const vec &b)
operator +	/usr/include/itpp/base/operators.h	/^vec operator+(const svec &a, const vec &b);$/;"	p	namespace:itpp	signature:(const svec &a, const vec &b)
operator +	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> operator+(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)$/;"	f	namespace:itpp	signature:(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)
operator +	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> operator+(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2);$/;"	p	namespace:itpp	signature:(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)
operator +	/usr/include/itpp/base/smat.h	/^extern template sparse_cmat operator+(const sparse_cmat &, const sparse_cmat &);$/;"	p	namespace:itpp	signature:(const sparse_cmat &, const sparse_cmat &)
operator +	/usr/include/itpp/base/smat.h	/^extern template sparse_imat operator+(const sparse_imat &, const sparse_imat &);$/;"	p	namespace:itpp	signature:(const sparse_imat &, const sparse_imat &)
operator +	/usr/include/itpp/base/smat.h	/^extern template sparse_mat operator+(const sparse_mat &, const sparse_mat &);$/;"	p	namespace:itpp	signature:(const sparse_mat &, const sparse_mat &)
operator +	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T> operator+(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2)$/;"	f	namespace:itpp	signature:(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2)
operator +	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T> operator+(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2);$/;"	p	namespace:itpp	signature:(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2)
operator +	/usr/include/itpp/base/svec.h	/^extern template sparse_cvec operator+(const sparse_cvec &,$/;"	p	namespace:itpp	signature:(const sparse_cvec &, const sparse_cvec &)
operator +	/usr/include/itpp/base/svec.h	/^extern template sparse_ivec operator+(const sparse_ivec &,$/;"	p	namespace:itpp	signature:(const sparse_ivec &, const sparse_ivec &)
operator +	/usr/include/itpp/base/svec.h	/^extern template sparse_vec operator+(const sparse_vec &,$/;"	p	namespace:itpp	signature:(const sparse_vec &, const sparse_vec &)
operator +	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator+(Num_T t, const Vec<Num_T> &v)$/;"	f	namespace:itpp	signature:(Num_T t, const Vec<Num_T> &v)
operator +	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator+(Num_T t, const Vec<Num_T> &v);$/;"	p	namespace:itpp	signature:(Num_T t, const Vec<Num_T> &v)
operator +	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator+(const Vec<Num_T> &v, Num_T t)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v, Num_T t)
operator +	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator+(const Vec<Num_T> &v, Num_T t);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v, Num_T t)
operator +	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator+(const Vec<Num_T> &v1, const Vec<Num_T> &v2)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
operator +	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator+(const Vec<Num_T> &v1, const Vec<Num_T> &v2);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
operator +	/usr/include/itpp/base/vec.h	/^extern template bvec operator+(bin t, const bvec &v1);$/;"	p	namespace:itpp	signature:(bin t, const bvec &v1)
operator +	/usr/include/itpp/base/vec.h	/^extern template bvec operator+(const bvec &v1, bin t);$/;"	p	namespace:itpp	signature:(const bvec &v1, bin t)
operator +	/usr/include/itpp/base/vec.h	/^extern template bvec operator+(const bvec &v1, const bvec &v2);$/;"	p	namespace:itpp	signature:(const bvec &v1, const bvec &v2)
operator +	/usr/include/itpp/base/vec.h	/^extern template cvec operator+(const cvec &v1, const cvec &v2);$/;"	p	namespace:itpp	signature:(const cvec &v1, const cvec &v2)
operator +	/usr/include/itpp/base/vec.h	/^extern template cvec operator+(const cvec &v1, std::complex<double> t);$/;"	p	namespace:itpp	signature:(const cvec &v1, std::complex<double> t)
operator +	/usr/include/itpp/base/vec.h	/^extern template cvec operator+(std::complex<double> t, const cvec &v1);$/;"	p	namespace:itpp	signature:(std::complex<double> t, const cvec &v1)
operator +	/usr/include/itpp/base/vec.h	/^extern template ivec operator+(const ivec &v1, const ivec &v2);$/;"	p	namespace:itpp	signature:(const ivec &v1, const ivec &v2)
operator +	/usr/include/itpp/base/vec.h	/^extern template ivec operator+(const ivec &v1, int t);$/;"	p	namespace:itpp	signature:(const ivec &v1, int t)
operator +	/usr/include/itpp/base/vec.h	/^extern template ivec operator+(int t, const ivec &v1);$/;"	p	namespace:itpp	signature:(int t, const ivec &v1)
operator +	/usr/include/itpp/base/vec.h	/^extern template svec operator+(const svec &v1, const svec &v2);$/;"	p	namespace:itpp	signature:(const svec &v1, const svec &v2)
operator +	/usr/include/itpp/base/vec.h	/^extern template svec operator+(const svec &v1, short t);$/;"	p	namespace:itpp	signature:(const svec &v1, short t)
operator +	/usr/include/itpp/base/vec.h	/^extern template svec operator+(short t, const svec &v1);$/;"	p	namespace:itpp	signature:(short t, const svec &v1)
operator +	/usr/include/itpp/base/vec.h	/^extern template vec operator+(const vec &v1, const vec &v2);$/;"	p	namespace:itpp	signature:(const vec &v1, const vec &v2)
operator +	/usr/include/itpp/base/vec.h	/^extern template vec operator+(const vec &v1, double t);$/;"	p	namespace:itpp	signature:(const vec &v1, double t)
operator +	/usr/include/itpp/base/vec.h	/^extern template vec operator+(double t, const vec &v1);$/;"	p	namespace:itpp	signature:(double t, const vec &v1)
operator +	/usr/include/itpp/comm/galois.h	/^  GF operator+(const GF &ingf) const;$/;"	p	class:itpp::GF	access:public	signature:(const GF &ingf) const
operator +	/usr/include/itpp/comm/galois.h	/^  GFX operator+(const GFX &ingfx) const;$/;"	p	class:itpp::GFX	access:public	signature:(const GFX &ingfx) const
operator +	/usr/include/itpp/comm/galois.h	/^inline GF GF::operator+(const GF &ingf) const$/;"	f	class:itpp::GF	signature:(const GF &ingf) const
operator +	/usr/include/itpp/comm/galois.h	/^inline GFX GFX::operator+(const GFX &ingfx) const$/;"	f	class:itpp::GFX	signature:(const GFX &ingfx) const
operator +	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator+(const CFix &x, const CFix &y);$/;"	p	namespace:itpp	signature:(const CFix &x, const CFix &y)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator+(const CFix &x, const Fix &y);$/;"	p	namespace:itpp	signature:(const CFix &x, const Fix &y)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator+(const CFix &x, const int y);$/;"	p	namespace:itpp	signature:(const CFix &x, const int y)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator+(const Fix &x, const CFix &y);$/;"	p	namespace:itpp	signature:(const Fix &x, const CFix &y)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator+(const int x, const CFix &y);$/;"	p	namespace:itpp	signature:(const int x, const CFix &y)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^Fix operator+(const Fix &x, const Fix &y);$/;"	p	namespace:itpp	signature:(const Fix &x, const Fix &y)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^Fix operator+(const Fix &x, const int y);$/;"	p	namespace:itpp	signature:(const Fix &x, const int y)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^Fix operator+(const int x, const Fix &y);$/;"	p	namespace:itpp	signature:(const int x, const Fix &y)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^cfixmat operator+(const cfixmat &a, const fixmat &b);$/;"	p	namespace:itpp	signature:(const cfixmat &a, const fixmat &b)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^cfixmat operator+(const cfixmat &a, const imat &b);$/;"	p	namespace:itpp	signature:(const cfixmat &a, const imat &b)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^cfixvec operator+(const cfixvec &a, const fixvec &b);$/;"	p	namespace:itpp	signature:(const cfixvec &a, const fixvec &b)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^cfixvec operator+(const cfixvec &a, const ivec &b);$/;"	p	namespace:itpp	signature:(const cfixvec &a, const ivec &b)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^fixmat operator+(const fixmat &a, const imat &b);$/;"	p	namespace:itpp	signature:(const fixmat &a, const imat &b)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^fixvec operator+(const fixvec &a, const ivec &b);$/;"	p	namespace:itpp	signature:(const fixvec &a, const ivec &b)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator+(const CFix &s, const fixmat &m) {return s + to<CFix>(m);}$/;"	f	namespace:itpp	signature:(const CFix &s, const fixmat &m)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator+(const CFix &s, const imat &m) {return s + to<CFix>(to_mat(m));}$/;"	f	namespace:itpp	signature:(const CFix &s, const imat &m)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator+(const Fix &s, const cfixmat &m) {return CFix(s) + m;}$/;"	f	namespace:itpp	signature:(const Fix &s, const cfixmat &m)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator+(const cfixmat &m, const Fix &s) {return m + CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixmat &m, const Fix &s)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator+(const cfixmat &m, const int s) {return m + CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixmat &m, const int s)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator+(const fixmat &a, const cfixmat &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const fixmat &a, const cfixmat &b)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator+(const fixmat &m, const CFix &s) {return to<CFix>(m) + s;}$/;"	f	namespace:itpp	signature:(const fixmat &m, const CFix &s)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator+(const imat &a, const cfixmat &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const imat &a, const cfixmat &b)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator+(const imat &m, const CFix &s) {return to<CFix>(to_mat(m)) + s;}$/;"	f	namespace:itpp	signature:(const imat &m, const CFix &s)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator+(const int s, const cfixmat &m) {return CFix(s) + m;}$/;"	f	namespace:itpp	signature:(const int s, const cfixmat &m)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator+(const CFix &s, const fixvec &v) {return s + to<CFix>(v);}$/;"	f	namespace:itpp	signature:(const CFix &s, const fixvec &v)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator+(const CFix &s, const ivec &v) {return s + to<CFix>(to_vec(v));}$/;"	f	namespace:itpp	signature:(const CFix &s, const ivec &v)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator+(const Fix &s, const cfixvec &v) {return CFix(s) + v;}$/;"	f	namespace:itpp	signature:(const Fix &s, const cfixvec &v)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator+(const cfixvec &v, const Fix &s) {return v + CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixvec &v, const Fix &s)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator+(const cfixvec &v, const int s) {return v + CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixvec &v, const int s)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator+(const fixvec &a, const cfixvec &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const fixvec &a, const cfixvec &b)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator+(const fixvec &v, const CFix &s) {return to<CFix>(v) + s;}$/;"	f	namespace:itpp	signature:(const fixvec &v, const CFix &s)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator+(const int s, const cfixvec &v) {return CFix(s) + v;}$/;"	f	namespace:itpp	signature:(const int s, const cfixvec &v)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator+(const ivec &a, const cfixvec &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const ivec &a, const cfixvec &b)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator+(const ivec &v, const CFix &s) {return to<CFix>(to_vec(v)) + s;}$/;"	f	namespace:itpp	signature:(const ivec &v, const CFix &s)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline fixmat operator+(const fixmat &v, const int s) {return v + Fix(s);}$/;"	f	namespace:itpp	signature:(const fixmat &v, const int s)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline fixmat operator+(const imat &a, const fixmat &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const imat &a, const fixmat &b)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline fixmat operator+(const int s, const fixmat &v) {return Fix(s) + v;}$/;"	f	namespace:itpp	signature:(const int s, const fixmat &v)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline fixvec operator+(const fixvec &v, const int s) {return v + Fix(s);}$/;"	f	namespace:itpp	signature:(const fixvec &v, const int s)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline fixvec operator+(const int s, const fixvec &v) {return Fix(s) + v;}$/;"	f	namespace:itpp	signature:(const int s, const fixvec &v)
operator +	/usr/include/itpp/fixed/fix_operators.h	/^inline fixvec operator+(const ivec &a, const fixvec &b) {return b + a;}$/;"	f	namespace:itpp	signature:(const ivec &a, const fixvec &b)
operator +	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number operator+(const int n) const { return Sequence_Number(seq + n); }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const int n) const
operator +	/usr/include/itpp/protocol/tcp.h	/^  friend Sequence_Number operator+(const int n1, const Sequence_Number &n2) { return Sequence_Number(n1 + n2.seq); }$/;"	f	class:itpp::Sequence_Number	access:friend	signature:(const int n1, const Sequence_Number &n2)
operator +<>	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> operator+<>(Num_T t, const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:friend	signature:(Num_T t, const Mat<Num_T> &m)
operator +<>	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> operator+<>(const Mat<Num_T> &m, Num_T t);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m, Num_T t)
operator +<>	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> operator+<>(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
operator +<>	/usr/include/itpp/base/smat.h	/^  friend Sparse_Mat<T> operator+<>(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2);$/;"	p	class:itpp::Sparse_Mat	access:friend	signature:(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)
operator +<>	/usr/include/itpp/base/svec.h	/^  friend Sparse_Vec<T> operator+<>(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2);$/;"	p	class:itpp::Sparse_Vec	access:friend	signature:(const Sparse_Vec<T> &v1, const Sparse_Vec<T> &v2)
operator +<>	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> operator+<>(Num_T t, const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:friend	signature:(Num_T t, const Vec<Num_T> &v)
operator +<>	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> operator+<>(const Vec<Num_T> &v, Num_T t);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v, Num_T t)
operator +<>	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> operator+<>(const Vec<Num_T> &v1, const Vec<Num_T> &v2);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
operator +=	/usr/include/itpp/base/binary.h	/^  void operator+=(const bin &inbin) { b ^= inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin)
operator +=	/usr/include/itpp/base/mat.h	/^  Mat<Num_T>& operator+=(Num_T t);$/;"	p	class:itpp::Mat	access:public	signature:(Num_T t)
operator +=	/usr/include/itpp/base/mat.h	/^  Mat<Num_T>& operator+=(const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:public	signature:(const Mat<Num_T> &m)
operator +=	/usr/include/itpp/base/mat.h	/^Mat<Num_T>& Mat<Num_T>::operator+=(Num_T t)$/;"	f	class:itpp::Mat	signature:(Num_T t)
operator +=	/usr/include/itpp/base/mat.h	/^Mat<Num_T>& Mat<Num_T>::operator+=(const Mat<Num_T> &m)$/;"	f	class:itpp::Mat	signature:(const Mat<Num_T> &m)
operator +=	/usr/include/itpp/base/smat.h	/^  void operator+=(const Mat<T> &v);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const Mat<T> &v)
operator +=	/usr/include/itpp/base/smat.h	/^  void operator+=(const Sparse_Mat<T> &v);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const Sparse_Mat<T> &v)
operator +=	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::operator+=(const Mat<T> &m)$/;"	f	class:itpp::Sparse_Mat	signature:(const Mat<T> &m)
operator +=	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::operator+=(const Sparse_Mat<T> &m)$/;"	f	class:itpp::Sparse_Mat	signature:(const Sparse_Mat<T> &m)
operator +=	/usr/include/itpp/base/svec.h	/^  void operator+=(const Sparse_Vec<T> &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const Sparse_Vec<T> &v)
operator +=	/usr/include/itpp/base/svec.h	/^  void operator+=(const Vec<T> &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const Vec<T> &v)
operator +=	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::operator+=(const Sparse_Vec<T> &v)$/;"	f	class:itpp::Sparse_Vec	signature:(const Sparse_Vec<T> &v)
operator +=	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::operator+=(const Vec<T> &v)$/;"	f	class:itpp::Sparse_Vec	signature:(const Vec<T> &v)
operator +=	/usr/include/itpp/base/vec.h	/^  Vec<Num_T>& operator+=(Num_T t);$/;"	p	class:itpp::Vec	access:public	signature:(Num_T t)
operator +=	/usr/include/itpp/base/vec.h	/^  Vec<Num_T>& operator+=(const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:public	signature:(const Vec<Num_T> &v)
operator +=	/usr/include/itpp/base/vec.h	/^Vec<Num_T>& Vec<Num_T>::operator+=(Num_T t)$/;"	f	class:itpp::Vec	signature:(Num_T t)
operator +=	/usr/include/itpp/base/vec.h	/^Vec<Num_T>& Vec<Num_T>::operator+=(const Vec<Num_T> &v)$/;"	f	class:itpp::Vec	signature:(const Vec<Num_T> &v)
operator +=	/usr/include/itpp/comm/galois.h	/^  void operator+=(const GF &ingf);$/;"	p	class:itpp::GF	access:public	signature:(const GF &ingf)
operator +=	/usr/include/itpp/comm/galois.h	/^  void operator+=(const GFX &ingfx);$/;"	p	class:itpp::GFX	access:public	signature:(const GFX &ingfx)
operator +=	/usr/include/itpp/comm/galois.h	/^inline void GF::operator+=(const GF &ingf)$/;"	f	class:itpp::GF	signature:(const GF &ingf)
operator +=	/usr/include/itpp/comm/galois.h	/^inline void GFX::operator+=(const GFX &ingfx)$/;"	f	class:itpp::GFX	signature:(const GFX &ingfx)
operator +=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator+=(const CFix &x);$/;"	p	class:itpp::CFix	access:public	signature:(const CFix &x)
operator +=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator+=(const Fix &x);$/;"	p	class:itpp::CFix	access:public	signature:(const Fix &x)
operator +=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator+=(const int x);$/;"	p	class:itpp::CFix	access:public	signature:(const int x)
operator +=	/usr/include/itpp/fixed/fix.h	/^  Fix& operator+=(const Fix &x);$/;"	p	class:itpp::Fix	access:public	signature:(const Fix &x)
operator +=	/usr/include/itpp/fixed/fix.h	/^  Fix& operator+=(const int x);$/;"	p	class:itpp::Fix	access:public	signature:(const int x)
operator +=	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number &operator+=(const int n) { seq += n; return *this; }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const int n)
operator -	/usr/include/itpp/base/binary.h	/^  bin operator-() const { return bin(b); }$/;"	f	class:itpp::bin	access:public	signature:() const
operator -	/usr/include/itpp/base/binary.h	/^  bin operator-(const bin &inbin) const { return bin(b ^ inbin.b); }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin) const
operator -	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator-(Num_T t, const Mat<Num_T> &m)$/;"	f	namespace:itpp	signature:(Num_T t, const Mat<Num_T> &m)
operator -	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator-(Num_T t, const Mat<Num_T> &m);$/;"	p	namespace:itpp	signature:(Num_T t, const Mat<Num_T> &m)
operator -	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator-(const Mat<Num_T> &m)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m)
operator -	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator-(const Mat<Num_T> &m);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m)
operator -	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator-(const Mat<Num_T> &m, Num_T t)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m, Num_T t)
operator -	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator-(const Mat<Num_T> &m, Num_T t);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m, Num_T t)
operator -	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator-(const Mat<Num_T> &m1, const Mat<Num_T> &m2)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
operator -	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator-(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
operator -	/usr/include/itpp/base/mat.h	/^extern template bmat operator-(bin t, const bmat &m);$/;"	p	namespace:itpp	signature:(bin t, const bmat &m)
operator -	/usr/include/itpp/base/mat.h	/^extern template bmat operator-(const bmat &m);$/;"	p	namespace:itpp	signature:(const bmat &m)
operator -	/usr/include/itpp/base/mat.h	/^extern template bmat operator-(const bmat &m, bin t);$/;"	p	namespace:itpp	signature:(const bmat &m, bin t)
operator -	/usr/include/itpp/base/mat.h	/^extern template bmat operator-(const bmat &m1, const bmat &m2);$/;"	p	namespace:itpp	signature:(const bmat &m1, const bmat &m2)
operator -	/usr/include/itpp/base/mat.h	/^extern template cmat operator-(const cmat &m);$/;"	p	namespace:itpp	signature:(const cmat &m)
operator -	/usr/include/itpp/base/mat.h	/^extern template cmat operator-(const cmat &m, std::complex<double> t);$/;"	p	namespace:itpp	signature:(const cmat &m, std::complex<double> t)
operator -	/usr/include/itpp/base/mat.h	/^extern template cmat operator-(const cmat &m1, const cmat &m2);$/;"	p	namespace:itpp	signature:(const cmat &m1, const cmat &m2)
operator -	/usr/include/itpp/base/mat.h	/^extern template cmat operator-(std::complex<double> t, const cmat &m);$/;"	p	namespace:itpp	signature:(std::complex<double> t, const cmat &m)
operator -	/usr/include/itpp/base/mat.h	/^extern template imat operator-(const imat &m);$/;"	p	namespace:itpp	signature:(const imat &m)
operator -	/usr/include/itpp/base/mat.h	/^extern template imat operator-(const imat &m, int t);$/;"	p	namespace:itpp	signature:(const imat &m, int t)
operator -	/usr/include/itpp/base/mat.h	/^extern template imat operator-(const imat &m1, const imat &m2);$/;"	p	namespace:itpp	signature:(const imat &m1, const imat &m2)
operator -	/usr/include/itpp/base/mat.h	/^extern template imat operator-(int t, const imat &m);$/;"	p	namespace:itpp	signature:(int t, const imat &m)
operator -	/usr/include/itpp/base/mat.h	/^extern template mat operator-(const mat &m);$/;"	p	namespace:itpp	signature:(const mat &m)
operator -	/usr/include/itpp/base/mat.h	/^extern template mat operator-(const mat &m, double t);$/;"	p	namespace:itpp	signature:(const mat &m, double t)
operator -	/usr/include/itpp/base/mat.h	/^extern template mat operator-(const mat &m1, const mat &m2);$/;"	p	namespace:itpp	signature:(const mat &m1, const mat &m2)
operator -	/usr/include/itpp/base/mat.h	/^extern template mat operator-(double t, const mat &m);$/;"	p	namespace:itpp	signature:(double t, const mat &m)
operator -	/usr/include/itpp/base/mat.h	/^extern template smat operator-(const smat &m);$/;"	p	namespace:itpp	signature:(const smat &m)
operator -	/usr/include/itpp/base/mat.h	/^extern template smat operator-(const smat &m, short t);$/;"	p	namespace:itpp	signature:(const smat &m, short t)
operator -	/usr/include/itpp/base/mat.h	/^extern template smat operator-(const smat &m1, const smat &m2);$/;"	p	namespace:itpp	signature:(const smat &m1, const smat &m2)
operator -	/usr/include/itpp/base/mat.h	/^extern template smat operator-(short t, const smat &m);$/;"	p	namespace:itpp	signature:(short t, const smat &m)
operator -	/usr/include/itpp/base/operators.h	/^cmat operator-(const double &s, const cmat &m);$/;"	p	namespace:itpp	signature:(const double &s, const cmat &m)
operator -	/usr/include/itpp/base/operators.h	/^cvec operator-(const double &s, const cvec &v);$/;"	p	namespace:itpp	signature:(const double &s, const cvec &v)
operator -	/usr/include/itpp/base/operators.h	/^cvec operator-(const std::complex<double> &s, const ivec &v);$/;"	p	namespace:itpp	signature:(const std::complex<double> &s, const ivec &v)
operator -	/usr/include/itpp/base/operators.h	/^inline cmat operator-(const bmat &a, const cmat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const bmat &a, const cmat &b)
operator -	/usr/include/itpp/base/operators.h	/^inline cmat operator-(const cmat &a, const bmat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const cmat &a, const bmat &b)
operator -	/usr/include/itpp/base/operators.h	/^inline cmat operator-(const cmat &a, const imat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const cmat &a, const imat &b)
operator -	/usr/include/itpp/base/operators.h	/^inline cmat operator-(const cmat &a, const mat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const cmat &a, const mat &b)
operator -	/usr/include/itpp/base/operators.h	/^inline cmat operator-(const cmat &a, const smat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const cmat &a, const smat &b)
operator -	/usr/include/itpp/base/operators.h	/^inline cmat operator-(const imat &a, const cmat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const imat &a, const cmat &b)
operator -	/usr/include/itpp/base/operators.h	/^inline cmat operator-(const mat &a, const cmat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const mat &a, const cmat &b)
operator -	/usr/include/itpp/base/operators.h	/^inline cmat operator-(const smat &a, const cmat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const smat &a, const cmat &b)
operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const bvec &a, const cvec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const bvec &a, const cvec &b)
operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const cvec &a, const bvec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const cvec &a, const bvec &b)
operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const cvec &a, const ivec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const cvec &a, const ivec &b)
operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const cvec &a, const svec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const cvec &a, const svec &b)
operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const cvec &v, const double &s) {return v + (-s);}$/;"	f	namespace:itpp	signature:(const cvec &v, const double &s)
operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const cvec &v, const float &s) {return v + (-s);}$/;"	f	namespace:itpp	signature:(const cvec &v, const float &s)
operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const cvec &v, const int &s) {return v + (-s);}$/;"	f	namespace:itpp	signature:(const cvec &v, const int &s)
operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const cvec &v, const short &s) {return v + (-s);}$/;"	f	namespace:itpp	signature:(const cvec &v, const short &s)
operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const float &s, const cvec &v) {return static_cast<double>(s) - v;}$/;"	f	namespace:itpp	signature:(const float &s, const cvec &v)
operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const int &s, const cvec &v) {return static_cast<double>(s) - v;}$/;"	f	namespace:itpp	signature:(const int &s, const cvec &v)
operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const ivec &a, const cvec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const ivec &a, const cvec &b)
operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const ivec &v, const std::complex<double> &s) { return v + (-s); }$/;"	f	namespace:itpp	signature:(const ivec &v, const std::complex<double> &s)
operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const short &s, const cvec &v) {return static_cast<double>(s) - v;}$/;"	f	namespace:itpp	signature:(const short &s, const cvec &v)
operator -	/usr/include/itpp/base/operators.h	/^inline cvec operator-(const svec &a, const cvec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const svec &a, const cvec &b)
operator -	/usr/include/itpp/base/operators.h	/^inline mat operator-(const bmat &a, const mat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const bmat &a, const mat &b)
operator -	/usr/include/itpp/base/operators.h	/^inline mat operator-(const float &s, const mat &m) {return static_cast<double>(s) - m;}$/;"	f	namespace:itpp	signature:(const float &s, const mat &m)
operator -	/usr/include/itpp/base/operators.h	/^inline mat operator-(const imat &a, const mat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const imat &a, const mat &b)
operator -	/usr/include/itpp/base/operators.h	/^inline mat operator-(const int &s, const mat &m) {return static_cast<double>(s) - m;}$/;"	f	namespace:itpp	signature:(const int &s, const mat &m)
operator -	/usr/include/itpp/base/operators.h	/^inline mat operator-(const mat &a, const bmat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const mat &a, const bmat &b)
operator -	/usr/include/itpp/base/operators.h	/^inline mat operator-(const mat &a, const imat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const mat &a, const imat &b)
operator -	/usr/include/itpp/base/operators.h	/^inline mat operator-(const mat &a, const smat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const mat &a, const smat &b)
operator -	/usr/include/itpp/base/operators.h	/^inline mat operator-(const mat &m, const float &s) {return m -static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const mat &m, const float &s)
operator -	/usr/include/itpp/base/operators.h	/^inline mat operator-(const mat &m, const int &s) {return m -static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const mat &m, const int &s)
operator -	/usr/include/itpp/base/operators.h	/^inline mat operator-(const mat &m, const short &s) {return m -static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const mat &m, const short &s)
operator -	/usr/include/itpp/base/operators.h	/^inline mat operator-(const short &s, const mat &m) {return static_cast<double>(s) - m;}$/;"	f	namespace:itpp	signature:(const short &s, const mat &m)
operator -	/usr/include/itpp/base/operators.h	/^inline mat operator-(const smat &a, const mat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const smat &a, const mat &b)
operator -	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator-(const float &x, const std::complex<double> &y) {return std::complex<double>(x - y.real(), x - y.imag());}$/;"	f	namespace:itpp	signature:(const float &x, const std::complex<double> &y)
operator -	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator-(const int &x, const std::complex<double> &y) {return std::complex<double>(x - y.real(), x - y.imag());}$/;"	f	namespace:itpp	signature:(const int &x, const std::complex<double> &y)
operator -	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator-(const std::complex<double> &x, const float &y) {return std::complex<double>(x.real() - y, x.imag() - y);}$/;"	f	namespace:itpp	signature:(const std::complex<double> &x, const float &y)
operator -	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator-(const std::complex<double> &x, const int &y) {return std::complex<double>(x.real() - y, x.imag() - y);}$/;"	f	namespace:itpp	signature:(const std::complex<double> &x, const int &y)
operator -	/usr/include/itpp/base/operators.h	/^inline vec operator-(const bvec &a, const vec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const bvec &a, const vec &b)
operator -	/usr/include/itpp/base/operators.h	/^inline vec operator-(const float &s, const vec &v) {return static_cast<double>(s) - v;}$/;"	f	namespace:itpp	signature:(const float &s, const vec &v)
operator -	/usr/include/itpp/base/operators.h	/^inline vec operator-(const int &s, const vec &v) {return static_cast<double>(s) - v;}$/;"	f	namespace:itpp	signature:(const int &s, const vec &v)
operator -	/usr/include/itpp/base/operators.h	/^inline vec operator-(const ivec &a, const vec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const ivec &a, const vec &b)
operator -	/usr/include/itpp/base/operators.h	/^inline vec operator-(const ivec &v, const double &s) { return v + (-s); }$/;"	f	namespace:itpp	signature:(const ivec &v, const double &s)
operator -	/usr/include/itpp/base/operators.h	/^inline vec operator-(const short &s, const vec &v) {return static_cast<double>(s) - v;}$/;"	f	namespace:itpp	signature:(const short &s, const vec &v)
operator -	/usr/include/itpp/base/operators.h	/^inline vec operator-(const svec &a, const vec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const svec &a, const vec &b)
operator -	/usr/include/itpp/base/operators.h	/^inline vec operator-(const vec &a, const bvec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const vec &a, const bvec &b)
operator -	/usr/include/itpp/base/operators.h	/^inline vec operator-(const vec &a, const ivec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const vec &a, const ivec &b)
operator -	/usr/include/itpp/base/operators.h	/^inline vec operator-(const vec &a, const svec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const vec &a, const svec &b)
operator -	/usr/include/itpp/base/operators.h	/^inline vec operator-(const vec &v, const float &s) {return v -static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const vec &v, const float &s)
operator -	/usr/include/itpp/base/operators.h	/^inline vec operator-(const vec &v, const int &s) {return v -static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const vec &v, const int &s)
operator -	/usr/include/itpp/base/operators.h	/^inline vec operator-(const vec &v, const short &s) {return v -static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const vec &v, const short &s)
operator -	/usr/include/itpp/base/operators.h	/^vec operator-(const double &s, const ivec &v);$/;"	p	namespace:itpp	signature:(const double &s, const ivec &v)
operator -	/usr/include/itpp/base/smat.h	/^  Sparse_Mat<T> operator-() const;$/;"	p	class:itpp::Sparse_Mat	access:public	signature:() const
operator -	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> Sparse_Mat<T>::operator-() const$/;"	f	class:itpp::Sparse_Mat	signature:() const
operator -	/usr/include/itpp/base/svec.h	/^  Sparse_Vec<T> operator-() const;$/;"	p	class:itpp::Sparse_Vec	access:public	signature:() const
operator -	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T> Sparse_Vec<T>::operator-() const$/;"	f	class:itpp::Sparse_Vec	signature:() const
operator -	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator-(Num_T t, const Vec<Num_T> &v)$/;"	f	namespace:itpp	signature:(Num_T t, const Vec<Num_T> &v)
operator -	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator-(Num_T t, const Vec<Num_T> &v);$/;"	p	namespace:itpp	signature:(Num_T t, const Vec<Num_T> &v)
operator -	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator-(const Vec<Num_T> &v)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v)
operator -	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator-(const Vec<Num_T> &v);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v)
operator -	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator-(const Vec<Num_T> &v, Num_T t)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v, Num_T t)
operator -	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator-(const Vec<Num_T> &v, Num_T t);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v, Num_T t)
operator -	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator-(const Vec<Num_T> &v1, const Vec<Num_T> &v2)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
operator -	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator-(const Vec<Num_T> &v1, const Vec<Num_T> &v2);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
operator -	/usr/include/itpp/base/vec.h	/^extern template bvec operator-(bin t, const bvec &v);$/;"	p	namespace:itpp	signature:(bin t, const bvec &v)
operator -	/usr/include/itpp/base/vec.h	/^extern template bvec operator-(const bvec &v);$/;"	p	namespace:itpp	signature:(const bvec &v)
operator -	/usr/include/itpp/base/vec.h	/^extern template bvec operator-(const bvec &v, bin t);$/;"	p	namespace:itpp	signature:(const bvec &v, bin t)
operator -	/usr/include/itpp/base/vec.h	/^extern template bvec operator-(const bvec &v1, const bvec &v2);$/;"	p	namespace:itpp	signature:(const bvec &v1, const bvec &v2)
operator -	/usr/include/itpp/base/vec.h	/^extern template cvec operator-(const cvec &v);$/;"	p	namespace:itpp	signature:(const cvec &v)
operator -	/usr/include/itpp/base/vec.h	/^extern template cvec operator-(const cvec &v, std::complex<double> t);$/;"	p	namespace:itpp	signature:(const cvec &v, std::complex<double> t)
operator -	/usr/include/itpp/base/vec.h	/^extern template cvec operator-(const cvec &v1, const cvec &v2);$/;"	p	namespace:itpp	signature:(const cvec &v1, const cvec &v2)
operator -	/usr/include/itpp/base/vec.h	/^extern template cvec operator-(std::complex<double> t, const cvec &v);$/;"	p	namespace:itpp	signature:(std::complex<double> t, const cvec &v)
operator -	/usr/include/itpp/base/vec.h	/^extern template ivec operator-(const ivec &v);$/;"	p	namespace:itpp	signature:(const ivec &v)
operator -	/usr/include/itpp/base/vec.h	/^extern template ivec operator-(const ivec &v, int t);$/;"	p	namespace:itpp	signature:(const ivec &v, int t)
operator -	/usr/include/itpp/base/vec.h	/^extern template ivec operator-(const ivec &v1, const ivec &v2);$/;"	p	namespace:itpp	signature:(const ivec &v1, const ivec &v2)
operator -	/usr/include/itpp/base/vec.h	/^extern template ivec operator-(int t, const ivec &v);$/;"	p	namespace:itpp	signature:(int t, const ivec &v)
operator -	/usr/include/itpp/base/vec.h	/^extern template svec operator-(const svec &v);$/;"	p	namespace:itpp	signature:(const svec &v)
operator -	/usr/include/itpp/base/vec.h	/^extern template svec operator-(const svec &v, short t);$/;"	p	namespace:itpp	signature:(const svec &v, short t)
operator -	/usr/include/itpp/base/vec.h	/^extern template svec operator-(const svec &v1, const svec &v2);$/;"	p	namespace:itpp	signature:(const svec &v1, const svec &v2)
operator -	/usr/include/itpp/base/vec.h	/^extern template svec operator-(short t, const svec &v);$/;"	p	namespace:itpp	signature:(short t, const svec &v)
operator -	/usr/include/itpp/base/vec.h	/^extern template vec operator-(const vec &v);$/;"	p	namespace:itpp	signature:(const vec &v)
operator -	/usr/include/itpp/base/vec.h	/^extern template vec operator-(const vec &v, double t);$/;"	p	namespace:itpp	signature:(const vec &v, double t)
operator -	/usr/include/itpp/base/vec.h	/^extern template vec operator-(const vec &v1, const vec &v2);$/;"	p	namespace:itpp	signature:(const vec &v1, const vec &v2)
operator -	/usr/include/itpp/base/vec.h	/^extern template vec operator-(double t, const vec &v);$/;"	p	namespace:itpp	signature:(double t, const vec &v)
operator -	/usr/include/itpp/comm/galois.h	/^  GF operator-(const GF &ingf) const;$/;"	p	class:itpp::GF	access:public	signature:(const GF &ingf) const
operator -	/usr/include/itpp/comm/galois.h	/^  GFX operator-(const GFX &ingfx) const;$/;"	p	class:itpp::GFX	access:public	signature:(const GFX &ingfx) const
operator -	/usr/include/itpp/comm/galois.h	/^inline GF GF::operator-(const GF &ingf) const$/;"	f	class:itpp::GF	signature:(const GF &ingf) const
operator -	/usr/include/itpp/comm/galois.h	/^inline GFX GFX::operator-(const GFX &ingfx) const$/;"	f	class:itpp::GFX	signature:(const GFX &ingfx) const
operator -	/usr/include/itpp/fixed/cfix.h	/^  CFix operator-() const;$/;"	p	class:itpp::CFix	access:public	signature:() const
operator -	/usr/include/itpp/fixed/fix.h	/^  Fix operator-() const;$/;"	p	class:itpp::Fix	access:public	signature:() const
operator -	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator-(const CFix &x, const CFix &y);$/;"	p	namespace:itpp	signature:(const CFix &x, const CFix &y)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator-(const CFix &x, const Fix &y);$/;"	p	namespace:itpp	signature:(const CFix &x, const Fix &y)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator-(const CFix &x, const int y);$/;"	p	namespace:itpp	signature:(const CFix &x, const int y)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator-(const Fix &x, const CFix &y);$/;"	p	namespace:itpp	signature:(const Fix &x, const CFix &y)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator-(const int x, const CFix &y);$/;"	p	namespace:itpp	signature:(const int x, const CFix &y)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^Fix operator-(const Fix &x, const Fix &y);$/;"	p	namespace:itpp	signature:(const Fix &x, const Fix &y)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^Fix operator-(const Fix &x, const int y);$/;"	p	namespace:itpp	signature:(const Fix &x, const int y)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^Fix operator-(const int x, const Fix &y);$/;"	p	namespace:itpp	signature:(const int x, const Fix &y)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator-(const CFix &s, const fixmat &m) {return s - to<CFix>(m);}$/;"	f	namespace:itpp	signature:(const CFix &s, const fixmat &m)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator-(const CFix &s, const imat &m) {return s - to<CFix>(to_mat(m));}$/;"	f	namespace:itpp	signature:(const CFix &s, const imat &m)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator-(const Fix &s, const cfixmat &m) {return CFix(s) - m;}$/;"	f	namespace:itpp	signature:(const Fix &s, const cfixmat &m)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator-(const cfixmat &a, const fixmat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const cfixmat &a, const fixmat &b)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator-(const cfixmat &a, const imat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const cfixmat &a, const imat &b)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator-(const cfixmat &m, const Fix &s) {return m - CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixmat &m, const Fix &s)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator-(const cfixmat &m, const int s) {return m - CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixmat &m, const int s)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator-(const fixmat &a, const cfixmat &b) {return (-b) + a;}$/;"	f	namespace:itpp	signature:(const fixmat &a, const cfixmat &b)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator-(const fixmat &m, const CFix &s) {return to<CFix>(m) - s;}$/;"	f	namespace:itpp	signature:(const fixmat &m, const CFix &s)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator-(const imat &a, const cfixmat &b) {return (-b) + a;}$/;"	f	namespace:itpp	signature:(const imat &a, const cfixmat &b)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator-(const imat &m, const CFix &s) {return to<CFix>(to_mat(m)) - s;}$/;"	f	namespace:itpp	signature:(const imat &m, const CFix &s)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator-(const int s, const cfixmat &m) {return CFix(s) - m;}$/;"	f	namespace:itpp	signature:(const int s, const cfixmat &m)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator-(const CFix &s, const fixvec &v) {return s - to<CFix>(v);}$/;"	f	namespace:itpp	signature:(const CFix &s, const fixvec &v)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator-(const CFix &s, const ivec &v) {return s - to<CFix>(to_vec(v));}$/;"	f	namespace:itpp	signature:(const CFix &s, const ivec &v)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator-(const Fix &s, const cfixvec &v) {return CFix(s) - v;}$/;"	f	namespace:itpp	signature:(const Fix &s, const cfixvec &v)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator-(const cfixvec &a, const fixvec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const cfixvec &a, const fixvec &b)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator-(const cfixvec &a, const ivec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const cfixvec &a, const ivec &b)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator-(const cfixvec &v, const Fix &s) {return v - CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixvec &v, const Fix &s)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator-(const cfixvec &v, const int s) {return v - CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixvec &v, const int s)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator-(const fixvec &a, const cfixvec &b) {return (-b) + a;}$/;"	f	namespace:itpp	signature:(const fixvec &a, const cfixvec &b)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator-(const fixvec &v, const CFix &s) {return to<CFix>(v) - s;}$/;"	f	namespace:itpp	signature:(const fixvec &v, const CFix &s)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator-(const int s, const cfixvec &v) {return CFix(s) - v;}$/;"	f	namespace:itpp	signature:(const int s, const cfixvec &v)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator-(const ivec &a, const cfixvec &b) {return (-b) + a;}$/;"	f	namespace:itpp	signature:(const ivec &a, const cfixvec &b)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator-(const ivec &v, const CFix &s) {return to<CFix>(to_vec(v)) - s;}$/;"	f	namespace:itpp	signature:(const ivec &v, const CFix &s)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline fixmat operator-(const fixmat &a, const imat &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const fixmat &a, const imat &b)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline fixmat operator-(const fixmat &v, const int s) {return v - Fix(s);}$/;"	f	namespace:itpp	signature:(const fixmat &v, const int s)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline fixmat operator-(const imat &a, const fixmat &b) {return (-b) + a;}$/;"	f	namespace:itpp	signature:(const imat &a, const fixmat &b)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline fixmat operator-(const int s, const fixmat &v) {return Fix(s) - v;}$/;"	f	namespace:itpp	signature:(const int s, const fixmat &v)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline fixvec operator-(const fixvec &a, const ivec &b) {return a + (-b);}$/;"	f	namespace:itpp	signature:(const fixvec &a, const ivec &b)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline fixvec operator-(const fixvec &v, const int s) {return v - Fix(s);}$/;"	f	namespace:itpp	signature:(const fixvec &v, const int s)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline fixvec operator-(const int s, const fixvec &v) {return Fix(s) - v;}$/;"	f	namespace:itpp	signature:(const int s, const fixvec &v)
operator -	/usr/include/itpp/fixed/fix_operators.h	/^inline fixvec operator-(const ivec &a, const fixvec &b) {return (-b) + a;}$/;"	f	namespace:itpp	signature:(const ivec &a, const fixvec &b)
operator -	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number operator-(const int n) const { return Sequence_Number(seq - n); }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const int n) const
operator -	/usr/include/itpp/protocol/tcp.h	/^  int operator-(const Sequence_Number &n) const { return seq - n.seq; }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const Sequence_Number &n) const
operator -<>	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> operator-<>(Num_T t, const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:friend	signature:(Num_T t, const Mat<Num_T> &m)
operator -<>	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> operator-<>(const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m)
operator -<>	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> operator-<>(const Mat<Num_T> &m, Num_T t);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m, Num_T t)
operator -<>	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> operator-<>(const Mat<Num_T> &m1, const Mat<Num_T> &m2);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m1, const Mat<Num_T> &m2)
operator -<>	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> operator-<>(Num_T t, const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:friend	signature:(Num_T t, const Vec<Num_T> &v)
operator -<>	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> operator-<>(const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v)
operator -<>	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> operator-<>(const Vec<Num_T> &v, Num_T t);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v, Num_T t)
operator -<>	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> operator-<>(const Vec<Num_T> &v1, const Vec<Num_T> &v2);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2)
operator -=	/usr/include/itpp/base/binary.h	/^  void operator-=(const bin &inbin) { b ^= inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin)
operator -=	/usr/include/itpp/base/mat.h	/^  Mat<Num_T>& operator-=(Num_T t);$/;"	p	class:itpp::Mat	access:public	signature:(Num_T t)
operator -=	/usr/include/itpp/base/mat.h	/^  Mat<Num_T>& operator-=(const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:public	signature:(const Mat<Num_T> &m)
operator -=	/usr/include/itpp/base/mat.h	/^Mat<Num_T>& Mat<Num_T>::operator-=(Num_T t)$/;"	f	class:itpp::Mat	signature:(Num_T t)
operator -=	/usr/include/itpp/base/mat.h	/^Mat<Num_T>& Mat<Num_T>::operator-=(const Mat<Num_T> &m)$/;"	f	class:itpp::Mat	signature:(const Mat<Num_T> &m)
operator -=	/usr/include/itpp/base/smat.h	/^  void operator-=(const Mat<T> &v);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const Mat<T> &v)
operator -=	/usr/include/itpp/base/smat.h	/^  void operator-=(const Sparse_Mat<T> &v);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const Sparse_Mat<T> &v)
operator -=	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::operator-=(const Mat<T> &m)$/;"	f	class:itpp::Sparse_Mat	signature:(const Mat<T> &m)
operator -=	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::operator-=(const Sparse_Mat<T> &m)$/;"	f	class:itpp::Sparse_Mat	signature:(const Sparse_Mat<T> &m)
operator -=	/usr/include/itpp/base/svec.h	/^  void operator-=(const Sparse_Vec<T> &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const Sparse_Vec<T> &v)
operator -=	/usr/include/itpp/base/svec.h	/^  void operator-=(const Vec<T> &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const Vec<T> &v)
operator -=	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::operator-=(const Sparse_Vec<T> &v)$/;"	f	class:itpp::Sparse_Vec	signature:(const Sparse_Vec<T> &v)
operator -=	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::operator-=(const Vec<T> &v)$/;"	f	class:itpp::Sparse_Vec	signature:(const Vec<T> &v)
operator -=	/usr/include/itpp/base/vec.h	/^  Vec<Num_T>& operator-=(Num_T t);$/;"	p	class:itpp::Vec	access:public	signature:(Num_T t)
operator -=	/usr/include/itpp/base/vec.h	/^  Vec<Num_T>& operator-=(const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:public	signature:(const Vec<Num_T> &v)
operator -=	/usr/include/itpp/base/vec.h	/^Vec<Num_T>& Vec<Num_T>::operator-=(Num_T t)$/;"	f	class:itpp::Vec	signature:(Num_T t)
operator -=	/usr/include/itpp/base/vec.h	/^Vec<Num_T>& Vec<Num_T>::operator-=(const Vec<Num_T> &v)$/;"	f	class:itpp::Vec	signature:(const Vec<Num_T> &v)
operator -=	/usr/include/itpp/comm/galois.h	/^  void operator-=(const GF &ingf);$/;"	p	class:itpp::GF	access:public	signature:(const GF &ingf)
operator -=	/usr/include/itpp/comm/galois.h	/^  void operator-=(const GFX &ingfx);$/;"	p	class:itpp::GFX	access:public	signature:(const GFX &ingfx)
operator -=	/usr/include/itpp/comm/galois.h	/^inline void GF::operator-=(const GF &ingf)$/;"	f	class:itpp::GF	signature:(const GF &ingf)
operator -=	/usr/include/itpp/comm/galois.h	/^inline void GFX::operator-=(const GFX &ingfx)$/;"	f	class:itpp::GFX	signature:(const GFX &ingfx)
operator -=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator-=(const CFix &x);$/;"	p	class:itpp::CFix	access:public	signature:(const CFix &x)
operator -=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator-=(const Fix &x);$/;"	p	class:itpp::CFix	access:public	signature:(const Fix &x)
operator -=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator-=(const int x);$/;"	p	class:itpp::CFix	access:public	signature:(const int x)
operator -=	/usr/include/itpp/fixed/fix.h	/^  Fix& operator-=(const Fix &x);$/;"	p	class:itpp::Fix	access:public	signature:(const Fix &x)
operator -=	/usr/include/itpp/fixed/fix.h	/^  Fix& operator-=(const int x);$/;"	p	class:itpp::Fix	access:public	signature:(const int x)
operator -=	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number &operator-=(const int n) { seq -= n; return *this; }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const int n)
operator /	/usr/include/itpp/base/binary.h	/^  bin operator\/(const bin &inbin) const { return bin(b | inbin.b); }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin) const
operator /	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator\/(const Mat<Num_T> &m, Num_T t)$/;"	f	namespace:itpp	signature:(const Mat<Num_T> &m, Num_T t)
operator /	/usr/include/itpp/base/mat.h	/^Mat<Num_T> operator\/(const Mat<Num_T> &m, Num_T t);$/;"	p	namespace:itpp	signature:(const Mat<Num_T> &m, Num_T t)
operator /	/usr/include/itpp/base/mat.h	/^extern template bmat operator\/(const bmat &m, bin t);$/;"	p	namespace:itpp	signature:(const bmat &m, bin t)
operator /	/usr/include/itpp/base/mat.h	/^extern template cmat operator\/(const cmat &m, std::complex<double> t);$/;"	p	namespace:itpp	signature:(const cmat &m, std::complex<double> t)
operator /	/usr/include/itpp/base/mat.h	/^extern template imat operator\/(const imat &m, int t);$/;"	p	namespace:itpp	signature:(const imat &m, int t)
operator /	/usr/include/itpp/base/mat.h	/^extern template mat operator\/(const mat &m, double t);$/;"	p	namespace:itpp	signature:(const mat &m, double t)
operator /	/usr/include/itpp/base/mat.h	/^extern template smat operator\/(const smat &m, short t);$/;"	p	namespace:itpp	signature:(const smat &m, short t)
operator /	/usr/include/itpp/base/operators.h	/^cmat operator\/(const cmat &m, const double &s);$/;"	p	namespace:itpp	signature:(const cmat &m, const double &s)
operator /	/usr/include/itpp/base/operators.h	/^cvec operator\/(const cvec &v, const double &s);$/;"	p	namespace:itpp	signature:(const cvec &v, const double &s)
operator /	/usr/include/itpp/base/operators.h	/^cvec operator\/(const double &s, const cvec &v);$/;"	p	namespace:itpp	signature:(const double &s, const cvec &v)
operator /	/usr/include/itpp/base/operators.h	/^cvec operator\/(const ivec &v, const std::complex<double> &s);$/;"	p	namespace:itpp	signature:(const ivec &v, const std::complex<double> &s)
operator /	/usr/include/itpp/base/operators.h	/^cvec operator\/(const std::complex<double> &s, const ivec &v);$/;"	p	namespace:itpp	signature:(const std::complex<double> &s, const ivec &v)
operator /	/usr/include/itpp/base/operators.h	/^inline cvec operator\/(const cvec &v, const float &s) {return v \/ static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const cvec &v, const float &s)
operator /	/usr/include/itpp/base/operators.h	/^inline cvec operator\/(const cvec &v, const int &s) {return v \/ static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const cvec &v, const int &s)
operator /	/usr/include/itpp/base/operators.h	/^inline cvec operator\/(const cvec &v, const short &s) {return v \/ static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const cvec &v, const short &s)
operator /	/usr/include/itpp/base/operators.h	/^inline mat operator\/(const mat &m, const float &s) {return m \/ static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const mat &m, const float &s)
operator /	/usr/include/itpp/base/operators.h	/^inline mat operator\/(const mat &m, const int &s) {return m \/ static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const mat &m, const int &s)
operator /	/usr/include/itpp/base/operators.h	/^inline mat operator\/(const mat &m, const short &s) {return m \/ static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const mat &m, const short &s)
operator /	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator\/(const std::complex<double> &x, const float &y) {return std::complex<double>(x.real() \/ y, x.imag() \/ y);}$/;"	f	namespace:itpp	signature:(const std::complex<double> &x, const float &y)
operator /	/usr/include/itpp/base/operators.h	/^inline std::complex<double> operator\/(const std::complex<double> &x, const int &y) {return std::complex<double>(x.real() \/ y, x.imag() \/ y);}$/;"	f	namespace:itpp	signature:(const std::complex<double> &x, const int &y)
operator /	/usr/include/itpp/base/operators.h	/^inline vec operator\/(const vec &v, const float &s) {return v \/ static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const vec &v, const float &s)
operator /	/usr/include/itpp/base/operators.h	/^inline vec operator\/(const vec &v, const int &s) {return v \/ static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const vec &v, const int &s)
operator /	/usr/include/itpp/base/operators.h	/^inline vec operator\/(const vec &v, const short &s) {return v \/ static_cast<double>(s);}$/;"	f	namespace:itpp	signature:(const vec &v, const short &s)
operator /	/usr/include/itpp/base/operators.h	/^vec operator\/(const double &s, const ivec &v);$/;"	p	namespace:itpp	signature:(const double &s, const ivec &v)
operator /	/usr/include/itpp/base/operators.h	/^vec operator\/(const ivec &v, const double &s);$/;"	p	namespace:itpp	signature:(const ivec &v, const double &s)
operator /	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator\/(Num_T t, const Vec<Num_T> &v)$/;"	f	namespace:itpp	signature:(Num_T t, const Vec<Num_T> &v)
operator /	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator\/(Num_T t, const Vec<Num_T> &v);$/;"	p	namespace:itpp	signature:(Num_T t, const Vec<Num_T> &v)
operator /	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator\/(const Vec<Num_T> &v, Num_T t)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v, Num_T t)
operator /	/usr/include/itpp/base/vec.h	/^Vec<Num_T> operator\/(const Vec<Num_T> &v, Num_T t);$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v, Num_T t)
operator /	/usr/include/itpp/base/vec.h	/^extern template bvec operator\/(bin t, const bvec &v);$/;"	p	namespace:itpp	signature:(bin t, const bvec &v)
operator /	/usr/include/itpp/base/vec.h	/^extern template bvec operator\/(const bvec &v, bin t);$/;"	p	namespace:itpp	signature:(const bvec &v, bin t)
operator /	/usr/include/itpp/base/vec.h	/^extern template cvec operator\/(const cvec &v, std::complex<double> t);$/;"	p	namespace:itpp	signature:(const cvec &v, std::complex<double> t)
operator /	/usr/include/itpp/base/vec.h	/^extern template cvec operator\/(std::complex<double> t, const cvec &v);$/;"	p	namespace:itpp	signature:(std::complex<double> t, const cvec &v)
operator /	/usr/include/itpp/base/vec.h	/^extern template ivec operator\/(const ivec &v, int t);$/;"	p	namespace:itpp	signature:(const ivec &v, int t)
operator /	/usr/include/itpp/base/vec.h	/^extern template ivec operator\/(int t, const ivec &v);$/;"	p	namespace:itpp	signature:(int t, const ivec &v)
operator /	/usr/include/itpp/base/vec.h	/^extern template svec operator\/(const svec &v, short t);$/;"	p	namespace:itpp	signature:(const svec &v, short t)
operator /	/usr/include/itpp/base/vec.h	/^extern template svec operator\/(short t, const svec &v);$/;"	p	namespace:itpp	signature:(short t, const svec &v)
operator /	/usr/include/itpp/base/vec.h	/^extern template vec operator\/(const vec &v, double t);$/;"	p	namespace:itpp	signature:(const vec &v, double t)
operator /	/usr/include/itpp/base/vec.h	/^extern template vec operator\/(double t, const vec &v);$/;"	p	namespace:itpp	signature:(double t, const vec &v)
operator /	/usr/include/itpp/comm/galois.h	/^  GF operator\/(const GF &ingf) const;$/;"	p	class:itpp::GF	access:public	signature:(const GF &ingf) const
operator /	/usr/include/itpp/comm/galois.h	/^  friend GFX  operator\/(const GFX &ingfx, const GF &ingf);$/;"	p	class:itpp::GFX	access:friend	signature:(const GFX &ingfx, const GF &ingf)
operator /	/usr/include/itpp/comm/galois.h	/^GFX  operator\/(const GFX &ingfx, const GF &ingf);$/;"	p	namespace:itpp	signature:(const GFX &ingfx, const GF &ingf)
operator /	/usr/include/itpp/comm/galois.h	/^inline GF GF::operator\/(const GF &ingf) const$/;"	f	class:itpp::GF	signature:(const GF &ingf) const
operator /	/usr/include/itpp/comm/galois.h	/^inline GFX  operator\/(const GFX &ingfx, const GF &ingf)$/;"	f	namespace:itpp	signature:(const GFX &ingfx, const GF &ingf)
operator /	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator\/(const CFix &x, const CFix &y);$/;"	p	namespace:itpp	signature:(const CFix &x, const CFix &y)
operator /	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator\/(const CFix &x, const Fix &y);$/;"	p	namespace:itpp	signature:(const CFix &x, const Fix &y)
operator /	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator\/(const CFix &x, const int y);$/;"	p	namespace:itpp	signature:(const CFix &x, const int y)
operator /	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator\/(const Fix &x, const CFix &y);$/;"	p	namespace:itpp	signature:(const Fix &x, const CFix &y)
operator /	/usr/include/itpp/fixed/fix_operators.h	/^CFix operator\/(const int x, const CFix &y);$/;"	p	namespace:itpp	signature:(const int x, const CFix &y)
operator /	/usr/include/itpp/fixed/fix_operators.h	/^Fix operator\/(const Fix &x, const Fix &y);$/;"	p	namespace:itpp	signature:(const Fix &x, const Fix &y)
operator /	/usr/include/itpp/fixed/fix_operators.h	/^Fix operator\/(const Fix &x, const int y);$/;"	p	namespace:itpp	signature:(const Fix &x, const int y)
operator /	/usr/include/itpp/fixed/fix_operators.h	/^Fix operator\/(const int x, const Fix &y);$/;"	p	namespace:itpp	signature:(const int x, const Fix &y)
operator /	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator\/(const cfixmat &m, const Fix &s) {return m \/ CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixmat &m, const Fix &s)
operator /	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator\/(const cfixmat &m, const int s) {return m \/ CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixmat &m, const int s)
operator /	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator\/(const fixmat &m, const CFix &s) {return to<CFix>(m) \/ s;}$/;"	f	namespace:itpp	signature:(const fixmat &m, const CFix &s)
operator /	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixmat operator\/(const imat &m, const CFix &s) {return to<CFix>(to_mat(m)) \/ s;}$/;"	f	namespace:itpp	signature:(const imat &m, const CFix &s)
operator /	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator\/(const cfixvec &v, const Fix &s) {return v \/ CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixvec &v, const Fix &s)
operator /	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator\/(const cfixvec &v, const int s) {return v \/ CFix(s);}$/;"	f	namespace:itpp	signature:(const cfixvec &v, const int s)
operator /	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator\/(const fixvec &v, const CFix &s) {return to<CFix>(v) \/ s;}$/;"	f	namespace:itpp	signature:(const fixvec &v, const CFix &s)
operator /	/usr/include/itpp/fixed/fix_operators.h	/^inline cfixvec operator\/(const ivec &v, const CFix &s) {return to<CFix>(to_vec(v)) \/ s;}$/;"	f	namespace:itpp	signature:(const ivec &v, const CFix &s)
operator /	/usr/include/itpp/fixed/fix_operators.h	/^inline fixmat operator\/(const fixmat &v, const int s) {return v \/ Fix(s);}$/;"	f	namespace:itpp	signature:(const fixmat &v, const int s)
operator /	/usr/include/itpp/fixed/fix_operators.h	/^inline fixvec operator\/(const fixvec &v, const int s) {return v \/ Fix(s);}$/;"	f	namespace:itpp	signature:(const fixvec &v, const int s)
operator /<>	/usr/include/itpp/base/mat.h	/^  friend Mat<Num_T> operator\/<>(const Mat<Num_T> &m, Num_T t);$/;"	p	class:itpp::Mat	access:friend	signature:(const Mat<Num_T> &m, Num_T t)
operator /<>	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> operator\/<>(Num_T t, const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:friend	signature:(Num_T t, const Vec<Num_T> &v)
operator /<>	/usr/include/itpp/base/vec.h	/^  friend Vec<Num_T> operator\/<>(const Vec<Num_T> &v, Num_T t);$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v, Num_T t)
operator /=	/usr/include/itpp/base/binary.h	/^  void operator\/=(const bin &inbin) { b |= inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin)
operator /=	/usr/include/itpp/base/mat.h	/^  Mat<Num_T>& operator\/=(Num_T t);$/;"	p	class:itpp::Mat	access:public	signature:(Num_T t)
operator /=	/usr/include/itpp/base/mat.h	/^  Mat<Num_T>& operator\/=(const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:public	signature:(const Mat<Num_T> &m)
operator /=	/usr/include/itpp/base/mat.h	/^Mat<Num_T>& Mat<Num_T>::operator\/=(Num_T t)$/;"	f	class:itpp::Mat	signature:(Num_T t)
operator /=	/usr/include/itpp/base/mat.h	/^Mat<Num_T>& Mat<Num_T>::operator\/=(const Mat<Num_T> &m)$/;"	f	class:itpp::Mat	signature:(const Mat<Num_T> &m)
operator /=	/usr/include/itpp/base/smat.h	/^  void operator\/=(const T &v);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const T &v)
operator /=	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::operator\/=(const T &m)$/;"	f	class:itpp::Sparse_Mat	signature:(const T &m)
operator /=	/usr/include/itpp/base/svec.h	/^  void operator\/=(const T &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const T &v)
operator /=	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::operator\/=(const T &v)$/;"	f	class:itpp::Sparse_Vec	signature:(const T &v)
operator /=	/usr/include/itpp/base/vec.h	/^  Vec<Num_T>& operator\/=(Num_T t);$/;"	p	class:itpp::Vec	access:public	signature:(Num_T t)
operator /=	/usr/include/itpp/base/vec.h	/^  Vec<Num_T>& operator\/=(const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:public	signature:(const Vec<Num_T> &v)
operator /=	/usr/include/itpp/base/vec.h	/^Vec<Num_T>& Vec<Num_T>::operator\/=(Num_T t)$/;"	f	class:itpp::Vec	signature:(Num_T t)
operator /=	/usr/include/itpp/base/vec.h	/^Vec<Num_T>& Vec<Num_T>::operator\/=(const Vec<Num_T> &v)$/;"	f	class:itpp::Vec	signature:(const Vec<Num_T> &v)
operator /=	/usr/include/itpp/comm/galois.h	/^  void operator\/=(const GF &ingf);$/;"	p	class:itpp::GF	access:public	signature:(const GF &ingf)
operator /=	/usr/include/itpp/comm/galois.h	/^inline void GF::operator\/=(const GF &ingf)$/;"	f	class:itpp::GF	signature:(const GF &ingf)
operator /=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator\/=(const CFix &x);$/;"	p	class:itpp::CFix	access:public	signature:(const CFix &x)
operator /=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator\/=(const Fix &x);$/;"	p	class:itpp::CFix	access:public	signature:(const Fix &x)
operator /=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator\/=(const int x);$/;"	p	class:itpp::CFix	access:public	signature:(const int x)
operator /=	/usr/include/itpp/fixed/fix.h	/^  Fix& operator\/=(const Fix &x);$/;"	p	class:itpp::Fix	access:public	signature:(const Fix &x)
operator /=	/usr/include/itpp/fixed/fix.h	/^  Fix& operator\/=(const int x);$/;"	p	class:itpp::Fix	access:public	signature:(const int x)
operator <	/usr/include/itpp/base/binary.h	/^  bool operator<(const bin &inbin) const  { return b < inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin) const
operator <	/usr/include/itpp/base/vec.h	/^  Vec<bin> operator<(Num_T t) const;$/;"	p	class:itpp::Vec	access:public	signature:(Num_T t) const
operator <	/usr/include/itpp/base/vec.h	/^bvec Vec<Num_T>::operator<(Num_T t) const$/;"	f	class:itpp::Vec	signature:(Num_T t) const
operator <	/usr/include/itpp/base/vec.h	/^bvec Vec<std::complex<double> >::operator<(std::complex<double>) const;$/;"	p	class:itpp::Vec	signature:(std::complex<double>) const
operator <	/usr/include/itpp/protocol/tcp.h	/^  bool operator<(const Sequence_Number &n) const { return (seq - n.seq) < 0; }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const Sequence_Number &n) const
operator <<	/usr/include/itpp/base/array.h	/^std::ostream &operator<<(std::ostream &os, const Array<T> &a)$/;"	f	namespace:itpp	signature:(std::ostream &os, const Array<T> &a)
operator <<	/usr/include/itpp/base/binary.h	/^std::ostream &operator<<(std::ostream &output, const bin &inbin);$/;"	p	namespace:itpp	signature:(std::ostream &output, const bin &inbin)
operator <<	/usr/include/itpp/base/binfile.h	/^  bfstream& operator<<(char a);$/;"	p	class:itpp::bfstream	access:public	signature:(char a)
operator <<	/usr/include/itpp/base/binfile.h	/^  bfstream& operator<<(const char* a);$/;"	p	class:itpp::bfstream	access:public	signature:(const char* a)
operator <<	/usr/include/itpp/base/binfile.h	/^  bfstream& operator<<(const std::string& a);$/;"	p	class:itpp::bfstream	access:public	signature:(const std::string& a)
operator <<	/usr/include/itpp/base/binfile.h	/^  bfstream& operator<<(double a);$/;"	p	class:itpp::bfstream	access:public	signature:(double a)
operator <<	/usr/include/itpp/base/binfile.h	/^  bfstream& operator<<(float a);$/;"	p	class:itpp::bfstream	access:public	signature:(float a)
operator <<	/usr/include/itpp/base/binfile.h	/^  bfstream& operator<<(int16_t a);$/;"	p	class:itpp::bfstream	access:public	signature:(int16_t a)
operator <<	/usr/include/itpp/base/binfile.h	/^  bfstream& operator<<(int32_t a);$/;"	p	class:itpp::bfstream	access:public	signature:(int32_t a)
operator <<	/usr/include/itpp/base/binfile.h	/^  bfstream& operator<<(int64_t a);$/;"	p	class:itpp::bfstream	access:public	signature:(int64_t a)
operator <<	/usr/include/itpp/base/binfile.h	/^  bfstream& operator<<(uint16_t a);$/;"	p	class:itpp::bfstream	access:public	signature:(uint16_t a)
operator <<	/usr/include/itpp/base/binfile.h	/^  bfstream& operator<<(uint32_t a);$/;"	p	class:itpp::bfstream	access:public	signature:(uint32_t a)
operator <<	/usr/include/itpp/base/binfile.h	/^  bfstream& operator<<(uint64_t a);$/;"	p	class:itpp::bfstream	access:public	signature:(uint64_t a)
operator <<	/usr/include/itpp/base/binfile.h	/^  bfstream& operator<<(unsigned char a);$/;"	p	class:itpp::bfstream	access:public	signature:(unsigned char a)
operator <<	/usr/include/itpp/base/binfile.h	/^  bofstream& operator<<(char a);$/;"	p	class:itpp::bofstream	access:public	signature:(char a)
operator <<	/usr/include/itpp/base/binfile.h	/^  bofstream& operator<<(const char* a);$/;"	p	class:itpp::bofstream	access:public	signature:(const char* a)
operator <<	/usr/include/itpp/base/binfile.h	/^  bofstream& operator<<(const std::string& a);$/;"	p	class:itpp::bofstream	access:public	signature:(const std::string& a)
operator <<	/usr/include/itpp/base/binfile.h	/^  bofstream& operator<<(double a);$/;"	p	class:itpp::bofstream	access:public	signature:(double a)
operator <<	/usr/include/itpp/base/binfile.h	/^  bofstream& operator<<(float a);$/;"	p	class:itpp::bofstream	access:public	signature:(float a)
operator <<	/usr/include/itpp/base/binfile.h	/^  bofstream& operator<<(int16_t a);$/;"	p	class:itpp::bofstream	access:public	signature:(int16_t a)
operator <<	/usr/include/itpp/base/binfile.h	/^  bofstream& operator<<(int32_t a);$/;"	p	class:itpp::bofstream	access:public	signature:(int32_t a)
operator <<	/usr/include/itpp/base/binfile.h	/^  bofstream& operator<<(int64_t a);$/;"	p	class:itpp::bofstream	access:public	signature:(int64_t a)
operator <<	/usr/include/itpp/base/binfile.h	/^  bofstream& operator<<(uint16_t a);$/;"	p	class:itpp::bofstream	access:public	signature:(uint16_t a)
operator <<	/usr/include/itpp/base/binfile.h	/^  bofstream& operator<<(uint32_t a);$/;"	p	class:itpp::bofstream	access:public	signature:(uint32_t a)
operator <<	/usr/include/itpp/base/binfile.h	/^  bofstream& operator<<(uint64_t a);$/;"	p	class:itpp::bofstream	access:public	signature:(uint64_t a)
operator <<	/usr/include/itpp/base/binfile.h	/^  bofstream& operator<<(unsigned char a);$/;"	p	class:itpp::bofstream	access:public	signature:(unsigned char a)
operator <<	/usr/include/itpp/base/gf2mat.h	/^  friend it_file &operator<<(it_file &f, const GF2mat &X);$/;"	p	class:itpp::GF2mat	access:friend	signature:(it_file &f, const GF2mat &X)
operator <<	/usr/include/itpp/base/gf2mat.h	/^  friend std::ostream &operator<<(std::ostream &os, const GF2mat &X);$/;"	p	class:itpp::GF2mat	access:friend	signature:(std::ostream &os, const GF2mat &X)
operator <<	/usr/include/itpp/base/gf2mat.h	/^it_file &operator<<(it_file &f, const GF2mat &X);$/;"	p	namespace:itpp	signature:(it_file &f, const GF2mat &X)
operator <<	/usr/include/itpp/base/gf2mat.h	/^std::ostream &operator<<(std::ostream &os, const GF2mat &X);$/;"	p	namespace:itpp	signature:(std::ostream &os, const GF2mat &X)
operator <<	/usr/include/itpp/base/itfile.h	/^  it_file& operator<<(it_manip func) { return (*func)(*this); }$/;"	f	class:itpp::it_file	access:public	signature:(it_manip func)
operator <<	/usr/include/itpp/base/itfile.h	/^  it_file_old& operator<<(it_manip func) { return (*func)(*this); }$/;"	f	class:itpp::it_file_old	access:public	signature:(it_manip func)
operator <<	/usr/include/itpp/base/itfile.h	/^inline it_file& operator<<(it_file& f, const Name& s)$/;"	f	namespace:itpp	signature:(it_file& f, const Name& s)
operator <<	/usr/include/itpp/base/itfile.h	/^inline it_file_old& operator<<(it_file_old& f, const Name& s)$/;"	f	namespace:itpp	signature:(it_file_old& f, const Name& s)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file &f, bool x);$/;"	p	namespace:itpp	signature:(it_file &f, bool x)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, bin x);$/;"	p	namespace:itpp	signature:(it_file& f, bin x)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, char x);$/;"	p	namespace:itpp	signature:(it_file& f, char x)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<bin>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<bin>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<bmat>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<bmat>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<bvec>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<bvec>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<cmat>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<cmat>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<cvec>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<cvec>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<double>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<double>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<float>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<float>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<imat>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<imat>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<int>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<int>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<ivec>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<ivec>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<mat>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<mat>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<short>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<short>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<smat>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<smat>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<std::complex<double> >& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<std::complex<double> >& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<std::complex<float> >& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<std::complex<float> >& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<std::string>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<std::string>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<svec>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<svec>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const Array<vec>& v);$/;"	p	namespace:itpp	signature:(it_file& f, const Array<vec>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const bmat& m);$/;"	p	namespace:itpp	signature:(it_file& f, const bmat& m)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const bvec& v);$/;"	p	namespace:itpp	signature:(it_file& f, const bvec& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const cmat& m);$/;"	p	namespace:itpp	signature:(it_file& f, const cmat& m)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const cvec& v);$/;"	p	namespace:itpp	signature:(it_file& f, const cvec& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const imat& m);$/;"	p	namespace:itpp	signature:(it_file& f, const imat& m)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const ivec& v);$/;"	p	namespace:itpp	signature:(it_file& f, const ivec& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const mat& m);$/;"	p	namespace:itpp	signature:(it_file& f, const mat& m)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const smat& m);$/;"	p	namespace:itpp	signature:(it_file& f, const smat& m)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const std::string& str);$/;"	p	namespace:itpp	signature:(it_file& f, const std::string& str)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const svec& v);$/;"	p	namespace:itpp	signature:(it_file& f, const svec& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, const vec& v);$/;"	p	namespace:itpp	signature:(it_file& f, const vec& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, double x);$/;"	p	namespace:itpp	signature:(it_file& f, double x)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, float x);$/;"	p	namespace:itpp	signature:(it_file& f, float x)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, int x);$/;"	p	namespace:itpp	signature:(it_file& f, int x)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, short x);$/;"	p	namespace:itpp	signature:(it_file& f, short x)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, std::complex<double> x);$/;"	p	namespace:itpp	signature:(it_file& f, std::complex<double> x)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file& operator<<(it_file& f, std::complex<float> x);$/;"	p	namespace:itpp	signature:(it_file& f, std::complex<float> x)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, bin x);$/;"	p	namespace:itpp	signature:(it_file_old& f, bin x)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, char x);$/;"	p	namespace:itpp	signature:(it_file_old& f, char x)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<bin>& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<bin>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<bmat>& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<bmat>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<bvec>& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<bvec>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<cmat>& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<cmat>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<cvec>& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<cvec>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<double>& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<double>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<float>& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<float>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<imat>& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<imat>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<int>& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<int>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<ivec>& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<ivec>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<mat>& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<mat>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<std::complex<double> >& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<std::complex<double> >& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<std::complex<float> >& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<std::complex<float> >& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<std::string>& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<std::string>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const Array<vec>& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const Array<vec>& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const bmat& m);$/;"	p	namespace:itpp	signature:(it_file_old& f, const bmat& m)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const bvec& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const bvec& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const cmat& m);$/;"	p	namespace:itpp	signature:(it_file_old& f, const cmat& m)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const cvec& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const cvec& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const imat& m);$/;"	p	namespace:itpp	signature:(it_file_old& f, const imat& m)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const ivec& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const ivec& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const mat& m);$/;"	p	namespace:itpp	signature:(it_file_old& f, const mat& m)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const std::string& str);$/;"	p	namespace:itpp	signature:(it_file_old& f, const std::string& str)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, const vec& v);$/;"	p	namespace:itpp	signature:(it_file_old& f, const vec& v)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, double x);$/;"	p	namespace:itpp	signature:(it_file_old& f, double x)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, float x);$/;"	p	namespace:itpp	signature:(it_file_old& f, float x)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, int x);$/;"	p	namespace:itpp	signature:(it_file_old& f, int x)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, short x);$/;"	p	namespace:itpp	signature:(it_file_old& f, short x)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, std::complex<double> x);$/;"	p	namespace:itpp	signature:(it_file_old& f, std::complex<double> x)
operator <<	/usr/include/itpp/base/itfile.h	/^it_file_old& operator<<(it_file_old& f, std::complex<float> x);$/;"	p	namespace:itpp	signature:(it_file_old& f, std::complex<float> x)
operator <<	/usr/include/itpp/base/mat.h	/^extern template std::ostream &operator<<(std::ostream &os, const bmat  &m);$/;"	p	namespace:itpp	signature:(std::ostream &os, const bmat &m)
operator <<	/usr/include/itpp/base/mat.h	/^extern template std::ostream &operator<<(std::ostream &os, const cmat &m);$/;"	p	namespace:itpp	signature:(std::ostream &os, const cmat &m)
operator <<	/usr/include/itpp/base/mat.h	/^extern template std::ostream &operator<<(std::ostream &os, const imat  &m);$/;"	p	namespace:itpp	signature:(std::ostream &os, const imat &m)
operator <<	/usr/include/itpp/base/mat.h	/^extern template std::ostream &operator<<(std::ostream &os, const mat  &m);$/;"	p	namespace:itpp	signature:(std::ostream &os, const mat &m)
operator <<	/usr/include/itpp/base/mat.h	/^extern template std::ostream &operator<<(std::ostream &os, const smat  &m);$/;"	p	namespace:itpp	signature:(std::ostream &os, const smat &m)
operator <<	/usr/include/itpp/base/mat.h	/^std::ostream &operator<<(std::ostream &os, const Mat<Num_T> &m)$/;"	f	namespace:itpp	signature:(std::ostream &os, const Mat<Num_T> &m)
operator <<	/usr/include/itpp/base/mat.h	/^std::ostream &operator<<(std::ostream &os, const Mat<Num_T> &m);$/;"	p	namespace:itpp	signature:(std::ostream &os, const Mat<Num_T> &m)
operator <<	/usr/include/itpp/base/math/misc.h	/^std::ostream& operator<<(std::ostream &os, const std::complex<T> &x)$/;"	f	namespace:std	signature:(std::ostream &os, const std::complex<T> &x)
operator <<	/usr/include/itpp/base/vec.h	/^extern template std::ostream &operator<<(std::ostream& os, const bvec &vect);$/;"	p	namespace:itpp	signature:(std::ostream& os, const bvec &vect)
operator <<	/usr/include/itpp/base/vec.h	/^extern template std::ostream &operator<<(std::ostream& os, const cvec &vect);$/;"	p	namespace:itpp	signature:(std::ostream& os, const cvec &vect)
operator <<	/usr/include/itpp/base/vec.h	/^extern template std::ostream &operator<<(std::ostream& os, const ivec &vect);$/;"	p	namespace:itpp	signature:(std::ostream& os, const ivec &vect)
operator <<	/usr/include/itpp/base/vec.h	/^extern template std::ostream &operator<<(std::ostream& os, const svec &vect);$/;"	p	namespace:itpp	signature:(std::ostream& os, const svec &vect)
operator <<	/usr/include/itpp/base/vec.h	/^extern template std::ostream &operator<<(std::ostream& os, const vec &vect);$/;"	p	namespace:itpp	signature:(std::ostream& os, const vec &vect)
operator <<	/usr/include/itpp/base/vec.h	/^std::ostream &operator<<(std::ostream &os, const Vec<Num_T> &v)$/;"	f	namespace:itpp	signature:(std::ostream &os, const Vec<Num_T> &v)
operator <<	/usr/include/itpp/base/vec.h	/^std::ostream &operator<<(std::ostream &os, const Vec<Num_T> &v);$/;"	p	namespace:itpp	signature:(std::ostream &os, const Vec<Num_T> &v)
operator <<	/usr/include/itpp/comm/galois.h	/^  friend std::ostream &operator<<(std::ostream &os, const GF &ingf);$/;"	p	class:itpp::GF	access:friend	signature:(std::ostream &os, const GF &ingf)
operator <<	/usr/include/itpp/comm/galois.h	/^  friend std::ostream &operator<<(std::ostream &os, const GFX &ingfx);$/;"	p	class:itpp::GFX	access:friend	signature:(std::ostream &os, const GFX &ingfx)
operator <<	/usr/include/itpp/comm/ldpc.h	/^  friend std::ostream &operator<<(std::ostream &os, const LDPC_Code &C);$/;"	p	class:itpp::LDPC_Code	access:friend	signature:(std::ostream &os, const LDPC_Code &C)
operator <<	/usr/include/itpp/comm/ldpc.h	/^std::ostream &operator<<(std::ostream &os, const LDPC_Code &C);$/;"	p	namespace:itpp	signature:(std::ostream &os, const LDPC_Code &C)
operator <<	/usr/include/itpp/comm/llr.h	/^  friend std::ostream &operator<<(std::ostream &os, const LLR_calc_unit &l);$/;"	p	class:itpp::LLR_calc_unit	access:friend	signature:(std::ostream &os, const LLR_calc_unit &l)
operator <<	/usr/include/itpp/comm/llr.h	/^std::ostream &operator<<(std::ostream &os, const LLR_calc_unit &lcu);$/;"	p	namespace:itpp	signature:(std::ostream &os, const LLR_calc_unit &lcu)
operator <<	/usr/include/itpp/comm/modulator_nd.h	/^  friend std::ostream &operator<<(std::ostream &os, const Modulator_NCD &m);$/;"	p	class:itpp::Modulator_NCD	access:friend	signature:(std::ostream &os, const Modulator_NCD &m)
operator <<	/usr/include/itpp/comm/modulator_nd.h	/^  friend std::ostream &operator<<(std::ostream &os, const Modulator_NRD &m);$/;"	p	class:itpp::Modulator_NRD	access:friend	signature:(std::ostream &os, const Modulator_NRD &m)
operator <<	/usr/include/itpp/comm/modulator_nd.h	/^std::ostream &operator<<(std::ostream &os, const Modulator_NCD &m);$/;"	p	namespace:itpp	signature:(std::ostream &os, const Modulator_NCD &m)
operator <<	/usr/include/itpp/comm/modulator_nd.h	/^std::ostream &operator<<(std::ostream &os, const Modulator_NRD &m);$/;"	p	namespace:itpp	signature:(std::ostream &os, const Modulator_NRD &m)
operator <<	/usr/include/itpp/fixed/cfix.h	/^std::ostream &operator<<(std::ostream &os, const CFix &x);$/;"	p	namespace:itpp	signature:(std::ostream &os, const CFix &x)
operator <<	/usr/include/itpp/fixed/fix.h	/^std::ostream &operator<<(std::ostream &os, const Fix &x);$/;"	p	namespace:itpp	signature:(std::ostream &os, const Fix &x)
operator <<	/usr/include/itpp/fixed/fix_base.h	/^inline std::ostream &operator<<(std::ostream &os, const output_mode &o)$/;"	f	namespace:itpp	signature:(std::ostream &os, const output_mode &o)
operator <<	/usr/include/itpp/protocol/tcp.h	/^  friend std::ostream & operator<<(std::ostream &, TCP_Packet &);$/;"	p	class:itpp::TCP_Packet	access:friend	signature:(std::ostream &, TCP_Packet &)
operator <<	/usr/include/itpp/protocol/tcp.h	/^  friend std::ostream & operator<<(std::ostream &os, const TCP_Segment &segment);$/;"	p	class:itpp::TCP_Segment	access:friend	signature:(std::ostream &os, const TCP_Segment &segment)
operator <<	/usr/include/itpp/protocol/tcp.h	/^  friend std::ostream &operator<<(std::ostream &os, const Sequence_Number &n) { os << n.seq; return os; }$/;"	f	class:itpp::Sequence_Number	access:friend	signature:(std::ostream &os, const Sequence_Number &n)
operator <<=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator<<=(const int n);$/;"	p	class:itpp::CFix	access:public	signature:(const int n)
operator <<=	/usr/include/itpp/fixed/fix.h	/^  Fix& operator<<=(const int n);$/;"	p	class:itpp::Fix	access:public	signature:(const int n)
operator <=	/usr/include/itpp/base/binary.h	/^  bool operator<=(const bin &inbin) const { return b <= inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin) const
operator <=	/usr/include/itpp/base/vec.h	/^  Vec<bin> operator<=(Num_T t) const;$/;"	p	class:itpp::Vec	access:public	signature:(Num_T t) const
operator <=	/usr/include/itpp/base/vec.h	/^bvec Vec<Num_T>::operator<=(Num_T t) const$/;"	f	class:itpp::Vec	signature:(Num_T t) const
operator <=	/usr/include/itpp/base/vec.h	/^bvec Vec<std::complex<double> >::operator<=(std::complex<double>) const;$/;"	p	class:itpp::Vec	signature:(std::complex<double>) const
operator <=	/usr/include/itpp/protocol/tcp.h	/^  bool operator<=(const Sequence_Number &n) const { return (seq - n.seq) <= 0; }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const Sequence_Number &n) const
operator =	/usr/include/itpp/base/array.h	/^  Array<T>& operator=(const Array<T> &a);$/;"	p	class:itpp::Array	access:public	signature:(const Array<T> &a)
operator =	/usr/include/itpp/base/array.h	/^  Array<T>& operator=(const T &e);$/;"	p	class:itpp::Array	access:public	signature:(const T &e)
operator =	/usr/include/itpp/base/array.h	/^  Array<T>& operator=(const char* values);$/;"	p	class:itpp::Array	access:public	signature:(const char* values)
operator =	/usr/include/itpp/base/array.h	/^Array<T>& Array<T>::operator=(const Array<T> &a)$/;"	f	class:itpp::Array	signature:(const Array<T> &a)
operator =	/usr/include/itpp/base/array.h	/^Array<T>& Array<T>::operator=(const T &e)$/;"	f	class:itpp::Array	signature:(const T &e)
operator =	/usr/include/itpp/base/array.h	/^Array<T>& Array<T>::operator=(const char* values)$/;"	f	class:itpp::Array	signature:(const char* values)
operator =	/usr/include/itpp/base/binary.h	/^  void operator=(const bin &inbin) { b = inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin)
operator =	/usr/include/itpp/base/binary.h	/^  void operator=(const int &value) {$/;"	f	class:itpp::bin	access:public	signature:(const int &value)
operator =	/usr/include/itpp/base/circular_buffer.h	/^  void operator=(const Circular_Buffer<T> &s);$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(const Circular_Buffer<T> &s)
operator =	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::operator=(const Circular_Buffer<T> &s)$/;"	f	class:itpp::Circular_Buffer	signature:(const Circular_Buffer<T> &s)
operator =	/usr/include/itpp/base/gf2mat.h	/^  void operator=(const GF2mat &X);$/;"	p	class:itpp::GF2mat	access:public	signature:(const GF2mat &X)
operator =	/usr/include/itpp/base/itfile.h	/^  Name &operator=(const Name&) { return *this; }$/;"	f	class:itpp::Name	access:public	signature:(const Name&)
operator =	/usr/include/itpp/base/mat.h	/^  Mat<Num_T>& operator=(Num_T t);$/;"	p	class:itpp::Mat	access:public	signature:(Num_T t)
operator =	/usr/include/itpp/base/mat.h	/^  Mat<Num_T>& operator=(const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:public	signature:(const Mat<Num_T> &m)
operator =	/usr/include/itpp/base/mat.h	/^  Mat<Num_T>& operator=(const Vec<Num_T> &v);$/;"	p	class:itpp::Mat	access:public	signature:(const Vec<Num_T> &v)
operator =	/usr/include/itpp/base/mat.h	/^  Mat<Num_T>& operator=(const char *str);$/;"	p	class:itpp::Mat	access:public	signature:(const char *str)
operator =	/usr/include/itpp/base/mat.h	/^Mat<Num_T>& Mat<Num_T>::operator=(Num_T t)$/;"	f	class:itpp::Mat	signature:(Num_T t)
operator =	/usr/include/itpp/base/mat.h	/^Mat<Num_T>& Mat<Num_T>::operator=(const Mat<Num_T> &m)$/;"	f	class:itpp::Mat	signature:(const Mat<Num_T> &m)
operator =	/usr/include/itpp/base/mat.h	/^Mat<Num_T>& Mat<Num_T>::operator=(const Vec<Num_T> &v)$/;"	f	class:itpp::Mat	signature:(const Vec<Num_T> &v)
operator =	/usr/include/itpp/base/mat.h	/^Mat<Num_T>& Mat<Num_T>::operator=(const char *str)$/;"	f	class:itpp::Mat	signature:(const char *str)
operator =	/usr/include/itpp/base/random.h	/^  Complex_Normal_RNG & operator=(const Complex_Normal_RNG&) { return *this; }$/;"	f	class:itpp::Complex_Normal_RNG	access:public	signature:(const Complex_Normal_RNG&)
operator =	/usr/include/itpp/base/smat.h	/^  void operator=(const Mat<T> &m);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const Mat<T> &m)
operator =	/usr/include/itpp/base/smat.h	/^  void operator=(const Sparse_Mat<T> &m);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const Sparse_Mat<T> &m)
operator =	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::operator=(const Mat<T> &m)$/;"	f	class:itpp::Sparse_Mat	signature:(const Mat<T> &m)
operator =	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::operator=(const Sparse_Mat<T> &m)$/;"	f	class:itpp::Sparse_Mat	signature:(const Sparse_Mat<T> &m)
operator =	/usr/include/itpp/base/stack.h	/^  void operator=(const Stack<T> &s);$/;"	p	class:itpp::Stack	access:public	signature:(const Stack<T> &s)
operator =	/usr/include/itpp/base/stack.h	/^void Stack<T>::operator=(const Stack<T> &s)$/;"	f	class:itpp::Stack	signature:(const Stack<T> &s)
operator =	/usr/include/itpp/base/svec.h	/^  void operator=(const Sparse_Vec<T> &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const Sparse_Vec<T> &v)
operator =	/usr/include/itpp/base/svec.h	/^  void operator=(const Vec<T> &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const Vec<T> &v)
operator =	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::operator=(const Sparse_Vec<T> &v)$/;"	f	class:itpp::Sparse_Vec	signature:(const Sparse_Vec<T> &v)
operator =	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::operator=(const Vec<T> &v)$/;"	f	class:itpp::Sparse_Vec	signature:(const Vec<T> &v)
operator =	/usr/include/itpp/base/vec.h	/^  Vec<Num_T>& operator=(Num_T t);$/;"	p	class:itpp::Vec	access:public	signature:(Num_T t)
operator =	/usr/include/itpp/base/vec.h	/^  Vec<Num_T>& operator=(const Mat<Num_T> &m);$/;"	p	class:itpp::Vec	access:public	signature:(const Mat<Num_T> &m)
operator =	/usr/include/itpp/base/vec.h	/^  Vec<Num_T>& operator=(const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:public	signature:(const Vec<Num_T> &v)
operator =	/usr/include/itpp/base/vec.h	/^  Vec<Num_T>& operator=(const char *values);$/;"	p	class:itpp::Vec	access:public	signature:(const char *values)
operator =	/usr/include/itpp/base/vec.h	/^Vec<Num_T>& Vec<Num_T>::operator=(Num_T t)$/;"	f	class:itpp::Vec	signature:(Num_T t)
operator =	/usr/include/itpp/base/vec.h	/^Vec<Num_T>& Vec<Num_T>::operator=(const Mat<Num_T> &m)$/;"	f	class:itpp::Vec	signature:(const Mat<Num_T> &m)
operator =	/usr/include/itpp/base/vec.h	/^Vec<Num_T>& Vec<Num_T>::operator=(const Vec<Num_T> &v)$/;"	f	class:itpp::Vec	signature:(const Vec<Num_T> &v)
operator =	/usr/include/itpp/base/vec.h	/^Vec<Num_T>& Vec<Num_T>::operator=(const char *values)$/;"	f	class:itpp::Vec	signature:(const char *values)
operator =	/usr/include/itpp/comm/bch.h	/^  BCH & operator=(const BCH &) { return *this; }$/;"	f	class:itpp::BCH	access:public	signature:(const BCH &)
operator =	/usr/include/itpp/comm/galois.h	/^  void operator=(const GF &ingf);$/;"	p	class:itpp::GF	access:public	signature:(const GF &ingf)
operator =	/usr/include/itpp/comm/galois.h	/^  void operator=(const GFX &ingfx);$/;"	p	class:itpp::GFX	access:public	signature:(const GFX &ingfx)
operator =	/usr/include/itpp/comm/galois.h	/^  void operator=(const int inexp);$/;"	p	class:itpp::GF	access:public	signature:(const int inexp)
operator =	/usr/include/itpp/comm/galois.h	/^inline void GF::operator=(const GF &ingf)$/;"	f	class:itpp::GF	signature:(const GF &ingf)
operator =	/usr/include/itpp/comm/galois.h	/^inline void GF::operator=(const int inexp)$/;"	f	class:itpp::GF	signature:(const int inexp)
operator =	/usr/include/itpp/comm/galois.h	/^inline void GFX::operator=(const GFX &ingfx)$/;"	f	class:itpp::GFX	signature:(const GFX &ingfx)
operator =	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  Rec_Syst_Conv_Code & operator=(const Rec_Syst_Conv_Code &) { return *this; }$/;"	f	class:itpp::Rec_Syst_Conv_Code	access:public	signature:(const Rec_Syst_Conv_Code &)
operator =	/usr/include/itpp/comm/reedsolomon.h	/^  Reed_Solomon & operator=(const Reed_Solomon &) { return *this; }$/;"	f	class:itpp::Reed_Solomon	access:public	signature:(const Reed_Solomon &)
operator =	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator=(const CFix &x);$/;"	p	class:itpp::CFix	access:public	signature:(const CFix &x)
operator =	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator=(const Fix &x);$/;"	p	class:itpp::CFix	access:public	signature:(const Fix &x)
operator =	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator=(const int x);$/;"	p	class:itpp::CFix	access:public	signature:(const int x)
operator =	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator=(const std::complex<double> &x);$/;"	p	class:itpp::CFix	access:public	signature:(const std::complex<double> &x)
operator =	/usr/include/itpp/fixed/cfixed.h	/^  CFixed& operator=(const CFix &x) {$/;"	f	class:itpp::CFixed	access:public	signature:(const CFix &x)
operator =	/usr/include/itpp/fixed/cfixed.h	/^  CFixed& operator=(const Fix &x) {$/;"	f	class:itpp::CFixed	access:public	signature:(const Fix &x)
operator =	/usr/include/itpp/fixed/cfixed.h	/^  CFixed& operator=(const std::complex<double> &x) {$/;"	f	class:itpp::CFixed	access:public	signature:(const std::complex<double> &x)
operator =	/usr/include/itpp/fixed/cfixed.h	/^  CFixed& operator=(int x) {$/;"	f	class:itpp::CFixed	access:public	signature:(int x)
operator =	/usr/include/itpp/fixed/fix.h	/^  Fix& operator=(const Fix &x);$/;"	p	class:itpp::Fix	access:public	signature:(const Fix &x)
operator =	/usr/include/itpp/fixed/fix.h	/^  Fix& operator=(const int x);$/;"	p	class:itpp::Fix	access:public	signature:(const int x)
operator =	/usr/include/itpp/fixed/fixed.h	/^  Fixed& operator=(const Fix &x) {$/;"	f	class:itpp::Fixed	access:public	signature:(const Fix &x)
operator =	/usr/include/itpp/fixed/fixed.h	/^  Fixed& operator=(int x) {$/;"	f	class:itpp::Fixed	access:public	signature:(int x)
operator =	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number &operator=(const Sequence_Number &n) { seq = n.seq; return *this; }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const Sequence_Number &n)
operator =	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number &operator=(const int &rep) { seq = rep; return *this; }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const int &rep)
operator =	/usr/include/itpp/protocol/tcp.h	/^  TCP_Segment &operator=(const TCP_Segment &segment);$/;"	p	class:itpp::TCP_Segment	access:public	signature:(const TCP_Segment &segment)
operator ==	/usr/include/itpp/base/binary.h	/^  bool operator==(const bin &inbin) const { return b == inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin) const
operator ==	/usr/include/itpp/base/binary.h	/^  bool operator==(const int &i) const { return b == i; }$/;"	f	class:itpp::bin	access:public	signature:(const int &i) const
operator ==	/usr/include/itpp/base/gf2mat.h	/^  bool operator==(const GF2mat &X) const;$/;"	p	class:itpp::GF2mat	access:public	signature:(const GF2mat &X) const
operator ==	/usr/include/itpp/base/mat.h	/^  bool operator==(const Mat<Num_T> &m) const;$/;"	p	class:itpp::Mat	access:public	signature:(const Mat<Num_T> &m) const
operator ==	/usr/include/itpp/base/mat.h	/^bool Mat<Num_T>::operator==(const Mat<Num_T> &m) const$/;"	f	class:itpp::Mat	signature:(const Mat<Num_T> &m) const
operator ==	/usr/include/itpp/base/smat.h	/^  bool operator==(const Sparse_Mat<T> &m) const;$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const Sparse_Mat<T> &m) const
operator ==	/usr/include/itpp/base/smat.h	/^bool Sparse_Mat<T>::operator==(const Sparse_Mat<T> &m) const$/;"	f	class:itpp::Sparse_Mat	signature:(const Sparse_Mat<T> &m) const
operator ==	/usr/include/itpp/base/svec.h	/^  bool operator==(const Sparse_Vec<T> &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const Sparse_Vec<T> &v)
operator ==	/usr/include/itpp/base/svec.h	/^bool Sparse_Vec<T>::operator==(const Sparse_Vec<T> &v)$/;"	f	class:itpp::Sparse_Vec	signature:(const Sparse_Vec<T> &v)
operator ==	/usr/include/itpp/base/vec.h	/^  Vec<bin> operator==(Num_T t) const;$/;"	p	class:itpp::Vec	access:public	signature:(Num_T t) const
operator ==	/usr/include/itpp/base/vec.h	/^  bool operator==(const Vec<Num_T> &v) const;$/;"	p	class:itpp::Vec	access:public	signature:(const Vec<Num_T> &v) const
operator ==	/usr/include/itpp/base/vec.h	/^bool Vec<Num_T>::operator==(const Vec<Num_T> &invector) const$/;"	f	class:itpp::Vec	signature:(const Vec<Num_T> &invector) const
operator ==	/usr/include/itpp/base/vec.h	/^bvec Vec<Num_T>::operator==(Num_T t) const$/;"	f	class:itpp::Vec	signature:(Num_T t) const
operator ==	/usr/include/itpp/base/vec.h	/^bvec Vec<std::complex<double> >::operator==(std::complex<double>) const;$/;"	p	class:itpp::Vec	signature:(std::complex<double>) const
operator ==	/usr/include/itpp/comm/galois.h	/^  int operator==(const GF &ingf) const;$/;"	p	class:itpp::GF	access:public	signature:(const GF &ingf) const
operator ==	/usr/include/itpp/comm/galois.h	/^inline int GF::operator==(const GF &ingf) const$/;"	f	class:itpp::GF	signature:(const GF &ingf) const
operator ==	/usr/include/itpp/protocol/tcp.h	/^  bool operator==(const Sequence_Number &n) const { return seq == n.seq; }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const Sequence_Number &n) const
operator ==	/usr/include/itpp/protocol/tcp.h	/^  bool operator==(const TCP_Segment &segment) const;$/;"	p	class:itpp::TCP_Segment	access:public	signature:(const TCP_Segment &segment) const
operator ==	/usr/include/itpp/protocol/tcp.h	/^inline bool TCP_Segment::operator==(const TCP_Segment &segment) const$/;"	f	class:itpp::TCP_Segment	signature:(const TCP_Segment &segment) const
operator >	/usr/include/itpp/base/binary.h	/^  bool operator>(const bin &inbin) const  { return b > inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin) const
operator >	/usr/include/itpp/base/vec.h	/^  Vec<bin> operator>(Num_T t) const;$/;"	p	class:itpp::Vec	access:public	signature:(Num_T t) const
operator >	/usr/include/itpp/base/vec.h	/^bvec Vec<Num_T>::operator>(Num_T t) const$/;"	f	class:itpp::Vec	signature:(Num_T t) const
operator >	/usr/include/itpp/base/vec.h	/^bvec Vec<std::complex<double> >::operator>(std::complex<double>) const;$/;"	p	class:itpp::Vec	signature:(std::complex<double>) const
operator >	/usr/include/itpp/protocol/tcp.h	/^  bool operator>(const Sequence_Number &n) const { return (seq - n.seq) > 0; }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const Sequence_Number &n) const
operator >=	/usr/include/itpp/base/binary.h	/^  bool operator>=(const bin &inbin) const { return b >= inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin) const
operator >=	/usr/include/itpp/base/vec.h	/^  Vec<bin> operator>=(Num_T t) const;$/;"	p	class:itpp::Vec	access:public	signature:(Num_T t) const
operator >=	/usr/include/itpp/base/vec.h	/^bvec Vec<Num_T>::operator>=(Num_T t) const$/;"	f	class:itpp::Vec	signature:(Num_T t) const
operator >=	/usr/include/itpp/base/vec.h	/^bvec Vec<std::complex<double> >::operator>=(std::complex<double>) const;$/;"	p	class:itpp::Vec	signature:(std::complex<double>) const
operator >=	/usr/include/itpp/protocol/tcp.h	/^  bool operator>=(const Sequence_Number &n) const { return (seq - n.seq) >= 0; }$/;"	f	class:itpp::Sequence_Number	access:public	signature:(const Sequence_Number &n) const
operator >>	/usr/include/itpp/base/array.h	/^std::istream &operator>>(std::istream &is, Array<T> &a)$/;"	f	namespace:itpp	signature:(std::istream &is, Array<T> &a)
operator >>	/usr/include/itpp/base/binary.h	/^std::istream &operator>>(std::istream &input, bin &outbin);$/;"	p	namespace:itpp	signature:(std::istream &input, bin &outbin)
operator >>	/usr/include/itpp/base/binfile.h	/^  bfstream& operator>>(char& a);$/;"	p	class:itpp::bfstream	access:public	signature:(char& a)
operator >>	/usr/include/itpp/base/binfile.h	/^  bfstream& operator>>(char* a);$/;"	p	class:itpp::bfstream	access:public	signature:(char* a)
operator >>	/usr/include/itpp/base/binfile.h	/^  bfstream& operator>>(double& a);$/;"	p	class:itpp::bfstream	access:public	signature:(double& a)
operator >>	/usr/include/itpp/base/binfile.h	/^  bfstream& operator>>(float& a);$/;"	p	class:itpp::bfstream	access:public	signature:(float& a)
operator >>	/usr/include/itpp/base/binfile.h	/^  bfstream& operator>>(int16_t& a);$/;"	p	class:itpp::bfstream	access:public	signature:(int16_t& a)
operator >>	/usr/include/itpp/base/binfile.h	/^  bfstream& operator>>(int32_t& a);$/;"	p	class:itpp::bfstream	access:public	signature:(int32_t& a)
operator >>	/usr/include/itpp/base/binfile.h	/^  bfstream& operator>>(int64_t& a);$/;"	p	class:itpp::bfstream	access:public	signature:(int64_t& a)
operator >>	/usr/include/itpp/base/binfile.h	/^  bfstream& operator>>(std::string& a);$/;"	p	class:itpp::bfstream	access:public	signature:(std::string& a)
operator >>	/usr/include/itpp/base/binfile.h	/^  bfstream& operator>>(uint16_t& a);$/;"	p	class:itpp::bfstream	access:public	signature:(uint16_t& a)
operator >>	/usr/include/itpp/base/binfile.h	/^  bfstream& operator>>(uint32_t& a);$/;"	p	class:itpp::bfstream	access:public	signature:(uint32_t& a)
operator >>	/usr/include/itpp/base/binfile.h	/^  bfstream& operator>>(uint64_t& a);$/;"	p	class:itpp::bfstream	access:public	signature:(uint64_t& a)
operator >>	/usr/include/itpp/base/binfile.h	/^  bfstream& operator>>(unsigned char& a);$/;"	p	class:itpp::bfstream	access:public	signature:(unsigned char& a)
operator >>	/usr/include/itpp/base/binfile.h	/^  bifstream& operator>>(char& a);$/;"	p	class:itpp::bifstream	access:public	signature:(char& a)
operator >>	/usr/include/itpp/base/binfile.h	/^  bifstream& operator>>(char* a);$/;"	p	class:itpp::bifstream	access:public	signature:(char* a)
operator >>	/usr/include/itpp/base/binfile.h	/^  bifstream& operator>>(double& a);$/;"	p	class:itpp::bifstream	access:public	signature:(double& a)
operator >>	/usr/include/itpp/base/binfile.h	/^  bifstream& operator>>(float& a);$/;"	p	class:itpp::bifstream	access:public	signature:(float& a)
operator >>	/usr/include/itpp/base/binfile.h	/^  bifstream& operator>>(int16_t& a);$/;"	p	class:itpp::bifstream	access:public	signature:(int16_t& a)
operator >>	/usr/include/itpp/base/binfile.h	/^  bifstream& operator>>(int32_t& a);$/;"	p	class:itpp::bifstream	access:public	signature:(int32_t& a)
operator >>	/usr/include/itpp/base/binfile.h	/^  bifstream& operator>>(int64_t& a);$/;"	p	class:itpp::bifstream	access:public	signature:(int64_t& a)
operator >>	/usr/include/itpp/base/binfile.h	/^  bifstream& operator>>(std::string& a);$/;"	p	class:itpp::bifstream	access:public	signature:(std::string& a)
operator >>	/usr/include/itpp/base/binfile.h	/^  bifstream& operator>>(uint16_t& a);$/;"	p	class:itpp::bifstream	access:public	signature:(uint16_t& a)
operator >>	/usr/include/itpp/base/binfile.h	/^  bifstream& operator>>(uint32_t& a);$/;"	p	class:itpp::bifstream	access:public	signature:(uint32_t& a)
operator >>	/usr/include/itpp/base/binfile.h	/^  bifstream& operator>>(uint64_t& a);$/;"	p	class:itpp::bifstream	access:public	signature:(uint64_t& a)
operator >>	/usr/include/itpp/base/binfile.h	/^  bifstream& operator>>(unsigned char& a);$/;"	p	class:itpp::bifstream	access:public	signature:(unsigned char& a)
operator >>	/usr/include/itpp/base/gf2mat.h	/^  friend it_ifile &operator>>(it_ifile &f, GF2mat &X);$/;"	p	class:itpp::GF2mat	access:friend	signature:(it_ifile &f, GF2mat &X)
operator >>	/usr/include/itpp/base/gf2mat.h	/^it_ifile &operator>>(it_ifile &f, GF2mat &X);$/;"	p	namespace:itpp	signature:(it_ifile &f, GF2mat &X)
operator >>	/usr/include/itpp/base/itfile.h	/^inline it_ifile& operator>>(it_ifile& f, const Name& s)$/;"	f	namespace:itpp	signature:(it_ifile& f, const Name& s)
operator >>	/usr/include/itpp/base/itfile.h	/^inline it_ifile_old& operator>>(it_ifile_old& f, const Name& s)$/;"	f	namespace:itpp	signature:(it_ifile_old& f, const Name& s)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile &f, bool &v);$/;"	p	namespace:itpp	signature:(it_ifile &f, bool &v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<bin>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<bin>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<bmat>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<bmat>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<bvec>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<bvec>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<cmat>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<cmat>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<cvec>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<cvec>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<double>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<double>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<float>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<float>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<imat>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<imat>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<int>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<int>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<ivec>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<ivec>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<mat>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<mat>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<short>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<short>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<smat>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<smat>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<std::complex<double> >& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<std::complex<double> >& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<std::complex<float> >& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<std::complex<float> >& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<std::string>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<std::string>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<svec>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<svec>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, Array<vec>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, Array<vec>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, bin& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, bin& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, bmat& m);$/;"	p	namespace:itpp	signature:(it_ifile& f, bmat& m)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, bvec& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, bvec& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, char& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, char& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, cmat& m);$/;"	p	namespace:itpp	signature:(it_ifile& f, cmat& m)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, cvec& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, cvec& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, double& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, double& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, float& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, float& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, imat& m);$/;"	p	namespace:itpp	signature:(it_ifile& f, imat& m)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, int& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, int& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, ivec& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, ivec& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, mat& m);$/;"	p	namespace:itpp	signature:(it_ifile& f, mat& m)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, short& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, short& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, smat& m);$/;"	p	namespace:itpp	signature:(it_ifile& f, smat& m)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, std::complex<double>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, std::complex<double>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, std::complex<float>& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, std::complex<float>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, std::string& str);$/;"	p	namespace:itpp	signature:(it_ifile& f, std::string& str)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, svec& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, svec& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile& operator>>(it_ifile& f, vec& v);$/;"	p	namespace:itpp	signature:(it_ifile& f, vec& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<bin>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<bin>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<bmat>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<bmat>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<bvec>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<bvec>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<cmat>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<cmat>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<cvec>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<cvec>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<double>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<double>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<float>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<float>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<imat>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<imat>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<int>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<int>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<ivec>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<ivec>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<mat>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<mat>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<std::complex<double> >& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<std::complex<double> >& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<std::complex<float> >& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<std::complex<float> >& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<std::string>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<std::string>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, Array<vec>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, Array<vec>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, bin& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, bin& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, bmat& m);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, bmat& m)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, bvec& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, bvec& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, char& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, char& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, cmat& m);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, cmat& m)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, cvec& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, cvec& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, double& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, double& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, float& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, float& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, imat& m);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, imat& m)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, int& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, int& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, ivec& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, ivec& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, mat& m);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, mat& m)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, short& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, short& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, std::complex<double>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, std::complex<double>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, std::complex<float>& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, std::complex<float>& v)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, std::string& str);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, std::string& str)
operator >>	/usr/include/itpp/base/itfile.h	/^it_ifile_old& operator>>(it_ifile_old& f, vec& v);$/;"	p	namespace:itpp	signature:(it_ifile_old& f, vec& v)
operator >>	/usr/include/itpp/base/mat.h	/^extern template std::istream &operator>>(std::istream &is, bmat  &m);$/;"	p	namespace:itpp	signature:(std::istream &is, bmat &m)
operator >>	/usr/include/itpp/base/mat.h	/^extern template std::istream &operator>>(std::istream &is, cmat &m);$/;"	p	namespace:itpp	signature:(std::istream &is, cmat &m)
operator >>	/usr/include/itpp/base/mat.h	/^extern template std::istream &operator>>(std::istream &is, imat  &m);$/;"	p	namespace:itpp	signature:(std::istream &is, imat &m)
operator >>	/usr/include/itpp/base/mat.h	/^extern template std::istream &operator>>(std::istream &is, mat  &m);$/;"	p	namespace:itpp	signature:(std::istream &is, mat &m)
operator >>	/usr/include/itpp/base/mat.h	/^extern template std::istream &operator>>(std::istream &is, smat  &m);$/;"	p	namespace:itpp	signature:(std::istream &is, smat &m)
operator >>	/usr/include/itpp/base/mat.h	/^std::istream &operator>>(std::istream &is, Mat<Num_T> &m)$/;"	f	namespace:itpp	signature:(std::istream &is, Mat<Num_T> &m)
operator >>	/usr/include/itpp/base/mat.h	/^std::istream &operator>>(std::istream &is, Mat<Num_T> &m);$/;"	p	namespace:itpp	signature:(std::istream &is, Mat<Num_T> &m)
operator >>	/usr/include/itpp/base/math/misc.h	/^std::istream& operator>>(std::istream &is, std::complex<T> &x)$/;"	f	namespace:std	signature:(std::istream &is, std::complex<T> &x)
operator >>	/usr/include/itpp/base/vec.h	/^extern template std::istream &operator>>(std::istream& is, bvec &vect);$/;"	p	namespace:itpp	signature:(std::istream& is, bvec &vect)
operator >>	/usr/include/itpp/base/vec.h	/^extern template std::istream &operator>>(std::istream& is, cvec &vect);$/;"	p	namespace:itpp	signature:(std::istream& is, cvec &vect)
operator >>	/usr/include/itpp/base/vec.h	/^extern template std::istream &operator>>(std::istream& is, ivec &vect);$/;"	p	namespace:itpp	signature:(std::istream& is, ivec &vect)
operator >>	/usr/include/itpp/base/vec.h	/^extern template std::istream &operator>>(std::istream& is, svec &vect);$/;"	p	namespace:itpp	signature:(std::istream& is, svec &vect)
operator >>	/usr/include/itpp/base/vec.h	/^extern template std::istream &operator>>(std::istream& is, vec &vect);$/;"	p	namespace:itpp	signature:(std::istream& is, vec &vect)
operator >>	/usr/include/itpp/base/vec.h	/^std::istream &operator>>(std::istream &is, Vec<Num_T> &v)$/;"	f	namespace:itpp	signature:(std::istream &is, Vec<Num_T> &v)
operator >>	/usr/include/itpp/base/vec.h	/^std::istream &operator>>(std::istream &is, Vec<Num_T> &v);$/;"	p	namespace:itpp	signature:(std::istream &is, Vec<Num_T> &v)
operator >>	/usr/include/itpp/fixed/cfix.h	/^std::istream &operator>>(std::istream &is, CFix &x);$/;"	p	namespace:itpp	signature:(std::istream &is, CFix &x)
operator >>	/usr/include/itpp/fixed/fix.h	/^std::istream &operator>>(std::istream &is, Fix &x);$/;"	p	namespace:itpp	signature:(std::istream &is, Fix &x)
operator >>=	/usr/include/itpp/fixed/cfix.h	/^  CFix& operator>>=(const int n);$/;"	p	class:itpp::CFix	access:public	signature:(const int n)
operator >>=	/usr/include/itpp/fixed/fix.h	/^  Fix& operator>>=(const int n);$/;"	p	class:itpp::Fix	access:public	signature:(const int n)
operator []	/usr/include/itpp/base/vec.h	/^  Num_T &operator[](int i);$/;"	p	class:itpp::Vec	access:public	signature:(int i)
operator []	/usr/include/itpp/base/vec.h	/^  const Num_T &operator[](int i) const;$/;"	p	class:itpp::Vec	access:public	signature:(int i) const
operator []	/usr/include/itpp/base/vec.h	/^Num_T& Vec<Num_T>::operator[](int i)$/;"	f	class:itpp::Vec	signature:(int i)
operator []	/usr/include/itpp/base/vec.h	/^const Num_T& Vec<Num_T>::operator[](int i) const$/;"	f	class:itpp::Vec	signature:(int i) const
operator []	/usr/include/itpp/comm/galois.h	/^  GF &operator[](int index) {$/;"	f	class:itpp::GFX	access:public	signature:(int index)
operator []	/usr/include/itpp/comm/galois.h	/^  GF operator[](int index) const {$/;"	f	class:itpp::GFX	access:public	signature:(int index) const
operator ^	/usr/include/itpp/base/binary.h	/^  bin operator^(const bin &inbin) const { return bin(b ^ inbin.b); }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin) const
operator ^=	/usr/include/itpp/base/binary.h	/^  void operator^=(const bin &inbin) { b ^= inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin)
operator bool	/usr/include/itpp/base/binary.h	/^  operator bool() const   { return b != 0; }$/;"	f	class:itpp::bin	access:public	signature:() const
operator double	/usr/include/itpp/base/binary.h	/^  operator double() const { return static_cast<double>(b); }$/;"	f	class:itpp::bin	access:public	signature:() const
operator double	/usr/include/itpp/fixed/fix.h	/^  operator double() const {$/;"	f	class:itpp::Fix	access:public	signature:() const
operator double	/usr/include/itpp/fixed/fix_factory.h	/^  operator double() const {return 0.0;}$/;"	f	class:itpp::Fix_Factory	access:public	signature:() const
operator float	/usr/include/itpp/base/binary.h	/^  operator float() const  { return static_cast<float>(b); }$/;"	f	class:itpp::bin	access:public	signature:() const
operator int	/usr/include/itpp/base/binary.h	/^  operator int() const    { return static_cast<int>(b); }$/;"	f	class:itpp::bin	access:public	signature:() const
operator short	/usr/include/itpp/base/binary.h	/^  operator short() const  { return static_cast<short>(b); }$/;"	f	class:itpp::bin	access:public	signature:() const
operator std::complex<double>	/usr/include/itpp/fixed/cfix.h	/^  operator std::complex<double>() const {$/;"	f	class:itpp::CFix	access:public	signature:() const
operator |	/usr/include/itpp/base/binary.h	/^  bin operator|(const bin &inbin) const { return bin(b | inbin.b); }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin) const
operator |=	/usr/include/itpp/base/binary.h	/^  void operator|=(const bin &inbin) { b |= inbin.b; }$/;"	f	class:itpp::bin	access:public	signature:(const bin &inbin)
operator ~	/usr/include/itpp/base/binary.h	/^  bin operator~(void) const { return bin(b ^ 1); }$/;"	f	class:itpp::bin	access:public	signature:(void) const
order	/usr/include/itpp/comm/interleave.h	/^  int order;$/;"	m	class:itpp::Cross_Interleaver	access:private
outer_product	/usr/include/itpp/base/vec.h	/^  friend Mat<Num_T> outer_product<>(const Vec<Num_T> &v1,$/;"	p	class:itpp::Vec	access:friend	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2, bool hermitian)
outer_product	/usr/include/itpp/base/vec.h	/^Mat<Num_T> outer_product(const Vec<Num_T> &v1, const Vec<Num_T> &v2, bool)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2, bool)
outer_product	/usr/include/itpp/base/vec.h	/^Mat<Num_T> outer_product(const Vec<Num_T> &v1, const Vec<Num_T> &v2,$/;"	p	namespace:itpp	signature:(const Vec<Num_T> &v1, const Vec<Num_T> &v2, bool hermitian = false)
outer_product	/usr/include/itpp/base/vec.h	/^cmat outer_product(const cvec &v1, const cvec &v2, bool hermitian)$/;"	f	namespace:itpp	signature:(const cvec &v1, const cvec &v2, bool hermitian)
outer_product	/usr/include/itpp/base/vec.h	/^extern template bmat outer_product(const bvec &v1, const bvec &v2,$/;"	p	namespace:itpp	signature:(const bvec &v1, const bvec &v2, bool hermitian)
outer_product	/usr/include/itpp/base/vec.h	/^extern template imat outer_product(const ivec &v1, const ivec &v2,$/;"	p	namespace:itpp	signature:(const ivec &v1, const ivec &v2, bool hermitian)
outer_product	/usr/include/itpp/base/vec.h	/^extern template mat outer_product(const vec &v1, const vec &v2,$/;"	p	namespace:itpp	signature:(const vec &v1, const vec &v2, bool hermitian)
outer_product	/usr/include/itpp/base/vec.h	/^extern template smat outer_product(const svec &v1, const svec &v2,$/;"	p	namespace:itpp	signature:(const svec &v1, const svec &v2, bool hermitian)
outer_product	/usr/include/itpp/base/vec.h	/^mat outer_product(const vec &v1, const vec &v2, bool)$/;"	f	namespace:itpp	signature:(const vec &v1, const vec &v2, bool)
output	/usr/include/itpp/protocol/packet_channel.h	/^  Signal<ACK*> output;$/;"	m	class:itpp::ACK_Channel	access:public
output	/usr/include/itpp/protocol/packet_channel.h	/^  Signal<Link_Packet*> output;$/;"	m	class:itpp::Packet_Channel	access:public
output	/usr/include/itpp/protocol/packet_generator.h	/^  Signal<Packet*> output;$/;"	m	class:itpp::Packet_Generator	access:public
output_indexes	/usr/include/itpp/protocol/selective_repeat.h	/^  ivec output_indexes;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
output_mode	/usr/include/itpp/fixed/fix_base.h	/^enum output_mode {$/;"	g	namespace:itpp
output_parity	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  imat state_trans, output_parity, rev_state_trans, rev_output_parity;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
output_reverse	/usr/include/itpp/comm/convcode.h	/^  bvec output_reverse(const int state, const int input);$/;"	p	class:itpp::Convolutional_Code	access:protected	signature:(const int state, const int input)
output_reverse	/usr/include/itpp/comm/convcode.h	/^  void output_reverse(const int state, bvec &zero_output, bvec &one_output);$/;"	p	class:itpp::Convolutional_Code	access:protected	signature:(const int state, bvec &zero_output, bvec &one_output)
output_reverse	/usr/include/itpp/comm/convcode.h	/^  void output_reverse(const int state, int &zero_output, int &one_output);$/;"	p	class:itpp::Convolutional_Code	access:protected	signature:(const int state, int &zero_output, int &one_output)
output_reverse_int	/usr/include/itpp/comm/convcode.h	/^  imat output_reverse_int;$/;"	m	class:itpp::Convolutional_Code	access:protected
outputmode	/usr/include/itpp/fixed/fix_base.h	/^  static output_mode outputmode;$/;"	m	class:itpp::Fix_Base	access:private
outstanding	/usr/include/itpp/protocol/selective_repeat.h	/^  int outstanding;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
overlap_add	/usr/include/itpp/signal/freq_filt.h	/^  cvec overlap_add(const cvec &x);$/;"	p	class:itpp::Freq_Filt	access:private	signature:(const cvec &x)
overlap_add	/usr/include/itpp/signal/freq_filt.h	/^  ivec overlap_add(const ivec &x);$/;"	p	class:itpp::Freq_Filt	access:private	signature:(const ivec &x)
overlap_add	/usr/include/itpp/signal/freq_filt.h	/^  svec overlap_add(const svec &x);$/;"	p	class:itpp::Freq_Filt	access:private	signature:(const svec &x)
overlap_add	/usr/include/itpp/signal/freq_filt.h	/^  vec overlap_add(const vec &x);$/;"	p	class:itpp::Freq_Filt	access:private	signature:(const vec &x)
overlap_add	/usr/include/itpp/signal/freq_filt.h	/^  void overlap_add(const cvec &x, cvec &y);$/;"	p	class:itpp::Freq_Filt	access:private	signature:(const cvec &x, cvec &y)
p	/usr/include/itpp/base/random.h	/^  double p;$/;"	m	class:itpp::Bernoulli_RNG	access:private
p	/usr/include/itpp/comm/channel.h	/^  double p;$/;"	m	class:itpp::BSC	access:private
pNext	/usr/include/itpp/base/random.h	/^  static unsigned int *pNext;$/;"	m	class:itpp::Random_Generator	access:private
pack	/usr/include/itpp/base/itfile.h	/^  void pack();$/;"	p	class:itpp::it_file	access:public	signature:()
pack	/usr/include/itpp/base/itfile.h	/^  void pack();$/;"	p	class:itpp::it_file_old	access:public	signature:()
packet_input	/usr/include/itpp/protocol/packet_generator.h	/^  Slot<Sink, Packet*> packet_input;$/;"	m	class:itpp::Sink	access:public
packet_input	/usr/include/itpp/protocol/selective_repeat.h	/^  Slot<Selective_Repeat_ARQ_Receiver, Array<Packet*> > packet_input; \/\/!< Receives incoming packets.$/;"	m	class:itpp::Selective_Repeat_ARQ_Receiver	access:public
packet_input	/usr/include/itpp/protocol/selective_repeat.h	/^  Slot<Selective_Repeat_ARQ_Sender, Packet*> packet_input; \/\/!< Receives incoming packets.$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:public
packet_output	/usr/include/itpp/protocol/selective_repeat.h	/^  Signal<Array<Packet*> > packet_output; \/\/!< Delivers transmitted packets.$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:public
packet_output	/usr/include/itpp/protocol/selective_repeat.h	/^  Signal<Packet*> packet_output;      \/\/!< Delivers received packets.$/;"	m	class:itpp::Selective_Repeat_ARQ_Receiver	access:public
packet_output_request	/usr/include/itpp/protocol/selective_repeat.h	/^  Slot<Selective_Repeat_ARQ_Sender, int> packet_output_request; \/\/!< Receives incoming packet output requests.$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:public
packet_size	/usr/include/itpp/protocol/packet_generator.h	/^  int packet_size;$/;"	m	class:itpp::Packet_Generator	access:private
parameters_ok	/usr/include/itpp/protocol/packet_channel.h	/^  bool parameters_ok;$/;"	m	class:itpp::ACK_Channel	access:private
parameters_ok	/usr/include/itpp/protocol/packet_channel.h	/^  bool parameters_ok;$/;"	m	class:itpp::Packet_Channel	access:private
parameters_ok	/usr/include/itpp/protocol/selective_repeat.h	/^  bool parameters_ok;$/;"	m	class:itpp::Selective_Repeat_ARQ_Receiver	access:private
parameters_ok	/usr/include/itpp/protocol/selective_repeat.h	/^  bool parameters_ok;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
paranoid	/usr/include/itpp/stat/mog_generic.h	/^  bool paranoid;$/;"	m	class:itpp::MOG_generic	access:protected
parity	/usr/include/itpp/comm/crc.h	/^  void parity(const bvec &in_bits, bvec &out) const;$/;"	p	class:itpp::CRC_Code	access:public	signature:(const bvec &in_bits, bvec &out) const
partitions	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  Array<ivec> partitions;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:protected
pat	/usr/include/itpp/signal/source.h	/^  vec pat;$/;"	m	class:itpp::Pattern_Source	access:private
path_memory	/usr/include/itpp/comm/convcode.h	/^  imat path_memory;$/;"	m	class:itpp::Convolutional_Code	access:protected
pause	/usr/include/itpp/base/timing.h	/^void pause(double t = -1);$/;"	p	namespace:itpp	signature:(double t = -1)
peek	/usr/include/itpp/base/circular_buffer.h	/^  T peek() const;$/;"	p	class:itpp::Circular_Buffer	access:public	signature:() const
peek	/usr/include/itpp/base/circular_buffer.h	/^  void peek(Array<T>& out, const int N = -1) const;$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(Array<T>& out, const int N = -1) const
peek	/usr/include/itpp/base/circular_buffer.h	/^  void peek(T& out) const;$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(T& out) const
peek	/usr/include/itpp/base/circular_buffer.h	/^  void peek(Vec<T>& out, const int N = -1) const;$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(Vec<T>& out, const int N = -1) const
peek	/usr/include/itpp/base/circular_buffer.h	/^  void peek(const int index, T& out) const;$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(const int index, T& out) const
peek	/usr/include/itpp/base/circular_buffer.h	/^  void peek(const ivec& index, Array<T>& out) const;$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(const ivec& index, Array<T>& out) const
peek	/usr/include/itpp/base/circular_buffer.h	/^  void peek(const ivec& index, Vec<T>& out) const;$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(const ivec& index, Vec<T>& out) const
peek	/usr/include/itpp/base/circular_buffer.h	/^T Circular_Buffer<T>::peek() const$/;"	f	class:itpp::Circular_Buffer	signature:() const
peek	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::peek(Array<T>& out, const int N) const$/;"	f	class:itpp::Circular_Buffer	signature:(Array<T>& out, const int N) const
peek	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::peek(T& out) const$/;"	f	class:itpp::Circular_Buffer	signature:(T& out) const
peek	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::peek(Vec<T>& out, const int N) const$/;"	f	class:itpp::Circular_Buffer	signature:(Vec<T>& out, const int N) const
peek	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::peek(const int index, T& out) const$/;"	f	class:itpp::Circular_Buffer	signature:(const int index, T& out) const
peek	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::peek(const ivec& index, Array<T>& out) const$/;"	f	class:itpp::Circular_Buffer	signature:(const ivec& index, Array<T>& out) const
peek	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::peek(const ivec& index, Vec<T>& out) const$/;"	f	class:itpp::Circular_Buffer	signature:(const ivec& index, Vec<T>& out) const
peek	/usr/include/itpp/base/stack.h	/^  T peek() const;$/;"	p	class:itpp::Stack	access:public	signature:() const
peek	/usr/include/itpp/base/stack.h	/^T Stack<T>::peek() const$/;"	f	class:itpp::Stack	signature:() const
peek_reverse	/usr/include/itpp/base/circular_buffer.h	/^  T peek_reverse() const;$/;"	p	class:itpp::Circular_Buffer	access:public	signature:() const
peek_reverse	/usr/include/itpp/base/circular_buffer.h	/^  void peek_reverse(Array<T>& out, const int N = -1) const;$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(Array<T>& out, const int N = -1) const
peek_reverse	/usr/include/itpp/base/circular_buffer.h	/^  void peek_reverse(T& out) const;$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(T& out) const
peek_reverse	/usr/include/itpp/base/circular_buffer.h	/^  void peek_reverse(Vec<T>& out, const int N = -1) const;$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(Vec<T>& out, const int N = -1) const
peek_reverse	/usr/include/itpp/base/circular_buffer.h	/^T Circular_Buffer<T>::peek_reverse() const$/;"	f	class:itpp::Circular_Buffer	signature:() const
peek_reverse	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::peek_reverse(Array<T>& out, const int N) const$/;"	f	class:itpp::Circular_Buffer	signature:(Array<T>& out, const int N) const
peek_reverse	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::peek_reverse(T& out) const$/;"	f	class:itpp::Circular_Buffer	signature:(T& out) const
peek_reverse	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::peek_reverse(Vec<T>& out, const int N) const$/;"	f	class:itpp::Circular_Buffer	signature:(Vec<T>& out, const int N) const
permutation_matrix	/usr/include/itpp/base/algebra/lu.h	/^bmat permutation_matrix(const ivec &p);$/;"	p	namespace:itpp	signature:(const ivec &p)
permute_cols	/usr/include/itpp/base/gf2mat.h	/^  void permute_cols(ivec &perm, bool I);$/;"	p	class:itpp::GF2mat	access:public	signature:(ivec &perm, bool I)
permute_rows	/usr/include/itpp/base/gf2mat.h	/^  void permute_rows(ivec &perm, bool I);$/;"	p	class:itpp::GF2mat	access:public	signature:(ivec &perm, bool I)
pgm_read	/usr/include/itpp/srccode/pnm.h	/^bool pgm_read(const std::string & filename, imat & m,$/;"	p	namespace:itpp	signature:(const std::string & filename, imat & m, std::string & comments)
pgm_read	/usr/include/itpp/srccode/pnm.h	/^bool pgm_read(const std::string & filename, imat &m,$/;"	p	namespace:itpp	signature:(const std::string & filename, imat &m, int r1, int r2, int c1, int c2)
pgm_read	/usr/include/itpp/srccode/pnm.h	/^imat pgm_read(const std::string & filename);$/;"	p	namespace:itpp	signature:(const std::string & filename)
pgm_write	/usr/include/itpp/srccode/pnm.h	/^bool pgm_write(const std::string & filename,$/;"	p	namespace:itpp	signature:(const std::string & filename, const imat &m, const std::string & comments = Ó)
pi	/usr/include/itpp/base/math/misc.h	/^const double pi = 3.14159265358979323846;$/;"	m	namespace:itpp
pisc	/usr/include/itpp/comm/ldpc.h	/^  bool pisc;   \/\/!< check syndrom before first iteration$/;"	m	class:itpp::LDPC_Code	access:protected
pkt_pointer	/usr/include/itpp/protocol/packet.h	/^  Packet *pkt_pointer;$/;"	m	class:itpp::L3_Packet_Info	access:public
pm	/usr/include/itpp/protocol/events.h	/^  void (ObjectType::*pm)(); \/\/ Pointer to class member function to be executed on event expire.$/;"	m	class:itpp::Event	access:private
pm	/usr/include/itpp/protocol/events.h	/^  void (ObjectType::*pm)(DataType data); \/\/ Pointer to class member function to be executed on event expire.$/;"	m	class:itpp::Data_Event	access:private
pm	/usr/include/itpp/protocol/signals_slots.h	/^  void(ObjectType::*pm)(DataType signal);$/;"	m	class:itpp::Slot	access:private
pnm_info	/usr/include/itpp/srccode/pnm.h	/^bool pnm_info(const std::string & filename,$/;"	p	namespace:itpp	signature:(const std::string & filename, char & pnm_type, int & width, int & height, int & max_val, std::string & comments)
pnm_type	/usr/include/itpp/srccode/pnm.h	/^char pnm_type(const std::string & filename);$/;"	p	namespace:itpp	signature:(const std::string & filename)
po	/usr/include/itpp/protocol/events.h	/^  ObjectType *po; \/\/ Pointer to object who's member function is to be executed on event expire.$/;"	m	class:itpp::Event	access:private
po	/usr/include/itpp/protocol/events.h	/^  ObjectType* po; \/\/ Pointer to object who's member function is to be executed on event expire.$/;"	m	class:itpp::Data_Event	access:private
po	/usr/include/itpp/protocol/signals_slots.h	/^  ObjectType *po;$/;"	m	class:itpp::Slot	access:private
pol2bin	/usr/include/itpp/base/converters.h	/^bvec pol2bin(const ivec &inpol);$/;"	p	namespace:itpp	signature:(const ivec &inpol)
poly	/usr/include/itpp/signal/poly.h	/^inline cvec poly(const cvec &r) { cvec temp; poly(r, temp); return temp; }$/;"	f	namespace:itpp	signature:(const cvec &r)
poly	/usr/include/itpp/signal/poly.h	/^inline vec poly(const vec &r) { vec temp; poly(r, temp); return temp; }$/;"	f	namespace:itpp	signature:(const vec &r)
poly	/usr/include/itpp/signal/poly.h	/^void poly(const cvec &r, cvec &p);$/;"	p	namespace:itpp	signature:(const cvec &r, cvec &p)
poly	/usr/include/itpp/signal/poly.h	/^void poly(const vec &r, vec &p);$/;"	p	namespace:itpp	signature:(const vec &r, vec &p)
poly2ac	/usr/include/itpp/srccode/lpcfunc.h	/^vec poly2ac(const vec &poly);$/;"	p	namespace:itpp	signature:(const vec &poly)
poly2cepstrum	/usr/include/itpp/srccode/lpcfunc.h	/^vec poly2cepstrum(const vec &a);$/;"	p	namespace:itpp	signature:(const vec &a)
poly2cepstrum	/usr/include/itpp/srccode/lpcfunc.h	/^vec poly2cepstrum(const vec &a, int num);$/;"	p	namespace:itpp	signature:(const vec &a, int num)
poly2lsf	/usr/include/itpp/srccode/lpcfunc.h	/^vec poly2lsf(const vec &poly);$/;"	p	namespace:itpp	signature:(const vec &poly)
poly2rc	/usr/include/itpp/srccode/lpcfunc.h	/^vec poly2rc(const vec &poly);$/;"	p	namespace:itpp	signature:(const vec &poly)
polynomial	/usr/include/itpp/comm/crc.h	/^  bvec polynomial;$/;"	m	class:itpp::CRC_Code	access:private
polystab	/usr/include/itpp/signal/filter_design.h	/^inline cvec polystab(const cvec &a) { cvec temp; polystab(a, temp); return temp; }$/;"	f	namespace:itpp	signature:(const cvec &a)
polystab	/usr/include/itpp/signal/filter_design.h	/^inline vec polystab(const vec &a) { vec temp; polystab(a, temp); return temp; }$/;"	f	namespace:itpp	signature:(const vec &a)
polystab	/usr/include/itpp/signal/filter_design.h	/^void polystab(const cvec &a, cvec &out);$/;"	p	namespace:itpp	signature:(const cvec &a, cvec &out)
polystab	/usr/include/itpp/signal/filter_design.h	/^void polystab(const vec &a, vec &out);$/;"	p	namespace:itpp	signature:(const vec &a, vec &out)
polyval	/usr/include/itpp/signal/poly.h	/^cvec polyval(const cvec &p, const cvec &x);$/;"	p	namespace:itpp	signature:(const cvec &p, const cvec &x)
polyval	/usr/include/itpp/signal/poly.h	/^cvec polyval(const cvec &p, const vec &x);$/;"	p	namespace:itpp	signature:(const cvec &p, const vec &x)
polyval	/usr/include/itpp/signal/poly.h	/^cvec polyval(const vec &p, const cvec &x);$/;"	p	namespace:itpp	signature:(const vec &p, const cvec &x)
polyval	/usr/include/itpp/signal/poly.h	/^vec polyval(const vec &p, const vec &x);$/;"	p	namespace:itpp	signature:(const vec &p, const vec &x)
pop	/usr/include/itpp/base/stack.h	/^  T pop();$/;"	p	class:itpp::Stack	access:public	signature:()
pop	/usr/include/itpp/base/stack.h	/^T Stack<T>::pop()$/;"	f	class:itpp::Stack	signature:()
pop	/usr/include/itpp/protocol/front_drop_queue.h	/^  void pop();$/;"	p	class:itpp::Front_Drop_Queue	access:public	signature:()
pos	/usr/include/itpp/signal/source.h	/^  double A, pos, dtheta;$/;"	m	class:itpp::Impulse_Source	access:private
pos	/usr/include/itpp/signal/source.h	/^  int pos;$/;"	m	class:itpp::Pattern_Source	access:private
pow	/usr/include/itpp/base/math/log_exp.h	/^inline mat pow(const double x, const mat &y)$/;"	f	namespace:itpp	signature:(const double x, const mat &y)
pow	/usr/include/itpp/base/math/log_exp.h	/^inline mat pow(const mat &x, const double y)$/;"	f	namespace:itpp	signature:(const mat &x, const double y)
pow	/usr/include/itpp/base/math/log_exp.h	/^inline vec pow(const double x, const vec &y)$/;"	f	namespace:itpp	signature:(const double x, const vec &y)
pow	/usr/include/itpp/base/math/log_exp.h	/^inline vec pow(const vec &x, const double y)$/;"	f	namespace:itpp	signature:(const vec &x, const double y)
pow10	/usr/include/itpp/base/math/log_exp.h	/^inline double pow10(double x) { return pow(10.0, x); }$/;"	f	namespace:itpp	signature:(double x)
pow10	/usr/include/itpp/base/math/log_exp.h	/^inline mat pow10(const mat &x)$/;"	f	namespace:itpp	signature:(const mat &x)
pow10	/usr/include/itpp/base/math/log_exp.h	/^inline vec pow10(const vec &x)$/;"	f	namespace:itpp	signature:(const vec &x)
pow2	/usr/include/itpp/base/math/log_exp.h	/^inline double pow2(double x) { return pow(2.0, x); }$/;"	f	namespace:itpp	signature:(double x)
pow2	/usr/include/itpp/base/math/log_exp.h	/^inline mat pow2(const mat &x)$/;"	f	namespace:itpp	signature:(const mat &x)
pow2	/usr/include/itpp/base/math/log_exp.h	/^inline vec pow2(const vec &x)$/;"	f	namespace:itpp	signature:(const vec &x)
pow2i	/usr/include/itpp/base/math/log_exp.h	/^inline int pow2i(int x) { return ((x < 0) ? 0 : (1 << x)); }$/;"	f	namespace:itpp	signature:(int x)
ppm_read	/usr/include/itpp/srccode/pnm.h	/^bool ppm_read(const std::string & filename,$/;"	p	namespace:itpp	signature:(const std::string & filename, imat &r, imat &g, imat &b)
ppm_read	/usr/include/itpp/srccode/pnm.h	/^bool ppm_read(const std::string & filename,$/;"	p	namespace:itpp	signature:(const std::string & filename, imat &r, imat &g, imat &b, int r1, int r2, int c1, int c2)
ppm_read	/usr/include/itpp/srccode/pnm.h	/^bool ppm_read(const std::string & filename,$/;"	p	namespace:itpp	signature:(const std::string & filename, imat &r, imat &g, imat &b, std::string & comments)
ppm_write	/usr/include/itpp/srccode/pnm.h	/^bool ppm_write(const std::string & filename,$/;"	p	namespace:itpp	signature:(const std::string & filename, const imat &r, const imat &g, const imat &b, const std::string & comments = Ó, int max_val = 255)
pr	/usr/include/itpp/protocol/packet_channel.h	/^  double pr;$/;"	m	class:itpp::ACK_Channel	access:private
pr	/usr/include/itpp/protocol/packet_channel.h	/^  double pr;$/;"	m	class:itpp::Packet_Channel	access:private
pre_parsing	/usr/include/itpp/base/parser.h	/^  void pre_parsing(void);$/;"	p	class:itpp::Parser	access:private	signature:(void)
previous_state	/usr/include/itpp/comm/convcode.h	/^  int previous_state(const int state, const int input) {$/;"	f	class:itpp::Convolutional_Code	access:protected	signature:(const int state, const int input)
previous_state	/usr/include/itpp/comm/convcode.h	/^  void previous_state(const int state, int &S0, int &S1) {$/;"	f	class:itpp::Convolutional_Code	access:protected	signature:(const int state, int &S0, int &S1)
print	/usr/include/itpp/fixed/cfix.h	/^  virtual void print() const;$/;"	p	class:itpp::CFix	access:public	signature:() const
print	/usr/include/itpp/fixed/fix.h	/^  virtual void print() const;$/;"	p	class:itpp::Fix	access:public	signature:() const
print	/usr/include/itpp/fixed/fix_base.h	/^  virtual void print() const;$/;"	p	class:itpp::Fix_Base	access:public	signature:() const
print_header	/usr/include/itpp/protocol/tcp.h	/^  virtual void print_header(std::ostream &) const;$/;"	p	class:itpp::TCP_Packet	access:public	signature:(std::ostream &) const
print_item	/usr/include/itpp/protocol/tcp.h	/^  virtual void print_item(std::ostream &, const std::string &);$/;"	p	class:itpp::TCP_Sender	access:public	signature:(std::ostream &, const std::string &)
probabilities	/usr/include/itpp/comm/modulator_nd.h	/^  Array<QLLRvec> probabilities(const QLLRvec &l);$/;"	p	class:itpp::Modulator_ND	access:protected	signature:(const QLLRvec &l)
probabilities	/usr/include/itpp/comm/modulator_nd.h	/^  QLLRvec probabilities(QLLR l); \/\/ some abuse of what QLLR stands for...$/;"	p	class:itpp::Modulator_ND	access:protected	signature:(QLLR l)
prod	/usr/include/itpp/base/matfunc.h	/^T prod(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
prod	/usr/include/itpp/base/matfunc.h	/^Vec<T> prod(const Mat<T> &m, int dim = 1)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, int dim = 1)
prod	/usr/include/itpp/base/matfunc.h	/^extern template bin prod(const bvec &v);$/;"	p	namespace:itpp	signature:(const bvec &v)
prod	/usr/include/itpp/base/matfunc.h	/^extern template bvec prod(const bmat &m, int dim);$/;"	p	namespace:itpp	signature:(const bmat &m, int dim)
prod	/usr/include/itpp/base/matfunc.h	/^extern template cvec prod(const cmat &v, int dim);$/;"	p	namespace:itpp	signature:(const cmat &v, int dim)
prod	/usr/include/itpp/base/matfunc.h	/^extern template double prod(const vec &v);$/;"	p	namespace:itpp	signature:(const vec &v)
prod	/usr/include/itpp/base/matfunc.h	/^extern template int prod(const ivec &v);$/;"	p	namespace:itpp	signature:(const ivec &v)
prod	/usr/include/itpp/base/matfunc.h	/^extern template ivec prod(const imat &m, int dim);$/;"	p	namespace:itpp	signature:(const imat &m, int dim)
prod	/usr/include/itpp/base/matfunc.h	/^extern template short prod(const svec &v);$/;"	p	namespace:itpp	signature:(const svec &v)
prod	/usr/include/itpp/base/matfunc.h	/^extern template std::complex<double> prod(const cvec &v);$/;"	p	namespace:itpp	signature:(const cvec &v)
prod	/usr/include/itpp/base/matfunc.h	/^extern template svec prod(const smat &m, int dim);$/;"	p	namespace:itpp	signature:(const smat &m, int dim)
prod	/usr/include/itpp/base/matfunc.h	/^extern template vec prod(const mat &m, int dim);$/;"	p	namespace:itpp	signature:(const mat &m, int dim)
psc	/usr/include/itpp/comm/ldpc.h	/^  bool psc;   \/\/!< check syndrom after each iteration$/;"	m	class:itpp::LDPC_Code	access:protected
pulse_length	/usr/include/itpp/comm/pulse_shape.h	/^  int pulse_length;$/;"	m	class:itpp::Pulse_Shape	access:protected
puncture_matrix	/usr/include/itpp/comm/punct_convcode.h	/^  bmat puncture_matrix;$/;"	m	class:itpp::Punctured_Convolutional_Code	access:protected
push	/usr/include/itpp/base/stack.h	/^  void push(T v);$/;"	p	class:itpp::Stack	access:public	signature:(T v)
push	/usr/include/itpp/base/stack.h	/^void Stack<T>::push(T v)$/;"	f	class:itpp::Stack	signature:(T v)
push	/usr/include/itpp/protocol/front_drop_queue.h	/^  void push(Packet *packet);$/;"	p	class:itpp::Front_Drop_Queue	access:public	signature:(Packet *packet)
push_packet_on_tx_buffer	/usr/include/itpp/protocol/selective_repeat.h	/^  void push_packet_on_tx_buffer(Packet *packet);$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:(Packet *packet)
put	/usr/include/itpp/base/circular_buffer.h	/^  void put(const Array<T>& in);$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(const Array<T>& in)
put	/usr/include/itpp/base/circular_buffer.h	/^  void put(const T& in);$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(const T& in)
put	/usr/include/itpp/base/circular_buffer.h	/^  void put(const Vec<T>& in);$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(const Vec<T>& in)
put	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::put(const Array<T>& in)$/;"	f	class:itpp::Circular_Buffer	signature:(const Array<T>& in)
put	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::put(const T& in)$/;"	f	class:itpp::Circular_Buffer	signature:(const T& in)
put	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::put(const Vec<T>& in)$/;"	f	class:itpp::Circular_Buffer	signature:(const Vec<T>& in)
q	/usr/include/itpp/comm/galois.h	/^  int degree, q;$/;"	m	class:itpp::GFX	access:private
q	/usr/include/itpp/comm/galois.h	/^  static ivec q;$/;"	m	class:itpp::GF	access:private
q	/usr/include/itpp/comm/reedsolomon.h	/^  int m, t, k, n, q;$/;"	m	class:itpp::Reed_Solomon	access:protected
q_mode	/usr/include/itpp/fixed/fix_base.h	/^enum q_mode {$/;"	g	namespace:itpp
qmode	/usr/include/itpp/fixed/fix_base.h	/^  q_mode qmode;$/;"	m	class:itpp::Fix_Base	access:protected
qmode	/usr/include/itpp/fixed/fix_factory.h	/^  q_mode qmode;$/;"	m	class:itpp::Fix_Factory	access:protected
qr	/usr/include/itpp/base/algebra/qr.h	/^bool qr(const cmat &A, cmat &Q, cmat &R);$/;"	p	namespace:itpp	signature:(const cmat &A, cmat &Q, cmat &R)
qr	/usr/include/itpp/base/algebra/qr.h	/^bool qr(const cmat &A, cmat &Q, cmat &R, bmat &P);$/;"	p	namespace:itpp	signature:(const cmat &A, cmat &Q, cmat &R, bmat &P)
qr	/usr/include/itpp/base/algebra/qr.h	/^bool qr(const mat &A, mat &Q, mat &R);$/;"	p	namespace:itpp	signature:(const mat &A, mat &Q, mat &R)
qr	/usr/include/itpp/base/algebra/qr.h	/^bool qr(const mat &A, mat &Q, mat &R, bmat &P);$/;"	p	namespace:itpp	signature:(const mat &A, mat &Q, mat &R, bmat &P)
quad	/usr/include/itpp/base/math/integration.h	/^double quad(double(*f)(double), double a, double b,$/;"	p	namespace:itpp	signature:(double(*f)(double), double a, double b, double tol = std::numeric_limits<double>::epsilon())
quadl	/usr/include/itpp/base/math/integration.h	/^double quadl(double(*f)(double), double a, double b,$/;"	p	namespace:itpp	signature:(double(*f)(double), double a, double b, double tol = std::numeric_limits<double>::epsilon())
query_nof_ready_packets	/usr/include/itpp/protocol/selective_repeat.h	/^  Slot<Selective_Repeat_ARQ_Sender, void*> query_nof_ready_packets; \/\/!< Receives incoming query for number of packets ready to transmit.$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:public
r	/usr/include/itpp/base/random.h	/^  double mem, r, factr, mean, var, r1, r2;$/;"	m	class:itpp::AR1_Normal_RNG	access:private
r1	/usr/include/itpp/base/random.h	/^  double mem, r, factr, mean, var, r1, r2;$/;"	m	class:itpp::AR1_Normal_RNG	access:private
r2	/usr/include/itpp/base/random.h	/^  double mem, r, factr, mean, var, r1, r2;$/;"	m	class:itpp::AR1_Normal_RNG	access:private
rad_to_deg	/usr/include/itpp/base/converters.h	/^inline double rad_to_deg(double x) { return (180.0 \/ itpp::pi * x); }$/;"	f	namespace:itpp	signature:(double x)
randb	/usr/include/itpp/base/random.h	/^inline bin randb(void) { Bernoulli_RNG src; return src.sample(); }$/;"	f	namespace:itpp	signature:(void)
randb	/usr/include/itpp/base/random.h	/^inline bmat randb(int rows, int cols) { bmat temp; randb(rows, cols, temp); return temp; }$/;"	f	namespace:itpp	signature:(int rows, int cols)
randb	/usr/include/itpp/base/random.h	/^inline bvec randb(int size) { bvec temp; randb(size, temp); return temp; }$/;"	f	namespace:itpp	signature:(int size)
randb	/usr/include/itpp/base/random.h	/^inline void randb(int rows, int cols, bmat &out) { Bernoulli_RNG src; src.sample_matrix(rows, cols, out); }$/;"	f	namespace:itpp	signature:(int rows, int cols, bmat &out)
randb	/usr/include/itpp/base/random.h	/^inline void randb(int size, bvec &out) { Bernoulli_RNG src; src.sample_vector(size, out); }$/;"	f	namespace:itpp	signature:(int size, bvec &out)
randexp	/usr/include/itpp/base/random.h	/^inline vec randexp(int size, double lambda = 1.0) { Exponential_RNG src; src.setup(lambda); return src(size); }$/;"	f	namespace:itpp	signature:(int size, double lambda = 1.0)
randi	/usr/include/itpp/base/random.h	/^inline imat randi(int rows, int cols, int low, int high) { I_Uniform_RNG src; src.setup(low, high); return src(rows, cols); }$/;"	f	namespace:itpp	signature:(int rows, int cols, int low, int high)
randi	/usr/include/itpp/base/random.h	/^inline int randi(int low, int high) { I_Uniform_RNG src; src.setup(low, high); return src(); }$/;"	f	namespace:itpp	signature:(int low, int high)
randi	/usr/include/itpp/base/random.h	/^inline ivec randi(int size, int low, int high) { I_Uniform_RNG src; src.setup(low, high); return src(size); }$/;"	f	namespace:itpp	signature:(int size, int low, int high)
randn	/usr/include/itpp/base/random.h	/^inline double randn(void) { Normal_RNG src; return src.sample(); }$/;"	f	namespace:itpp	signature:(void)
randn	/usr/include/itpp/base/random.h	/^inline mat randn(int rows, int cols) { mat temp; randn(rows, cols, temp); return temp; }$/;"	f	namespace:itpp	signature:(int rows, int cols)
randn	/usr/include/itpp/base/random.h	/^inline vec randn(int size) { vec temp; randn(size, temp); return temp; }$/;"	f	namespace:itpp	signature:(int size)
randn	/usr/include/itpp/base/random.h	/^inline void randn(int rows, int cols, mat &out)  { Normal_RNG src; src.sample_matrix(rows, cols, out); }$/;"	f	namespace:itpp	signature:(int rows, int cols, mat &out)
randn	/usr/include/itpp/base/random.h	/^inline void randn(int size, vec &out) { Normal_RNG src; src.sample_vector(size, out); }$/;"	f	namespace:itpp	signature:(int size, vec &out)
randn_c	/usr/include/itpp/base/random.h	/^inline cmat randn_c(int rows, int cols) { cmat temp; randn_c(rows, cols, temp); return temp; }$/;"	f	namespace:itpp	signature:(int rows, int cols)
randn_c	/usr/include/itpp/base/random.h	/^inline cvec randn_c(int size) { cvec temp; randn_c(size, temp); return temp; }$/;"	f	namespace:itpp	signature:(int size)
randn_c	/usr/include/itpp/base/random.h	/^inline std::complex<double> randn_c(void) { Complex_Normal_RNG src; return src.sample(); }$/;"	f	namespace:itpp	signature:(void)
randn_c	/usr/include/itpp/base/random.h	/^inline void randn_c(int rows, int cols, cmat &out) { Complex_Normal_RNG src; src.sample_matrix(rows, cols, out); }$/;"	f	namespace:itpp	signature:(int rows, int cols, cmat &out)
randn_c	/usr/include/itpp/base/random.h	/^inline void randn_c(int size, cvec &out)  { Complex_Normal_RNG src; src.sample_vector(size, out); }$/;"	f	namespace:itpp	signature:(int size, cvec &out)
random53_01_lclosed	/usr/include/itpp/base/random.h	/^  double random53_01_lclosed() {$/;"	f	class:itpp::Random_Generator	access:public	signature:()
random_01	/usr/include/itpp/base/random.h	/^  double random_01() { return (random_int() + 0.5) * (1.0 \/ 4294967296.0); }$/;"	f	class:itpp::Random_Generator	access:public	signature:()
random_01_closed	/usr/include/itpp/base/random.h	/^  double random_01_closed() { return random_int() * (1.0 \/ 4294967295.0); }$/;"	f	class:itpp::Random_Generator	access:public	signature:()
random_01_lclosed	/usr/include/itpp/base/random.h	/^  double random_01_lclosed() { return random_int() * (1.0 \/ 4294967296.0); }$/;"	f	class:itpp::Random_Generator	access:public	signature:()
random_int	/usr/include/itpp/base/random.h	/^  unsigned int random_int() {$/;"	f	class:itpp::Random_Generator	access:public	signature:()
randomize	/usr/include/itpp/base/random.h	/^  void randomize() { reset(hash(time(0), clock())); }$/;"	f	class:itpp::Random_Generator	access:public	signature:()
randomize_interleaver_sequence	/usr/include/itpp/comm/interleave.h	/^  void randomize_interleaver_sequence();$/;"	p	class:itpp::Sequence_Interleaver	access:public	signature:()
randomize_interleaver_sequence	/usr/include/itpp/comm/interleave.h	/^void Sequence_Interleaver<T>::randomize_interleaver_sequence()$/;"	f	class:itpp::Sequence_Interleaver	signature:()
randray	/usr/include/itpp/base/random.h	/^inline vec randray(int size, double sigma = 1.0) { Rayleigh_RNG src; src.setup(sigma); return src(size); }$/;"	f	namespace:itpp	signature:(int size, double sigma = 1.0)
randrice	/usr/include/itpp/base/random.h	/^inline vec randrice(int size, double sigma = 1.0, double s = 1.0) { Rice_RNG src; src.setup(sigma, s); return src(size); }$/;"	f	namespace:itpp	signature:(int size, double sigma = 1.0, double s = 1.0)
randu	/usr/include/itpp/base/random.h	/^inline double randu(void) { Uniform_RNG src; return src.sample(); }$/;"	f	namespace:itpp	signature:(void)
randu	/usr/include/itpp/base/random.h	/^inline mat randu(int rows, int cols) { mat temp; randu(rows, cols, temp); return temp; }$/;"	f	namespace:itpp	signature:(int rows, int cols)
randu	/usr/include/itpp/base/random.h	/^inline vec randu(int size) { vec temp; randu(size, temp); return temp; }$/;"	f	namespace:itpp	signature:(int size)
randu	/usr/include/itpp/base/random.h	/^inline void randu(int rows, int cols, mat &out) { Uniform_RNG src; src.sample_matrix(rows, cols, out); }$/;"	f	namespace:itpp	signature:(int rows, int cols, mat &out)
randu	/usr/include/itpp/base/random.h	/^inline void randu(int size, vec &out) { Uniform_RNG src; src.sample_vector(size, out); }$/;"	f	namespace:itpp	signature:(int size, vec &out)
rate	/usr/include/itpp/comm/convcode.h	/^  double rate;$/;"	m	class:itpp::Convolutional_Code	access:protected
rate	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  double rate, Lc;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
rate	/usr/include/itpp/srccode/audiofile.h	/^  int rate() const { return header.sample_rate; }$/;"	f	class:itpp::SND_Format	access:public	signature:() const
raw16be_read	/usr/include/itpp/srccode/audiofile.h	/^bool raw16be_read(const char *fname, vec &v);$/;"	p	namespace:itpp	signature:(const char *fname, vec &v)
raw16be_read	/usr/include/itpp/srccode/audiofile.h	/^bool raw16be_read(const char *fname, vec &v, int beg, int len);$/;"	p	namespace:itpp	signature:(const char *fname, vec &v, int beg, int len)
raw16be_write	/usr/include/itpp/srccode/audiofile.h	/^bool raw16be_write(const char *fname, const vec &v, bool append = false);$/;"	p	namespace:itpp	signature:(const char *fname, const vec &v, bool append = false)
raw16le_read	/usr/include/itpp/srccode/audiofile.h	/^bool raw16le_read(const char *fname, vec &v);$/;"	p	namespace:itpp	signature:(const char *fname, vec &v)
raw16le_read	/usr/include/itpp/srccode/audiofile.h	/^bool raw16le_read(const char *fname, vec &v, int beg, int len);$/;"	p	namespace:itpp	signature:(const char *fname, vec &v, int beg, int len)
raw16le_write	/usr/include/itpp/srccode/audiofile.h	/^bool raw16le_write(const char *fname, const vec &v, bool append = false);$/;"	p	namespace:itpp	signature:(const char *fname, const vec &v, bool append = false)
rc2ac	/usr/include/itpp/srccode/lpcfunc.h	/^vec rc2ac(const vec &rc);$/;"	p	namespace:itpp	signature:(const vec &rc)
rc2is	/usr/include/itpp/srccode/lpcfunc.h	/^vec rc2is(const vec &rc);$/;"	p	namespace:itpp	signature:(const vec &rc)
rc2lar	/usr/include/itpp/srccode/lpcfunc.h	/^vec rc2lar(const vec &rc);$/;"	p	namespace:itpp	signature:(const vec &rc)
rc2poly	/usr/include/itpp/srccode/lpcfunc.h	/^vec rc2poly(const vec &rc);$/;"	p	namespace:itpp	signature:(const vec &rc)
rd_pos	/usr/include/itpp/protocol/selective_repeat.h	/^  int rd_pos;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
re	/usr/include/itpp/fixed/cfix.h	/^  fixrep re;   \/\/!< Real data part$/;"	m	class:itpp::CFix	access:protected
re	/usr/include/itpp/fixed/fix.h	/^  fixrep re;$/;"	m	class:itpp::Fix	access:protected
read	/usr/include/itpp/base/gf2mat.h	/^  void read(const std::string &fname);$/;"	p	class:itpp::GF2mat_sparse_alist	access:public	signature:(const std::string &fname)
read	/usr/include/itpp/protocol/tcp.h	/^  void read(unsigned noOfBytes); \/**< \\brief read up to "noOfBytes" bytes from queue *\/$/;"	p	class:itpp::TCP_Receiver_Buffer	access:public	signature:(unsigned noOfBytes)
read	/usr/include/itpp/srccode/audiofile.h	/^  virtual bool read(vec &v);$/;"	p	class:itpp::SND_In_File	access:public	signature:(vec &v)
read	/usr/include/itpp/srccode/audiofile.h	/^  virtual bool read(vec &v, int n);$/;"	p	class:itpp::SND_In_File	access:public	signature:(vec &v, int n)
read_check_file_header	/usr/include/itpp/base/itfile.h	/^  bool read_check_file_header();$/;"	p	class:itpp::it_ifile	access:public	signature:()
read_check_file_header	/usr/include/itpp/base/itfile.h	/^  bool read_check_file_header();$/;"	p	class:itpp::it_ifile_old	access:public	signature:()
read_data_header	/usr/include/itpp/base/itfile.h	/^  void read_data_header(data_header& h);$/;"	p	class:itpp::it_ifile	access:public	signature:(data_header& h)
read_data_header	/usr/include/itpp/base/itfile.h	/^  void read_data_header(data_header& h);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(data_header& h)
read_endian	/usr/include/itpp/srccode/audiofile.h	/^inline T read_endian(std::istream &s, bool switch_endian = false)$/;"	f	namespace:itpp	signature:(std::istream &s, bool switch_endian = false)
read_from_net	/usr/include/itpp/protocol/tcp_client_server.h	/^  void read_from_net(unsigned byte_size) {$/;"	f	class:itpp::TCP_Client_Application	access:public	signature:(unsigned byte_size)
read_header	/usr/include/itpp/srccode/audiofile.h	/^  bool read_header(std::istream &f);$/;"	p	class:itpp::SND_Format	access:protected	signature:(std::istream &f)
real	/usr/include/itpp/base/math/elem_math.h	/^mat real(const cmat &x);$/;"	p	namespace:itpp	signature:(const cmat &x)
real	/usr/include/itpp/base/math/elem_math.h	/^vec real(const cvec &x);$/;"	p	namespace:itpp	signature:(const cvec &x)
real	/usr/include/itpp/fixed/fix_functions.h	/^Fix real(const CFix &x);$/;"	p	namespace:itpp	signature:(const CFix &x)
recalculate_means	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  void recalculate_means();$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:protected	signature:()
received_packet_indication	/usr/include/itpp/protocol/tcp_client_server.h	/^  void TCP_Client_Application::received_packet_indication(int label) {$/;"	f	class:itpp::TCP_Client_Application::TCP_Client_Application	access:private	signature:(int label)
received_seq_num_index	/usr/include/itpp/protocol/tcp.h	/^  int received_seq_num_index;$/;"	m	class:itpp::TCP_Receiver	access:private
received_seq_num_time	/usr/include/itpp/protocol/tcp.h	/^  vec received_seq_num_time;$/;"	m	class:itpp::TCP_Receiver	access:private
received_seq_num_val	/usr/include/itpp/protocol/tcp.h	/^  ivec received_seq_num_val;$/;"	m	class:itpp::TCP_Receiver	access:private
registered_handler	/usr/include/itpp/protocol/signals_slots.h	/^  THandler *registered_handler;$/;"	m	class:itpp::TTimer	access:private
registered_handler_function	/usr/include/itpp/protocol/signals_slots.h	/^  void(THandler::*registered_handler_function)(Ttype expiry_time);$/;"	m	class:itpp::TTimer	access:private
release	/usr/include/itpp/protocol/tcp.h	/^  virtual void release(std::string trace_filename = "");$/;"	p	class:itpp::TCP_Receiver	access:public	signature:(std::string trace_filename = Ó)
release	/usr/include/itpp/protocol/tcp.h	/^  virtual void release(std::string trace_filename = "");$/;"	p	class:itpp::TCP_Sender	access:public	signature:(std::string trace_filename = Ó)
reload	/usr/include/itpp/base/random.h	/^  void reload() {$/;"	f	class:itpp::Random_Generator	access:private	signature:()
rem	/usr/include/itpp/base/math/elem_math.h	/^inline double rem(double x, double y) { return fmod(x, y); }$/;"	f	namespace:itpp	signature:(double x, double y)
rem	/usr/include/itpp/base/math/elem_math.h	/^inline mat rem(const mat &x, double y)$/;"	f	namespace:itpp	signature:(const mat &x, double y)
rem	/usr/include/itpp/base/math/elem_math.h	/^inline mat rem(double x, const mat &y)$/;"	f	namespace:itpp	signature:(double x, const mat &y)
rem	/usr/include/itpp/base/math/elem_math.h	/^inline vec rem(const vec &x, double y)$/;"	f	namespace:itpp	signature:(const vec &x, double y)
rem	/usr/include/itpp/base/math/elem_math.h	/^inline vec rem(double x, const vec &y)$/;"	f	namespace:itpp	signature:(double x, const vec &y)
rem_mask	/usr/include/itpp/base/gf2mat.h	/^  static const unsigned char rem_mask = (1 << shift_divisor) - 1;$/;"	m	class:itpp::GF2mat	access:private
remove	/usr/include/itpp/base/itfile.h	/^  void remove();$/;"	p	class:itpp::it_file	access:protected	signature:()
remove	/usr/include/itpp/base/itfile.h	/^  void remove();$/;"	p	class:itpp::it_file_old	access:protected	signature:()
remove	/usr/include/itpp/base/itfile.h	/^  void remove(const std::string& name);$/;"	p	class:itpp::it_file	access:public	signature:(const std::string& name)
remove	/usr/include/itpp/base/itfile.h	/^  void remove(const std::string& name);$/;"	p	class:itpp::it_file_old	access:public	signature:(const std::string& name)
remove	/usr/include/itpp/protocol/selective_repeat.h	/^  void remove(const int Sequence_number);$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:(const int Sequence_number)
remove_small_elements	/usr/include/itpp/base/svec.h	/^  void remove_small_elements();$/;"	p	class:itpp::Sparse_Vec	access:public	signature:()
remove_small_elements	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::remove_small_elements()$/;"	f	class:itpp::Sparse_Vec	signature:()
repeat	/usr/include/itpp/signal/resampling.h	/^Mat<T> repeat(const Mat<T> &m, int norepeats)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, int norepeats)
repeat	/usr/include/itpp/signal/resampling.h	/^Vec<T> repeat(const Vec<T> &v, int norepeats)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, int norepeats)
repeat	/usr/include/itpp/signal/resampling.h	/^extern template bmat repeat(const bmat &m, int norepeats);$/;"	p	namespace:itpp	signature:(const bmat &m, int norepeats)
repeat	/usr/include/itpp/signal/resampling.h	/^extern template bvec repeat(const bvec &v, int norepeats);$/;"	p	namespace:itpp	signature:(const bvec &v, int norepeats)
repeat	/usr/include/itpp/signal/resampling.h	/^extern template cmat repeat(const cmat &m, int norepeats);$/;"	p	namespace:itpp	signature:(const cmat &m, int norepeats)
repeat	/usr/include/itpp/signal/resampling.h	/^extern template cvec repeat(const cvec &v, int norepeats);$/;"	p	namespace:itpp	signature:(const cvec &v, int norepeats)
repeat	/usr/include/itpp/signal/resampling.h	/^extern template imat repeat(const imat &m, int norepeats);$/;"	p	namespace:itpp	signature:(const imat &m, int norepeats)
repeat	/usr/include/itpp/signal/resampling.h	/^extern template ivec repeat(const ivec &v, int norepeats);$/;"	p	namespace:itpp	signature:(const ivec &v, int norepeats)
repeat	/usr/include/itpp/signal/resampling.h	/^extern template mat repeat(const mat &m, int norepeats);$/;"	p	namespace:itpp	signature:(const mat &m, int norepeats)
repeat	/usr/include/itpp/signal/resampling.h	/^extern template smat repeat(const smat &m, int norepeats);$/;"	p	namespace:itpp	signature:(const smat &m, int norepeats)
repeat	/usr/include/itpp/signal/resampling.h	/^extern template svec repeat(const svec &v, int norepeats);$/;"	p	namespace:itpp	signature:(const svec &v, int norepeats)
repeat	/usr/include/itpp/signal/resampling.h	/^extern template vec repeat(const vec &v, int norepeats);$/;"	p	namespace:itpp	signature:(const vec &v, int norepeats)
replace_commas	/usr/include/itpp/base/vec.h	/^  std::string replace_commas(const std::string &str);$/;"	p	class:itpp::Vec	access:private	signature:(const std::string &str)
replace_mid	/usr/include/itpp/base/vec.h	/^  void replace_mid(int i, const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:public	signature:(int i, const Vec<Num_T> &v)
replace_mid	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::replace_mid(int i, const Vec<Num_T> &v)$/;"	f	class:itpp::Vec	signature:(int i, const Vec<Num_T> &v)
repmat	/usr/include/itpp/base/matfunc.h	/^Mat<T> repmat(const Mat<T> &data, int m, int n)$/;"	f	namespace:itpp	signature:(const Mat<T> &data, int m, int n)
repmat	/usr/include/itpp/base/matfunc.h	/^Mat<T> repmat(const Vec<T> &v, int m, int n, bool transpose = false)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, int m, int n, bool transpose = false)
repmat	/usr/include/itpp/base/matfunc.h	/^Vec<T> repmat(const Vec<T> &v, int n)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, int n)
repmat	/usr/include/itpp/base/matfunc.h	/^extern template bmat repmat(const bmat &data, int m, int n);$/;"	p	namespace:itpp	signature:(const bmat &data, int m, int n)
repmat	/usr/include/itpp/base/matfunc.h	/^extern template bmat repmat(const bvec &v, int m, int n, bool transpose);$/;"	p	namespace:itpp	signature:(const bvec &v, int m, int n, bool transpose)
repmat	/usr/include/itpp/base/matfunc.h	/^extern template bvec repmat(const bvec &v, int n);$/;"	p	namespace:itpp	signature:(const bvec &v, int n)
repmat	/usr/include/itpp/base/matfunc.h	/^extern template cmat repmat(const cmat &data, int m, int n);$/;"	p	namespace:itpp	signature:(const cmat &data, int m, int n)
repmat	/usr/include/itpp/base/matfunc.h	/^extern template cmat repmat(const cvec &v, int m, int n, bool transpose);$/;"	p	namespace:itpp	signature:(const cvec &v, int m, int n, bool transpose)
repmat	/usr/include/itpp/base/matfunc.h	/^extern template cvec repmat(const cvec &v, int n);$/;"	p	namespace:itpp	signature:(const cvec &v, int n)
repmat	/usr/include/itpp/base/matfunc.h	/^extern template imat repmat(const imat &data, int m, int n);$/;"	p	namespace:itpp	signature:(const imat &data, int m, int n)
repmat	/usr/include/itpp/base/matfunc.h	/^extern template imat repmat(const ivec &v, int m, int n, bool transpose);$/;"	p	namespace:itpp	signature:(const ivec &v, int m, int n, bool transpose)
repmat	/usr/include/itpp/base/matfunc.h	/^extern template ivec repmat(const ivec &v, int n);$/;"	p	namespace:itpp	signature:(const ivec &v, int n)
repmat	/usr/include/itpp/base/matfunc.h	/^extern template mat repmat(const mat &data, int m, int n);$/;"	p	namespace:itpp	signature:(const mat &data, int m, int n)
repmat	/usr/include/itpp/base/matfunc.h	/^extern template mat repmat(const vec &v, int m, int n, bool transpose);$/;"	p	namespace:itpp	signature:(const vec &v, int m, int n, bool transpose)
repmat	/usr/include/itpp/base/matfunc.h	/^extern template smat repmat(const smat &data, int m, int n);$/;"	p	namespace:itpp	signature:(const smat &data, int m, int n)
repmat	/usr/include/itpp/base/matfunc.h	/^extern template smat repmat(const svec &v, int m, int n, bool transpose);$/;"	p	namespace:itpp	signature:(const svec &v, int m, int n, bool transpose)
repmat	/usr/include/itpp/base/matfunc.h	/^extern template svec repmat(const svec &v, int n);$/;"	p	namespace:itpp	signature:(const svec &v, int n)
repmat	/usr/include/itpp/base/matfunc.h	/^extern template vec repmat(const vec &v, int n);$/;"	p	namespace:itpp	signature:(const vec &v, int n)
report	/usr/include/itpp/comm/error_counters.h	/^  void report() const;$/;"	p	class:itpp::BERC	access:public	signature:() const
reset	/usr/include/itpp/base/random.h	/^  void reset() { initialize(last_seed); reload(); initialized = true; }$/;"	f	class:itpp::Random_Generator	access:public	signature:()
reset	/usr/include/itpp/base/random.h	/^  void reset();$/;"	p	class:itpp::AR1_Normal_RNG	access:public	signature:()
reset	/usr/include/itpp/base/random.h	/^  void reset(unsigned int seed) { last_seed = seed; reset(); }$/;"	f	class:itpp::Random_Generator	access:public	signature:(unsigned int seed)
reset	/usr/include/itpp/base/timing.h	/^  void reset(double t = 0.0);$/;"	p	class:itpp::Timer	access:public	signature:(double t = 0.0)
reset	/usr/include/itpp/comm/convcode.h	/^  void reset();$/;"	p	class:itpp::Convolutional_Code	access:public	signature:()
reset	/usr/include/itpp/protocol/tcp.h	/^  void reset(); \/**< \\brief clears internal list structure *\/$/;"	p	class:itpp::TCP_Receiver_Buffer	access:public	signature:()
reset	/usr/include/itpp/stat/histogram.h	/^  void reset() { trials_cnt = 0; bins.zeros(); };$/;"	f	class:itpp::Histogram	access:public	signature:()
reshape	/usr/include/itpp/base/matfunc.h	/^Mat<T> reshape(const Mat<T> &m, int rows, int cols)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, int rows, int cols)
reshape	/usr/include/itpp/base/matfunc.h	/^Mat<T> reshape(const Vec<T> &v, int rows, int cols)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, int rows, int cols)
reshape	/usr/include/itpp/base/matfunc.h	/^extern template bmat reshape(const bmat &m, int rows, int cols);$/;"	p	namespace:itpp	signature:(const bmat &m, int rows, int cols)
reshape	/usr/include/itpp/base/matfunc.h	/^extern template bmat reshape(const bvec &m, int rows, int cols);$/;"	p	namespace:itpp	signature:(const bvec &m, int rows, int cols)
reshape	/usr/include/itpp/base/matfunc.h	/^extern template cmat reshape(const cmat &m, int rows, int cols);$/;"	p	namespace:itpp	signature:(const cmat &m, int rows, int cols)
reshape	/usr/include/itpp/base/matfunc.h	/^extern template cmat reshape(const cvec &m, int rows, int cols);$/;"	p	namespace:itpp	signature:(const cvec &m, int rows, int cols)
reshape	/usr/include/itpp/base/matfunc.h	/^extern template imat reshape(const imat &m, int rows, int cols);$/;"	p	namespace:itpp	signature:(const imat &m, int rows, int cols)
reshape	/usr/include/itpp/base/matfunc.h	/^extern template imat reshape(const ivec &m, int rows, int cols);$/;"	p	namespace:itpp	signature:(const ivec &m, int rows, int cols)
reshape	/usr/include/itpp/base/matfunc.h	/^extern template mat reshape(const mat &m, int rows, int cols);$/;"	p	namespace:itpp	signature:(const mat &m, int rows, int cols)
reshape	/usr/include/itpp/base/matfunc.h	/^extern template mat reshape(const vec &m, int rows, int cols);$/;"	p	namespace:itpp	signature:(const vec &m, int rows, int cols)
reshape	/usr/include/itpp/base/matfunc.h	/^extern template smat reshape(const smat &m, int rows, int cols);$/;"	p	namespace:itpp	signature:(const smat &m, int rows, int cols)
reshape	/usr/include/itpp/base/matfunc.h	/^extern template smat reshape(const svec &m, int rows, int cols);$/;"	p	namespace:itpp	signature:(const svec &m, int rows, int cols)
resize_data	/usr/include/itpp/base/svec.h	/^  void resize_data(int new_size);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(int new_size)
resize_data	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::resize_data(int new_size)$/;"	f	class:itpp::Sparse_Vec	signature:(int new_size)
result	/usr/include/itpp/fixed/fix_functions.h	/^  typedef Array<typename ConvertU2T<T, U>::result> result;  \/\/ Recursive$/;"	t	class:itpp::ConvertU2T	access:public
result	/usr/include/itpp/fixed/fix_functions.h	/^  typedef Mat<T> result;$/;"	t	class:itpp::ConvertU2T	access:public
result	/usr/include/itpp/fixed/fix_functions.h	/^  typedef T result;$/;"	t	class:itpp::ConvertU2T	access:public
result	/usr/include/itpp/fixed/fix_functions.h	/^  typedef Vec<T> result;$/;"	t	class:itpp::ConvertU2T	access:public
retransmission_indexes	/usr/include/itpp/protocol/selective_repeat.h	/^  ivec retransmission_indexes;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
retransmit	/usr/include/itpp/protocol/selective_repeat.h	/^  void retransmit(int Sequence_number);    \/\/ Take care of incomming query for number of packets ready to transmit.$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:(int Sequence_number)
rev_output_parity	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  imat state_trans, output_parity, rev_state_trans, rev_output_parity;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
rev_state_trans	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  imat state_trans, output_parity, rev_state_trans, rev_output_parity;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
reverse	/usr/include/itpp/base/matfunc.h	/^Vec<T> reverse(const Vec<T> &in)$/;"	f	namespace:itpp	signature:(const Vec<T> &in)
reverse	/usr/include/itpp/base/matfunc.h	/^extern template bvec reverse(const bvec &in);$/;"	p	namespace:itpp	signature:(const bvec &in)
reverse	/usr/include/itpp/base/matfunc.h	/^extern template cvec reverse(const cvec &in);$/;"	p	namespace:itpp	signature:(const cvec &in)
reverse	/usr/include/itpp/base/matfunc.h	/^extern template ivec reverse(const ivec &in);$/;"	p	namespace:itpp	signature:(const ivec &in)
reverse	/usr/include/itpp/base/matfunc.h	/^extern template svec reverse(const svec &in);$/;"	p	namespace:itpp	signature:(const svec &in)
reverse	/usr/include/itpp/base/matfunc.h	/^extern template vec reverse(const vec &in);$/;"	p	namespace:itpp	signature:(const vec &in)
reverse_int	/usr/include/itpp/comm/convcode.h	/^int reverse_int(int length, int in);$/;"	p	namespace:itpp	signature:(int length, int in)
reverse_parity	/usr/include/itpp/comm/crc.h	/^  bool reverse_parity;$/;"	m	class:itpp::CRC_Code	access:private
rice_method	/usr/include/itpp/comm/channel.h	/^  RICE_METHOD rice_method;$/;"	m	class:itpp::Rice_Fading_Generator	access:protected
right	/usr/include/itpp/base/array.h	/^  Array<T> right(int n) const;$/;"	p	class:itpp::Array	access:public	signature:(int n) const
right	/usr/include/itpp/base/array.h	/^Array<T> Array<T>::right(int n) const$/;"	f	class:itpp::Array	signature:(int n) const
right	/usr/include/itpp/base/vec.h	/^  Vec<Num_T> right(int nr) const;$/;"	p	class:itpp::Vec	access:public	signature:(int nr) const
right	/usr/include/itpp/base/vec.h	/^Vec<Num_T> Vec<Num_T>::right(int nr) const$/;"	f	class:itpp::Vec	signature:(int nr) const
rint	/usr/include/itpp/base/converters.h	/^double rint(double x);$/;"	p	signature:(double x)
rng_cn	/usr/include/itpp/comm/channel.h	/^  Complex_Normal_RNG rng_cn;$/;"	m	class:itpp::AWGN_Channel	access:private
rng_n	/usr/include/itpp/comm/channel.h	/^  Normal_RNG rng_n;$/;"	m	class:itpp::AWGN_Channel	access:private
roll_off_factor	/usr/include/itpp/comm/pulse_shape.h	/^  double roll_off_factor;$/;"	m	class:itpp::Raised_Cosine	access:protected
roll_off_factor	/usr/include/itpp/comm/pulse_shape.h	/^  double roll_off_factor;$/;"	m	class:itpp::Root_Raised_Cosine	access:protected
roots	/usr/include/itpp/signal/poly.h	/^inline cvec roots(const cvec &p) { cvec temp; roots(p, temp); return temp; }$/;"	f	namespace:itpp	signature:(const cvec &p)
roots	/usr/include/itpp/signal/poly.h	/^inline cvec roots(const vec &p) { cvec temp; roots(p, temp); return temp; }$/;"	f	namespace:itpp	signature:(const vec &p)
roots	/usr/include/itpp/signal/poly.h	/^void roots(const cvec &p, cvec &r);$/;"	p	namespace:itpp	signature:(const cvec &p, cvec &r)
roots	/usr/include/itpp/signal/poly.h	/^void roots(const vec &p, cvec &r);$/;"	p	namespace:itpp	signature:(const vec &p, cvec &r)
rotation_matrix	/usr/include/itpp/base/specmat.h	/^mat rotation_matrix(int dim, int plane1, int plane2, double angle);$/;"	p	namespace:itpp	signature:(int dim, int plane1, int plane2, double angle)
round	/usr/include/itpp/base/converters.h	/^inline double round(double x) { return ::rint(x); }$/;"	f	namespace:itpp	signature:(double x)
round	/usr/include/itpp/base/converters.h	/^inline mat round(const mat &x) { return apply_function<double>(::rint, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
round	/usr/include/itpp/base/converters.h	/^inline vec round(const vec &x) { return apply_function<double>(::rint, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
round_i	/usr/include/itpp/base/converters.h	/^imat round_i(const mat &x);$/;"	p	namespace:itpp	signature:(const mat &x)
round_i	/usr/include/itpp/base/converters.h	/^inline int round_i(double x) { return static_cast<int>(::rint(x)); }$/;"	f	namespace:itpp	signature:(double x)
round_i	/usr/include/itpp/base/converters.h	/^ivec round_i(const vec &x);$/;"	p	namespace:itpp	signature:(const vec &x)
round_to_zero	/usr/include/itpp/base/converters.h	/^cmat round_to_zero(const cmat &x, double threshold = 1e-14);$/;"	p	namespace:itpp	signature:(const cmat &x, double threshold = 1e-14)
round_to_zero	/usr/include/itpp/base/converters.h	/^cvec round_to_zero(const cvec &x, double threshold = 1e-14);$/;"	p	namespace:itpp	signature:(const cvec &x, double threshold = 1e-14)
round_to_zero	/usr/include/itpp/base/converters.h	/^inline double round_to_zero(double x, double threshold = 1e-14)$/;"	f	namespace:itpp	signature:(double x, double threshold = 1e-14)
round_to_zero	/usr/include/itpp/base/converters.h	/^inline mat round_to_zero(const mat &x, double threshold = 1e-14)$/;"	f	namespace:itpp	signature:(const mat &x, double threshold = 1e-14)
round_to_zero	/usr/include/itpp/base/converters.h	/^inline std::complex<double> round_to_zero(const std::complex<double>& x,$/;"	f	namespace:itpp	signature:(const std::complex<double>& x, double threshold = 1e-14)
round_to_zero	/usr/include/itpp/base/converters.h	/^inline vec round_to_zero(const vec &x, double threshold = 1e-14)$/;"	f	namespace:itpp	signature:(const vec &x, double threshold = 1e-14)
row_in_range	/usr/include/itpp/base/mat.h	/^  bool row_in_range(int r) const { return ((r >= 0) && (r < no_rows)); }$/;"	f	class:itpp::Mat	access:private	signature:(int r) const
row_rank	/usr/include/itpp/base/gf2mat.h	/^  int row_rank() const;$/;"	p	class:itpp::GF2mat	access:public	signature:() const
rows	/usr/include/itpp/base/gf2mat.h	/^  int rows() const { return nrows; }$/;"	f	class:itpp::GF2mat	access:public	signature:() const
rows	/usr/include/itpp/base/mat.h	/^  int rows() const { return no_rows; }$/;"	f	class:itpp::Mat	access:public	signature:() const
rows	/usr/include/itpp/base/smat.h	/^  int rows() const { return n_rows; }$/;"	f	class:itpp::Sparse_Mat	access:public	signature:() const
rows	/usr/include/itpp/comm/interleave.h	/^  int rows, cols, input_length;$/;"	m	class:itpp::Block_Interleaver	access:private
rscc1	/usr/include/itpp/comm/turbo.h	/^  Rec_Syst_Conv_Code rscc1, rscc2;$/;"	m	class:itpp::Turbo_Codec	access:private
rscc2	/usr/include/itpp/comm/turbo.h	/^  Rec_Syst_Conv_Code rscc1, rscc2;$/;"	m	class:itpp::Turbo_Codec	access:private
rshift	/usr/include/itpp/fixed/cfix.h	/^  void rshift(int n);$/;"	p	class:itpp::CFix	access:public	signature:(int n)
rshift	/usr/include/itpp/fixed/cfix.h	/^  void rshift(int n, q_mode q);$/;"	p	class:itpp::CFix	access:public	signature:(int n, q_mode q)
rshift	/usr/include/itpp/fixed/fix.h	/^  void rshift(int n);$/;"	p	class:itpp::Fix	access:public	signature:(int n)
rshift	/usr/include/itpp/fixed/fix.h	/^  void rshift(int n, q_mode q);$/;"	p	class:itpp::Fix	access:public	signature:(int n, q_mode q)
rshift_and_apply_q_mode	/usr/include/itpp/fixed/fix_base.h	/^  fixrep rshift_and_apply_q_mode(fixrep x, int n) const {return rshift_and_apply_q_mode(x, n, qmode);}$/;"	f	class:itpp::Fix_Base	access:protected	signature:(fixrep x, int n) const
rshift_and_apply_q_mode	/usr/include/itpp/fixed/fix_base.h	/^  fixrep rshift_and_apply_q_mode(fixrep x, int n, q_mode q) const;$/;"	p	class:itpp::Fix_Base	access:protected	signature:(fixrep x, int n, q_mode q) const
rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(CFix &y, int n) {y.rshift(n);}$/;"	f	namespace:itpp	signature:(CFix &y, int n)
rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(CFix &y, int n, q_mode q) {y.rshift(n, q);}$/;"	f	namespace:itpp	signature:(CFix &y, int n, q_mode q)
rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(Fix &y, int n) {y.rshift(n);}$/;"	f	namespace:itpp	signature:(Fix &y, int n)
rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(Fix &y, int n, q_mode q) {y.rshift(n, q);}$/;"	f	namespace:itpp	signature:(Fix &y, int n, q_mode q)
rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(cfixmat &y, int n)$/;"	f	namespace:itpp	signature:(cfixmat &y, int n)
rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(cfixmat &y, int n, q_mode q)$/;"	f	namespace:itpp	signature:(cfixmat &y, int n, q_mode q)
rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(cfixvec &y, int n)$/;"	f	namespace:itpp	signature:(cfixvec &y, int n)
rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(cfixvec &y, int n, q_mode q)$/;"	f	namespace:itpp	signature:(cfixvec &y, int n, q_mode q)
rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(cmat &, int) {}$/;"	f	namespace:itpp	signature:(cmat &, int)
rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(cmat &, int, q_mode) {}$/;"	f	namespace:itpp	signature:(cmat &, int, q_mode)
rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(cvec &, int) {}$/;"	f	namespace:itpp	signature:(cvec &, int)
rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(cvec &, int, q_mode) {}$/;"	f	namespace:itpp	signature:(cvec &, int, q_mode)
rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(double &, int) {}$/;"	f	namespace:itpp	signature:(double &, int)
rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(double &, int, q_mode) {}$/;"	f	namespace:itpp	signature:(double &, int, q_mode)
rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(fixmat &y, int n)$/;"	f	namespace:itpp	signature:(fixmat &y, int n)
rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(fixmat &y, int n, q_mode q)$/;"	f	namespace:itpp	signature:(fixmat &y, int n, q_mode q)
rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(fixvec &y, int n)$/;"	f	namespace:itpp	signature:(fixvec &y, int n)
rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(fixvec &y, int n, q_mode q)$/;"	f	namespace:itpp	signature:(fixvec &y, int n, q_mode q)
rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(mat &, int) {}$/;"	f	namespace:itpp	signature:(mat &, int)
rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(mat &, int, q_mode) {}$/;"	f	namespace:itpp	signature:(mat &, int, q_mode)
rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(std::complex<double> &, int) {}$/;"	f	namespace:itpp	signature:(std::complex<double> &, int)
rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(std::complex<double> &, int, q_mode) {}$/;"	f	namespace:itpp	signature:(std::complex<double> &, int, q_mode)
rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(vec &, int) {}$/;"	f	namespace:itpp	signature:(vec &, int)
rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void rshift_fix(vec &, int, q_mode) {}$/;"	f	namespace:itpp	signature:(vec &, int, q_mode)
rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<class T> inline void rshift_fix(Array<T> &y, int n)$/;"	f	namespace:itpp	signature:(Array<T> &y, int n)
rshift_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<class T> inline void rshift_fix(Array<T> &y, int n, q_mode q)$/;"	f	namespace:itpp	signature:(Array<T> &y, int n, q_mode q)
rt_pos	/usr/include/itpp/protocol/selective_repeat.h	/^  int rt_pos;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
run	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  void run(MOG_diag &model_in, Array<vec> &X_in, int max_iter_in = 10, double trust_in = 0.5, bool normalise_in = true, bool verbose_in = false);$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:public	signature:(MOG_diag &model_in, Array<vec> &X_in, int max_iter_in = 10, double trust_in = 0.5, bool normalise_in = true, bool verbose_in = false)
running	/usr/include/itpp/base/timing.h	/^  bool running;$/;"	m	class:itpp::Timer	access:protected
rvectorize	/usr/include/itpp/base/matfunc.h	/^Vec<T> rvectorize(const Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
rvectorize	/usr/include/itpp/base/matfunc.h	/^extern template bvec rvectorize(const bmat &m);$/;"	p	namespace:itpp	signature:(const bmat &m)
rvectorize	/usr/include/itpp/base/matfunc.h	/^extern template cvec rvectorize(const cmat &m);$/;"	p	namespace:itpp	signature:(const cmat &m)
rvectorize	/usr/include/itpp/base/matfunc.h	/^extern template ivec rvectorize(const imat &m);$/;"	p	namespace:itpp	signature:(const imat &m)
rvectorize	/usr/include/itpp/base/matfunc.h	/^extern template svec rvectorize(const smat &m);$/;"	p	namespace:itpp	signature:(const smat &m)
rvectorize	/usr/include/itpp/base/matfunc.h	/^extern template vec rvectorize(const mat &m);$/;"	p	namespace:itpp	signature:(const mat &m)
rx_buffer	/usr/include/itpp/protocol/selective_repeat.h	/^  Array<Link_Packet*> rx_buffer;$/;"	m	class:itpp::Selective_Repeat_ARQ_Receiver	access:private
s	/usr/include/itpp/base/itfile.h	/^  bfstream s;$/;"	m	class:itpp::it_ifile	access:protected
s	/usr/include/itpp/base/itfile.h	/^  bfstream s;$/;"	m	class:itpp::it_ifile_old	access:protected
s	/usr/include/itpp/base/random.h	/^  double sig, s;$/;"	m	class:itpp::Rice_RNG	access:private
sample	/usr/include/itpp/base/random.h	/^  bin sample() { return bin(RNG.random_01() < p ? 1 : 0); }$/;"	f	class:itpp::Bernoulli_RNG	access:public	signature:()
sample	/usr/include/itpp/base/random.h	/^  double sample() {  return (-std::log(RNG.random_01()) \/ l); }$/;"	f	class:itpp::Exponential_RNG	access:private	signature:()
sample	/usr/include/itpp/base/random.h	/^  double sample() {  return RNG.random_01(); }$/;"	f	class:itpp::Uniform_RNG	access:public	signature:()
sample	/usr/include/itpp/base/random.h	/^  double sample() {$/;"	f	class:itpp::AR1_Normal_RNG	access:private	signature:()
sample	/usr/include/itpp/base/random.h	/^  double sample() {$/;"	f	class:itpp::Laplace_RNG	access:public	signature:()
sample	/usr/include/itpp/base/random.h	/^  double sample() {$/;"	f	class:itpp::Rayleigh_RNG	access:private	signature:()
sample	/usr/include/itpp/base/random.h	/^  double sample() {$/;"	f	class:itpp::Rice_RNG	access:private	signature:()
sample	/usr/include/itpp/base/random.h	/^  double sample() {$/;"	f	class:itpp::Weibull_RNG	access:private	signature:()
sample	/usr/include/itpp/base/random.h	/^  double sample();$/;"	p	class:itpp::Normal_RNG	access:public	signature:()
sample	/usr/include/itpp/base/random.h	/^  int sample() { return (floor_i(RNG.random_01() * (hi - lo + 1)) + lo); }$/;"	f	class:itpp::I_Uniform_RNG	access:public	signature:()
sample	/usr/include/itpp/base/random.h	/^  std::complex<double> sample() {$/;"	f	class:itpp::Complex_Normal_RNG	access:public	signature:()
sample	/usr/include/itpp/signal/source.h	/^  double sample();$/;"	p	class:itpp::Impulse_Source	access:private	signature:()
sample	/usr/include/itpp/signal/source.h	/^  double sample();$/;"	p	class:itpp::Pattern_Source	access:private	signature:()
sample	/usr/include/itpp/signal/source.h	/^  double sample();$/;"	p	class:itpp::Sawtooth_Source	access:private	signature:()
sample	/usr/include/itpp/signal/source.h	/^  double sample();$/;"	p	class:itpp::Sine_Source	access:private	signature:()
sample	/usr/include/itpp/signal/source.h	/^  double sample();$/;"	p	class:itpp::Square_Source	access:private	signature:()
sample	/usr/include/itpp/signal/source.h	/^  double sample();$/;"	p	class:itpp::Triangle_Source	access:private	signature:()
sample	/usr/include/itpp/stat/misc_stat.h	/^  virtual void sample(const double s, const bool overflow = false) {$/;"	f	class:itpp::Stat	access:public	signature:(const double s, const bool overflow = false)
sampleSize	/usr/include/itpp/signal/fastica.h	/^  double a1, a2, mu, epsilon, sampleSize;$/;"	m	class:itpp::Fast_ICA	access:private
sample_matrix	/usr/include/itpp/base/random.h	/^  void sample_matrix(int rows, int cols, bmat &out) {$/;"	f	class:itpp::Bernoulli_RNG	access:public	signature:(int rows, int cols, bmat &out)
sample_matrix	/usr/include/itpp/base/random.h	/^  void sample_matrix(int rows, int cols, cmat &out) {$/;"	f	class:itpp::Complex_Normal_RNG	access:public	signature:(int rows, int cols, cmat &out)
sample_matrix	/usr/include/itpp/base/random.h	/^  void sample_matrix(int rows, int cols, mat &out) {$/;"	f	class:itpp::Normal_RNG	access:public	signature:(int rows, int cols, mat &out)
sample_matrix	/usr/include/itpp/base/random.h	/^  void sample_matrix(int rows, int cols, mat &out) {$/;"	f	class:itpp::Uniform_RNG	access:public	signature:(int rows, int cols, mat &out)
sample_rate	/usr/include/itpp/srccode/audiofile.h	/^    unsigned sample_rate;$/;"	m	struct:itpp::SND_Format::__anon1	access:public
sample_size	/usr/include/itpp/srccode/audiofile.h	/^  int sample_size() const;$/;"	p	class:itpp::SND_Format	access:protected	signature:() const
sample_vector	/usr/include/itpp/base/random.h	/^  void sample_vector(int size, bvec &out) {$/;"	f	class:itpp::Bernoulli_RNG	access:public	signature:(int size, bvec &out)
sample_vector	/usr/include/itpp/base/random.h	/^  void sample_vector(int size, cvec &out) {$/;"	f	class:itpp::Complex_Normal_RNG	access:public	signature:(int size, cvec &out)
sample_vector	/usr/include/itpp/base/random.h	/^  void sample_vector(int size, vec &out) {$/;"	f	class:itpp::Normal_RNG	access:public	signature:(int size, vec &out)
sample_vector	/usr/include/itpp/base/random.h	/^  void sample_vector(int size, vec &out) {$/;"	f	class:itpp::Uniform_RNG	access:public	signature:(int size, vec &out)
samples	/usr/include/itpp/srccode/audiofile.h	/^  int samples() const { return header.data_size \/ sample_size(); }$/;"	f	class:itpp::SND_Format	access:public	signature:() const
sanitise_params	/usr/include/itpp/stat/mog_diag_em.h	/^  void inline sanitise_params();$/;"	p	class:itpp::MOG_diag_EM_sup	access:protected	signature:()
save	/usr/include/itpp/comm/ldpc.h	/^  virtual void save(const std::string& filename) const = 0;$/;"	p	class:itpp::LDPC_Generator	access:protected	signature:(const std::string& filename) const
save	/usr/include/itpp/comm/ldpc.h	/^  virtual void save(const std::string& filename) const;$/;"	p	class:itpp::LDPC_Generator_Systematic	access:protected	signature:(const std::string& filename) const
save	/usr/include/itpp/comm/ldpc.h	/^  void save(const std::string &filename) const;$/;"	p	class:itpp::BLDPC_Generator	access:protected	signature:(const std::string &filename) const
save	/usr/include/itpp/srccode/gmm.h	/^  void save(std::string filename);$/;"	p	class:itpp::GMM	access:public	signature:(std::string filename)
save	/usr/include/itpp/srccode/vq.h	/^  void save(const char *Name) const;$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:(const char *Name) const
save	/usr/include/itpp/stat/mog_generic.h	/^  virtual void save(const std::string &name_in) const;$/;"	p	class:itpp::MOG_generic	access:public	signature:(const std::string &name_in) const
save_alist	/usr/include/itpp/comm/ldpc.h	/^  void save_alist(const std::string& alist_file) const;$/;"	p	class:itpp::LDPC_Parity	access:public	signature:(const std::string& alist_file) const
save_base_matrix	/usr/include/itpp/comm/ldpc.h	/^  void save_base_matrix(const std::string &filename) const;$/;"	p	class:itpp::BLDPC_Parity	access:public	signature:(const std::string &filename) const
save_code	/usr/include/itpp/comm/ldpc.h	/^  void save_code(const std::string& filename) const;$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const std::string& filename) const
save_to_file	/usr/include/itpp/protocol/tcp_client_server.h	/^  void TCP_Client_Application::save_to_file(string file) {$/;"	f	class:itpp::TCP_Client_Application::TCP_Client_Application	access:private	signature:(string file)
save_trace	/usr/include/itpp/protocol/tcp.h	/^  virtual void save_trace(std::string filename);$/;"	p	class:itpp::TCP_Receiver	access:public	signature:(std::string filename)
save_trace	/usr/include/itpp/protocol/tcp.h	/^  virtual void save_trace(std::string filename);$/;"	p	class:itpp::TCP_Sender	access:public	signature:(std::string filename)
scal_vector	/usr/include/itpp/base/copy_vector.h	/^inline void scal_vector(int n, double alpha, double *x)$/;"	f	namespace:itpp	signature:(int n, double alpha, double *x)
scal_vector	/usr/include/itpp/base/copy_vector.h	/^inline void scal_vector(int n, double alpha, double *x, int incx)$/;"	f	namespace:itpp	signature:(int n, double alpha, double *x, int incx)
scal_vector	/usr/include/itpp/base/copy_vector.h	/^inline void scal_vector(int n, std::complex<double> alpha,$/;"	f	namespace:itpp	signature:(int n, std::complex<double> alpha, std::complex<double> *x)
scal_vector	/usr/include/itpp/base/copy_vector.h	/^inline void scal_vector(int n, std::complex<double> alpha,$/;"	f	namespace:itpp	signature:(int n, std::complex<double> alpha, std::complex<double> *x, int incx)
scal_vector	/usr/include/itpp/base/copy_vector.h	/^void scal_vector(int n, T alpha, T *x)$/;"	f	namespace:itpp	signature:(int n, T alpha, T *x)
scal_vector	/usr/include/itpp/base/copy_vector.h	/^void scal_vector(int n, T alpha, T *x, int incx)$/;"	f	namespace:itpp	signature:(int n, T alpha, T *x, int incx)
scalar_encode	/usr/include/itpp/srccode/vq.h	/^int scalar_encode(double x, vec &Levels) ;$/;"	p	namespace:itpp	signature:(double x, vec &Levels)
scalar_encode	/usr/include/itpp/srccode/vq.h	/^ivec scalar_encode(vec &x, vec &Levels);$/;"	p	namespace:itpp	signature:(vec &x, vec &Levels)
scalar_quantize	/usr/include/itpp/srccode/vq.h	/^inline double scalar_quantize(double x, vec &Levels) { return Levels(scalar_encode(x, Levels)); }$/;"	f	namespace:itpp	signature:(double x, vec &Levels)
scalar_quantize	/usr/include/itpp/srccode/vq.h	/^inline vec scalar_quantize(vec &x, vec &Levels) { return Levels(scalar_encode(x, Levels)); }$/;"	f	namespace:itpp	signature:(vec &x, vec &Levels)
scale_and_apply_modes	/usr/include/itpp/fixed/fix_base.h	/^  fixrep scale_and_apply_modes(double x) const {return scale_and_apply_modes(x, qmode);}$/;"	f	class:itpp::Fix_Base	access:protected	signature:(double x) const
scale_and_apply_modes	/usr/include/itpp/fixed/fix_base.h	/^  fixrep scale_and_apply_modes(double x, q_mode q) const;$/;"	p	class:itpp::Fix_Base	access:protected	signature:(double x, q_mode q) const
scaling_factor	/usr/include/itpp/comm/modulator.h	/^  double scaling_factor;$/;"	m	class:itpp::PAM	access:protected
scaling_factor	/usr/include/itpp/comm/modulator.h	/^  double scaling_factor;$/;"	m	class:itpp::PAM_c	access:protected
scaling_factor	/usr/include/itpp/comm/modulator.h	/^  double scaling_factor;$/;"	m	class:itpp::QAM	access:protected
scfixed1	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<1, TC, SAT> scfixed1;$/;"	t	namespace:itpp
scfixed10	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<10, TC, SAT> scfixed10;$/;"	t	namespace:itpp
scfixed11	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<11, TC, SAT> scfixed11;$/;"	t	namespace:itpp
scfixed12	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<12, TC, SAT> scfixed12;$/;"	t	namespace:itpp
scfixed13	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<13, TC, SAT> scfixed13;$/;"	t	namespace:itpp
scfixed14	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<14, TC, SAT> scfixed14;$/;"	t	namespace:itpp
scfixed15	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<15, TC, SAT> scfixed15;$/;"	t	namespace:itpp
scfixed16	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<16, TC, SAT> scfixed16;$/;"	t	namespace:itpp
scfixed17	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<17, TC, SAT> scfixed17;$/;"	t	namespace:itpp
scfixed18	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<18, TC, SAT> scfixed18;$/;"	t	namespace:itpp
scfixed19	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<19, TC, SAT> scfixed19;$/;"	t	namespace:itpp
scfixed2	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<2, TC, SAT> scfixed2;$/;"	t	namespace:itpp
scfixed20	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<20, TC, SAT> scfixed20;$/;"	t	namespace:itpp
scfixed21	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<21, TC, SAT> scfixed21;$/;"	t	namespace:itpp
scfixed22	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<22, TC, SAT> scfixed22;$/;"	t	namespace:itpp
scfixed23	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<23, TC, SAT> scfixed23;$/;"	t	namespace:itpp
scfixed24	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<24, TC, SAT> scfixed24;$/;"	t	namespace:itpp
scfixed25	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<25, TC, SAT> scfixed25;$/;"	t	namespace:itpp
scfixed26	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<26, TC, SAT> scfixed26;$/;"	t	namespace:itpp
scfixed27	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<27, TC, SAT> scfixed27;$/;"	t	namespace:itpp
scfixed28	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<28, TC, SAT> scfixed28;$/;"	t	namespace:itpp
scfixed29	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<29, TC, SAT> scfixed29;$/;"	t	namespace:itpp
scfixed3	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<3, TC, SAT> scfixed3;$/;"	t	namespace:itpp
scfixed30	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<30, TC, SAT> scfixed30;$/;"	t	namespace:itpp
scfixed31	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<31, TC, SAT> scfixed31;$/;"	t	namespace:itpp
scfixed32	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<32, TC, SAT> scfixed32;$/;"	t	namespace:itpp
scfixed33	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<33, TC, SAT> scfixed33;$/;"	t	namespace:itpp
scfixed34	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<34, TC, SAT> scfixed34;$/;"	t	namespace:itpp
scfixed35	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<35, TC, SAT> scfixed35;$/;"	t	namespace:itpp
scfixed36	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<36, TC, SAT> scfixed36;$/;"	t	namespace:itpp
scfixed37	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<37, TC, SAT> scfixed37;$/;"	t	namespace:itpp
scfixed38	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<38, TC, SAT> scfixed38;$/;"	t	namespace:itpp
scfixed39	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<39, TC, SAT> scfixed39;$/;"	t	namespace:itpp
scfixed4	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<4, TC, SAT> scfixed4;$/;"	t	namespace:itpp
scfixed40	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<40, TC, SAT> scfixed40;$/;"	t	namespace:itpp
scfixed41	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<41, TC, SAT> scfixed41;$/;"	t	namespace:itpp
scfixed42	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<42, TC, SAT> scfixed42;$/;"	t	namespace:itpp
scfixed43	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<43, TC, SAT> scfixed43;$/;"	t	namespace:itpp
scfixed44	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<44, TC, SAT> scfixed44;$/;"	t	namespace:itpp
scfixed45	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<45, TC, SAT> scfixed45;$/;"	t	namespace:itpp
scfixed46	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<46, TC, SAT> scfixed46;$/;"	t	namespace:itpp
scfixed47	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<47, TC, SAT> scfixed47;$/;"	t	namespace:itpp
scfixed48	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<48, TC, SAT> scfixed48;$/;"	t	namespace:itpp
scfixed49	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<49, TC, SAT> scfixed49;$/;"	t	namespace:itpp
scfixed5	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<5, TC, SAT> scfixed5;$/;"	t	namespace:itpp
scfixed50	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<50, TC, SAT> scfixed50;$/;"	t	namespace:itpp
scfixed51	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<51, TC, SAT> scfixed51;$/;"	t	namespace:itpp
scfixed52	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<52, TC, SAT> scfixed52;$/;"	t	namespace:itpp
scfixed53	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<53, TC, SAT> scfixed53;$/;"	t	namespace:itpp
scfixed54	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<54, TC, SAT> scfixed54;$/;"	t	namespace:itpp
scfixed55	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<55, TC, SAT> scfixed55;$/;"	t	namespace:itpp
scfixed56	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<56, TC, SAT> scfixed56;$/;"	t	namespace:itpp
scfixed57	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<57, TC, SAT> scfixed57;$/;"	t	namespace:itpp
scfixed58	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<58, TC, SAT> scfixed58;$/;"	t	namespace:itpp
scfixed59	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<59, TC, SAT> scfixed59;$/;"	t	namespace:itpp
scfixed6	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<6, TC, SAT> scfixed6;$/;"	t	namespace:itpp
scfixed60	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<60, TC, SAT> scfixed60;$/;"	t	namespace:itpp
scfixed61	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<61, TC, SAT> scfixed61;$/;"	t	namespace:itpp
scfixed62	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<62, TC, SAT> scfixed62;$/;"	t	namespace:itpp
scfixed63	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<63, TC, SAT> scfixed63;$/;"	t	namespace:itpp
scfixed64	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<64, TC, SAT> scfixed64;$/;"	t	namespace:itpp
scfixed7	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<7, TC, SAT> scfixed7;$/;"	t	namespace:itpp
scfixed8	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<8, TC, SAT> scfixed8;$/;"	t	namespace:itpp
scfixed9	/usr/include/itpp/fixed/cfixed.h	/^typedef CFixed<9, TC, SAT> scfixed9;$/;"	t	namespace:itpp
schedule_output	/usr/include/itpp/protocol/selective_repeat.h	/^  void schedule_output(const int Buffer_index, const int Sequence_number, const bool Retransmission);$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:(const int Buffer_index, const int Sequence_number, const bool Retransmission)
scheduled_retransmissions	/usr/include/itpp/protocol/selective_repeat.h	/^  int scheduled_retransmissions;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
scheduled_total	/usr/include/itpp/protocol/selective_repeat.h	/^  int scheduled_total;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
schur	/usr/include/itpp/base/algebra/schur.h	/^bool schur(const cmat &A, cmat &U, cmat &T);$/;"	p	namespace:itpp	signature:(const cmat &A, cmat &U, cmat &T)
schur	/usr/include/itpp/base/algebra/schur.h	/^bool schur(const mat &A, mat &U, mat &T);$/;"	p	namespace:itpp	signature:(const mat &A, mat &U, mat &T)
schur	/usr/include/itpp/base/algebra/schur.h	/^cmat schur(const cmat &A);$/;"	p	namespace:itpp	signature:(const cmat &A)
schur	/usr/include/itpp/base/algebra/schur.h	/^mat schur(const mat &A);$/;"	p	namespace:itpp	signature:(const mat &A)
schurrc	/usr/include/itpp/srccode/lpcfunc.h	/^vec schurrc(const vec &R, int order);$/;"	p	namespace:itpp	signature:(const vec &R, int order)
sd	/usr/include/itpp/srccode/lpcfunc.h	/^double sd(const vec &In1, const vec &In2);$/;"	p	namespace:itpp	signature:(const vec &In1, const vec &In2)
sd	/usr/include/itpp/srccode/lpcfunc.h	/^double sd(const vec &In1, const vec &In2, double highestfreq);$/;"	p	namespace:itpp	signature:(const vec &In1, const vec &In2, double highestfreq)
search	/usr/include/itpp/optim/newton_search.h	/^  bool search();$/;"	p	class:itpp::Line_Search	access:public	signature:()
search	/usr/include/itpp/optim/newton_search.h	/^  bool search();$/;"	p	class:itpp::Newton_Search	access:public	signature:()
search	/usr/include/itpp/optim/newton_search.h	/^  bool search(const vec &x, double F, const vec &g, const vec &h, vec &xn,$/;"	p	class:itpp::Line_Search	access:public	signature:(const vec &x, double F, const vec &g, const vec &h, vec &xn, double &Fn, vec &gn)
search	/usr/include/itpp/optim/newton_search.h	/^  bool search(const vec &x0, vec &xn);$/;"	p	class:itpp::Newton_Search	access:public	signature:(const vec &x0, vec &xn)
search	/usr/include/itpp/optim/newton_search.h	/^  bool search(vec &xn);$/;"	p	class:itpp::Newton_Search	access:public	signature:(vec &xn)
search	/usr/include/itpp/optim/newton_search.h	/^  bool search(vec &xn, double &Fn, vec &gn);$/;"	p	class:itpp::Line_Search	access:public	signature:(vec &xn, double &Fn, vec &gn)
seek	/usr/include/itpp/base/itfile.h	/^  bool seek(const std::string& name);$/;"	p	class:itpp::it_ifile	access:public	signature:(const std::string& name)
seek	/usr/include/itpp/base/itfile.h	/^  bool seek(const std::string& name);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(const std::string& name)
seek	/usr/include/itpp/base/itfile.h	/^  bool seek(int n);$/;"	p	class:itpp::it_ifile	access:public	signature:(int n)
seek	/usr/include/itpp/base/itfile.h	/^  bool seek(int n);$/;"	p	class:itpp::it_ifile_old	access:public	signature:(int n)
seek_read	/usr/include/itpp/srccode/audiofile.h	/^  bool seek_read(int pos);$/;"	p	class:itpp::SND_In_File	access:public	signature:(int pos)
seek_write	/usr/include/itpp/srccode/audiofile.h	/^  bool seek_write(int pos);$/;"	p	class:itpp::SND_Out_File	access:public	signature:(int pos)
select	/usr/include/itpp/protocol/tcp_client_server.h	/^  Slot<TCP_Client_Application, int> select;$/;"	m	class:itpp::TCP_Client_Application	access:public
self_dht	/usr/include/itpp/signal/transforms.h	/^extern template void self_dht(cvec &v);$/;"	p	namespace:itpp	signature:(cvec &v)
self_dht	/usr/include/itpp/signal/transforms.h	/^extern template void self_dht(vec &v);$/;"	p	namespace:itpp	signature:(vec &v)
self_dht	/usr/include/itpp/signal/transforms.h	/^template <class T> void self_dht(Vec<T> &v);$/;"	p	namespace:itpp	signature:(Vec<T> &v)
self_dht	/usr/include/itpp/signal/transforms.h	/^void self_dht(Vec<T> &v)$/;"	f	namespace:itpp	signature:(Vec<T> &v)
self_dwht	/usr/include/itpp/signal/transforms.h	/^extern template void self_dwht(cvec &v);$/;"	p	namespace:itpp	signature:(cvec &v)
self_dwht	/usr/include/itpp/signal/transforms.h	/^extern template void self_dwht(vec &v);$/;"	p	namespace:itpp	signature:(vec &v)
self_dwht	/usr/include/itpp/signal/transforms.h	/^template <class T> void self_dwht(Vec<T> &v);$/;"	p	namespace:itpp	signature:(Vec<T> &v)
self_dwht	/usr/include/itpp/signal/transforms.h	/^void self_dwht(Vec<T> &v)$/;"	f	namespace:itpp	signature:(Vec<T> &v)
sender_recv_ack_seq_num_index	/usr/include/itpp/protocol/tcp.h	/^  int sender_recv_ack_seq_num_index;$/;"	m	class:itpp::TCP_Sender	access:private
sender_recv_ack_seq_num_time	/usr/include/itpp/protocol/tcp.h	/^  vec sender_recv_ack_seq_num_time;$/;"	m	class:itpp::TCP_Sender	access:private
sender_recv_ack_seq_num_val	/usr/include/itpp/protocol/tcp.h	/^  ivec sender_recv_ack_seq_num_val;$/;"	m	class:itpp::TCP_Sender	access:private
sent_seq_num_index	/usr/include/itpp/protocol/tcp.h	/^  int sent_seq_num_index;$/;"	m	class:itpp::TCP_Sender	access:private
sent_seq_num_time	/usr/include/itpp/protocol/tcp.h	/^  vec sent_seq_num_time;$/;"	m	class:itpp::TCP_Sender	access:private
sent_seq_num_val	/usr/include/itpp/protocol/tcp.h	/^  ivec sent_seq_num_val;$/;"	m	class:itpp::TCP_Sender	access:private
separate	/usr/include/itpp/signal/fastica.h	/^  void separate(void);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(void)
seq	/usr/include/itpp/protocol/tcp.h	/^  int seq;$/;"	m	class:itpp::Sequence_Number	access:protected
seq_begin	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number  seq_begin; \/**< \\brief no. of first byte of segment *\/$/;"	m	class:itpp::TCP_Segment	access:protected
seq_end	/usr/include/itpp/protocol/tcp.h	/^  Sequence_Number  seq_end;   \/**< \\brief no. of last byte of segment + 1 *\/$/;"	m	class:itpp::TCP_Segment	access:protected
seq_no	/usr/include/itpp/protocol/packet.h	/^  int seq_no;$/;"	m	class:itpp::ACK	access:public
seq_no	/usr/include/itpp/protocol/packet.h	/^  int seq_no;$/;"	m	class:itpp::Link_Packet	access:public
seq_no	/usr/include/itpp/protocol/selective_repeat.h	/^  int seq_no;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
seq_no_max	/usr/include/itpp/protocol/selective_repeat.h	/^  int seq_no_max;$/;"	m	class:itpp::Selective_Repeat_ARQ_Receiver	access:private
seq_no_max	/usr/include/itpp/protocol/selective_repeat.h	/^  int seq_no_max;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
seq_no_size	/usr/include/itpp/protocol/selective_repeat.h	/^  int seq_no_size;$/;"	m	class:itpp::Selective_Repeat_ARQ_Receiver	access:private
seq_no_size	/usr/include/itpp/protocol/selective_repeat.h	/^  int seq_no_size;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
seq_num_index	/usr/include/itpp/protocol/tcp_client_server.h	/^  int seq_num_index;$/;"	m	class:itpp::TCP_Client_Application	access:private
seq_num_time	/usr/include/itpp/protocol/tcp_client_server.h	/^  vec seq_num_time;$/;"	m	class:itpp::TCP_Client_Application	access:private
seq_num_val	/usr/include/itpp/protocol/tcp_client_server.h	/^  vec seq_num_val;$/;"	m	class:itpp::TCP_Client_Application	access:private
sequence_number_2_buffer_index	/usr/include/itpp/protocol/selective_repeat.h	/^  int sequence_number_2_buffer_index(const int Sequence_number);$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:private	signature:(const int Sequence_number)
set	/usr/include/itpp/base/gf2mat.h	/^  inline void set(int i, int j, bin s);$/;"	p	class:itpp::GF2mat	access:public	signature:(int i, int j, bin s)
set	/usr/include/itpp/base/gf2mat.h	/^inline void GF2mat::set(int i, int j, bin s)$/;"	f	class:itpp::GF2mat	signature:(int i, int j, bin s)
set	/usr/include/itpp/base/mat.h	/^  void set(const char *str);$/;"	p	class:itpp::Mat	access:public	signature:(const char *str)
set	/usr/include/itpp/base/mat.h	/^  void set(const std::string &str);$/;"	p	class:itpp::Mat	access:public	signature:(const std::string &str)
set	/usr/include/itpp/base/mat.h	/^  void set(int r, int c, Num_T t);$/;"	p	class:itpp::Mat	access:public	signature:(int r, int c, Num_T t)
set	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::set(const char *str)$/;"	f	class:itpp::Mat	signature:(const char *str)
set	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::set(const std::string &str)$/;"	f	class:itpp::Mat	signature:(const std::string &str)
set	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::set(int r, int c, Num_T t)$/;"	f	class:itpp::Mat	signature:(int r, int c, Num_T t)
set	/usr/include/itpp/base/smat.h	/^  void set(int r, int c, T v);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(int r, int c, T v)
set	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::set(int r, int c, T v)$/;"	f	class:itpp::Sparse_Mat	signature:(int r, int c, T v)
set	/usr/include/itpp/base/svec.h	/^  void set(const ivec &index_vec, const Vec<T> &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const ivec &index_vec, const Vec<T> &v)
set	/usr/include/itpp/base/svec.h	/^  void set(int i, T v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(int i, T v)
set	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::set(const ivec& index_vec, const Vec<T>& v)$/;"	f	class:itpp::Sparse_Vec	signature:(const ivec& index_vec, const Vec<T>& v)
set	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::set(int i, T v)$/;"	f	class:itpp::Sparse_Vec	signature:(int i, T v)
set	/usr/include/itpp/base/vec.h	/^  void set(const char *str);$/;"	p	class:itpp::Vec	access:public	signature:(const char *str)
set	/usr/include/itpp/base/vec.h	/^  void set(const std::string &str);$/;"	p	class:itpp::Vec	access:public	signature:(const std::string &str)
set	/usr/include/itpp/base/vec.h	/^  void set(int i, Num_T t);$/;"	p	class:itpp::Vec	access:public	signature:(int i, Num_T t)
set	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::set(const char *str)$/;"	f	class:itpp::Vec	signature:(const char *str)
set	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::set(const std::string &str)$/;"	f	class:itpp::Vec	signature:(const std::string &str)
set	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::set(int i, Num_T t)$/;"	f	class:itpp::Vec	signature:(int i, Num_T t)
set	/usr/include/itpp/base/vec.h	/^void Vec<bin>::set(const std::string &str);$/;"	p	class:itpp::Vec	signature:(const std::string &str)
set	/usr/include/itpp/base/vec.h	/^void Vec<double>::set(const std::string &str);$/;"	p	class:itpp::Vec	signature:(const std::string &str)
set	/usr/include/itpp/base/vec.h	/^void Vec<int>::set(const std::string &str);$/;"	p	class:itpp::Vec	signature:(const std::string &str)
set	/usr/include/itpp/base/vec.h	/^void Vec<short int>::set(const std::string &str);$/;"	p	class:itpp::Vec	signature:(const std::string &str)
set	/usr/include/itpp/base/vec.h	/^void Vec<std::complex<double> >::set(const std::string &str);$/;"	p	class:itpp::Vec	signature:(const std::string &str)
set	/usr/include/itpp/comm/galois.h	/^  void set(int qvalue, const bvec &vectorspace);$/;"	p	class:itpp::GF	access:public	signature:(int qvalue, const bvec &vectorspace)
set	/usr/include/itpp/comm/galois.h	/^  void set(int qvalue, const char *invalues);$/;"	p	class:itpp::GFX	access:public	signature:(int qvalue, const char *invalues)
set	/usr/include/itpp/comm/galois.h	/^  void set(int qvalue, const ivec &invalues);$/;"	p	class:itpp::GFX	access:public	signature:(int qvalue, const ivec &invalues)
set	/usr/include/itpp/comm/galois.h	/^  void set(int qvalue, const std::string invalues);$/;"	p	class:itpp::GFX	access:public	signature:(int qvalue, const std::string invalues)
set	/usr/include/itpp/comm/galois.h	/^  void set(int qvalue, int inexp) {$/;"	f	class:itpp::GF	access:public	signature:(int qvalue, int inexp)
set	/usr/include/itpp/comm/galois.h	/^inline void GF::set(int qvalue, const bvec &vectorspace)$/;"	f	class:itpp::GF	signature:(int qvalue, const bvec &vectorspace)
set	/usr/include/itpp/comm/galois.h	/^inline void GFX::set(int qvalue, const char *invalues)$/;"	f	class:itpp::GFX	signature:(int qvalue, const char *invalues)
set	/usr/include/itpp/comm/galois.h	/^inline void GFX::set(int qvalue, const ivec &invalues)$/;"	f	class:itpp::GFX	signature:(int qvalue, const ivec &invalues)
set	/usr/include/itpp/comm/galois.h	/^inline void GFX::set(int qvalue, const std::string invalues)$/;"	f	class:itpp::GFX	signature:(int qvalue, const std::string invalues)
set	/usr/include/itpp/comm/ldpc.h	/^  void set(int i, int j, bin value);$/;"	p	class:itpp::LDPC_Parity	access:public	signature:(int i, int j, bin value)
set	/usr/include/itpp/comm/modulator.h	/^  virtual void set(const Vec<T>& symbols, const ivec& bits2symbols);$/;"	p	class:itpp::Modulator	access:public	signature:(const Vec<T>& symbols, const ivec& bits2symbols)
set	/usr/include/itpp/comm/modulator.h	/^void Modulator<T>::set(const Vec<T> &in_symbols, const ivec &in_bits2symbols)$/;"	f	class:itpp::Modulator	signature:(const Vec<T> &in_symbols, const ivec &in_bits2symbols)
set	/usr/include/itpp/fixed/cfix.h	/^  void set(const std::complex<double> &x, int n);$/;"	p	class:itpp::CFix	access:public	signature:(const std::complex<double> &x, int n)
set	/usr/include/itpp/fixed/cfix.h	/^  void set(const std::complex<double> &x, int n, q_mode q);$/;"	p	class:itpp::CFix	access:public	signature:(const std::complex<double> &x, int n, q_mode q)
set	/usr/include/itpp/fixed/cfix.h	/^  void set(double real, double imag, int n);$/;"	p	class:itpp::CFix	access:public	signature:(double real, double imag, int n)
set	/usr/include/itpp/fixed/cfix.h	/^  void set(double real, double imag, int n, q_mode q);$/;"	p	class:itpp::CFix	access:public	signature:(double real, double imag, int n, q_mode q)
set	/usr/include/itpp/fixed/cfix.h	/^template<> void cfixmat::set(const char *values);$/;"	p	class:itpp::cfixmat	signature:(const char *values)
set	/usr/include/itpp/fixed/cfix.h	/^template<> void cfixvec::set(const char *values);$/;"	p	class:itpp::cfixvec	signature:(const char *values)
set	/usr/include/itpp/fixed/fix.h	/^  void set(double x, int n);$/;"	p	class:itpp::Fix	access:public	signature:(double x, int n)
set	/usr/include/itpp/fixed/fix.h	/^  void set(double x, int n, q_mode q);$/;"	p	class:itpp::Fix	access:public	signature:(double x, int n, q_mode q)
set	/usr/include/itpp/fixed/fix.h	/^template<> void fixmat::set(const char *values);$/;"	p	class:itpp::fixmat	signature:(const char *values)
set	/usr/include/itpp/fixed/fix.h	/^template<> void fixvec::set(const char *values);$/;"	p	class:itpp::fixvec	signature:(const char *values)
set	/usr/include/itpp/protocol/signals_slots.h	/^  void set(DataType u, const Ttype delta_t) {$/;"	f	class:itpp::ATimer	access:public	signature:(DataType u, const Ttype delta_t)
set_ACK	/usr/include/itpp/protocol/tcp.h	/^  void set_ACK(Sequence_Number val) { fACK = val; }$/;"	f	class:itpp::TCP_Packet	access:public	signature:(Sequence_Number val)
set_LOS	/usr/include/itpp/comm/channel.h	/^  void set_LOS(const vec& relative_power, const vec& relative_doppler = "");$/;"	p	class:itpp::Channel_Specification	access:public	signature:(const vec& relative_power, const vec& relative_doppler = Ó)
set_LOS	/usr/include/itpp/comm/channel.h	/^  void set_LOS(const vec& relative_power, const vec& relative_doppler = "");$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const vec& relative_power, const vec& relative_doppler = Ó)
set_LOS	/usr/include/itpp/comm/channel.h	/^  void set_LOS(int tap_number, double relative_power, double relative_doppler = 0.7);$/;"	p	class:itpp::Channel_Specification	access:public	signature:(int tap_number, double relative_power, double relative_doppler = 0.7)
set_LOS_doppler	/usr/include/itpp/comm/channel.h	/^  virtual void set_LOS_doppler(double relative_doppler);$/;"	p	class:itpp::Correlated_Fading_Generator	access:public	signature:(double relative_doppler)
set_LOS_doppler	/usr/include/itpp/comm/channel.h	/^  virtual void set_LOS_doppler(double relative_doppler);$/;"	p	class:itpp::Fading_Generator	access:public	signature:(double relative_doppler)
set_LOS_doppler	/usr/include/itpp/comm/channel.h	/^  void set_LOS_doppler(const vec& relative_doppler);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const vec& relative_doppler)
set_LOS_power	/usr/include/itpp/comm/channel.h	/^  void set_LOS_power(const vec& relative_power);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const vec& relative_power)
set_LOS_power	/usr/include/itpp/comm/channel.h	/^  void set_LOS_power(double relative_power);$/;"	p	class:itpp::Fading_Generator	access:public	signature:(double relative_power)
set_M	/usr/include/itpp/comm/modulator.h	/^  void set_M(int M);$/;"	p	class:itpp::PAM	access:public	signature:(int M)
set_M	/usr/include/itpp/comm/modulator.h	/^  void set_M(int M);$/;"	p	class:itpp::PAM_c	access:public	signature:(int M)
set_M	/usr/include/itpp/comm/modulator.h	/^  void set_M(int M);$/;"	p	class:itpp::PSK	access:public	signature:(int M)
set_M	/usr/include/itpp/comm/modulator.h	/^  void set_M(int M);$/;"	p	class:itpp::QAM	access:public	signature:(int M)
set_M	/usr/include/itpp/comm/modulator_nd.h	/^  void set_M(int nt = 1, int Mary = 2);$/;"	p	class:itpp::ND_UPAM	access:public	signature:(int nt = 1, int Mary = 2)
set_M	/usr/include/itpp/comm/modulator_nd.h	/^  void set_M(int nt = 1, int Mary = 4);$/;"	p	class:itpp::ND_UPSK	access:public	signature:(int nt = 1, int Mary = 4)
set_M	/usr/include/itpp/comm/modulator_nd.h	/^  void set_M(int nt = 1, int Mary = 4);$/;"	p	class:itpp::ND_UQAM	access:public	signature:(int nt = 1, int Mary = 4)
set_M	/usr/include/itpp/comm/modulator_nd.h	/^  void set_M(int nt = 1, ivec Mary = "2");$/;"	p	class:itpp::ND_UPAM	access:public	signature:(int nt = 1, ivec Mary = Ó)
set_M	/usr/include/itpp/comm/modulator_nd.h	/^  void set_M(int nt = 1, ivec Mary = "4");$/;"	p	class:itpp::ND_UPSK	access:public	signature:(int nt = 1, ivec Mary = Ó)
set_M	/usr/include/itpp/comm/modulator_nd.h	/^  void set_M(int nt = 1, ivec Mary = "4");$/;"	p	class:itpp::ND_UQAM	access:public	signature:(int nt = 1, ivec Mary = Ó)
set_a1	/usr/include/itpp/signal/fastica.h	/^  void set_a1(double fl_a1);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(double fl_a1)
set_a2	/usr/include/itpp/signal/fastica.h	/^  void set_a2(double fl_a2);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(double fl_a2)
set_adaptive_stop	/usr/include/itpp/comm/turbo.h	/^  void set_adaptive_stop(bool in_adaptive_stop = true);$/;"	p	class:itpp::Turbo_Codec	access:public	signature:(bool in_adaptive_stop = true)
set_approach	/usr/include/itpp/signal/fastica.h	/^  void set_approach(int in_approach);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(int in_approach)
set_array	/usr/include/itpp/base/array.h	/^void set_array(Array<T> &a, const char *values)$/;"	f	namespace:itpp	signature:(Array<T> &a, const char *values)
set_array	/usr/include/itpp/base/array.h	/^void set_array(Array<T> &a, const std::string &str)$/;"	f	namespace:itpp	signature:(Array<T> &a, const std::string &str)
set_awgn_channel_parameters	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  void set_awgn_channel_parameters(double Ec, double N0);$/;"	p	class:itpp::Rec_Syst_Conv_Code	access:public	signature:(double Ec, double N0)
set_awgn_channel_parameters	/usr/include/itpp/comm/turbo.h	/^  void set_awgn_channel_parameters(double in_Ec, double in_N0);$/;"	p	class:itpp::Turbo_Codec	access:public	signature:(double in_Ec, double in_N0)
set_begin	/usr/include/itpp/protocol/tcp.h	/^  void set_begin(const Sequence_Number &sn);$/;"	p	class:itpp::TCP_Segment	access:public	signature:(const Sequence_Number &sn)
set_begin	/usr/include/itpp/protocol/tcp.h	/^inline void TCP_Segment::set_begin(const Sequence_Number &sn)$/;"	f	class:itpp::TCP_Segment	signature:(const Sequence_Number &sn)
set_bit_size	/usr/include/itpp/protocol/packet.h	/^  void set_bit_size(int packet_size) { it_assert(packet_size >= 0, "Packet size must be positive"); size_bits = packet_size; }$/;"	f	class:itpp::Packet	access:public	signature:(int packet_size)
set_blocksize	/usr/include/itpp/comm/error_counters.h	/^  void set_blocksize(int inblocksize, bool clear = true);$/;"	p	class:itpp::BLERC	access:public	signature:(int inblocksize, bool clear = true)
set_channel_profile	/usr/include/itpp/comm/channel.h	/^  void set_channel_profile(const CHANNEL_PROFILE profile);$/;"	p	class:itpp::Channel_Specification	access:public	signature:(const CHANNEL_PROFILE profile)
set_channel_profile	/usr/include/itpp/comm/channel.h	/^  void set_channel_profile(const Channel_Specification &channel_spec, double sampling_time);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const Channel_Specification &channel_spec, double sampling_time)
set_channel_profile	/usr/include/itpp/comm/channel.h	/^  void set_channel_profile(const vec &avg_power_dB, const ivec &delay_prof);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const vec &avg_power_dB, const ivec &delay_prof)
set_channel_profile	/usr/include/itpp/comm/channel.h	/^  void set_channel_profile(const vec &avg_power_dB, const vec &delay_prof);$/;"	p	class:itpp::Channel_Specification	access:public	signature:(const vec &avg_power_dB, const vec &delay_prof)
set_channel_profile_exponential	/usr/include/itpp/comm/channel.h	/^  void set_channel_profile_exponential(int no_taps);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(int no_taps)
set_channel_profile_uniform	/usr/include/itpp/comm/channel.h	/^  void set_channel_profile_uniform(int no_taps);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(int no_taps)
set_checks	/usr/include/itpp/stat/mog_generic.h	/^  void set_checks(bool do_checks_in) { do_checks = do_checks_in; }$/;"	f	class:itpp::MOG_generic	access:public	signature:(bool do_checks_in)
set_code	/usr/include/itpp/comm/convcode.h	/^  void set_code(const CONVOLUTIONAL_CODE_TYPE type_of_code, int inverse_rate,$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const CONVOLUTIONAL_CODE_TYPE type_of_code, int inverse_rate, int constraint_length)
set_code	/usr/include/itpp/comm/crc.h	/^  void set_code(const std::string &code);$/;"	p	class:itpp::CRC_Code	access:public	signature:(const std::string &code)
set_code	/usr/include/itpp/comm/ldpc.h	/^  void set_code(const LDPC_Parity* const H, LDPC_Generator* const G = 0);$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const LDPC_Parity* const H, LDPC_Generator* const G = 0)
set_code	/usr/include/itpp/comm/punct_convcode.h	/^  void set_code(const CONVOLUTIONAL_CODE_TYPE type_of_code, int inverse_rate, int constraint_length)$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const CONVOLUTIONAL_CODE_TYPE type_of_code, int inverse_rate, int constraint_length)
set_code	/usr/include/itpp/comm/spread.h	/^  void set_code(const vec &incode);$/;"	p	class:itpp::Spread_1d	access:public	signature:(const vec &incode)
set_code	/usr/include/itpp/comm/spread.h	/^  void set_code(const vec &incodeI, const vec &incodeQ);$/;"	p	class:itpp::Spread_2d	access:public	signature:(const vec &incodeI, const vec &incodeQ)
set_codebook	/usr/include/itpp/srccode/vq.h	/^  void set_codebook(const mat &CB);$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:(const mat &CB)
set_codes	/usr/include/itpp/comm/spread.h	/^  void set_codes(const mat &incodes);$/;"	p	class:itpp::Multicode_Spread_1d	access:public	signature:(const mat &incodes)
set_codes	/usr/include/itpp/comm/spread.h	/^  void set_codes(const mat &incodesI, const mat &incodesQ);$/;"	p	class:itpp::Multicode_Spread_2d	access:public	signature:(const mat &incodesI, const mat &incodesQ)
set_codevector	/usr/include/itpp/srccode/vq.h	/^  void set_codevector(int Index, const vec &indata);$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:(int Index, const vec &indata)
set_coeffs	/usr/include/itpp/signal/filter.h	/^  void set_coeffs(const Vec<T2> &a);$/;"	p	class:itpp::AR_Filter	access:public	signature:(const Vec<T2> &a)
set_coeffs	/usr/include/itpp/signal/filter.h	/^  void set_coeffs(const Vec<T2> &b);$/;"	p	class:itpp::MA_Filter	access:public	signature:(const Vec<T2> &b)
set_coeffs	/usr/include/itpp/signal/filter.h	/^  void set_coeffs(const Vec<T2> &b, const Vec<T2> &a);$/;"	p	class:itpp::ARMA_Filter	access:public	signature:(const Vec<T2> &b, const Vec<T2> &a)
set_coeffs	/usr/include/itpp/signal/filter.h	/^void ARMA_Filter<T1, T2, T3>::set_coeffs(const Vec<T2> &b, const Vec<T2> &a)$/;"	f	class:itpp::ARMA_Filter	signature:(const Vec<T2> &b, const Vec<T2> &a)
set_coeffs	/usr/include/itpp/signal/filter.h	/^void AR_Filter<T1, T2, T3>::set_coeffs(const Vec<T2> &a)$/;"	f	class:itpp::AR_Filter	signature:(const Vec<T2> &a)
set_coeffs	/usr/include/itpp/signal/filter.h	/^void MA_Filter<T1, T2, T3>::set_coeffs(const Vec<T2> &b)$/;"	f	class:itpp::MA_Filter	signature:(const Vec<T2> &b)
set_col	/usr/include/itpp/base/gf2mat.h	/^  void set_col(int j, bvec x);$/;"	p	class:itpp::GF2mat	access:public	signature:(int j, bvec x)
set_col	/usr/include/itpp/base/mat.h	/^  void set_col(int c, const Vec<Num_T> &v);$/;"	p	class:itpp::Mat	access:public	signature:(int c, const Vec<Num_T> &v)
set_col	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::set_col(int c, const Vec<Num_T> &v)$/;"	f	class:itpp::Mat	signature:(int c, const Vec<Num_T> &v)
set_col	/usr/include/itpp/base/smat.h	/^  void set_col(int c, const Sparse_Vec<T> &v);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(int c, const Sparse_Vec<T> &v)
set_col	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::set_col(int c, const Sparse_Vec<T> &v)$/;"	f	class:itpp::Sparse_Mat	signature:(int c, const Sparse_Vec<T> &v)
set_cols	/usr/include/itpp/base/mat.h	/^  void set_cols(int c, const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:public	signature:(int c, const Mat<Num_T> &m)
set_cols	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::set_cols(int c, const Mat<Num_T> &m)$/;"	f	class:itpp::Mat	signature:(int c, const Mat<Num_T> &m)
set_cols	/usr/include/itpp/comm/interleave.h	/^  void set_cols(int in_cols) {cols = in_cols;};$/;"	f	class:itpp::Block_Interleaver	access:public	signature:(int in_cols)
set_connections	/usr/include/itpp/comm/sequence.h	/^  void set_connections(const bvec &connections);$/;"	p	class:itpp::LFSR	access:public	signature:(const bvec &connections)
set_connections	/usr/include/itpp/comm/sequence.h	/^  void set_connections(const ivec &connections);$/;"	p	class:itpp::LFSR	access:public	signature:(const ivec &connections)
set_correlated_method	/usr/include/itpp/comm/channel.h	/^  void set_correlated_method(CORRELATED_METHOD method);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(CORRELATED_METHOD method)
set_covariance	/usr/include/itpp/srccode/gmm.h	/^  void set_covariance(const mat &sigma_in);$/;"	p	class:itpp::GMM	access:public	signature:(const mat &sigma_in)
set_covariance	/usr/include/itpp/srccode/gmm.h	/^  void set_covariance(const vec &covariances, bool compflag = true);$/;"	p	class:itpp::GMM	access:public	signature:(const vec &covariances, bool compflag = true)
set_covariance	/usr/include/itpp/srccode/gmm.h	/^  void set_covariance(int i, const vec &covariances, bool compflag = true);$/;"	p	class:itpp::GMM	access:public	signature:(int i, const vec &covariances, bool compflag = true)
set_covariance	/usr/include/itpp/srccode/gmm.h	/^inline void GMM::set_covariance(const vec &covariances, bool compflag) {sigma = covariances; if (compflag) compute_internals(); }$/;"	f	class:itpp::GMM	signature:(const vec &covariances, bool compflag)
set_debug	/usr/include/itpp/protocol/front_drop_queue.h	/^  void set_debug(const bool enable_debug = true) {$/;"	f	class:itpp::Front_Drop_Queue	access:public	signature:(const bool enable_debug = true)
set_debug	/usr/include/itpp/protocol/signals_slots.h	/^  void set_debug(const bool enable_debug = true);$/;"	p	class:itpp::Signal	access:public	signature:(const bool enable_debug = true)
set_debug	/usr/include/itpp/protocol/signals_slots.h	/^void Signal<DataType>::set_debug(const bool enable_debug)$/;"	f	class:itpp::Signal	signature:(const bool enable_debug)
set_debug	/usr/include/itpp/protocol/tcp.h	/^  virtual void set_debug(bool enable_debug, bool enable_signal_debug);$/;"	p	class:itpp::TCP_Receiver	access:public	signature:(bool enable_debug, bool enable_signal_debug)
set_debug	/usr/include/itpp/protocol/tcp.h	/^  virtual void set_debug(bool enable_debug, bool enable_signal_debug);$/;"	p	class:itpp::TCP_Sender	access:public	signature:(bool enable_debug, bool enable_signal_debug)
set_debug	/usr/include/itpp/protocol/tcp.h	/^  virtual void set_debug(const bool enable_debug = true);$/;"	p	class:itpp::TCP_Receiver	access:public	signature:(const bool enable_debug = true)
set_debug	/usr/include/itpp/protocol/tcp.h	/^  virtual void set_debug(const bool enable_debug = true);$/;"	p	class:itpp::TCP_Sender	access:public	signature:(const bool enable_debug = true)
set_decoding_method	/usr/include/itpp/comm/ldpc.h	/^  void set_decoding_method(const std::string& method);$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const std::string& method)
set_degree	/usr/include/itpp/comm/galois.h	/^  void set_degree(int indegree);$/;"	p	class:itpp::GFX	access:public	signature:(int indegree)
set_degree	/usr/include/itpp/comm/galois.h	/^inline void GFX::set_degree(int indegree)$/;"	f	class:itpp::GFX	signature:(int indegree)
set_destination_port	/usr/include/itpp/protocol/tcp.h	/^  void set_destination_port(unsigned val) { fDestinationPort = val; }$/;"	f	class:itpp::TCP_Packet	access:public	signature:(unsigned val)
set_diag_covs	/usr/include/itpp/stat/mog_generic.h	/^  void set_diag_covs(Array<vec> &diag_covs_in);$/;"	p	class:itpp::MOG_generic	access:public	signature:(Array<vec> &diag_covs_in)
set_diag_covs_internal	/usr/include/itpp/stat/mog_generic.h	/^  void set_diag_covs_internal(Array<vec> &diag_covs_in);$/;"	p	class:itpp::MOG_generic	access:protected	signature:(Array<vec> &diag_covs_in)
set_diag_covs_unity	/usr/include/itpp/stat/mog_generic.h	/^  void set_diag_covs_unity();$/;"	p	class:itpp::MOG_generic	access:public	signature:()
set_diag_covs_unity_internal	/usr/include/itpp/stat/mog_generic.h	/^  void set_diag_covs_unity_internal();$/;"	p	class:itpp::MOG_generic	access:protected	signature:()
set_doppler_spectrum	/usr/include/itpp/comm/channel.h	/^  virtual void set_doppler_spectrum(DOPPLER_SPECTRUM spectrum);$/;"	p	class:itpp::Fading_Generator	access:public	signature:(DOPPLER_SPECTRUM spectrum)
set_doppler_spectrum	/usr/include/itpp/comm/channel.h	/^  virtual void set_doppler_spectrum(DOPPLER_SPECTRUM spectrum);$/;"	p	class:itpp::Rice_Fading_Generator	access:public	signature:(DOPPLER_SPECTRUM spectrum)
set_doppler_spectrum	/usr/include/itpp/comm/channel.h	/^  void set_doppler_spectrum(DOPPLER_SPECTRUM *tap_spectrum);$/;"	p	class:itpp::Channel_Specification	access:public	signature:(DOPPLER_SPECTRUM *tap_spectrum)
set_doppler_spectrum	/usr/include/itpp/comm/channel.h	/^  void set_doppler_spectrum(const DOPPLER_SPECTRUM *tap_spectrum);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(const DOPPLER_SPECTRUM *tap_spectrum)
set_doppler_spectrum	/usr/include/itpp/comm/channel.h	/^  void set_doppler_spectrum(int tap_number, DOPPLER_SPECTRUM tap_spectrum);$/;"	p	class:itpp::Channel_Specification	access:public	signature:(int tap_number, DOPPLER_SPECTRUM tap_spectrum)
set_doppler_spectrum	/usr/include/itpp/comm/channel.h	/^  void set_doppler_spectrum(int tap_number, DOPPLER_SPECTRUM tap_spectrum);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(int tap_number, DOPPLER_SPECTRUM tap_spectrum)
set_end	/usr/include/itpp/protocol/tcp.h	/^  void set_end(const Sequence_Number &sn);$/;"	p	class:itpp::TCP_Segment	access:public	signature:(const Sequence_Number &sn)
set_end	/usr/include/itpp/protocol/tcp.h	/^inline void TCP_Segment::set_end(const Sequence_Number &sn)$/;"	f	class:itpp::TCP_Segment	signature:(const Sequence_Number &sn)
set_endianity	/usr/include/itpp/base/binfile.h	/^  void set_endianity(endian e) {$/;"	f	class:itpp::bfstream_base	access:public	signature:(endian e)
set_epsilon	/usr/include/itpp/signal/fastica.h	/^  void set_epsilon(double fl_epsilon);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(double fl_epsilon)
set_errors	/usr/include/itpp/protocol/packet_channel.h	/^  void set_errors(const ivec &Lost);$/;"	p	class:itpp::Packet_Channel	access:public	signature:(const ivec &Lost)
set_errors	/usr/include/itpp/protocol/packet_channel.h	/^  void set_errors(const ivec& Lost);$/;"	p	class:itpp::ACK_Channel	access:public	signature:(const ivec& Lost)
set_exit_conditions	/usr/include/itpp/comm/ldpc.h	/^  void set_exit_conditions(int max_iters,$/;"	p	class:itpp::LDPC_Code	access:public	signature:(int max_iters, bool syndr_check_each_iter = true, bool syndr_check_at_start = false)
set_exp_factor	/usr/include/itpp/comm/ldpc.h	/^  void set_exp_factor(int exp_factor);$/;"	p	class:itpp::BLDPC_Parity	access:public	signature:(int exp_factor)
set_fading_type	/usr/include/itpp/comm/channel.h	/^  void set_fading_type(FADING_TYPE fading_type);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(FADING_TYPE fading_type)
set_filter_length	/usr/include/itpp/comm/channel.h	/^  virtual void set_filter_length(int filter_length);$/;"	p	class:itpp::FIR_Fading_Generator	access:public	signature:(int filter_length)
set_filter_length	/usr/include/itpp/comm/channel.h	/^  virtual void set_filter_length(int filter_length);$/;"	p	class:itpp::Fading_Generator	access:public	signature:(int filter_length)
set_filter_length	/usr/include/itpp/comm/channel.h	/^  void set_filter_length(int filter_length);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(int filter_length)
set_fine_tune	/usr/include/itpp/signal/fastica.h	/^  void set_fine_tune(bool in_finetune);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(bool in_finetune)
set_first_eig	/usr/include/itpp/signal/fastica.h	/^  void set_first_eig(int in_firstEig);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(int in_firstEig)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(CFix &y, double real, double imag, int n) {y.set(real, imag, n);}$/;"	f	namespace:itpp	signature:(CFix &y, double real, double imag, int n)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(CFix &y, double real, double imag, int n, q_mode q) {y.set(real, imag, n, q);}$/;"	f	namespace:itpp	signature:(CFix &y, double real, double imag, int n, q_mode q)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(CFix &y, std::complex<double> x, int n) {y.set(x, n);}$/;"	f	namespace:itpp	signature:(CFix &y, std::complex<double> x, int n)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(CFix &y, std::complex<double> x, int n, q_mode q) {y.set(x, n, q);}$/;"	f	namespace:itpp	signature:(CFix &y, std::complex<double> x, int n, q_mode q)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(Fix &y, double x, int n) {y.set(x, n);}$/;"	f	namespace:itpp	signature:(Fix &y, double x, int n)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(Fix &y, double x, int n, q_mode q) {y.set(x, n, q);}$/;"	f	namespace:itpp	signature:(Fix &y, double x, int n, q_mode q)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cfixmat &y, const cmat &x, int n)$/;"	f	namespace:itpp	signature:(cfixmat &y, const cmat &x, int n)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cfixmat &y, const cmat &x, int n, q_mode q)$/;"	f	namespace:itpp	signature:(cfixmat &y, const cmat &x, int n, q_mode q)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cfixmat &y, const mat &real, const mat &imag, int n)$/;"	f	namespace:itpp	signature:(cfixmat &y, const mat &real, const mat &imag, int n)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cfixmat &y, const mat &real, const mat &imag, int n, q_mode q)$/;"	f	namespace:itpp	signature:(cfixmat &y, const mat &real, const mat &imag, int n, q_mode q)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cfixvec &y, const cvec &x, int n)$/;"	f	namespace:itpp	signature:(cfixvec &y, const cvec &x, int n)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cfixvec &y, const cvec &x, int n, q_mode q)$/;"	f	namespace:itpp	signature:(cfixvec &y, const cvec &x, int n, q_mode q)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cfixvec &y, const vec &real, const vec &imag, int n)$/;"	f	namespace:itpp	signature:(cfixvec &y, const vec &real, const vec &imag, int n)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cfixvec &y, const vec &real, const vec &imag, int n, q_mode q)$/;"	f	namespace:itpp	signature:(cfixvec &y, const vec &real, const vec &imag, int n, q_mode q)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cmat &y, const cmat &x, int) {y = x;}$/;"	f	namespace:itpp	signature:(cmat &y, const cmat &x, int)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cmat &y, const cmat &x, int, q_mode) {y = x;}$/;"	f	namespace:itpp	signature:(cmat &y, const cmat &x, int, q_mode)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cmat &y, const mat &real, const mat &imag, int) {y = to_cmat(real, imag);}$/;"	f	namespace:itpp	signature:(cmat &y, const mat &real, const mat &imag, int)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cmat &y, const mat &real, const mat &imag, int, q_mode) {y = to_cmat(real, imag);}$/;"	f	namespace:itpp	signature:(cmat &y, const mat &real, const mat &imag, int, q_mode)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cvec &y, const cvec &x, int) {y = x;}$/;"	f	namespace:itpp	signature:(cvec &y, const cvec &x, int)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cvec &y, const cvec &x, int, q_mode) {y = x;}$/;"	f	namespace:itpp	signature:(cvec &y, const cvec &x, int, q_mode)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cvec &y, const vec &real, const vec &imag, int) {y = to_cvec(real, imag);}$/;"	f	namespace:itpp	signature:(cvec &y, const vec &real, const vec &imag, int)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(cvec &y, const vec &real, const vec &imag, int, q_mode) {y = to_cvec(real, imag);}$/;"	f	namespace:itpp	signature:(cvec &y, const vec &real, const vec &imag, int, q_mode)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(double &y, double x, int) {y = x;}$/;"	f	namespace:itpp	signature:(double &y, double x, int)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(double &y, double x, int, q_mode) {y = x;}$/;"	f	namespace:itpp	signature:(double &y, double x, int, q_mode)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(fixmat &y, const mat &x, int n)$/;"	f	namespace:itpp	signature:(fixmat &y, const mat &x, int n)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(fixmat &y, const mat &x, int n, q_mode q)$/;"	f	namespace:itpp	signature:(fixmat &y, const mat &x, int n, q_mode q)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(fixvec &y, const vec &x, int n)$/;"	f	namespace:itpp	signature:(fixvec &y, const vec &x, int n)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(fixvec &y, const vec &x, int n, q_mode q)$/;"	f	namespace:itpp	signature:(fixvec &y, const vec &x, int n, q_mode q)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(mat &y, const mat &x, int) {y = x;}$/;"	f	namespace:itpp	signature:(mat &y, const mat &x, int)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(mat &y, const mat &x, int, q_mode) {y = x;}$/;"	f	namespace:itpp	signature:(mat &y, const mat &x, int, q_mode)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(std::complex<double> &y, const std::complex<double> &x, int) {y = x;}$/;"	f	namespace:itpp	signature:(std::complex<double> &y, const std::complex<double> &x, int)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(std::complex<double> &y, const std::complex<double> &x, int, q_mode) {y = x;}$/;"	f	namespace:itpp	signature:(std::complex<double> &y, const std::complex<double> &x, int, q_mode)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(std::complex<double> &y, double real, double imag, int) {y = std::complex<double>(real, imag);}$/;"	f	namespace:itpp	signature:(std::complex<double> &y, double real, double imag, int)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(std::complex<double> &y, double real, double imag, int, q_mode) {y = std::complex<double>(real, imag);}$/;"	f	namespace:itpp	signature:(std::complex<double> &y, double real, double imag, int, q_mode)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(vec &y, const vec &x, int) {y = x;}$/;"	f	namespace:itpp	signature:(vec &y, const vec &x, int)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^inline void set_fix(vec &y, const vec &x, int, q_mode) {y = x;}$/;"	f	namespace:itpp	signature:(vec &y, const vec &x, int, q_mode)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<class T1, class T2> inline void set_fix(Array<T1> &y, const Array<T2> &real, const Array<T2> &imag, int n)$/;"	f	namespace:itpp	signature:(Array<T1> &y, const Array<T2> &real, const Array<T2> &imag, int n)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<class T1, class T2> inline void set_fix(Array<T1> &y, const Array<T2> &real, const Array<T2> &imag, int n, q_mode q)$/;"	f	namespace:itpp	signature:(Array<T1> &y, const Array<T2> &real, const Array<T2> &imag, int n, q_mode q)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<class T1, class T2> inline void set_fix(Array<T1> &y, const Array<T2> &x, int n)$/;"	f	namespace:itpp	signature:(Array<T1> &y, const Array<T2> &x, int n)
set_fix	/usr/include/itpp/fixed/fix_functions.h	/^template<class T1, class T2> inline void set_fix(Array<T1> &y, const Array<T2> &x, int n, q_mode q)$/;"	f	namespace:itpp	signature:(Array<T1> &y, const Array<T2> &x, int n, q_mode q)
set_full_covs	/usr/include/itpp/stat/mog_generic.h	/^  void set_full_covs(Array<mat> &full_covs_in);$/;"	p	class:itpp::MOG_generic	access:public	signature:(Array<mat> &full_covs_in)
set_full_covs_internal	/usr/include/itpp/stat/mog_generic.h	/^  void set_full_covs_internal(Array<mat> &full_covs_in);$/;"	p	class:itpp::MOG_generic	access:protected	signature:(Array<mat> &full_covs_in)
set_full_covs_unity	/usr/include/itpp/stat/mog_generic.h	/^  void set_full_covs_unity();$/;"	p	class:itpp::MOG_generic	access:public	signature:()
set_full_covs_unity_internal	/usr/include/itpp/stat/mog_generic.h	/^  void set_full_covs_unity_internal();$/;"	p	class:itpp::MOG_generic	access:protected	signature:()
set_function	/usr/include/itpp/optim/newton_search.h	/^  void set_function(double(*function)(const vec&));$/;"	p	class:itpp::Line_Search	access:public	signature:(double(*function)(const vec&))
set_function	/usr/include/itpp/optim/newton_search.h	/^  void set_function(double(*function)(const vec&));$/;"	p	class:itpp::Newton_Search	access:public	signature:(double(*function)(const vec&))
set_functions	/usr/include/itpp/optim/newton_search.h	/^  void set_functions(double(*function)(const vec&), vec(*gradient)(const vec&)) { set_function(function); set_gradient(gradient); }$/;"	f	class:itpp::Line_Search	access:public	signature:(double(*function)(const vec&), vec(*gradient)(const vec&))
set_functions	/usr/include/itpp/optim/newton_search.h	/^  void set_functions(double(*function)(const vec&), vec(*gradient)(const vec&)) { set_function(function); set_gradient(gradient); }$/;"	f	class:itpp::Newton_Search	access:public	signature:(double(*function)(const vec&), vec(*gradient)(const vec&))
set_generator	/usr/include/itpp/comm/crc.h	/^  void set_generator(const bvec &poly);$/;"	p	class:itpp::CRC_Code	access:public	signature:(const bvec &poly)
set_generator_polynomials	/usr/include/itpp/comm/convcode.h	/^  void set_generator_polynomials(const ivec &gen, int constraint_length);$/;"	p	class:itpp::Convolutional_Code	access:public	signature:(const ivec &gen, int constraint_length)
set_generator_polynomials	/usr/include/itpp/comm/punct_convcode.h	/^  void set_generator_polynomials(const ivec &gen, int constraint_length)$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const ivec &gen, int constraint_length)
set_generator_polynomials	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  void set_generator_polynomials(const ivec &gen, int constraint_length);$/;"	p	class:itpp::Rec_Syst_Conv_Code	access:public	signature:(const ivec &gen, int constraint_length)
set_gradient	/usr/include/itpp/optim/newton_search.h	/^  void set_gradient(vec(*gradient)(const vec&));$/;"	p	class:itpp::Line_Search	access:public	signature:(vec(gradient)const vec&))
set_gradient	/usr/include/itpp/optim/newton_search.h	/^  void set_gradient(vec(*gradient)(const vec&));$/;"	p	class:itpp::Newton_Search	access:public	signature:(vec(gradient)const vec&))
set_im	/usr/include/itpp/fixed/cfix.h	/^  void set_im(fixrep x) {im = apply_o_mode(x);}$/;"	f	class:itpp::CFix	access:public	signature:(fixrep x)
set_info	/usr/include/itpp/protocol/tcp.h	/^  void set_info(unsigned ssThresh, unsigned recWnd, unsigned cWnd, double estRTT, Sequence_Number sndUna, Sequence_Number sndNxt, bool isRtx);$/;"	p	class:itpp::TCP_Packet	access:public	signature:(unsigned ssThresh, unsigned recWnd, unsigned cWnd, double estRTT, Sequence_Number sndUna, Sequence_Number sndNxt, bool isRtx)
set_init_guess	/usr/include/itpp/signal/fastica.h	/^  void set_init_guess(mat ma_initGuess);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(mat ma_initGuess)
set_initial_stepsize	/usr/include/itpp/optim/newton_search.h	/^  void set_initial_stepsize(double value);$/;"	p	class:itpp::Newton_Search	access:public	signature:(double value)
set_interleaver	/usr/include/itpp/comm/turbo.h	/^  void set_interleaver(const ivec &interleaver_sequence);$/;"	p	class:itpp::Turbo_Codec	access:public	signature:(const ivec &interleaver_sequence)
set_interleaver_depth	/usr/include/itpp/comm/interleave.h	/^  void set_interleaver_depth(int in_interleaver_depth) { interleaver_depth = in_interleaver_depth; };$/;"	f	class:itpp::Sequence_Interleaver	access:public	signature:(int in_interleaver_depth)
set_interleaver_sequence	/usr/include/itpp/comm/interleave.h	/^  void set_interleaver_sequence(ivec in_interleaver_sequence);$/;"	p	class:itpp::Sequence_Interleaver	access:public	signature:(ivec in_interleaver_sequence)
set_interleaver_sequence	/usr/include/itpp/comm/interleave.h	/^void Sequence_Interleaver<T>::set_interleaver_sequence(ivec in_interleaver_sequence)$/;"	f	class:itpp::Sequence_Interleaver	signature:(ivec in_interleaver_sequence)
set_iterations	/usr/include/itpp/comm/turbo.h	/^  void set_iterations(int in_iterations = 8);$/;"	p	class:itpp::Turbo_Codec	access:public	signature:(int in_iterations = 8)
set_label	/usr/include/itpp/protocol/tcp.h	/^  virtual void set_label(int label);$/;"	p	class:itpp::TCP_Sender	access:private	signature:(int label)
set_last_eig	/usr/include/itpp/signal/fastica.h	/^  void set_last_eig(int in_lastEig);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(int in_lastEig)
set_length	/usr/include/itpp/base/array.h	/^  void set_length(int n, bool copy = false) { set_size(n, copy); }$/;"	f	class:itpp::Array	access:public	signature:(int n, bool copy = false)
set_length	/usr/include/itpp/base/vec.h	/^  void set_length(int size, bool copy = false) { set_size(size, copy); }$/;"	f	class:itpp::Vec	access:public	signature:(int size, bool copy = false)
set_levels	/usr/include/itpp/srccode/vq.h	/^  void set_levels(const vec &L);$/;"	p	class:itpp::Scalar_Quantizer	access:public	signature:(const vec &L)
set_levels	/usr/include/itpp/srccode/vq.h	/^inline void Scalar_Quantizer::set_levels(const vec &L) {Levels = L;sort(Levels); }$/;"	f	class:itpp::Scalar_Quantizer	signature:(const vec &L)
set_llrcalc	/usr/include/itpp/comm/ldpc.h	/^  void set_llrcalc(const LLR_calc_unit& llrcalc);$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const LLR_calc_unit& llrcalc)
set_llrcalc	/usr/include/itpp/comm/modulator_nd.h	/^  void set_llrcalc(LLR_calc_unit llrcalc_in) { llrcalc = llrcalc_in; };$/;"	f	class:itpp::Modulator_ND	access:public	signature:(LLR_calc_unit llrcalc_in)
set_llrcalc	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  void set_llrcalc(LLR_calc_unit in_llrcalc);$/;"	p	class:itpp::Rec_Syst_Conv_Code	access:public	signature:(LLR_calc_unit in_llrcalc)
set_low_precision	/usr/include/itpp/base/itfile.h	/^  void set_low_precision(bool p = true)  { low_prec = p; }$/;"	f	class:itpp::it_file	access:public	signature:(bool p = true)
set_low_precision	/usr/include/itpp/base/itfile.h	/^  void set_low_precision(bool p = true)  { low_prec = p; }$/;"	f	class:itpp::it_file_old	access:public	signature:(bool p = true)
set_max_byte_size	/usr/include/itpp/protocol/front_drop_queue.h	/^  void set_max_byte_size(int max_bytes) { max_bytes_in_queue = max_bytes; }$/;"	f	class:itpp::Front_Drop_Queue	access:public	signature:(int max_bytes)
set_max_evaluations	/usr/include/itpp/optim/newton_search.h	/^  void set_max_evaluations(int value);$/;"	p	class:itpp::Newton_Search	access:public	signature:(int value)
set_max_fine_tune	/usr/include/itpp/signal/fastica.h	/^  void set_max_fine_tune(int in_maxFineTune);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(int in_maxFineTune)
set_max_iterations	/usr/include/itpp/optim/newton_search.h	/^  void set_max_iterations(int value);$/;"	p	class:itpp::Line_Search	access:public	signature:(int value)
set_max_num_iterations	/usr/include/itpp/signal/fastica.h	/^  void set_max_num_iterations(int in_maxNumIterations);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(int in_maxNumIterations)
set_max_stepsize	/usr/include/itpp/optim/newton_search.h	/^  void set_max_stepsize(double value);$/;"	p	class:itpp::Line_Search	access:public	signature:(double value)
set_mean	/usr/include/itpp/srccode/gmm.h	/^  void set_mean(const mat &m_in);$/;"	p	class:itpp::GMM	access:public	signature:(const mat &m_in)
set_mean	/usr/include/itpp/srccode/gmm.h	/^  void set_mean(const vec &means, bool compflag = true);$/;"	p	class:itpp::GMM	access:public	signature:(const vec &means, bool compflag = true)
set_mean	/usr/include/itpp/srccode/gmm.h	/^  void set_mean(int i, const vec &means, bool compflag = true);$/;"	p	class:itpp::GMM	access:public	signature:(int i, const vec &means, bool compflag = true)
set_mean	/usr/include/itpp/srccode/gmm.h	/^inline void GMM::set_mean(const vec &means, bool compflag) {m = means; if (compflag) compute_internals(); }$/;"	f	class:itpp::GMM	signature:(const vec &means, bool compflag)
set_means	/usr/include/itpp/stat/mog_generic.h	/^  void set_means(Array<vec> &means_in);$/;"	p	class:itpp::MOG_generic	access:public	signature:(Array<vec> &means_in)
set_means_internal	/usr/include/itpp/stat/mog_generic.h	/^  void set_means_internal(Array<vec> &means_in);$/;"	p	class:itpp::MOG_generic	access:protected	signature:(Array<vec> &means_in)
set_means_zero	/usr/include/itpp/stat/mog_generic.h	/^  void set_means_zero();$/;"	p	class:itpp::MOG_generic	access:public	signature:()
set_means_zero_internal	/usr/include/itpp/stat/mog_generic.h	/^  void set_means_zero_internal();$/;"	p	class:itpp::MOG_generic	access:protected	signature:()
set_method	/usr/include/itpp/base/sort.h	/^  void set_method(SORTING_METHOD method) { sort_method = method; }$/;"	f	class:itpp::Sort	access:public	signature:(SORTING_METHOD method)
set_method	/usr/include/itpp/comm/convcode.h	/^  void set_method(const CONVOLUTIONAL_CODE_METHOD method) {$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(const CONVOLUTIONAL_CODE_METHOD method)
set_method	/usr/include/itpp/comm/punct_convcode.h	/^  void set_method(const CONVOLUTIONAL_CODE_METHOD method) { Convolutional_Code::set_method(method); }$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const CONVOLUTIONAL_CODE_METHOD method)
set_method	/usr/include/itpp/optim/newton_search.h	/^  void set_method(const Line_Search_Method &method);$/;"	p	class:itpp::Line_Search	access:public	signature:(const Line_Search_Method &method)
set_method	/usr/include/itpp/optim/newton_search.h	/^  void set_method(const Newton_Search_Method &method);$/;"	p	class:itpp::Newton_Search	access:public	signature:(const Newton_Search_Method &method)
set_metric	/usr/include/itpp/comm/turbo.h	/^  void set_metric(std::string in_metric = "LOGMAX", double in_logmax_scale_factor = 1.0,$/;"	p	class:itpp::Turbo_Codec	access:public	signature:(std::string in_metric = Ó, double in_logmax_scale_factor = 1.0, LLR_calc_unit lcalc = LLR_calc_unit())
set_mu	/usr/include/itpp/signal/fastica.h	/^  void set_mu(double fl_mu);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(double fl_mu)
set_name	/usr/include/itpp/protocol/signals_slots.h	/^  void set_name(const std::string &signal_name);$/;"	p	class:itpp::Signal	access:public	signature:(const std::string &signal_name)
set_name	/usr/include/itpp/protocol/signals_slots.h	/^  void set_name(const std::string &slot_name);$/;"	p	class:itpp::Base_Slot	access:public	signature:(const std::string &slot_name)
set_name	/usr/include/itpp/protocol/signals_slots.h	/^  void set_name(const std::string Name) {$/;"	f	class:itpp::ATimer	access:public	signature:(const std::string Name)
set_name	/usr/include/itpp/protocol/signals_slots.h	/^void Base_Slot<DataType>::set_name(const std::string &slot_name)$/;"	f	class:itpp::Base_Slot	signature:(const std::string &slot_name)
set_name	/usr/include/itpp/protocol/signals_slots.h	/^void Signal<DataType>::set_name(const std::string &signal_name)$/;"	f	class:itpp::Signal	signature:(const std::string &signal_name)
set_native_endianity	/usr/include/itpp/base/binfile.h	/^  void set_native_endianity() { switch_endianity = false; }$/;"	f	class:itpp::bfstream_base	access:public	signature:()
set_new	/usr/include/itpp/base/smat.h	/^  void set_new(int r, int c, T v);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(int r, int c, T v)
set_new	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::set_new(int r, int c, T v)$/;"	f	class:itpp::Sparse_Mat	signature:(int r, int c, T v)
set_new	/usr/include/itpp/base/svec.h	/^  void set_new(const ivec &index_vec, const Vec<T> &v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const ivec &index_vec, const Vec<T> &v)
set_new	/usr/include/itpp/base/svec.h	/^  void set_new(int i, T v);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(int i, T v)
set_new	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::set_new(const ivec& index_vec, const Vec<T>& v)$/;"	f	class:itpp::Sparse_Vec	signature:(const ivec& index_vec, const Vec<T>& v)
set_new	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::set_new(int i, T v)$/;"	f	class:itpp::Sparse_Vec	signature:(int i, T v)
set_next_name	/usr/include/itpp/base/itfile.h	/^  void set_next_name(const std::string& n) { next_name = n; }$/;"	f	class:itpp::it_file_old	access:public	signature:(const std::string& n)
set_next_name	/usr/include/itpp/base/itfile.h	/^  void set_next_name(const std::string& name,$/;"	f	class:itpp::it_file	access:public	signature:(const std::string& name, const std::string& description = Ó)
set_no_frequencies	/usr/include/itpp/comm/channel.h	/^  virtual void set_no_frequencies(int no_freq);$/;"	p	class:itpp::Fading_Generator	access:public	signature:(int no_freq)
set_no_frequencies	/usr/include/itpp/comm/channel.h	/^  virtual void set_no_frequencies(int no_freq);$/;"	p	class:itpp::Rice_Fading_Generator	access:public	signature:(int no_freq)
set_no_frequencies	/usr/include/itpp/comm/channel.h	/^  void set_no_frequencies(int no_freq);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(int no_freq)
set_noise	/usr/include/itpp/comm/channel.h	/^  void set_noise(double noisevar) { sigma = std::sqrt(noisevar); }$/;"	f	class:itpp::AWGN_Channel	access:public	signature:(double noisevar)
set_non_linearity	/usr/include/itpp/signal/fastica.h	/^  void set_non_linearity(int in_g);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(int in_g)
set_norm_doppler	/usr/include/itpp/comm/channel.h	/^  virtual void set_norm_doppler(double norm_doppler);$/;"	p	class:itpp::Correlated_Fading_Generator	access:public	signature:(double norm_doppler)
set_norm_doppler	/usr/include/itpp/comm/channel.h	/^  virtual void set_norm_doppler(double norm_doppler);$/;"	p	class:itpp::Fading_Generator	access:public	signature:(double norm_doppler)
set_norm_doppler	/usr/include/itpp/comm/channel.h	/^  void set_norm_doppler(double norm_doppler);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(double norm_doppler)
set_nrof_independent_components	/usr/include/itpp/signal/fastica.h	/^  void set_nrof_independent_components(int in_nrIC);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(int in_nrIC)
set_order	/usr/include/itpp/comm/interleave.h	/^  void set_order(int in_order);$/;"	p	class:itpp::Cross_Interleaver	access:public	signature:(int in_order)
set_order	/usr/include/itpp/comm/interleave.h	/^void Cross_Interleaver<T>::set_order(int in_order)$/;"	f	class:itpp::Cross_Interleaver	signature:(int in_order)
set_output_mode	/usr/include/itpp/fixed/fix_base.h	/^  static void set_output_mode(output_mode o) {outputmode = o;}$/;"	f	class:itpp::Fix_Base	access:public	signature:(output_mode o)
set_output_mode	/usr/include/itpp/fixed/fix_base.h	/^  static void set_output_mode(std::string o);$/;"	p	class:itpp::Fix_Base	access:public	signature:(std::string o)
set_parameters	/usr/include/itpp/comm/ofdm.h	/^  void set_parameters(const int Nfft, const int Ncp, const int inNupsample = 1);$/;"	p	class:itpp::OFDM	access:public	signature:(const int Nfft, const int Ncp, const int inNupsample = 1)
set_parameters	/usr/include/itpp/comm/turbo.h	/^  void set_parameters(ivec gen1, ivec gen2, int constraint_length,$/;"	p	class:itpp::Turbo_Codec	access:public	signature:(ivec gen1, ivec gen2, int constraint_length, const ivec &interleaver_sequence, int in_iterations = 8, std::string in_metric = Ó, double in_logmax_scale_factor = 1.0, bool in_adaptive_stop = false, LLR_calc_unit lcalc = LLR_calc_unit())
set_parameters	/usr/include/itpp/protocol/packet_channel.h	/^  void set_parameters(const double Pr, const Ttype Delay);$/;"	p	class:itpp::ACK_Channel	access:public	signature:(const double Pr, const Ttype Delay)
set_parameters	/usr/include/itpp/protocol/packet_channel.h	/^  void set_parameters(const double Pr, const Ttype Delay, const double Block_rate, const int Max_slots);$/;"	p	class:itpp::Packet_Channel	access:public	signature:(const double Pr, const Ttype Delay, const double Block_rate, const int Max_slots)
set_parameters	/usr/include/itpp/protocol/packet_generator.h	/^  void set_parameters(const double Avg_bit_rate, const int Packet_size, const unsigned long int Max_packets);$/;"	p	class:itpp::Poisson_Packet_Generator	access:public	signature:(const double Avg_bit_rate, const int Packet_size, const unsigned long int Max_packets)
set_parameters	/usr/include/itpp/protocol/packet_generator.h	/^  void set_parameters(const int Packet_size, const unsigned long int Max_packets);$/;"	p	class:itpp::Packet_Generator	access:public	signature:(const int Packet_size, const unsigned long int Max_packets)
set_parameters	/usr/include/itpp/protocol/selective_repeat.h	/^  void set_parameters(const int Seq_no_size); \/\/ # bits in sequence no.$/;"	p	class:itpp::Selective_Repeat_ARQ_Receiver	access:public	signature:(const int Seq_no_size)
set_parameters	/usr/include/itpp/protocol/selective_repeat.h	/^  void set_parameters(const int Seq_no_size,        \/\/ # bits in sequence no.$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:public	signature:(const int Seq_no_size, const int Buffer_size_factor, const int Link_packet_size, const Ttype Time_out)
set_paranoid	/usr/include/itpp/stat/mog_generic.h	/^  void set_paranoid(bool paranoid_in) { paranoid = paranoid_in; }$/;"	f	class:itpp::MOG_generic	access:public	signature:(bool paranoid_in)
set_pca_only	/usr/include/itpp/signal/fastica.h	/^  void set_pca_only(bool in_PCAonly);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(bool in_PCAonly)
set_prob	/usr/include/itpp/comm/channel.h	/^  void set_prob(double in_p) { p = in_p; };$/;"	f	class:itpp::BSC	access:public	signature:(double in_p)
set_pulse_shape	/usr/include/itpp/comm/pulse_shape.h	/^  void set_pulse_shape(const Vec<T2> &impulse_response, int upsampling_factor);$/;"	p	class:itpp::Pulse_Shape	access:public	signature:(const Vec<T2> &impulse_response, int upsampling_factor)
set_pulse_shape	/usr/include/itpp/comm/pulse_shape.h	/^  void set_pulse_shape(double roll_off_factor, int filter_length = 6, int upsampling_factor = 8);$/;"	p	class:itpp::Raised_Cosine	access:public	signature:(double roll_off_factor, int filter_length = 6, int upsampling_factor = 8)
set_pulse_shape	/usr/include/itpp/comm/pulse_shape.h	/^  void set_pulse_shape(double roll_off_factor, int filter_length = 6, int upsampling_factor = 8);$/;"	p	class:itpp::Root_Raised_Cosine	access:public	signature:(double roll_off_factor, int filter_length = 6, int upsampling_factor = 8)
set_pulse_shape	/usr/include/itpp/comm/pulse_shape.h	/^void Pulse_Shape<T1, T2, T3>::set_pulse_shape(const Vec<T2> &impulse_response_in, int upsampling_factor_in)$/;"	f	class:itpp::Pulse_Shape	signature:(const Vec<T2> &impulse_response_in, int upsampling_factor_in)
set_pulse_shape	/usr/include/itpp/comm/pulse_shape.h	/^void Raised_Cosine<T1>::set_pulse_shape(double roll_off_factor_in, int filter_length, int upsampling_factor_in)$/;"	f	class:itpp::Raised_Cosine	signature:(double roll_off_factor_in, int filter_length, int upsampling_factor_in)
set_pulse_shape	/usr/include/itpp/comm/pulse_shape.h	/^void Root_Raised_Cosine<T1>::set_pulse_shape(double roll_off_factor_in, int filter_length, int upsampling_factor_in)$/;"	f	class:itpp::Root_Raised_Cosine	signature:(double roll_off_factor_in, int filter_length, int upsampling_factor_in)
set_puncture_matrix	/usr/include/itpp/comm/punct_convcode.h	/^  void set_puncture_matrix(const bmat &pmatrix); \/\/ add test of matrix size$/;"	p	class:itpp::Punctured_Convolutional_Code	access:public	signature:(const bmat &pmatrix)
set_rate	/usr/include/itpp/srccode/audiofile.h	/^  void set_rate(int r) { header.sample_rate = r; }$/;"	f	class:itpp::SND_Format	access:public	signature:(int r)
set_re	/usr/include/itpp/fixed/cfix.h	/^  void set_re(fixrep x) {re = apply_o_mode(x);}$/;"	f	class:itpp::CFix	access:public	signature:(fixrep x)
set_re	/usr/include/itpp/fixed/fix.h	/^  void set_re(fixrep x) {re = apply_o_mode(x);}$/;"	f	class:itpp::Fix	access:public	signature:(fixrep x)
set_rice_method	/usr/include/itpp/comm/channel.h	/^  virtual void set_rice_method(RICE_METHOD method);$/;"	p	class:itpp::Fading_Generator	access:public	signature:(RICE_METHOD method)
set_rice_method	/usr/include/itpp/comm/channel.h	/^  virtual void set_rice_method(RICE_METHOD method);$/;"	p	class:itpp::Rice_Fading_Generator	access:public	signature:(RICE_METHOD method)
set_row	/usr/include/itpp/base/gf2mat.h	/^  void set_row(int i, bvec x);$/;"	p	class:itpp::GF2mat	access:public	signature:(int i, bvec x)
set_row	/usr/include/itpp/base/mat.h	/^  void set_row(int r, const Vec<Num_T> &v);$/;"	p	class:itpp::Mat	access:public	signature:(int r, const Vec<Num_T> &v)
set_row	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::set_row(int r, const Vec<Num_T> &v)$/;"	f	class:itpp::Mat	signature:(int r, const Vec<Num_T> &v)
set_rows	/usr/include/itpp/base/mat.h	/^  void set_rows(int r, const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:public	signature:(int r, const Mat<Num_T> &m)
set_rows	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::set_rows(int r, const Mat<Num_T> &m)$/;"	f	class:itpp::Mat	signature:(int r, const Mat<Num_T> &m)
set_rows	/usr/include/itpp/comm/interleave.h	/^  void set_rows(int in_rows) {rows = in_rows;};$/;"	f	class:itpp::Block_Interleaver	access:public	signature:(int in_rows)
set_sample_size	/usr/include/itpp/signal/fastica.h	/^  void set_sample_size(double fl_sampleSize);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(double fl_sampleSize)
set_scaling_factor	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  void set_scaling_factor(double in_Lc);$/;"	p	class:itpp::Rec_Syst_Conv_Code	access:public	signature:(double in_Lc)
set_scaling_factor	/usr/include/itpp/comm/turbo.h	/^  void set_scaling_factor(double in_Lc);$/;"	p	class:itpp::Turbo_Codec	access:public	signature:(double in_Lc)
set_segment	/usr/include/itpp/protocol/tcp.h	/^  void set_segment(const TCP_Segment &seg) {  fSegment = seg; }$/;"	f	class:itpp::TCP_Packet	access:public	signature:(const TCP_Segment &seg)
set_session_id	/usr/include/itpp/protocol/tcp.h	/^  void set_session_id(int val) { fSessionId = val; }$/;"	f	class:itpp::TCP_Packet	access:public	signature:(int val)
set_shift	/usr/include/itpp/fixed/fix_base.h	/^  void set_shift(int s) {shift = s;}$/;"	f	class:itpp::Fix_Base	access:public	signature:(int s)
set_silentmode	/usr/include/itpp/base/parser.h	/^  void set_silentmode(bool v = true);$/;"	p	class:itpp::Parser	access:public	signature:(bool v = true)
set_size	/usr/include/itpp/base/array.h	/^  void set_size(int n, bool copy = false);$/;"	p	class:itpp::Array	access:public	signature:(int n, bool copy = false)
set_size	/usr/include/itpp/base/array.h	/^void Array<T>::set_size(int size, bool copy)$/;"	f	class:itpp::Array	signature:(int size, bool copy)
set_size	/usr/include/itpp/base/circular_buffer.h	/^  void set_size(int n, bool copy = false);$/;"	p	class:itpp::Circular_Buffer	access:public	signature:(int n, bool copy = false)
set_size	/usr/include/itpp/base/circular_buffer.h	/^void Circular_Buffer<T>::set_size(int sz, bool copy)$/;"	f	class:itpp::Circular_Buffer	signature:(int sz, bool copy)
set_size	/usr/include/itpp/base/gf2mat.h	/^  void set_size(int m, int n, bool copy = false);$/;"	p	class:itpp::GF2mat	access:public	signature:(int m, int n, bool copy = false)
set_size	/usr/include/itpp/base/mat.h	/^  void set_size(int rows, int cols, bool copy = false);$/;"	p	class:itpp::Mat	access:public	signature:(int rows, int cols, bool copy = false)
set_size	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::set_size(int rows, int cols, bool copy)$/;"	f	class:itpp::Mat	signature:(int rows, int cols, bool copy)
set_size	/usr/include/itpp/base/smat.h	/^  void set_size(int rows, int cols, int row_data_init = -1);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(int rows, int cols, int row_data_init = -1)
set_size	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::set_size(int rows, int cols, int row_data_init)$/;"	f	class:itpp::Sparse_Mat	signature:(int rows, int cols, int row_data_init)
set_size	/usr/include/itpp/base/stack.h	/^  void set_size(int n, bool copy = false);$/;"	p	class:itpp::Stack	access:public	signature:(int n, bool copy = false)
set_size	/usr/include/itpp/base/stack.h	/^void Stack<T>::set_size(int sz, bool copy)$/;"	f	class:itpp::Stack	signature:(int sz, bool copy)
set_size	/usr/include/itpp/base/svec.h	/^  void set_size(int sz, int data_init = -1);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(int sz, int data_init = -1)
set_size	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::set_size(int new_size, int data_init)$/;"	f	class:itpp::Sparse_Vec	signature:(int new_size, int data_init)
set_size	/usr/include/itpp/base/vec.h	/^  void set_size(int size, bool copy = false);$/;"	p	class:itpp::Vec	access:public	signature:(int size, bool copy = false)
set_size	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::set_size(int size, bool copy)$/;"	f	class:itpp::Vec	signature:(int size, bool copy)
set_size	/usr/include/itpp/comm/galois.h	/^  void set_size(int qvalue);$/;"	p	class:itpp::GF	access:public	signature:(int qvalue)
set_small_element	/usr/include/itpp/base/svec.h	/^  void set_small_element(const T& epsilon);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const T& epsilon)
set_small_element	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::set_small_element(const T& epsilon)$/;"	f	class:itpp::Sparse_Vec	signature:(const T& epsilon)
set_source_port	/usr/include/itpp/protocol/tcp.h	/^  void set_source_port(unsigned val) { fSourcePort = val; }$/;"	f	class:itpp::TCP_Packet	access:public	signature:(unsigned val)
set_stabilization	/usr/include/itpp/signal/fastica.h	/^  void set_stabilization(bool in_stabilization);$/;"	p	class:itpp::Fast_ICA	access:public	signature:(bool in_stabilization)
set_start_point	/usr/include/itpp/optim/newton_search.h	/^  void set_start_point(const vec &x);$/;"	p	class:itpp::Newton_Search	access:public	signature:(const vec &x)
set_start_point	/usr/include/itpp/optim/newton_search.h	/^  void set_start_point(const vec &x, const mat &D);$/;"	p	class:itpp::Newton_Search	access:public	signature:(const vec &x, const mat &D)
set_start_point	/usr/include/itpp/optim/newton_search.h	/^  void set_start_point(const vec &x, double F, const vec &g, const vec &h);$/;"	p	class:itpp::Line_Search	access:public	signature:(const vec &x, double F, const vec &g, const vec &h)
set_start_state	/usr/include/itpp/comm/convcode.h	/^  void set_start_state(int state) {$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(int state)
set_state	/usr/include/itpp/base/random.h	/^  void set_state(ivec &new_state);$/;"	p	class:itpp::Random_Generator	access:public	signature:(ivec &new_state)
set_state	/usr/include/itpp/comm/sequence.h	/^  void set_state(const bvec &state);$/;"	p	class:itpp::LFSR	access:public	signature:(const bvec &state)
set_state	/usr/include/itpp/comm/sequence.h	/^  void set_state(const bvec &state1, const bvec &state2);$/;"	p	class:itpp::Gold	access:public	signature:(const bvec &state1, const bvec &state2)
set_state	/usr/include/itpp/comm/sequence.h	/^  void set_state(const ivec &state);$/;"	p	class:itpp::LFSR	access:public	signature:(const ivec &state)
set_state	/usr/include/itpp/comm/sequence.h	/^  void set_state(const ivec &state1, const ivec &state2);$/;"	p	class:itpp::Gold	access:public	signature:(const ivec &state1, const ivec &state2)
set_state	/usr/include/itpp/signal/filter.h	/^  void set_state(const Vec<T3> &state);$/;"	p	class:itpp::ARMA_Filter	access:public	signature:(const Vec<T3> &state)
set_state	/usr/include/itpp/signal/filter.h	/^  void set_state(const Vec<T3> &state);$/;"	p	class:itpp::AR_Filter	access:public	signature:(const Vec<T3> &state)
set_state	/usr/include/itpp/signal/filter.h	/^  void set_state(const Vec<T3> &state);$/;"	p	class:itpp::MA_Filter	access:public	signature:(const Vec<T3> &state)
set_state	/usr/include/itpp/signal/filter.h	/^void ARMA_Filter<T1, T2, T3>::set_state(const Vec<T3> &state)$/;"	f	class:itpp::ARMA_Filter	signature:(const Vec<T3> &state)
set_state	/usr/include/itpp/signal/filter.h	/^void AR_Filter<T1, T2, T3>::set_state(const Vec<T3> &state)$/;"	f	class:itpp::AR_Filter	signature:(const Vec<T3> &state)
set_state	/usr/include/itpp/signal/filter.h	/^void MA_Filter<T1, T2, T3>::set_state(const Vec<T3> &state)$/;"	f	class:itpp::MA_Filter	signature:(const Vec<T3> &state)
set_stop_values	/usr/include/itpp/optim/newton_search.h	/^  void set_stop_values(double epsilon_1, double epsilon_2);$/;"	p	class:itpp::Newton_Search	access:public	signature:(double epsilon_1, double epsilon_2)
set_stop_values	/usr/include/itpp/optim/newton_search.h	/^  void set_stop_values(double rho, double beta);$/;"	p	class:itpp::Line_Search	access:public	signature:(double rho, double beta)
set_subarray	/usr/include/itpp/base/array.h	/^  void set_subarray(int i1, int i2, const Array<T> &a);$/;"	p	class:itpp::Array	access:public	signature:(int i1, int i2, const Array<T> &a)
set_subarray	/usr/include/itpp/base/array.h	/^  void set_subarray(int i1, int i2, const T t);$/;"	p	class:itpp::Array	access:public	signature:(int i1, int i2, const T t)
set_subarray	/usr/include/itpp/base/array.h	/^void Array<T>::set_subarray(int i1, int i2, const Array<T> &a)$/;"	f	class:itpp::Array	signature:(int i1, int i2, const Array<T> &a)
set_subarray	/usr/include/itpp/base/array.h	/^void Array<T>::set_subarray(int i1, int i2, const T t)$/;"	f	class:itpp::Array	signature:(int i1, int i2, const T t)
set_submatrix	/usr/include/itpp/base/mat.h	/^  void set_submatrix(int r, int c, const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:public	signature:(int r, int c, const Mat<Num_T> &m)
set_submatrix	/usr/include/itpp/base/mat.h	/^  void set_submatrix(int r1, int r2, int c1, int c2, Num_T t);$/;"	p	class:itpp::Mat	access:public	signature:(int r1, int r2, int c1, int c2, Num_T t)
set_submatrix	/usr/include/itpp/base/mat.h	/^  void set_submatrix(int r1, int r2, int c1, int c2, const Mat<Num_T> &m);$/;"	p	class:itpp::Mat	access:public	signature:(int r1, int r2, int c1, int c2, const Mat<Num_T> &m)
set_submatrix	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::set_submatrix(int r, int c, const Mat<Num_T> &m)$/;"	f	class:itpp::Mat	signature:(int r, int c, const Mat<Num_T> &m)
set_submatrix	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::set_submatrix(int r1, int r2, int c1, int c2, Num_T t)$/;"	f	class:itpp::Mat	signature:(int r1, int r2, int c1, int c2, Num_T t)
set_submatrix	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::set_submatrix(int r1, int r2, int c1, int c2,$/;"	f	class:itpp::Mat	signature:(int r1, int r2, int c1, int c2, const Mat<Num_T> &m)
set_submatrix	/usr/include/itpp/base/smat.h	/^  void set_submatrix(int r, int c, const Mat<T>& m);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(int r, int c, const Mat<T>& m)
set_submatrix	/usr/include/itpp/base/smat.h	/^  void set_submatrix(int r1, int r2, int c1, int c2, const Mat<T> &m);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(int r1, int r2, int c1, int c2, const Mat<T> &m)
set_submatrix	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::set_submatrix(int r, int c, const Mat<T>& m)$/;"	f	class:itpp::Sparse_Mat	signature:(int r, int c, const Mat<T>& m)
set_submatrix	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::set_submatrix(int r1, int r2, int c1, int c2, const Mat<T>& m)$/;"	f	class:itpp::Sparse_Mat	signature:(int r1, int r2, int c1, int c2, const Mat<T>& m)
set_subvector	/usr/include/itpp/base/vec.h	/^  void set_subvector(int i, const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:public	signature:(int i, const Vec<Num_T> &v)
set_subvector	/usr/include/itpp/base/vec.h	/^  void set_subvector(int i1, int i2, Num_T t);$/;"	p	class:itpp::Vec	access:public	signature:(int i1, int i2, Num_T t)
set_subvector	/usr/include/itpp/base/vec.h	/^  void set_subvector(int i1, int i2, const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:public	signature:(int i1, int i2, const Vec<Num_T> &v)
set_subvector	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>:: set_subvector(int i, const Vec<Num_T> &v)$/;"	f	class:itpp::Vec	signature:(int i, const Vec<Num_T> &v)
set_subvector	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::set_subvector(int i1, int i2, Num_T t)$/;"	f	class:itpp::Vec	signature:(int i1, int i2, Num_T t)
set_subvector	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::set_subvector(int i1, int i2, const Vec<Num_T> &v)$/;"	f	class:itpp::Vec	signature:(int i1, int i2, const Vec<Num_T> &v)
set_time_offset	/usr/include/itpp/comm/channel.h	/^  virtual void set_time_offset(int offset);$/;"	p	class:itpp::Correlated_Fading_Generator	access:public	signature:(int offset)
set_time_offset	/usr/include/itpp/comm/channel.h	/^  virtual void set_time_offset(int offset);$/;"	p	class:itpp::Fading_Generator	access:public	signature:(int offset)
set_time_offset	/usr/include/itpp/comm/channel.h	/^  void set_time_offset(int offset);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(int offset)
set_trace	/usr/include/itpp/protocol/tcp.h	/^  virtual void set_trace(const bool enable_trace = true);$/;"	p	class:itpp::TCP_Receiver	access:public	signature:(const bool enable_trace = true)
set_trace	/usr/include/itpp/protocol/tcp.h	/^  virtual void set_trace(const bool enable_trace = true);$/;"	p	class:itpp::TCP_Sender	access:public	signature:(const bool enable_trace = true)
set_truncation_length	/usr/include/itpp/comm/convcode.h	/^  void set_truncation_length(const int length) {$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(const int length)
set_weight	/usr/include/itpp/srccode/gmm.h	/^  void set_weight(const vec &weights, bool compflag = true);$/;"	p	class:itpp::GMM	access:public	signature:(const vec &weights, bool compflag = true)
set_weight	/usr/include/itpp/srccode/gmm.h	/^  void set_weight(int i, double weight, bool compflag = true);$/;"	p	class:itpp::GMM	access:public	signature:(int i, double weight, bool compflag = true)
set_weight	/usr/include/itpp/srccode/gmm.h	/^inline void GMM::set_weight(const vec &weights, bool compflag) {w = weights; if (compflag) compute_internals(); }$/;"	f	class:itpp::GMM	signature:(const vec &weights, bool compflag)
set_weight	/usr/include/itpp/srccode/gmm.h	/^inline void GMM::set_weight(int i, double weight, bool compflag) {w(i) = weight; if (compflag) compute_internals(); }$/;"	f	class:itpp::GMM	signature:(int i, double weight, bool compflag)
set_weights	/usr/include/itpp/stat/mog_generic.h	/^  void set_weights(vec &weights_in);$/;"	p	class:itpp::MOG_generic	access:public	signature:(vec &weights_in)
set_weights_internal	/usr/include/itpp/stat/mog_generic.h	/^  void set_weights_internal(vec &_weigths);$/;"	p	class:itpp::MOG_generic	access:protected	signature:(vec &_weigths)
set_weights_uniform	/usr/include/itpp/stat/mog_generic.h	/^  void set_weights_uniform();$/;"	p	class:itpp::MOG_generic	access:public	signature:()
set_weights_uniform_internal	/usr/include/itpp/stat/mog_generic.h	/^  void set_weights_uniform_internal();$/;"	p	class:itpp::MOG_generic	access:protected	signature:()
set_wnd	/usr/include/itpp/protocol/tcp.h	/^  void set_wnd(unsigned val) { fWnd = val; }$/;"	f	class:itpp::TCP_Packet	access:public	signature:(unsigned val)
setup	/usr/include/itpp/base/random.h	/^  void setup(double lambda) { l = lambda; }$/;"	f	class:itpp::Exponential_RNG	access:public	signature:(double lambda)
setup	/usr/include/itpp/base/random.h	/^  void setup(double lambda, double beta);$/;"	p	class:itpp::Weibull_RNG	access:public	signature:(double lambda, double beta)
setup	/usr/include/itpp/base/random.h	/^  void setup(double meanval, double variance)$/;"	f	class:itpp::Normal_RNG	access:public	signature:(double meanval, double variance)
setup	/usr/include/itpp/base/random.h	/^  void setup(double meanval, double variance);$/;"	p	class:itpp::Laplace_RNG	access:public	signature:(double meanval, double variance)
setup	/usr/include/itpp/base/random.h	/^  void setup(double meanval, double variance, double rho);$/;"	p	class:itpp::AR1_Normal_RNG	access:public	signature:(double meanval, double variance, double rho)
setup	/usr/include/itpp/base/random.h	/^  void setup(double min, double max);$/;"	p	class:itpp::Uniform_RNG	access:public	signature:(double min, double max)
setup	/usr/include/itpp/base/random.h	/^  void setup(double prob) {$/;"	f	class:itpp::Bernoulli_RNG	access:public	signature:(double prob)
setup	/usr/include/itpp/base/random.h	/^  void setup(double sigma) { sig = sigma; }$/;"	f	class:itpp::Rayleigh_RNG	access:public	signature:(double sigma)
setup	/usr/include/itpp/base/random.h	/^  void setup(double sigma, double v) { sig = sigma; s = v; }$/;"	f	class:itpp::Rice_RNG	access:public	signature:(double sigma, double v)
setup	/usr/include/itpp/base/random.h	/^  void setup(int min, int max);$/;"	p	class:itpp::I_Uniform_RNG	access:public	signature:(int min, int max)
setup	/usr/include/itpp/base/random.h	/^  void setup(std::complex<double> mean, double variance) {$/;"	f	class:itpp::Complex_Normal_RNG	access:public	signature:(std::complex<double> mean, double variance)
setup	/usr/include/itpp/protocol/tcp.h	/^  virtual void setup();$/;"	p	class:itpp::TCP_Receiver	access:public	signature:()
setup	/usr/include/itpp/protocol/tcp.h	/^  virtual void setup();$/;"	p	class:itpp::TCP_Sender	access:public	signature:()
setup	/usr/include/itpp/stat/histogram.h	/^  void setup(Num_T from, Num_T to, int n_bins);$/;"	p	class:itpp::Histogram	access:public	signature:(Num_T from, Num_T to, int n_bins)
setup	/usr/include/itpp/stat/histogram.h	/^inline void Histogram<Num_T>::setup(Num_T from, Num_T to, int n_bins)$/;"	f	class:itpp::Histogram	signature:(Num_T from, Num_T to, int n_bins)
setup_covs	/usr/include/itpp/stat/mog_diag.h	/^  void setup_covs();$/;"	p	class:itpp::MOG_diag	access:protected	signature:()
setup_covs	/usr/include/itpp/stat/mog_generic.h	/^  virtual void setup_covs();$/;"	p	class:itpp::MOG_generic	access:protected	signature:()
setup_decoder	/usr/include/itpp/comm/ldpc.h	/^  void setup_decoder();$/;"	p	class:itpp::LDPC_Code	access:protected	signature:()
setup_done	/usr/include/itpp/comm/error_counters.h	/^  bool setup_done;$/;"	m	class:itpp::BLERC	access:private
setup_done	/usr/include/itpp/comm/modulator.h	/^  bool setup_done;$/;"	m	class:itpp::Modulator	access:protected
setup_done	/usr/include/itpp/comm/ofdm.h	/^  bool setup_done;$/;"	m	class:itpp::OFDM	access:private
setup_done	/usr/include/itpp/comm/pulse_shape.h	/^  bool setup_done;$/;"	m	class:itpp::Pulse_Shape	access:protected
setup_means	/usr/include/itpp/stat/mog_diag.h	/^  void setup_means();$/;"	p	class:itpp::MOG_diag	access:protected	signature:()
setup_means	/usr/include/itpp/stat/mog_generic.h	/^  virtual void setup_means();$/;"	p	class:itpp::MOG_generic	access:protected	signature:()
setup_misc	/usr/include/itpp/stat/mog_diag.h	/^  void setup_misc();$/;"	p	class:itpp::MOG_diag	access:protected	signature:()
setup_misc	/usr/include/itpp/stat/mog_generic.h	/^  virtual void setup_misc();$/;"	p	class:itpp::MOG_generic	access:protected	signature:()
setup_weights	/usr/include/itpp/stat/mog_diag.h	/^  void setup_weights();$/;"	p	class:itpp::MOG_diag	access:protected	signature:()
setup_weights	/usr/include/itpp/stat/mog_generic.h	/^  virtual void setup_weights();$/;"	p	class:itpp::MOG_generic	access:protected	signature:()
sfixed1	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<1, TC, SAT> sfixed1;$/;"	t	namespace:itpp
sfixed10	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<10, TC, SAT> sfixed10;$/;"	t	namespace:itpp
sfixed11	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<11, TC, SAT> sfixed11;$/;"	t	namespace:itpp
sfixed12	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<12, TC, SAT> sfixed12;$/;"	t	namespace:itpp
sfixed13	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<13, TC, SAT> sfixed13;$/;"	t	namespace:itpp
sfixed14	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<14, TC, SAT> sfixed14;$/;"	t	namespace:itpp
sfixed15	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<15, TC, SAT> sfixed15;$/;"	t	namespace:itpp
sfixed16	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<16, TC, SAT> sfixed16;$/;"	t	namespace:itpp
sfixed17	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<17, TC, SAT> sfixed17;$/;"	t	namespace:itpp
sfixed18	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<18, TC, SAT> sfixed18;$/;"	t	namespace:itpp
sfixed19	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<19, TC, SAT> sfixed19;$/;"	t	namespace:itpp
sfixed2	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<2, TC, SAT> sfixed2;$/;"	t	namespace:itpp
sfixed20	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<20, TC, SAT> sfixed20;$/;"	t	namespace:itpp
sfixed21	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<21, TC, SAT> sfixed21;$/;"	t	namespace:itpp
sfixed22	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<22, TC, SAT> sfixed22;$/;"	t	namespace:itpp
sfixed23	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<23, TC, SAT> sfixed23;$/;"	t	namespace:itpp
sfixed24	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<24, TC, SAT> sfixed24;$/;"	t	namespace:itpp
sfixed25	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<25, TC, SAT> sfixed25;$/;"	t	namespace:itpp
sfixed26	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<26, TC, SAT> sfixed26;$/;"	t	namespace:itpp
sfixed27	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<27, TC, SAT> sfixed27;$/;"	t	namespace:itpp
sfixed28	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<28, TC, SAT> sfixed28;$/;"	t	namespace:itpp
sfixed29	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<29, TC, SAT> sfixed29;$/;"	t	namespace:itpp
sfixed3	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<3, TC, SAT> sfixed3;$/;"	t	namespace:itpp
sfixed30	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<30, TC, SAT> sfixed30;$/;"	t	namespace:itpp
sfixed31	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<31, TC, SAT> sfixed31;$/;"	t	namespace:itpp
sfixed32	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<32, TC, SAT> sfixed32;$/;"	t	namespace:itpp
sfixed33	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<33, TC, SAT> sfixed33;$/;"	t	namespace:itpp
sfixed34	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<34, TC, SAT> sfixed34;$/;"	t	namespace:itpp
sfixed35	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<35, TC, SAT> sfixed35;$/;"	t	namespace:itpp
sfixed36	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<36, TC, SAT> sfixed36;$/;"	t	namespace:itpp
sfixed37	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<37, TC, SAT> sfixed37;$/;"	t	namespace:itpp
sfixed38	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<38, TC, SAT> sfixed38;$/;"	t	namespace:itpp
sfixed39	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<39, TC, SAT> sfixed39;$/;"	t	namespace:itpp
sfixed4	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<4, TC, SAT> sfixed4;$/;"	t	namespace:itpp
sfixed40	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<40, TC, SAT> sfixed40;$/;"	t	namespace:itpp
sfixed41	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<41, TC, SAT> sfixed41;$/;"	t	namespace:itpp
sfixed42	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<42, TC, SAT> sfixed42;$/;"	t	namespace:itpp
sfixed43	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<43, TC, SAT> sfixed43;$/;"	t	namespace:itpp
sfixed44	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<44, TC, SAT> sfixed44;$/;"	t	namespace:itpp
sfixed45	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<45, TC, SAT> sfixed45;$/;"	t	namespace:itpp
sfixed46	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<46, TC, SAT> sfixed46;$/;"	t	namespace:itpp
sfixed47	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<47, TC, SAT> sfixed47;$/;"	t	namespace:itpp
sfixed48	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<48, TC, SAT> sfixed48;$/;"	t	namespace:itpp
sfixed49	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<49, TC, SAT> sfixed49;$/;"	t	namespace:itpp
sfixed5	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<5, TC, SAT> sfixed5;$/;"	t	namespace:itpp
sfixed50	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<50, TC, SAT> sfixed50;$/;"	t	namespace:itpp
sfixed51	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<51, TC, SAT> sfixed51;$/;"	t	namespace:itpp
sfixed52	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<52, TC, SAT> sfixed52;$/;"	t	namespace:itpp
sfixed53	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<53, TC, SAT> sfixed53;$/;"	t	namespace:itpp
sfixed54	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<54, TC, SAT> sfixed54;$/;"	t	namespace:itpp
sfixed55	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<55, TC, SAT> sfixed55;$/;"	t	namespace:itpp
sfixed56	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<56, TC, SAT> sfixed56;$/;"	t	namespace:itpp
sfixed57	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<57, TC, SAT> sfixed57;$/;"	t	namespace:itpp
sfixed58	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<58, TC, SAT> sfixed58;$/;"	t	namespace:itpp
sfixed59	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<59, TC, SAT> sfixed59;$/;"	t	namespace:itpp
sfixed6	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<6, TC, SAT> sfixed6;$/;"	t	namespace:itpp
sfixed60	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<60, TC, SAT> sfixed60;$/;"	t	namespace:itpp
sfixed61	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<61, TC, SAT> sfixed61;$/;"	t	namespace:itpp
sfixed62	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<62, TC, SAT> sfixed62;$/;"	t	namespace:itpp
sfixed63	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<63, TC, SAT> sfixed63;$/;"	t	namespace:itpp
sfixed64	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<64, TC, SAT> sfixed64;$/;"	t	namespace:itpp
sfixed7	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<7, TC, SAT> sfixed7;$/;"	t	namespace:itpp
sfixed8	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<8, TC, SAT> sfixed8;$/;"	t	namespace:itpp
sfixed9	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<9, TC, SAT> sfixed9;$/;"	t	namespace:itpp
sgn	/usr/include/itpp/base/math/elem_math.h	/^inline double sgn(double x) { return sign(x); }$/;"	f	namespace:itpp	signature:(double x)
sgn	/usr/include/itpp/base/math/elem_math.h	/^inline mat sgn(const mat &x) { return apply_function<double>(sign, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
sgn	/usr/include/itpp/base/math/elem_math.h	/^inline vec sgn(const vec &x) { return apply_function<double>(sign, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
sgn_i	/usr/include/itpp/base/math/elem_math.h	/^inline imat sgn_i(const imat &x) { return apply_function<int>(sign_i, x); }$/;"	f	namespace:itpp	signature:(const imat &x)
sgn_i	/usr/include/itpp/base/math/elem_math.h	/^inline int sgn_i(int x) { return sign_i(x); }$/;"	f	namespace:itpp	signature:(int x)
sgn_i	/usr/include/itpp/base/math/elem_math.h	/^inline ivec sgn_i(const ivec &x) { return apply_function<int>(sign_i, x); }$/;"	f	namespace:itpp	signature:(const ivec &x)
shape_samples	/usr/include/itpp/comm/pulse_shape.h	/^  Vec<T3> shape_samples(const Vec<T1> &input);$/;"	p	class:itpp::Pulse_Shape	access:public	signature:(const Vec<T1> &input)
shape_samples	/usr/include/itpp/comm/pulse_shape.h	/^  void shape_samples(const Vec<T1> &input, Vec<T3> &output);$/;"	p	class:itpp::Pulse_Shape	access:public	signature:(const Vec<T1> &input, Vec<T3> &output)
shape_samples	/usr/include/itpp/comm/pulse_shape.h	/^Vec<T3> Pulse_Shape<T1, T2, T3>::shape_samples(const Vec<T1>& input)$/;"	f	class:itpp::Pulse_Shape	signature:(const Vec<T1>& input)
shape_samples	/usr/include/itpp/comm/pulse_shape.h	/^void Pulse_Shape<T1, T2, T3>::shape_samples(const Vec<T1>& input, Vec<T3> &output)$/;"	f	class:itpp::Pulse_Shape	signature:(const Vec<T1>& input, Vec<T3> &output)
shape_symbols	/usr/include/itpp/comm/pulse_shape.h	/^  Vec<T3> shape_symbols(const Vec<T1> &input);$/;"	p	class:itpp::Pulse_Shape	access:public	signature:(const Vec<T1> &input)
shape_symbols	/usr/include/itpp/comm/pulse_shape.h	/^  void shape_symbols(const Vec<T1> &input, Vec<T3> &output);$/;"	p	class:itpp::Pulse_Shape	access:public	signature:(const Vec<T1> &input, Vec<T3> &output)
shape_symbols	/usr/include/itpp/comm/pulse_shape.h	/^Vec<T3> Pulse_Shape<T1, T2, T3>::shape_symbols(const Vec<T1>& input)$/;"	f	class:itpp::Pulse_Shape	signature:(const Vec<T1>& input)
shape_symbols	/usr/include/itpp/comm/pulse_shape.h	/^void Pulse_Shape<T1, T2, T3>::shape_symbols(const Vec<T1>& input, Vec<T3> &output)$/;"	f	class:itpp::Pulse_Shape	signature:(const Vec<T1>& input, Vec<T3> &output)
shaping_filter	/usr/include/itpp/comm/pulse_shape.h	/^  MA_Filter<T1, T2, T3> shaping_filter;$/;"	m	class:itpp::Pulse_Shape	access:protected
shift	/usr/include/itpp/comm/sequence.h	/^  bin shift(void);$/;"	p	class:itpp::Gold	access:public	signature:(void)
shift	/usr/include/itpp/comm/sequence.h	/^  bin shift(void);$/;"	p	class:itpp::LFSR	access:public	signature:(void)
shift	/usr/include/itpp/comm/sequence.h	/^  bvec shift(int no_shifts);$/;"	p	class:itpp::Gold	access:public	signature:(int no_shifts)
shift	/usr/include/itpp/comm/sequence.h	/^  bvec shift(int no_shifts);$/;"	p	class:itpp::LFSR	access:public	signature:(int no_shifts)
shift	/usr/include/itpp/comm/sequence.h	/^inline bin Gold::shift(void) {return (mseq1.shift() + mseq2.shift());}$/;"	f	class:itpp::Gold	signature:(void)
shift	/usr/include/itpp/comm/sequence.h	/^inline bin LFSR::shift(void) {bin temp = memory * Connections;memory.shift_right(temp);return temp;}$/;"	f	class:itpp::LFSR	signature:(void)
shift	/usr/include/itpp/fixed/fix_base.h	/^  int shift;$/;"	m	class:itpp::Fix_Base	access:protected
shift_divisor	/usr/include/itpp/base/gf2mat.h	/^  static const unsigned char shift_divisor = 3;$/;"	m	class:itpp::GF2mat	access:private
shift_left	/usr/include/itpp/base/array.h	/^  T shift_left(const T& e);$/;"	p	class:itpp::Array	access:public	signature:(const T& e)
shift_left	/usr/include/itpp/base/array.h	/^  const Array<T> shift_left(const Array<T> &a);$/;"	p	class:itpp::Array	access:public	signature:(const Array<T> &a)
shift_left	/usr/include/itpp/base/array.h	/^T Array<T>::shift_left(const T& x)$/;"	f	class:itpp::Array	signature:(const T& x)
shift_left	/usr/include/itpp/base/array.h	/^const Array<T> Array<T>::shift_left(const Array<T> &a)$/;"	f	class:itpp::Array	signature:(const Array<T> &a)
shift_left	/usr/include/itpp/base/vec.h	/^  void shift_left(Num_T t, int n = 1);$/;"	p	class:itpp::Vec	access:public	signature:(Num_T t, int n = 1)
shift_left	/usr/include/itpp/base/vec.h	/^  void shift_left(const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:public	signature:(const Vec<Num_T> &v)
shift_left	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::shift_left(Num_T t, int n)$/;"	f	class:itpp::Vec	signature:(Num_T t, int n)
shift_left	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::shift_left(const Vec<Num_T> &v)$/;"	f	class:itpp::Vec	signature:(const Vec<Num_T> &v)
shift_right	/usr/include/itpp/base/array.h	/^  T shift_right(const T& e);$/;"	p	class:itpp::Array	access:public	signature:(const T& e)
shift_right	/usr/include/itpp/base/array.h	/^  const Array<T> shift_right(const Array<T> &a);$/;"	p	class:itpp::Array	access:public	signature:(const Array<T> &a)
shift_right	/usr/include/itpp/base/array.h	/^T Array<T>::shift_right(const T& x)$/;"	f	class:itpp::Array	signature:(const T& x)
shift_right	/usr/include/itpp/base/array.h	/^const Array<T> Array<T>::shift_right(const Array<T> &a)$/;"	f	class:itpp::Array	signature:(const Array<T> &a)
shift_right	/usr/include/itpp/base/vec.h	/^  void shift_right(Num_T t, int n = 1);$/;"	p	class:itpp::Vec	access:public	signature:(Num_T t, int n = 1)
shift_right	/usr/include/itpp/base/vec.h	/^  void shift_right(const Vec<Num_T> &v);$/;"	p	class:itpp::Vec	access:public	signature:(const Vec<Num_T> &v)
shift_right	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::shift_right(Num_T t, int n)$/;"	f	class:itpp::Vec	signature:(Num_T t, int n)
shift_right	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::shift_right(const Vec<Num_T> &v)$/;"	f	class:itpp::Vec	signature:(const Vec<Num_T> &v)
shift_time_offset	/usr/include/itpp/comm/channel.h	/^  virtual void shift_time_offset(int no_samples);$/;"	p	class:itpp::Correlated_Fading_Generator	access:public	signature:(int no_samples)
shift_time_offset	/usr/include/itpp/comm/channel.h	/^  virtual void shift_time_offset(int no_samples);$/;"	p	class:itpp::Fading_Generator	access:public	signature:(int no_samples)
shift_time_offset	/usr/include/itpp/comm/channel.h	/^  void shift_time_offset(int no_samples);$/;"	p	class:itpp::TDL_Channel	access:public	signature:(int no_samples)
short2mxArray	/usr/include/itpp/itmex.h	/^void short2mxArray(const short &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const short &in, mxArray *out)
sig	/usr/include/itpp/base/random.h	/^  double sig, s;$/;"	m	class:itpp::Rice_RNG	access:private
sig	/usr/include/itpp/base/random.h	/^  double sig;$/;"	m	class:itpp::Rayleigh_RNG	access:private
sigma	/usr/include/itpp/base/random.h	/^  double mean, sigma;$/;"	m	class:itpp::Normal_RNG	access:private
sigma	/usr/include/itpp/base/random.h	/^  double sigma;$/;"	m	class:itpp::Complex_Normal_RNG	access:private
sigma	/usr/include/itpp/comm/channel.h	/^  double sigma;$/;"	m	class:itpp::AWGN_Channel	access:private
sigma	/usr/include/itpp/srccode/gmm.h	/^  vec   m, sigma, w;$/;"	m	class:itpp::GMM	access:protected
sigma	/usr/include/itpp/stat/misc_stat.h	/^  double sigma() const {$/;"	f	class:itpp::Stat	access:public	signature:() const
sign	/usr/include/itpp/base/math/elem_math.h	/^inline double sign(double x)$/;"	f	namespace:itpp	signature:(double x)
sign	/usr/include/itpp/base/math/elem_math.h	/^inline mat sign(const mat &x) { return apply_function<double>(sign, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
sign	/usr/include/itpp/base/math/elem_math.h	/^inline vec sign(const vec &x) { return apply_function<double>(sign, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
sign_i	/usr/include/itpp/base/math/elem_math.h	/^inline imat sign_i(const imat &x) { return apply_function<int>(sign_i, x); }$/;"	f	namespace:itpp	signature:(const imat &x)
sign_i	/usr/include/itpp/base/math/elem_math.h	/^inline int sign_i(double x)$/;"	f	namespace:itpp	signature:(double x)
sign_i	/usr/include/itpp/base/math/elem_math.h	/^inline int sign_i(int x)$/;"	f	namespace:itpp	signature:(int x)
sign_i	/usr/include/itpp/base/math/elem_math.h	/^inline ivec sign_i(const ivec &x) { return apply_function<int>(sign_i, x); }$/;"	f	namespace:itpp	signature:(const ivec &x)
sign_nozero_i	/usr/include/itpp/comm/modulator_nd.h	/^  inline int sign_nozero_i(double a) { return (a > 0.0 ? 1 : -1); }$/;"	f	class:itpp::ND_UPAM	access:private	signature:(double a)
sign_nozero_i	/usr/include/itpp/comm/modulator_nd.h	/^  inline int sign_nozero_i(int a) { return (a > 0 ? 1 : -1); }$/;"	f	class:itpp::ND_UPAM	access:private	signature:(int a)
signal	/usr/include/itpp/protocol/signals_slots.h	/^  Signal<double> signal;     \/\/ Used internally$/;"	m	class:itpp::TTimer	access:private
sin	/usr/include/itpp/base/math/trig_hyp.h	/^inline mat sin(const mat &x) { return apply_function<double>(std::sin, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
sin	/usr/include/itpp/base/math/trig_hyp.h	/^inline vec sin(const vec &x) { return apply_function<double>(std::sin, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
sinc	/usr/include/itpp/base/math/trig_hyp.h	/^inline double sinc(double x)$/;"	f	namespace:itpp	signature:(double x)
sinc	/usr/include/itpp/base/math/trig_hyp.h	/^inline mat sinc(const mat &x) { return apply_function<double>(sinc, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
sinc	/usr/include/itpp/base/math/trig_hyp.h	/^inline vec sinc(const vec &x) { return apply_function<double>(sinc, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
single	/usr/include/itpp/protocol/signals_slots.h	/^  bool single;$/;"	m	class:itpp::Signal	access:private
sinh	/usr/include/itpp/base/math/trig_hyp.h	/^inline mat sinh(const mat &x) { return apply_function<double>(std::sinh, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
sinh	/usr/include/itpp/base/math/trig_hyp.h	/^inline vec sinh(const vec &x) { return apply_function<double>(std::sinh, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
size	/usr/include/itpp/base/array.h	/^  int size() const { return ndata; }$/;"	f	class:itpp::Array	access:public	signature:() const
size	/usr/include/itpp/base/circular_buffer.h	/^  int size() const { return _ndata; }$/;"	f	class:itpp::Circular_Buffer	access:public	signature:() const
size	/usr/include/itpp/base/mat.h	/^  int size() const { return datasize; }$/;"	f	class:itpp::Mat	access:public	signature:() const
size	/usr/include/itpp/base/matfunc.h	/^int size(const Vec<T> &v) { return v.length(); }$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
size	/usr/include/itpp/base/stack.h	/^  int size() const { return ndata; }$/;"	f	class:itpp::Stack	access:public	signature:() const
size	/usr/include/itpp/base/svec.h	/^  int size() const { return v_size; }$/;"	f	class:itpp::Sparse_Vec	access:public	signature:() const
size	/usr/include/itpp/base/vec.h	/^  int size() const { return datasize; }$/;"	f	class:itpp::Vec	access:public	signature:() const
size	/usr/include/itpp/srccode/vq.h	/^  int size() const;$/;"	p	class:itpp::Scalar_Quantizer	access:public	signature:() const
size	/usr/include/itpp/srccode/vq.h	/^  int size() const;$/;"	p	class:itpp::Vector_Quantizer	access:public	signature:() const
size	/usr/include/itpp/srccode/vq.h	/^inline int Scalar_Quantizer::size() const { return Levels.length(); }$/;"	f	class:itpp::Scalar_Quantizer	signature:() const
size	/usr/include/itpp/srccode/vq.h	/^inline int Vector_Quantizer::size() const { return Size; }$/;"	f	class:itpp::Vector_Quantizer	signature:() const
size_bits	/usr/include/itpp/protocol/packet.h	/^  int size_bits; \/\/ size of packet in bits$/;"	m	class:itpp::Packet	access:private
skewness	/usr/include/itpp/stat/misc_stat.h	/^double skewness(const vec &x);$/;"	p	namespace:itpp	signature:(const vec &x)
slope_ratio	/usr/include/itpp/optim/newton_search.h	/^  double slope_ratio; \/\/ slope ratio at xn, info(2)$/;"	m	class:itpp::Line_Search	access:private
slot	/usr/include/itpp/protocol/signals_slots.h	/^  Slot<TTimer, double> slot; \/\/ Used internally$/;"	m	class:itpp::TTimer	access:private
smat	/usr/include/itpp/base/mat.h	/^typedef Mat<short int> smat;$/;"	t	namespace:itpp
smat2mxArray	/usr/include/itpp/itmex.h	/^void smat2mxArray(const smat &in, mxArray *out)$/;"	f	namespace:itpp	signature:(const smat &in, mxArray *out)
smat2mxArray	/usr/include/itpp/itmex.h	/^void smat2mxArray(const smat &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const smat &in, mxArray *out)
snd_read	/usr/include/itpp/srccode/audiofile.h	/^bool snd_read(const char *fname, vec &v);$/;"	p	namespace:itpp	signature:(const char *fname, vec &v)
snd_read	/usr/include/itpp/srccode/audiofile.h	/^bool snd_read(const char *fname, vec &v, int beg, int len);$/;"	p	namespace:itpp	signature:(const char *fname, vec &v, int beg, int len)
snd_write	/usr/include/itpp/srccode/audiofile.h	/^bool snd_write(const char *fname, const vec &v, int rate = 8000,$/;"	p	namespace:itpp	signature:(const char *fname, const vec &v, int rate = 8000, SND_Format::data_encoding e = SND_Format::enc_linear16)
sort	/usr/include/itpp/base/sort.h	/^  void sort(int low, int high, Vec<T> &data);$/;"	p	class:itpp::Sort	access:public	signature:(int low, int high, Vec<T> &data)
sort	/usr/include/itpp/base/sort.h	/^void Sort<T>::sort(int low, int high, Vec<T> &data)$/;"	f	class:itpp::Sort	signature:(int low, int high, Vec<T> &data)
sort	/usr/include/itpp/base/sort.h	/^void sort(Vec<T> &data, SORTING_METHOD method = INTROSORT)$/;"	f	namespace:itpp	signature:(Vec<T> &data, SORTING_METHOD method = INTROSORT)
sort_index	/usr/include/itpp/base/sort.h	/^  ivec sort_index(int low, int high, const Vec<T> &data);$/;"	p	class:itpp::Sort	access:public	signature:(int low, int high, const Vec<T> &data)
sort_index	/usr/include/itpp/base/sort.h	/^ivec Sort<T>::sort_index(int low, int high, const Vec<T> &data)$/;"	f	class:itpp::Sort	signature:(int low, int high, const Vec<T> &data)
sort_index	/usr/include/itpp/base/sort.h	/^ivec sort_index(const Vec<T> &data, SORTING_METHOD method = INTROSORT)$/;"	f	namespace:itpp	signature:(const Vec<T> &data, SORTING_METHOD method = INTROSORT)
sort_method	/usr/include/itpp/base/sort.h	/^  SORTING_METHOD sort_method;$/;"	m	class:itpp::Sort	access:private
spacing	/usr/include/itpp/comm/modulator_nd.h	/^  vec spacing;  \/\/ spacing between the constellation points$/;"	m	class:itpp::ND_UPAM	access:private
sparse	/usr/include/itpp/base/smat.h	/^inline Sparse_Mat<T> sparse(const Mat<T> &m, T epsilon)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, T epsilon)
sparse	/usr/include/itpp/base/svec.h	/^inline Sparse_Vec<T> sparse(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
sparse	/usr/include/itpp/base/svec.h	/^inline Sparse_Vec<T> sparse(const Vec<T> &v, T epsilon)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, T epsilon)
sparse_cmat	/usr/include/itpp/base/smat.h	/^typedef Sparse_Mat<std::complex<double> > sparse_cmat;$/;"	t	namespace:itpp
sparse_cvec	/usr/include/itpp/base/svec.h	/^typedef Sparse_Vec<std::complex<double> > sparse_cvec;$/;"	t	namespace:itpp
sparse_imat	/usr/include/itpp/base/smat.h	/^typedef Sparse_Mat<int> sparse_imat;$/;"	t	namespace:itpp
sparse_ivec	/usr/include/itpp/base/svec.h	/^typedef Sparse_Vec<int> sparse_ivec;$/;"	t	namespace:itpp
sparse_mat	/usr/include/itpp/base/smat.h	/^typedef Sparse_Mat<double> sparse_mat;$/;"	t	namespace:itpp
sparse_vec	/usr/include/itpp/base/svec.h	/^typedef Sparse_Vec<double> sparse_vec;$/;"	t	namespace:itpp
sparsify	/usr/include/itpp/base/gf2mat.h	/^  GF2mat_sparse sparsify() const;$/;"	p	class:itpp::GF2mat	access:public	signature:() const
spectrum	/usr/include/itpp/signal/sigfun.h	/^vec spectrum(const vec &v, const vec &w, int noverlap = 0);$/;"	p	namespace:itpp	signature:(const vec &v, const vec &w, int noverlap = 0)
spectrum	/usr/include/itpp/signal/sigfun.h	/^vec spectrum(const vec &v, int nfft = 256, int noverlap = 0);$/;"	p	namespace:itpp	signature:(const vec &v, int nfft = 256, int noverlap = 0)
sphere_decoding	/usr/include/itpp/comm/modulator_nd.h	/^  int sphere_decoding(const vec &y, const mat &H, double rmin, double rmax,$/;"	p	class:itpp::ND_UPAM	access:public	signature:(const vec &y, const mat &H, double rmin, double rmax, double stepup, QLLRvec &detected_bits)
sphere_search_SE	/usr/include/itpp/comm/modulator_nd.h	/^  int sphere_search_SE(const vec &y, const mat &H, const imat &zrange,$/;"	p	class:itpp::ND_UPAM	access:private	signature:(const vec &y, const mat &H, const imat &zrange, double r, ivec &zhat)
split	/usr/include/itpp/base/vec.h	/^  Vec<Num_T> split(int pos);$/;"	p	class:itpp::Vec	access:public	signature:(int pos)
split	/usr/include/itpp/base/vec.h	/^Vec<Num_T> Vec<Num_T>::split(int pos)$/;"	f	class:itpp::Vec	signature:(int pos)
spread	/usr/include/itpp/comm/spread.h	/^  cvec spread(const cvec &symbols) { cvec out; spread(symbols, out); return out; }$/;"	f	class:itpp::Spread_2d	access:public	signature:(const cvec &symbols)
spread	/usr/include/itpp/comm/spread.h	/^  cvec spread(const cvec &symbols);$/;"	p	class:itpp::Multicode_Spread_2d	access:public	signature:(const cvec &symbols)
spread	/usr/include/itpp/comm/spread.h	/^  vec spread(const vec &symbols) { vec out; spread(symbols, out); return out; }$/;"	f	class:itpp::Spread_1d	access:public	signature:(const vec &symbols)
spread	/usr/include/itpp/comm/spread.h	/^  vec spread(const vec &symbols);$/;"	p	class:itpp::Multicode_Spread_1d	access:public	signature:(const vec &symbols)
spread	/usr/include/itpp/comm/spread.h	/^  void spread(const cvec &symbols, cvec &out);$/;"	p	class:itpp::Spread_2d	access:public	signature:(const cvec &symbols, cvec &out)
spread	/usr/include/itpp/comm/spread.h	/^  void spread(const vec &symbols, vec &out);$/;"	p	class:itpp::Spread_1d	access:public	signature:(const vec &symbols, vec &out)
spreadI	/usr/include/itpp/comm/spread.h	/^  Spread_1d spreadI, spreadQ;$/;"	m	class:itpp::Spread_2d	access:protected
spreadQ	/usr/include/itpp/comm/spread.h	/^  Spread_1d spreadI, spreadQ;$/;"	m	class:itpp::Spread_2d	access:protected
sqr	/usr/include/itpp/base/math/elem_math.h	/^inline double sqr(const std::complex<double>& x)$/;"	f	namespace:itpp	signature:(const std::complex<double>& x)
sqr	/usr/include/itpp/base/math/elem_math.h	/^inline double sqr(double x) { return (x * x); }$/;"	f	namespace:itpp	signature:(double x)
sqr	/usr/include/itpp/base/math/elem_math.h	/^inline mat sqr(const mat &x) { return apply_function<double>(sqr, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
sqr	/usr/include/itpp/base/math/elem_math.h	/^inline vec sqr(const vec &x) { return apply_function<double>(sqr, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
sqr	/usr/include/itpp/base/math/elem_math.h	/^mat sqr(const cmat &x);$/;"	p	namespace:itpp	signature:(const cmat &x)
sqr	/usr/include/itpp/base/math/elem_math.h	/^vec sqr(const cvec &x);$/;"	p	namespace:itpp	signature:(const cvec &x)
sqr	/usr/include/itpp/base/svec.h	/^  T sqr() const;$/;"	p	class:itpp::Sparse_Vec	access:public	signature:() const
sqr	/usr/include/itpp/base/svec.h	/^T Sparse_Vec<T>::sqr() const$/;"	f	class:itpp::Sparse_Vec	signature:() const
sqr_sum	/usr/include/itpp/stat/misc_stat.h	/^  double sqr_sum() const {return _sqr_sum;}$/;"	f	class:itpp::Stat	access:public	signature:() const
sqrt	/usr/include/itpp/base/math/elem_math.h	/^inline mat sqrt(const mat &x) { return apply_function<double>(std::sqrt, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
sqrt	/usr/include/itpp/base/math/elem_math.h	/^inline vec sqrt(const vec &x) { return apply_function<double>(std::sqrt, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
sqrt_12var	/usr/include/itpp/base/random.h	/^  double mean, var, sqrt_12var;$/;"	m	class:itpp::Laplace_RNG	access:private
sqrt_win	/usr/include/itpp/signal/window.h	/^vec sqrt_win(int n);$/;"	p	namespace:itpp	signature:(int n)
sqrtm	/usr/include/itpp/base/matfunc.h	/^cmat sqrtm(const cmat& A);$/;"	p	namespace:itpp	signature:(const cmat& A)
sqrtm	/usr/include/itpp/base/matfunc.h	/^cmat sqrtm(const mat& A);$/;"	p	namespace:itpp	signature:(const mat& A)
sqtrain	/usr/include/itpp/srccode/vqtrain.h	/^vec sqtrain(const vec &inDB, int SIZE);$/;"	p	namespace:itpp	signature:(const vec &inDB, int SIZE)
stabilization	/usr/include/itpp/signal/fastica.h	/^  bool finetune, stabilization, PCAonly;$/;"	m	class:itpp::Fast_ICA	access:private
start	/usr/include/itpp/base/timing.h	/^  void start(void);$/;"	p	class:itpp::Timer	access:public	signature:(void)
start	/usr/include/itpp/protocol/events.h	/^  static void start();$/;"	p	class:itpp::Event_Queue	access:public	signature:()
start	/usr/include/itpp/protocol/packet_channel.h	/^  Slot<Packet_Channel, bool> start;$/;"	m	class:itpp::Packet_Channel	access:public
start	/usr/include/itpp/protocol/packet_generator.h	/^  Slot<Packet_Generator, bool> start;$/;"	m	class:itpp::Packet_Generator	access:public
start_state	/usr/include/itpp/comm/convcode.h	/^  int start_state;$/;"	m	class:itpp::Convolutional_Code	access:protected
start_time	/usr/include/itpp/base/timing.h	/^  double start_time;$/;"	m	class:itpp::Timer	access:protected
start_time	/usr/include/itpp/protocol/packet_generator.h	/^  Ttype start_time;$/;"	m	class:itpp::Sink	access:private
stat_ptr	/usr/include/itpp/fixed/fix_base.h	/^  Stat *stat_ptr;$/;"	m	class:itpp::Fix_Base	access:protected
stat_ptr	/usr/include/itpp/fixed/fix_factory.h	/^  Stat *stat_ptr;$/;"	m	class:itpp::Fix_Factory	access:protected
state	/usr/include/itpp/base/random.h	/^  static unsigned int state[624];$/;"	m	class:itpp::Random_Generator	access:private
state_trans	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  imat state_trans, output_parity, rev_state_trans, rev_output_parity;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
static_sample	/usr/include/itpp/comm/channel.h	/^  std::complex<double> static_sample;$/;"	m	class:itpp::Static_Fading_Generator	access:protected
std	/usr/include/itpp/base/binary.h	/^namespace std   \/\/ added 11\/2005, EGL$/;"	n
std	/usr/include/itpp/base/math/misc.h	/^namespace std$/;"	n
std::abs	/usr/include/itpp/base/binary.h	/^inline int abs(const itpp::bin &inbin) { return inbin; }$/;"	f	namespace:std	signature:(const itpp::bin &inbin)
std::isfinite	/usr/include/itpp/base/math/misc.h	/^inline int isfinite(double x) { return ::finite(x); }$/;"	f	namespace:std	signature:(double x)
std::isfinite	/usr/include/itpp/base/math/misc.h	/^inline int isfinite(double x) { return ::isfinite(x); }$/;"	f	namespace:std	signature:(double x)
std::isfinite	/usr/include/itpp/base/math/misc.h	/^inline int isfinite(double x)$/;"	f	namespace:std	signature:(double x)
std::isinf	/usr/include/itpp/base/math/misc.h	/^inline int isinf(double x) { return ::isinf(x); }$/;"	f	namespace:std	signature:(double x)
std::isnan	/usr/include/itpp/base/math/misc.h	/^inline int isnan(double x) { return ((x != x) ? 1 : 0); }$/;"	f	namespace:std	signature:(double x)
std::isnan	/usr/include/itpp/base/math/misc.h	/^inline int isnan(double x) { return ::isnan(x); }$/;"	f	namespace:std	signature:(double x)
std::operator <<	/usr/include/itpp/base/math/misc.h	/^std::ostream& operator<<(std::ostream &os, const std::complex<T> &x)$/;"	f	namespace:std	signature:(std::ostream &os, const std::complex<T> &x)
std::operator >>	/usr/include/itpp/base/math/misc.h	/^std::istream& operator>>(std::istream &is, std::complex<T> &x)$/;"	f	namespace:std	signature:(std::istream &is, std::complex<T> &x)
step	/usr/include/itpp/stat/histogram.h	/^  Num_T step;$/;"	m	class:itpp::Histogram	access:private
stop	/usr/include/itpp/base/timing.h	/^  double stop(void);$/;"	p	class:itpp::Timer	access:public	signature:(void)
stop	/usr/include/itpp/protocol/events.h	/^  static void stop();$/;"	p	class:itpp::Event_Queue	access:public	signature:()
stop_beta	/usr/include/itpp/optim/newton_search.h	/^  double stop_beta; \/\/ opts(3)$/;"	m	class:itpp::Line_Search	access:private
stop_epsilon_1	/usr/include/itpp/optim/newton_search.h	/^  double stop_epsilon_1; \/\/ opts(2)$/;"	m	class:itpp::Newton_Search	access:private
stop_epsilon_2	/usr/include/itpp/optim/newton_search.h	/^  double stop_epsilon_2; \/\/ opt(3)$/;"	m	class:itpp::Newton_Search	access:private
stop_rho	/usr/include/itpp/optim/newton_search.h	/^  double stop_rho; \/\/ opts(2)$/;"	m	class:itpp::Line_Search	access:private
stop_time	/usr/include/itpp/base/timing.h	/^  double stop_time;$/;"	m	class:itpp::Timer	access:protected
string2mxArray	/usr/include/itpp/itmex.h	/^void string2mxArray(const std::string &in, mxArray* &out)$/;"	f	namespace:itpp	signature:(const std::string &in, mxArray* &out)
string2mxArray	/usr/include/itpp/itmex.h	/^void string2mxArray(const std::string &in, mxArray* &out);$/;"	p	namespace:itpp	signature:(const std::string &in, mxArray* &out)
sub_m_v_vT	/usr/include/itpp/base/fastmath.h	/^void sub_m_v_vT(mat &m, const vec &v);$/;"	p	namespace:itpp	signature:(mat &m, const vec &v)
sub_v_vT_m	/usr/include/itpp/base/fastmath.h	/^void sub_v_vT_m(mat &m, const vec &v);$/;"	p	namespace:itpp	signature:(mat &m, const vec &v)
sufixed1	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<1, US, SAT> sufixed1;$/;"	t	namespace:itpp
sufixed10	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<10, US, SAT> sufixed10;$/;"	t	namespace:itpp
sufixed11	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<11, US, SAT> sufixed11;$/;"	t	namespace:itpp
sufixed12	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<12, US, SAT> sufixed12;$/;"	t	namespace:itpp
sufixed13	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<13, US, SAT> sufixed13;$/;"	t	namespace:itpp
sufixed14	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<14, US, SAT> sufixed14;$/;"	t	namespace:itpp
sufixed15	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<15, US, SAT> sufixed15;$/;"	t	namespace:itpp
sufixed16	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<16, US, SAT> sufixed16;$/;"	t	namespace:itpp
sufixed17	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<17, US, SAT> sufixed17;$/;"	t	namespace:itpp
sufixed18	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<18, US, SAT> sufixed18;$/;"	t	namespace:itpp
sufixed19	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<19, US, SAT> sufixed19;$/;"	t	namespace:itpp
sufixed2	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<2, US, SAT> sufixed2;$/;"	t	namespace:itpp
sufixed20	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<20, US, SAT> sufixed20;$/;"	t	namespace:itpp
sufixed21	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<21, US, SAT> sufixed21;$/;"	t	namespace:itpp
sufixed22	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<22, US, SAT> sufixed22;$/;"	t	namespace:itpp
sufixed23	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<23, US, SAT> sufixed23;$/;"	t	namespace:itpp
sufixed24	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<24, US, SAT> sufixed24;$/;"	t	namespace:itpp
sufixed25	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<25, US, SAT> sufixed25;$/;"	t	namespace:itpp
sufixed26	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<26, US, SAT> sufixed26;$/;"	t	namespace:itpp
sufixed27	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<27, US, SAT> sufixed27;$/;"	t	namespace:itpp
sufixed28	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<28, US, SAT> sufixed28;$/;"	t	namespace:itpp
sufixed29	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<29, US, SAT> sufixed29;$/;"	t	namespace:itpp
sufixed3	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<3, US, SAT> sufixed3;$/;"	t	namespace:itpp
sufixed30	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<30, US, SAT> sufixed30;$/;"	t	namespace:itpp
sufixed31	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<31, US, SAT> sufixed31;$/;"	t	namespace:itpp
sufixed32	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<32, US, SAT> sufixed32;$/;"	t	namespace:itpp
sufixed33	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<33, US, SAT> sufixed33;$/;"	t	namespace:itpp
sufixed34	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<34, US, SAT> sufixed34;$/;"	t	namespace:itpp
sufixed35	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<35, US, SAT> sufixed35;$/;"	t	namespace:itpp
sufixed36	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<36, US, SAT> sufixed36;$/;"	t	namespace:itpp
sufixed37	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<37, US, SAT> sufixed37;$/;"	t	namespace:itpp
sufixed38	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<38, US, SAT> sufixed38;$/;"	t	namespace:itpp
sufixed39	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<39, US, SAT> sufixed39;$/;"	t	namespace:itpp
sufixed4	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<4, US, SAT> sufixed4;$/;"	t	namespace:itpp
sufixed40	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<40, US, SAT> sufixed40;$/;"	t	namespace:itpp
sufixed41	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<41, US, SAT> sufixed41;$/;"	t	namespace:itpp
sufixed42	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<42, US, SAT> sufixed42;$/;"	t	namespace:itpp
sufixed43	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<43, US, SAT> sufixed43;$/;"	t	namespace:itpp
sufixed44	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<44, US, SAT> sufixed44;$/;"	t	namespace:itpp
sufixed45	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<45, US, SAT> sufixed45;$/;"	t	namespace:itpp
sufixed46	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<46, US, SAT> sufixed46;$/;"	t	namespace:itpp
sufixed47	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<47, US, SAT> sufixed47;$/;"	t	namespace:itpp
sufixed48	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<48, US, SAT> sufixed48;$/;"	t	namespace:itpp
sufixed49	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<49, US, SAT> sufixed49;$/;"	t	namespace:itpp
sufixed5	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<5, US, SAT> sufixed5;$/;"	t	namespace:itpp
sufixed50	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<50, US, SAT> sufixed50;$/;"	t	namespace:itpp
sufixed51	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<51, US, SAT> sufixed51;$/;"	t	namespace:itpp
sufixed52	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<52, US, SAT> sufixed52;$/;"	t	namespace:itpp
sufixed53	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<53, US, SAT> sufixed53;$/;"	t	namespace:itpp
sufixed54	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<54, US, SAT> sufixed54;$/;"	t	namespace:itpp
sufixed55	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<55, US, SAT> sufixed55;$/;"	t	namespace:itpp
sufixed56	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<56, US, SAT> sufixed56;$/;"	t	namespace:itpp
sufixed57	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<57, US, SAT> sufixed57;$/;"	t	namespace:itpp
sufixed58	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<58, US, SAT> sufixed58;$/;"	t	namespace:itpp
sufixed59	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<59, US, SAT> sufixed59;$/;"	t	namespace:itpp
sufixed6	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<6, US, SAT> sufixed6;$/;"	t	namespace:itpp
sufixed60	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<60, US, SAT> sufixed60;$/;"	t	namespace:itpp
sufixed61	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<61, US, SAT> sufixed61;$/;"	t	namespace:itpp
sufixed62	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<62, US, SAT> sufixed62;$/;"	t	namespace:itpp
sufixed63	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<63, US, SAT> sufixed63;$/;"	t	namespace:itpp
sufixed64	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<64, US, SAT> sufixed64;$/;"	t	namespace:itpp
sufixed7	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<7, US, SAT> sufixed7;$/;"	t	namespace:itpp
sufixed8	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<8, US, SAT> sufixed8;$/;"	t	namespace:itpp
sufixed9	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<9, US, SAT> sufixed9;$/;"	t	namespace:itpp
sum	/usr/include/itpp/base/matfunc.h	/^T sum(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
sum	/usr/include/itpp/base/matfunc.h	/^Vec<T> sum(const Mat<T> &m, int dim = 1)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, int dim = 1)
sum	/usr/include/itpp/base/matfunc.h	/^extern template bin sum(const bvec &v);$/;"	p	namespace:itpp	signature:(const bvec &v)
sum	/usr/include/itpp/base/matfunc.h	/^extern template bvec sum(const bmat &m, int dim);$/;"	p	namespace:itpp	signature:(const bmat &m, int dim)
sum	/usr/include/itpp/base/matfunc.h	/^extern template cvec sum(const cmat &m, int dim);$/;"	p	namespace:itpp	signature:(const cmat &m, int dim)
sum	/usr/include/itpp/base/matfunc.h	/^extern template double sum(const vec &v);$/;"	p	namespace:itpp	signature:(const vec &v)
sum	/usr/include/itpp/base/matfunc.h	/^extern template int sum(const ivec &v);$/;"	p	namespace:itpp	signature:(const ivec &v)
sum	/usr/include/itpp/base/matfunc.h	/^extern template ivec sum(const imat &m, int dim);$/;"	p	namespace:itpp	signature:(const imat &m, int dim)
sum	/usr/include/itpp/base/matfunc.h	/^extern template short sum(const svec &v);$/;"	p	namespace:itpp	signature:(const svec &v)
sum	/usr/include/itpp/base/matfunc.h	/^extern template std::complex<double> sum(const cvec &v);$/;"	p	namespace:itpp	signature:(const cvec &v)
sum	/usr/include/itpp/base/matfunc.h	/^extern template svec sum(const smat &m, int dim);$/;"	p	namespace:itpp	signature:(const smat &m, int dim)
sum	/usr/include/itpp/base/matfunc.h	/^extern template vec sum(const mat &m, int dim);$/;"	p	namespace:itpp	signature:(const mat &m, int dim)
sum	/usr/include/itpp/stat/misc_stat.h	/^  double sum() const {return _sum;}$/;"	f	class:itpp::Stat	access:public	signature:() const
sumX1	/usr/include/itpp/comm/ldpc.h	/^  ivec C, V, sumX1, sumX2, iind, jind;$/;"	m	class:itpp::LDPC_Code	access:private
sumX1	/usr/include/itpp/comm/ldpc.h	/^  ivec sumX1;$/;"	m	class:itpp::LDPC_Parity	access:protected
sumX2	/usr/include/itpp/comm/ldpc.h	/^  ivec C, V, sumX1, sumX2, iind, jind;$/;"	m	class:itpp::LDPC_Code	access:private
sumX2	/usr/include/itpp/comm/ldpc.h	/^  ivec sumX2;$/;"	m	class:itpp::LDPC_Parity	access:protected
sum_metric	/usr/include/itpp/comm/convcode.h	/^  vec sum_metric;$/;"	m	class:itpp::Convolutional_Code	access:protected
sum_sqr	/usr/include/itpp/base/matfunc.h	/^T sum_sqr(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
sum_sqr	/usr/include/itpp/base/matfunc.h	/^Vec<T> sum_sqr(const Mat<T> &m, int dim = 1)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, int dim = 1)
sum_sqr	/usr/include/itpp/base/matfunc.h	/^extern template bin sum_sqr(const bvec &v);$/;"	p	namespace:itpp	signature:(const bvec &v)
sum_sqr	/usr/include/itpp/base/matfunc.h	/^extern template bvec sum_sqr(const bmat &m, int dim);$/;"	p	namespace:itpp	signature:(const bmat &m, int dim)
sum_sqr	/usr/include/itpp/base/matfunc.h	/^extern template cvec sum_sqr(const cmat &m, int dim);$/;"	p	namespace:itpp	signature:(const cmat &m, int dim)
sum_sqr	/usr/include/itpp/base/matfunc.h	/^extern template double sum_sqr(const vec &v);$/;"	p	namespace:itpp	signature:(const vec &v)
sum_sqr	/usr/include/itpp/base/matfunc.h	/^extern template int sum_sqr(const ivec &v);$/;"	p	namespace:itpp	signature:(const ivec &v)
sum_sqr	/usr/include/itpp/base/matfunc.h	/^extern template ivec sum_sqr(const imat &m, int dim);$/;"	p	namespace:itpp	signature:(const imat &m, int dim)
sum_sqr	/usr/include/itpp/base/matfunc.h	/^extern template short sum_sqr(const svec &v);$/;"	p	namespace:itpp	signature:(const svec &v)
sum_sqr	/usr/include/itpp/base/matfunc.h	/^extern template std::complex<double> sum_sqr(const cvec &v);$/;"	p	namespace:itpp	signature:(const cvec &v)
sum_sqr	/usr/include/itpp/base/matfunc.h	/^extern template svec sum_sqr(const smat &m, int dim);$/;"	p	namespace:itpp	signature:(const smat &m, int dim)
sum_sqr	/usr/include/itpp/base/matfunc.h	/^extern template vec sum_sqr(const mat & m, int dim);$/;"	p	namespace:itpp	signature:(const mat & m, int dim)
sumsum	/usr/include/itpp/base/matfunc.h	/^T sumsum(const Mat<T> &X)$/;"	f	namespace:itpp	signature:(const Mat<T> &X)
sumsum	/usr/include/itpp/base/matfunc.h	/^extern template bin sumsum(const bmat &X);$/;"	p	namespace:itpp	signature:(const bmat &X)
sumsum	/usr/include/itpp/base/matfunc.h	/^extern template double sumsum(const mat &X);$/;"	p	namespace:itpp	signature:(const mat &X)
sumsum	/usr/include/itpp/base/matfunc.h	/^extern template int sumsum(const imat &X);$/;"	p	namespace:itpp	signature:(const imat &X)
sumsum	/usr/include/itpp/base/matfunc.h	/^extern template short sumsum(const smat &X);$/;"	p	namespace:itpp	signature:(const smat &X)
sumsum	/usr/include/itpp/base/matfunc.h	/^extern template std::complex<double> sumsum(const cmat &X);$/;"	p	namespace:itpp	signature:(const cmat &X)
svd	/usr/include/itpp/base/algebra/svd.h	/^bool svd(const cmat &A, cmat &U, vec &s, cmat &V);$/;"	p	namespace:itpp	signature:(const cmat &A, cmat &U, vec &s, cmat &V)
svd	/usr/include/itpp/base/algebra/svd.h	/^bool svd(const cmat &A, vec &s);$/;"	p	namespace:itpp	signature:(const cmat &A, vec &s)
svd	/usr/include/itpp/base/algebra/svd.h	/^bool svd(const mat &A, mat &U, vec &s, mat &V);$/;"	p	namespace:itpp	signature:(const mat &A, mat &U, vec &s, mat &V)
svd	/usr/include/itpp/base/algebra/svd.h	/^bool svd(const mat &A, vec &s);$/;"	p	namespace:itpp	signature:(const mat &A, vec &s)
svd	/usr/include/itpp/base/algebra/svd.h	/^vec svd(const cmat &A);$/;"	p	namespace:itpp	signature:(const cmat &A)
svd	/usr/include/itpp/base/algebra/svd.h	/^vec svd(const mat &A);$/;"	p	namespace:itpp	signature:(const mat &A)
svec	/usr/include/itpp/base/vec.h	/^typedef Vec<short int> svec;$/;"	t	namespace:itpp
svec2mxArray	/usr/include/itpp/itmex.h	/^void svec2mxArray(const svec &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const svec &in, mxArray *out)
swap	/usr/include/itpp/base/array.h	/^  void swap(int i, int j);$/;"	p	class:itpp::Array	access:public	signature:(int i, int j)
swap	/usr/include/itpp/base/array.h	/^void Array<T>::swap(int i, int j)$/;"	f	class:itpp::Array	signature:(int i, int j)
swap_cols	/usr/include/itpp/base/gf2mat.h	/^  void swap_cols(int i, int j);$/;"	p	class:itpp::GF2mat	access:public	signature:(int i, int j)
swap_cols	/usr/include/itpp/base/mat.h	/^  void swap_cols(int c1, int c2);$/;"	p	class:itpp::Mat	access:public	signature:(int c1, int c2)
swap_cols	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::swap_cols(int c1, int c2)$/;"	f	class:itpp::Mat	signature:(int c1, int c2)
swap_rows	/usr/include/itpp/base/gf2mat.h	/^  void swap_rows(int i, int j);$/;"	p	class:itpp::GF2mat	access:public	signature:(int i, int j)
swap_rows	/usr/include/itpp/base/mat.h	/^  void swap_rows(int r1, int r2);$/;"	p	class:itpp::Mat	access:public	signature:(int r1, int r2)
swap_rows	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::swap_rows(int r1, int r2)$/;"	f	class:itpp::Mat	signature:(int r1, int r2)
swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, bin *x, bin *y) { for (int i = 0; i < n; i++) std::swap(x[i], y[i]); }$/;"	f	namespace:itpp	signature:(const int n, bin *x, bin *y)
swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, bin *x, const int incx, bin *y, const int incy) { for (int i = 0; i < n; i++) std::swap(x[i*incx], y[i*incy]); }$/;"	f	namespace:itpp	signature:(const int n, bin *x, const int incx, bin *y, const int incy)
swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, double *x, const int incx, double *y, const int incy) { for (int i = 0; i < n; i++) std::swap(x[i*incx], y[i*incy]); }$/;"	f	namespace:itpp	signature:(const int n, double *x, const int incx, double *y, const int incy)
swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, double *x, const int incx, double *y,$/;"	f	namespace:itpp	signature:(const int n, double *x, const int incx, double *y, const int incy)
swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, double *x, double *y) { for (int i = 0; i < n; i++) std::swap(x[i], y[i]); }$/;"	f	namespace:itpp	signature:(const int n, double *x, double *y)
swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, double *x, double *y)$/;"	f	namespace:itpp	signature:(const int n, double *x, double *y)
swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, float *x, const int incx, float *y, const int incy) { for (int i = 0; i < n; i++) std::swap(x[i*incx], y[i*incy]); }$/;"	f	namespace:itpp	signature:(const int n, float *x, const int incx, float *y, const int incy)
swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, float *x, float *y) { for (int i = 0; i < n; i++) std::swap(x[i], y[i]); }$/;"	f	namespace:itpp	signature:(const int n, float *x, float *y)
swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, int *x, const int incx, int *y, const int incy) { for (int i = 0; i < n; i++) std::swap(x[i*incx], y[i*incy]); }$/;"	f	namespace:itpp	signature:(const int n, int *x, const int incx, int *y, const int incy)
swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, int *x, int *y) { for (int i = 0; i < n; i++) std::swap(x[i], y[i]); }$/;"	f	namespace:itpp	signature:(const int n, int *x, int *y)
swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, short *x, const int incx, short *y, const int incy) { for (int i = 0; i < n; i++) std::swap(x[i*incx], y[i*incy]); }$/;"	f	namespace:itpp	signature:(const int n, short *x, const int incx, short *y, const int incy)
swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, short *x, short *y) { for (int i = 0; i < n; i++) std::swap(x[i], y[i]); }$/;"	f	namespace:itpp	signature:(const int n, short *x, short *y)
swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, std::complex<double> *x, const int incx, std::complex<double> *y, const int incy) { for (int i = 0; i < n; i++) std::swap(x[i*incx], y[i*incy]); }$/;"	f	namespace:itpp	signature:(const int n, std::complex<double> *x, const int incx, std::complex<double> *y, const int incy)
swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, std::complex<double> *x, const int incx,$/;"	f	namespace:itpp	signature:(const int n, std::complex<double> *x, const int incx, std::complex<double> *y, const int incy)
swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, std::complex<double> *x, std::complex<double> *y) { for (int i = 0; i < n; i++) std::swap(x[i], y[i]); }$/;"	f	namespace:itpp	signature:(const int n, std::complex<double> *x, std::complex<double> *y)
swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, std::complex<double> *x,$/;"	f	namespace:itpp	signature:(const int n, std::complex<double> *x, std::complex<double> *y)
swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, std::complex<float> *x, const int incx, std::complex<float> *y, const int incy) { for (int i = 0; i < n; i++) std::swap(x[i*incx], y[i*incy]); }$/;"	f	namespace:itpp	signature:(const int n, std::complex<float> *x, const int incx, std::complex<float> *y, const int incy)
swap_vector	/usr/include/itpp/base/copy_vector.h	/^inline void swap_vector(const int n, std::complex<float> *x, std::complex<float> *y) { for (int i = 0; i < n; i++) std::swap(x[i], y[i]); }$/;"	f	namespace:itpp	signature:(const int n, std::complex<float> *x, std::complex<float> *y)
swap_vector	/usr/include/itpp/base/copy_vector.h	/^void swap_vector(const int n, T *x, T *y)$/;"	f	namespace:itpp	signature:(const int n, T *x, T *y)
swap_vector	/usr/include/itpp/base/copy_vector.h	/^void swap_vector(const int n, T *x, const int incx, T *y, const int incy)$/;"	f	namespace:itpp	signature:(const int n, T *x, const int incx, T *y, const int incy)
switch_endianity	/usr/include/itpp/base/binfile.h	/^  bool switch_endianity;$/;"	m	class:itpp::bfstream_base	access:protected
symbols	/usr/include/itpp/comm/modulator.h	/^  Vec<T> symbols;$/;"	m	class:itpp::Modulator	access:protected
symbols	/usr/include/itpp/comm/modulator_nd.h	/^  Array<cvec> symbols;$/;"	m	class:itpp::Modulator_NCD	access:protected
symbols	/usr/include/itpp/comm/modulator_nd.h	/^  Array<vec> symbols;$/;"	m	class:itpp::Modulator_NRD	access:protected
syndrome_check	/usr/include/itpp/comm/ldpc.h	/^  bool syndrome_check(const QLLRvec &LLR) const;$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const QLLRvec &LLR) const
syndrome_check	/usr/include/itpp/comm/ldpc.h	/^  bool syndrome_check(const bvec &b) const;$/;"	p	class:itpp::LDPC_Code	access:public	signature:(const bvec &b) const
systematic	/usr/include/itpp/comm/bch.h	/^  const bool systematic;$/;"	m	class:itpp::BCH	access:private
systematic	/usr/include/itpp/comm/reedsolomon.h	/^  const bool systematic;$/;"	m	class:itpp::Reed_Solomon	access:protected
t	/usr/include/itpp/comm/bch.h	/^  int n, k, t;$/;"	m	class:itpp::BCH	access:private
t	/usr/include/itpp/comm/reedsolomon.h	/^  int m, t, k, n, q;$/;"	m	class:itpp::Reed_Solomon	access:protected
t	/usr/include/itpp/protocol/events.h	/^  static Ttype t; \/\/ Current time.$/;"	m	class:itpp::Event_Queue	access:private
tan	/usr/include/itpp/base/math/trig_hyp.h	/^inline mat tan(const mat &x) { return apply_function<double>(std::tan, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
tan	/usr/include/itpp/base/math/trig_hyp.h	/^inline vec tan(const vec &x) { return apply_function<double>(std::tan, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
tanh	/usr/include/itpp/base/math/trig_hyp.h	/^inline mat tanh(const mat &x) { return apply_function<double>(std::tanh, x); }$/;"	f	namespace:itpp	signature:(const mat &x)
tanh	/usr/include/itpp/base/math/trig_hyp.h	/^inline vec tanh(const vec &x) { return apply_function<double>(std::tanh, x); }$/;"	f	namespace:itpp	signature:(const vec &x)
tap_doppler_spectrum	/usr/include/itpp/comm/channel.h	/^  Array<DOPPLER_SPECTRUM> tap_doppler_spectrum; \/\/!< Doppler spectrum for each tap$/;"	m	class:itpp::Channel_Specification	access:protected
tap_doppler_spectrum	/usr/include/itpp/comm/channel.h	/^  Array<DOPPLER_SPECTRUM> tap_doppler_spectrum; \/\/!< Doppler spectrum for each tap$/;"	m	class:itpp::TDL_Channel	access:protected
taps	/usr/include/itpp/comm/channel.h	/^  int taps() const { return N_taps; }$/;"	f	class:itpp::Channel_Specification	access:public	signature:() const
taps	/usr/include/itpp/comm/channel.h	/^  int taps() const { return N_taps; }$/;"	f	class:itpp::TDL_Channel	access:public	signature:() const
tcp_new_data	/usr/include/itpp/protocol/tcp.h	/^  Signal<int> tcp_new_data; \/**< \\brief indicate new data to higher layer *\/$/;"	m	class:itpp::TCP_Receiver	access:public
tcp_receive	/usr/include/itpp/protocol/tcp.h	/^  Slot<TCP_Receiver, itpp::Packet*> tcp_receive;$/;"	m	class:itpp::TCP_Receiver	access:public
tcp_receive_ack	/usr/include/itpp/protocol/tcp.h	/^  Slot<TCP_Sender, itpp::Packet*> tcp_receive_ack;$/;"	m	class:itpp::TCP_Sender	access:public
tcp_receiver_p	/usr/include/itpp/protocol/tcp_client_server.h	/^  TCP_Receiver *tcp_receiver_p;$/;"	m	class:itpp::TCP_Client_Application	access:private
tcp_release	/usr/include/itpp/protocol/tcp.h	/^  Slot<TCP_Receiver, std::string> tcp_release;$/;"	m	class:itpp::TCP_Receiver	access:public
tcp_release	/usr/include/itpp/protocol/tcp.h	/^  Slot<TCP_Sender, std::string> tcp_release;$/;"	m	class:itpp::TCP_Sender	access:public
tcp_send	/usr/include/itpp/protocol/tcp.h	/^  Signal<itpp::Packet*> tcp_send;$/;"	m	class:itpp::TCP_Sender	access:public
tcp_send_ack	/usr/include/itpp/protocol/tcp.h	/^  Signal<itpp::Packet*> tcp_send_ack;$/;"	m	class:itpp::TCP_Receiver	access:public
tcp_sender_p	/usr/include/itpp/protocol/tcp_client_server.h	/^  TCP_Sender *tcp_sender_p;$/;"	m	class:itpp::TCP_Client_Application	access:private
tcp_socket_write	/usr/include/itpp/protocol/tcp.h	/^  Slot<TCP_Sender, itpp::Packet*> tcp_socket_write;$/;"	m	class:itpp::TCP_Sender	access:public
tell_read	/usr/include/itpp/srccode/audiofile.h	/^  int tell_read();$/;"	p	class:itpp::SND_In_File	access:public	signature:()
tell_write	/usr/include/itpp/srccode/audiofile.h	/^  int tell_write();$/;"	p	class:itpp::SND_Out_File	access:public	signature:()
tempvec	/usr/include/itpp/comm/interleave.h	/^  Vec<T> tempvec, zerostemp;$/;"	m	class:itpp::Cross_Interleaver	access:private
terminated	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  bool terminated;$/;"	m	class:itpp::Rec_Syst_Conv_Code	access:private
tgamma	/usr/include/itpp/base/math/elem_math.h	/^double tgamma(double x);$/;"	p	signature:(double x)
th1	/usr/include/itpp/comm/channel.h	/^  vec f1, f2, c1, c2, th1, th2;$/;"	m	class:itpp::Rice_Fading_Generator	access:protected
th2	/usr/include/itpp/comm/channel.h	/^  vec f1, f2, c1, c2, th1, th2;$/;"	m	class:itpp::Rice_Fading_Generator	access:protected
theta	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Sawtooth_Source	access:private
theta	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Sine_Source	access:private
theta	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Square_Source	access:private
theta	/usr/include/itpp/signal/source.h	/^  double m, A, theta, dtheta;$/;"	m	class:itpp::Triangle_Source	access:private
tic	/usr/include/itpp/base/timing.h	/^  void tic(void);$/;"	p	class:itpp::Timer	access:public	signature:(void)
tic	/usr/include/itpp/base/timing.h	/^void tic();$/;"	p	namespace:itpp	signature:()
time_offset	/usr/include/itpp/comm/channel.h	/^  double time_offset; \/\/!< Time offset in samples (time state in the generator)$/;"	m	class:itpp::Correlated_Fading_Generator	access:protected
time_out	/usr/include/itpp/protocol/selective_repeat.h	/^  Ttype time_out;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
time_out_signal	/usr/include/itpp/protocol/signals_slots.h	/^  Signal<DataType> *time_out_signal;$/;"	m	class:itpp::ATimer	access:private
time_out_slot	/usr/include/itpp/protocol/signals_slots.h	/^  Slot<ObjectType, DataType> *time_out_slot;$/;"	m	class:itpp::ATimer	access:private
timer	/usr/include/itpp/protocol/selective_repeat.h	/^  Array<ATimer<Selective_Repeat_ARQ_Sender, int> > timer;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
timestamp	/usr/include/itpp/protocol/packet.h	/^  Ttype timestamp;$/;"	m	class:itpp::L3_Packet_Info	access:public
tmpvec	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  vec tmpvec;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:private
tmpvecD	/usr/include/itpp/stat/mog_diag_em.h	/^  vec tmpvecD;$/;"	m	class:itpp::MOG_diag_EM_sup	access:private
tmpvecD	/usr/include/itpp/stat/mog_generic.h	/^  vec tmpvecD;$/;"	m	class:itpp::MOG_generic	access:private
tmpvecK	/usr/include/itpp/stat/mog_diag.h	/^  vec tmpvecK;$/;"	m	class:itpp::MOG_diag	access:private
tmpvecK	/usr/include/itpp/stat/mog_diag_em.h	/^  vec tmpvecK;$/;"	m	class:itpp::MOG_diag_EM_sup	access:private
tmpvecK	/usr/include/itpp/stat/mog_generic.h	/^  vec tmpvecK;$/;"	m	class:itpp::MOG_generic	access:private
to	/usr/include/itpp/fixed/fix_functions.h	/^Array<typename ConvertU2T<T, U>::result> to(const Array<U> &real, const Array<U> &imag)$/;"	f	namespace:itpp	signature:(const Array<U> &real, const Array<U> &imag)
to	/usr/include/itpp/fixed/fix_functions.h	/^Array<typename ConvertU2T<T, U>::result> to(const Array<U> &x)$/;"	f	namespace:itpp	signature:(const Array<U> &x)
to	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline cfixmat to<CFix>(const cfixmat &x) {return x;}$/;"	f	namespace:itpp	signature:(const cfixmat &x)
to	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline cfixvec to<CFix>(const cfixvec &x) {return x;}$/;"	f	namespace:itpp	signature:(const cfixvec &x)
to	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline cmat to<std::complex<double> >(const cmat &x) {return x;}$/;"	f	namespace:itpp	signature:(const cmat &x)
to	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline cvec to<std::complex<double> >(const cvec &x) {return x;}$/;"	f	namespace:itpp	signature:(const cvec &x)
to	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline fixmat to<Fix>(const fixmat &x) {return x;}$/;"	f	namespace:itpp	signature:(const fixmat &x)
to	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline fixvec to<Fix>(const fixvec &x) {return x;}$/;"	f	namespace:itpp	signature:(const fixvec &x)
to	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline mat to<double>(const mat &x) {return x;}$/;"	f	namespace:itpp	signature:(const mat &x)
to	/usr/include/itpp/fixed/fix_functions.h	/^template<> inline vec to<double>(const vec &x) {return x;}$/;"	f	namespace:itpp	signature:(const vec &x)
to	/usr/include/itpp/fixed/fix_functions.h	/^template<class T, class U> Mat<T> to(const Mat<U> &real, const Mat<U> &imag)$/;"	f	namespace:itpp	signature:(const Mat<U> &real, const Mat<U> &imag)
to	/usr/include/itpp/fixed/fix_functions.h	/^template<class T, class U> Mat<T> to(const Mat<U> &x)$/;"	f	namespace:itpp	signature:(const Mat<U> &x)
to	/usr/include/itpp/fixed/fix_functions.h	/^template<class T, class U> Vec<T> to(const Vec<U> &real, const Vec<U> &imag)$/;"	f	namespace:itpp	signature:(const Vec<U> &real, const Vec<U> &imag)
to	/usr/include/itpp/fixed/fix_functions.h	/^template<class T, class U> Vec<T> to(const Vec<U> &x)$/;"	f	namespace:itpp	signature:(const Vec<U> &x)
to	/usr/include/itpp/fixed/fix_functions.h	/^template<class T> inline T to(const CFix &x) {return T(x);}$/;"	f	namespace:itpp	signature:(const CFix &x)
to	/usr/include/itpp/fixed/fix_functions.h	/^template<class T> inline T to(const Fix &real, const Fix &imag) {return T(real, imag);}$/;"	f	namespace:itpp	signature:(const Fix &real, const Fix &imag)
to	/usr/include/itpp/fixed/fix_functions.h	/^template<class T> inline T to(const Fix &x) {return T(x);}$/;"	f	namespace:itpp	signature:(const Fix &x)
to	/usr/include/itpp/fixed/fix_functions.h	/^template<class T> inline T to(const std::complex<double> &x) {return T(x);}$/;"	f	namespace:itpp	signature:(const std::complex<double> &x)
to	/usr/include/itpp/fixed/fix_functions.h	/^template<class T> inline T to(double real, double imag) {return T(real, imag);}$/;"	f	namespace:itpp	signature:(double real, double imag)
to	/usr/include/itpp/fixed/fix_functions.h	/^template<class T> inline T to(double x) {return T(x);}$/;"	f	namespace:itpp	signature:(double x)
to_bmat	/usr/include/itpp/base/converters.h	/^bmat to_bmat(const Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
to_bmat	/usr/include/itpp/base/converters.h	/^extern template bmat to_bmat(const imat &m);$/;"	p	namespace:itpp	signature:(const imat &m)
to_bmat	/usr/include/itpp/base/converters.h	/^extern template bmat to_bmat(const smat &m);$/;"	p	namespace:itpp	signature:(const smat &m)
to_bvec	/usr/include/itpp/base/converters.h	/^bvec to_bvec(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
to_bvec	/usr/include/itpp/base/converters.h	/^extern template bvec to_bvec(const ivec &v);$/;"	p	namespace:itpp	signature:(const ivec &v)
to_bvec	/usr/include/itpp/base/converters.h	/^extern template bvec to_bvec(const svec &v);$/;"	p	namespace:itpp	signature:(const svec &v)
to_cmat	/usr/include/itpp/base/converters.h	/^cmat to_cmat(const Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
to_cmat	/usr/include/itpp/base/converters.h	/^cmat to_cmat(const Mat<T> &real, const Mat<T> &imag)$/;"	f	namespace:itpp	signature:(const Mat<T> &real, const Mat<T> &imag)
to_cmat	/usr/include/itpp/base/converters.h	/^cmat to_cmat(const cmat& m)$/;"	f	namespace:itpp	signature:(const cmat& m)
to_cmat	/usr/include/itpp/base/converters.h	/^extern template cmat to_cmat(const bmat &m);$/;"	p	namespace:itpp	signature:(const bmat &m)
to_cmat	/usr/include/itpp/base/converters.h	/^extern template cmat to_cmat(const bmat &real, const bmat &imag);$/;"	p	namespace:itpp	signature:(const bmat &real, const bmat &imag)
to_cmat	/usr/include/itpp/base/converters.h	/^extern template cmat to_cmat(const imat &m);$/;"	p	namespace:itpp	signature:(const imat &m)
to_cmat	/usr/include/itpp/base/converters.h	/^extern template cmat to_cmat(const imat &real, const imat &imag);$/;"	p	namespace:itpp	signature:(const imat &real, const imat &imag)
to_cmat	/usr/include/itpp/base/converters.h	/^extern template cmat to_cmat(const mat &m);$/;"	p	namespace:itpp	signature:(const mat &m)
to_cmat	/usr/include/itpp/base/converters.h	/^extern template cmat to_cmat(const mat &real, const mat &imag);$/;"	p	namespace:itpp	signature:(const mat &real, const mat &imag)
to_cmat	/usr/include/itpp/base/converters.h	/^extern template cmat to_cmat(const smat &m);$/;"	p	namespace:itpp	signature:(const smat &m)
to_cmat	/usr/include/itpp/base/converters.h	/^extern template cmat to_cmat(const smat &real, const smat &imag);$/;"	p	namespace:itpp	signature:(const smat &real, const smat &imag)
to_cmat	/usr/include/itpp/fixed/fix_functions.h	/^cmat to_cmat(const cfixmat &m);$/;"	p	namespace:itpp	signature:(const cfixmat &m)
to_cvec	/usr/include/itpp/base/converters.h	/^cvec to_cvec(const Vec<T> &real, const Vec<T> &imag)$/;"	f	namespace:itpp	signature:(const Vec<T> &real, const Vec<T> &imag)
to_cvec	/usr/include/itpp/base/converters.h	/^cvec to_cvec(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
to_cvec	/usr/include/itpp/base/converters.h	/^cvec to_cvec(const cvec& v)$/;"	f	namespace:itpp	signature:(const cvec& v)
to_cvec	/usr/include/itpp/base/converters.h	/^cvec to_cvec(double real, double imag);$/;"	p	namespace:itpp	signature:(double real, double imag)
to_cvec	/usr/include/itpp/base/converters.h	/^extern template cvec to_cvec(const bvec &real, const bvec &imag);$/;"	p	namespace:itpp	signature:(const bvec &real, const bvec &imag)
to_cvec	/usr/include/itpp/base/converters.h	/^extern template cvec to_cvec(const bvec &v);$/;"	p	namespace:itpp	signature:(const bvec &v)
to_cvec	/usr/include/itpp/base/converters.h	/^extern template cvec to_cvec(const ivec &real, const ivec &imag);$/;"	p	namespace:itpp	signature:(const ivec &real, const ivec &imag)
to_cvec	/usr/include/itpp/base/converters.h	/^extern template cvec to_cvec(const ivec &v);$/;"	p	namespace:itpp	signature:(const ivec &v)
to_cvec	/usr/include/itpp/base/converters.h	/^extern template cvec to_cvec(const svec &real, const svec &imag);$/;"	p	namespace:itpp	signature:(const svec &real, const svec &imag)
to_cvec	/usr/include/itpp/base/converters.h	/^extern template cvec to_cvec(const svec &v);$/;"	p	namespace:itpp	signature:(const svec &v)
to_cvec	/usr/include/itpp/base/converters.h	/^extern template cvec to_cvec(const vec &real, const vec &imag);$/;"	p	namespace:itpp	signature:(const vec &real, const vec &imag)
to_cvec	/usr/include/itpp/base/converters.h	/^extern template cvec to_cvec(const vec &v);$/;"	p	namespace:itpp	signature:(const vec &v)
to_cvec	/usr/include/itpp/fixed/fix_functions.h	/^cvec to_cvec(const cfixvec &v);$/;"	p	namespace:itpp	signature:(const cfixvec &v)
to_double	/usr/include/itpp/comm/llr.h	/^  double to_double(QLLR l) const;$/;"	p	class:itpp::LLR_calc_unit	access:public	signature:(QLLR l) const
to_double	/usr/include/itpp/comm/llr.h	/^  mat to_double(const QLLRmat &l) const;$/;"	p	class:itpp::LLR_calc_unit	access:public	signature:(const QLLRmat &l) const
to_double	/usr/include/itpp/comm/llr.h	/^  vec to_double(const QLLRvec &l) const;$/;"	p	class:itpp::LLR_calc_unit	access:public	signature:(const QLLRvec &l) const
to_double	/usr/include/itpp/comm/llr.h	/^inline double LLR_calc_unit::to_double(QLLR l) const$/;"	f	class:itpp::LLR_calc_unit	signature:(QLLR l) const
to_double	/usr/include/itpp/fixed/fix_functions.h	/^  typedef Array<typename Convert<T>::to_double> to_double;  \/\/ Recursive$/;"	t	class:itpp::Convert	access:public
to_double	/usr/include/itpp/fixed/fix_functions.h	/^  typedef Mat<typename Convert<T>::to_double> to_double;  \/\/ Recursive$/;"	t	class:itpp::Convert	access:public
to_double	/usr/include/itpp/fixed/fix_functions.h	/^  typedef Vec<typename Convert<T>::to_double> to_double;  \/\/ Recursive$/;"	t	class:itpp::Convert	access:public
to_double	/usr/include/itpp/fixed/fix_functions.h	/^  typedef double to_double;$/;"	t	class:itpp::Convert	access:public
to_double	/usr/include/itpp/fixed/fix_functions.h	/^  typedef std::complex<double> to_double;$/;"	t	class:itpp::Convert	access:public
to_imat	/usr/include/itpp/base/converters.h	/^extern template imat to_imat(const bmat &m);$/;"	p	namespace:itpp	signature:(const bmat &m)
to_imat	/usr/include/itpp/base/converters.h	/^extern template imat to_imat(const mat &m);$/;"	p	namespace:itpp	signature:(const mat &m)
to_imat	/usr/include/itpp/base/converters.h	/^extern template imat to_imat(const smat &m);$/;"	p	namespace:itpp	signature:(const smat &m)
to_imat	/usr/include/itpp/base/converters.h	/^imat to_imat(const Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
to_ivec	/usr/include/itpp/base/converters.h	/^extern template ivec to_ivec(const bvec &v);$/;"	p	namespace:itpp	signature:(const bvec &v)
to_ivec	/usr/include/itpp/base/converters.h	/^extern template ivec to_ivec(const svec &v);$/;"	p	namespace:itpp	signature:(const svec &v)
to_ivec	/usr/include/itpp/base/converters.h	/^extern template ivec to_ivec(const vec &v);$/;"	p	namespace:itpp	signature:(const vec &v)
to_ivec	/usr/include/itpp/base/converters.h	/^ivec to_ivec(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
to_ivec	/usr/include/itpp/base/converters.h	/^ivec to_ivec(int s);$/;"	p	namespace:itpp	signature:(int s)
to_mat	/usr/include/itpp/base/converters.h	/^extern template mat to_mat(const bmat &m);$/;"	p	namespace:itpp	signature:(const bmat &m)
to_mat	/usr/include/itpp/base/converters.h	/^extern template mat to_mat(const imat &m);$/;"	p	namespace:itpp	signature:(const imat &m)
to_mat	/usr/include/itpp/base/converters.h	/^extern template mat to_mat(const smat &m);$/;"	p	namespace:itpp	signature:(const smat &m)
to_mat	/usr/include/itpp/base/converters.h	/^mat to_mat(const Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
to_mat	/usr/include/itpp/fixed/fix_functions.h	/^mat to_mat(const fixmat &m);$/;"	p	namespace:itpp	signature:(const fixmat &m)
to_qllr	/usr/include/itpp/comm/llr.h	/^  QLLR to_qllr(double l) const;$/;"	p	class:itpp::LLR_calc_unit	access:public	signature:(double l) const
to_qllr	/usr/include/itpp/comm/llr.h	/^  QLLRmat to_qllr(const mat &l) const;$/;"	p	class:itpp::LLR_calc_unit	access:public	signature:(const mat &l) const
to_qllr	/usr/include/itpp/comm/llr.h	/^  QLLRvec to_qllr(const vec &l) const;$/;"	p	class:itpp::LLR_calc_unit	access:public	signature:(const vec &l) const
to_qllr	/usr/include/itpp/comm/llr.h	/^inline QLLR LLR_calc_unit::to_qllr(double l) const$/;"	f	class:itpp::LLR_calc_unit	signature:(double l) const
to_smat	/usr/include/itpp/base/converters.h	/^extern template smat to_smat(const bmat &m);$/;"	p	namespace:itpp	signature:(const bmat &m)
to_smat	/usr/include/itpp/base/converters.h	/^extern template smat to_smat(const imat &m);$/;"	p	namespace:itpp	signature:(const imat &m)
to_smat	/usr/include/itpp/base/converters.h	/^extern template smat to_smat(const mat &m);$/;"	p	namespace:itpp	signature:(const mat &m)
to_smat	/usr/include/itpp/base/converters.h	/^smat to_smat(const Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
to_sparse	/usr/include/itpp/base/gf2mat.h	/^  GF2mat_sparse to_sparse(bool transpose = false) const;$/;"	p	class:itpp::GF2mat_sparse_alist	access:public	signature:(bool transpose = false) const
to_str	/usr/include/itpp/base/converters.h	/^std::string to_str(const T &i)$/;"	f	namespace:itpp	signature:(const T &i)
to_str	/usr/include/itpp/base/converters.h	/^std::string to_str(const T &i);$/;"	p	namespace:itpp	signature:(const T &i)
to_str	/usr/include/itpp/base/converters.h	/^std::string to_str(const double &i, const int precision);$/;"	p	namespace:itpp	signature:(const double &i, const int precision)
to_svec	/usr/include/itpp/base/converters.h	/^extern template svec to_svec(const bvec &v);$/;"	p	namespace:itpp	signature:(const bvec &v)
to_svec	/usr/include/itpp/base/converters.h	/^extern template svec to_svec(const ivec &v);$/;"	p	namespace:itpp	signature:(const ivec &v)
to_svec	/usr/include/itpp/base/converters.h	/^extern template svec to_svec(const vec &v);$/;"	p	namespace:itpp	signature:(const vec &v)
to_svec	/usr/include/itpp/base/converters.h	/^svec to_svec(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
to_vec	/usr/include/itpp/base/converters.h	/^extern template vec to_vec(const bvec &v);$/;"	p	namespace:itpp	signature:(const bvec &v)
to_vec	/usr/include/itpp/base/converters.h	/^extern template vec to_vec(const ivec &v);$/;"	p	namespace:itpp	signature:(const ivec &v)
to_vec	/usr/include/itpp/base/converters.h	/^extern template vec to_vec(const svec &v);$/;"	p	namespace:itpp	signature:(const svec &v)
to_vec	/usr/include/itpp/base/converters.h	/^vec to_vec(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
to_vec	/usr/include/itpp/base/converters.h	/^vec to_vec(double s);$/;"	p	namespace:itpp	signature:(double s)
to_vec	/usr/include/itpp/fixed/fix_functions.h	/^vec to_vec(const fixvec &v);$/;"	p	namespace:itpp	signature:(const fixvec &v)
toc	/usr/include/itpp/base/timing.h	/^  double toc(void);$/;"	p	class:itpp::Timer	access:public	signature:(void)
toc	/usr/include/itpp/base/timing.h	/^double toc();$/;"	p	namespace:itpp	signature:()
toc_print	/usr/include/itpp/base/timing.h	/^  void toc_print(void);$/;"	p	class:itpp::Timer	access:public	signature:(void)
toc_print	/usr/include/itpp/base/timing.h	/^void toc_print();$/;"	p	namespace:itpp	signature:()
toeplitz	/usr/include/itpp/base/specmat.h	/^const Mat<Num_T> toeplitz(const Vec<Num_T> &c)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &c)
toeplitz	/usr/include/itpp/base/specmat.h	/^const Mat<Num_T> toeplitz(const Vec<Num_T> &c, const Vec<Num_T> &r)$/;"	f	namespace:itpp	signature:(const Vec<Num_T> &c, const Vec<Num_T> &r)
toeplitz	/usr/include/itpp/base/specmat.h	/^const cmat toeplitz(const cvec &c);$/;"	p	namespace:itpp	signature:(const cvec &c)
total	/usr/include/itpp/comm/punct_convcode.h	/^  int total;$/;"	m	class:itpp::Punctured_Convolutional_Code	access:protected
trace	/usr/include/itpp/base/matfunc.h	/^T trace(const Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
trace	/usr/include/itpp/base/matfunc.h	/^extern template bin trace(const bmat &in);$/;"	p	namespace:itpp	signature:(const bmat &in)
trace	/usr/include/itpp/base/matfunc.h	/^extern template double trace(const mat &in);$/;"	p	namespace:itpp	signature:(const mat &in)
trace	/usr/include/itpp/base/matfunc.h	/^extern template int trace(const imat &in);$/;"	p	namespace:itpp	signature:(const imat &in)
trace	/usr/include/itpp/base/matfunc.h	/^extern template short trace(const smat &in);$/;"	p	namespace:itpp	signature:(const smat &in)
trace	/usr/include/itpp/base/matfunc.h	/^extern template std::complex<double> trace(const cmat &in);$/;"	p	namespace:itpp	signature:(const cmat &in)
trace	/usr/include/itpp/optim/newton_search.h	/^  bool init, finished, trace;$/;"	m	class:itpp::Newton_Search	access:private
trace	/usr/include/itpp/optim/newton_search.h	/^  bool trace; \/\/ true if trace is enabled$/;"	m	class:itpp::Line_Search	access:private
trans_mult	/usr/include/itpp/base/smat.h	/^  friend Mat<T> trans_mult <>(const Sparse_Mat<T> &m);$/;"	p	class:itpp::Sparse_Mat	access:friend	signature:(const Sparse_Mat<T> &m)
trans_mult	/usr/include/itpp/base/smat.h	/^  friend Sparse_Mat<T> trans_mult <>(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2);$/;"	p	class:itpp::Sparse_Mat	access:friend	signature:(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)
trans_mult	/usr/include/itpp/base/smat.h	/^  friend Vec<T> trans_mult <>(const Sparse_Mat<T> &m, const Vec<T> &v);$/;"	p	class:itpp::Sparse_Mat	access:friend	signature:(const Sparse_Mat<T> &m, const Vec<T> &v)
trans_mult	/usr/include/itpp/base/smat.h	/^Mat<T> trans_mult(const Sparse_Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Sparse_Mat<T> &m)
trans_mult	/usr/include/itpp/base/smat.h	/^Mat<T> trans_mult(const Sparse_Mat<T> &m);$/;"	p	namespace:itpp	signature:(const Sparse_Mat<T> &m)
trans_mult	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> trans_mult(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)$/;"	f	namespace:itpp	signature:(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)
trans_mult	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> trans_mult(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2);$/;"	p	namespace:itpp	signature:(const Sparse_Mat<T> &m1, const Sparse_Mat<T> &m2)
trans_mult	/usr/include/itpp/base/smat.h	/^Vec<T> trans_mult(const Sparse_Mat<T> &m, const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Sparse_Mat<T> &m, const Vec<T> &v)
trans_mult	/usr/include/itpp/base/smat.h	/^Vec<T> trans_mult(const Sparse_Mat<T> &m, const Vec<T> &v);$/;"	p	namespace:itpp	signature:(const Sparse_Mat<T> &m, const Vec<T> &v)
trans_mult	/usr/include/itpp/base/smat.h	/^extern template cmat trans_mult(const sparse_cmat &);$/;"	p	namespace:itpp	signature:(const sparse_cmat &)
trans_mult	/usr/include/itpp/base/smat.h	/^extern template cvec trans_mult(const sparse_cmat &, const cvec &);$/;"	p	namespace:itpp	signature:(const sparse_cmat &, const cvec &)
trans_mult	/usr/include/itpp/base/smat.h	/^extern template imat trans_mult(const sparse_imat &);$/;"	p	namespace:itpp	signature:(const sparse_imat &)
trans_mult	/usr/include/itpp/base/smat.h	/^extern template ivec trans_mult(const sparse_imat &, const ivec &);$/;"	p	namespace:itpp	signature:(const sparse_imat &, const ivec &)
trans_mult	/usr/include/itpp/base/smat.h	/^extern template mat trans_mult(const sparse_mat &);$/;"	p	namespace:itpp	signature:(const sparse_mat &)
trans_mult	/usr/include/itpp/base/smat.h	/^extern template sparse_cmat trans_mult(const sparse_cmat &, const sparse_cmat &);$/;"	p	namespace:itpp	signature:(const sparse_cmat &, const sparse_cmat &)
trans_mult	/usr/include/itpp/base/smat.h	/^extern template sparse_imat trans_mult(const sparse_imat &, const sparse_imat &);$/;"	p	namespace:itpp	signature:(const sparse_imat &, const sparse_imat &)
trans_mult	/usr/include/itpp/base/smat.h	/^extern template sparse_mat trans_mult(const sparse_mat &, const sparse_mat &);$/;"	p	namespace:itpp	signature:(const sparse_mat &, const sparse_mat &)
trans_mult	/usr/include/itpp/base/smat.h	/^extern template vec trans_mult(const sparse_mat &, const vec &);$/;"	p	namespace:itpp	signature:(const sparse_mat &, const vec &)
trans_mult_s	/usr/include/itpp/base/smat.h	/^  friend Sparse_Mat<T> trans_mult_s <>(const Sparse_Mat<T> &m);$/;"	p	class:itpp::Sparse_Mat	access:friend	signature:(const Sparse_Mat<T> &m)
trans_mult_s	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> trans_mult_s(const Sparse_Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Sparse_Mat<T> &m)
trans_mult_s	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> trans_mult_s(const Sparse_Mat<T> &m);$/;"	p	namespace:itpp	signature:(const Sparse_Mat<T> &m)
trans_mult_s	/usr/include/itpp/base/smat.h	/^extern template sparse_cmat trans_mult_s(const sparse_cmat &);$/;"	p	namespace:itpp	signature:(const sparse_cmat &)
trans_mult_s	/usr/include/itpp/base/smat.h	/^extern template sparse_imat trans_mult_s(const sparse_imat &);$/;"	p	namespace:itpp	signature:(const sparse_imat &)
trans_mult_s	/usr/include/itpp/base/smat.h	/^extern template sparse_mat trans_mult_s(const sparse_mat &);$/;"	p	namespace:itpp	signature:(const sparse_mat &)
transpose	/usr/include/itpp/base/gf2mat.h	/^  GF2mat transpose() const;$/;"	p	class:itpp::GF2mat	access:public	signature:() const
transpose	/usr/include/itpp/base/mat.h	/^  Mat<Num_T> transpose() const;$/;"	p	class:itpp::Mat	access:public	signature:() const
transpose	/usr/include/itpp/base/mat.h	/^Mat<Num_T> Mat<Num_T>::transpose() const$/;"	f	class:itpp::Mat	signature:() const
transpose	/usr/include/itpp/base/matfunc.h	/^Mat<T> transpose(const Mat<T> &m) { return m.T(); }$/;"	f	namespace:itpp	signature:(const Mat<T> &m)
transpose	/usr/include/itpp/base/matfunc.h	/^extern template bmat transpose(const bmat &m);$/;"	p	namespace:itpp	signature:(const bmat &m)
transpose	/usr/include/itpp/base/matfunc.h	/^extern template cmat transpose(const cmat &m);$/;"	p	namespace:itpp	signature:(const cmat &m)
transpose	/usr/include/itpp/base/matfunc.h	/^extern template imat transpose(const imat &m);$/;"	p	namespace:itpp	signature:(const imat &m)
transpose	/usr/include/itpp/base/matfunc.h	/^extern template mat transpose(const mat &m);$/;"	p	namespace:itpp	signature:(const mat &m)
transpose	/usr/include/itpp/base/matfunc.h	/^extern template smat transpose(const smat &m);$/;"	p	namespace:itpp	signature:(const smat &m)
transpose	/usr/include/itpp/base/matfunc.h	/^extern template void transpose(const bmat &m, bmat &out);$/;"	p	namespace:itpp	signature:(const bmat &m, bmat &out)
transpose	/usr/include/itpp/base/matfunc.h	/^extern template void transpose(const cmat &m, cmat &out);$/;"	p	namespace:itpp	signature:(const cmat &m, cmat &out)
transpose	/usr/include/itpp/base/matfunc.h	/^extern template void transpose(const imat &m, imat &out);$/;"	p	namespace:itpp	signature:(const imat &m, imat &out)
transpose	/usr/include/itpp/base/matfunc.h	/^extern template void transpose(const mat &m, mat &out);$/;"	p	namespace:itpp	signature:(const mat &m, mat &out)
transpose	/usr/include/itpp/base/matfunc.h	/^extern template void transpose(const smat &m, smat &out);$/;"	p	namespace:itpp	signature:(const smat &m, smat &out)
transpose	/usr/include/itpp/base/matfunc.h	/^void transpose(const Mat<T> &m, Mat<T> &out) { out = m.T(); }$/;"	f	namespace:itpp	signature:(const Mat<T> &m, Mat<T> &out)
transpose	/usr/include/itpp/base/smat.h	/^  Sparse_Mat<T> transpose() const;$/;"	p	class:itpp::Sparse_Mat	access:public	signature:() const
transpose	/usr/include/itpp/base/smat.h	/^  void transpose(Sparse_Mat<T> &m) const;$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(Sparse_Mat<T> &m) const
transpose	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T> Sparse_Mat<T>::transpose() const$/;"	f	class:itpp::Sparse_Mat	signature:() const
transpose	/usr/include/itpp/base/smat.h	/^inline Sparse_Mat<T> transpose(const Sparse_Mat<T> &s)$/;"	f	namespace:itpp	signature:(const Sparse_Mat<T> &s)
transpose	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::transpose(Sparse_Mat<T> &m) const$/;"	f	class:itpp::Sparse_Mat	signature:(Sparse_Mat<T> &m) const
transpose	/usr/include/itpp/base/vec.h	/^  Mat<Num_T> transpose() const;$/;"	p	class:itpp::Vec	access:public	signature:() const
transpose	/usr/include/itpp/base/vec.h	/^Mat<Num_T> Vec<Num_T>::transpose() const$/;"	f	class:itpp::Vec	signature:() const
trials_cnt	/usr/include/itpp/stat/histogram.h	/^  int trials_cnt;$/;"	m	class:itpp::Histogram	access:private
trials_num	/usr/include/itpp/stat/histogram.h	/^  int trials_num() const {return trials_cnt;};$/;"	f	class:itpp::Histogram	access:public	signature:() const
triang	/usr/include/itpp/signal/window.h	/^vec triang(int n);$/;"	p	namespace:itpp	signature:(int n)
tridiag	/usr/include/itpp/base/matfunc.h	/^Mat<T> tridiag(const Vec<T> &main, const Vec<T> &sup, const Vec<T> &sub)$/;"	f	namespace:itpp	signature:(const Vec<T> &main, const Vec<T> &sup, const Vec<T> &sub)
tridiag	/usr/include/itpp/base/matfunc.h	/^extern template cmat tridiag(const cvec &main, const cvec &, const cvec &);$/;"	p	namespace:itpp	signature:(const cvec &main, const cvec &, const cvec &)
tridiag	/usr/include/itpp/base/matfunc.h	/^extern template mat tridiag(const vec &main, const vec &, const vec &);$/;"	p	namespace:itpp	signature:(const vec &main, const vec &, const vec &)
tridiag	/usr/include/itpp/base/matfunc.h	/^extern template void tridiag(const cmat &m, cvec &, cvec &, cvec &);$/;"	p	namespace:itpp	signature:(const cmat &m, cvec &, cvec &, cvec &)
tridiag	/usr/include/itpp/base/matfunc.h	/^extern template void tridiag(const cvec &main, const cvec &, const cvec &, cmat &);$/;"	p	namespace:itpp	signature:(const cvec &main, const cvec &, const cvec &, cmat &)
tridiag	/usr/include/itpp/base/matfunc.h	/^extern template void tridiag(const mat &m, vec &, vec &, vec &);$/;"	p	namespace:itpp	signature:(const mat &m, vec &, vec &, vec &)
tridiag	/usr/include/itpp/base/matfunc.h	/^extern template void tridiag(const vec &main, const vec &, const vec &, mat &);$/;"	p	namespace:itpp	signature:(const vec &main, const vec &, const vec &, mat &)
tridiag	/usr/include/itpp/base/matfunc.h	/^void tridiag(const Mat<T> &m, Vec<T> &main, Vec<T> &sup, Vec<T> &sub)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, Vec<T> &main, Vec<T> &sup, Vec<T> &sub)
tridiag	/usr/include/itpp/base/matfunc.h	/^void tridiag(const Vec<T> &main, const Vec<T> &sup, const Vec<T> &sub, Mat<T> &m)$/;"	f	namespace:itpp	signature:(const Vec<T> &main, const Vec<T> &sup, const Vec<T> &sub, Mat<T> &m)
trigger	/usr/include/itpp/protocol/signals_slots.h	/^  void trigger(DataType u);$/;"	p	class:itpp::Signal	access:public	signature:(DataType u)
trigger	/usr/include/itpp/protocol/signals_slots.h	/^void Signal<DataType>::trigger(DataType u)$/;"	f	class:itpp::Signal	signature:(DataType u)
trunc_exp	/usr/include/itpp/base/math/log_exp.h	/^inline double trunc_exp(double x)$/;"	f	namespace:itpp	signature:(double x)
trunc_length	/usr/include/itpp/comm/convcode.h	/^  int trunc_length;$/;"	m	class:itpp::Convolutional_Code	access:protected
trunc_log	/usr/include/itpp/base/math/log_exp.h	/^inline double trunc_log(double x)$/;"	f	namespace:itpp	signature:(double x)
trunc_ptr	/usr/include/itpp/comm/convcode.h	/^  int trunc_ptr;$/;"	m	class:itpp::Convolutional_Code	access:protected
trunc_state	/usr/include/itpp/comm/convcode.h	/^  int trunc_state;$/;"	m	class:itpp::Convolutional_Code	access:protected
trust	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  double trust;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:protected
twist	/usr/include/itpp/base/random.h	/^  unsigned int twist(const unsigned int& m, const unsigned int& s0,$/;"	f	class:itpp::Random_Generator	access:private	signature:(const unsigned int& m, const unsigned int& s0, const unsigned int& s1) const
tx_last	/usr/include/itpp/protocol/selective_repeat.h	/^  int tx_last;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
tx_next	/usr/include/itpp/protocol/selective_repeat.h	/^  int tx_next;$/;"	m	class:itpp::Selective_Repeat_ARQ_Sender	access:private
type	/usr/include/itpp/base/itfile.h	/^    std::string type;$/;"	m	struct:itpp::it_file_base::data_header	access:public
type	/usr/include/itpp/base/itfile.h	/^    std::string type;$/;"	m	struct:itpp::it_file_base_old::data_header	access:public
type	/usr/include/itpp/comm/ldpc.h	/^  std::string type;  \/\/!< Generator type$/;"	m	class:itpp::LDPC_Generator	access:protected
u	/usr/include/itpp/comm/channel.h	/^  Uniform_RNG u;$/;"	m	class:itpp::BSC	access:private
u	/usr/include/itpp/protocol/events.h	/^  DataType u; \/\/ User data.$/;"	m	class:itpp::Data_Event	access:private
ufixed1	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<1, US, WRAP> ufixed1;$/;"	t	namespace:itpp
ufixed10	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<10, US, WRAP> ufixed10;$/;"	t	namespace:itpp
ufixed11	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<11, US, WRAP> ufixed11;$/;"	t	namespace:itpp
ufixed12	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<12, US, WRAP> ufixed12;$/;"	t	namespace:itpp
ufixed13	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<13, US, WRAP> ufixed13;$/;"	t	namespace:itpp
ufixed14	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<14, US, WRAP> ufixed14;$/;"	t	namespace:itpp
ufixed15	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<15, US, WRAP> ufixed15;$/;"	t	namespace:itpp
ufixed16	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<16, US, WRAP> ufixed16;$/;"	t	namespace:itpp
ufixed17	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<17, US, WRAP> ufixed17;$/;"	t	namespace:itpp
ufixed18	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<18, US, WRAP> ufixed18;$/;"	t	namespace:itpp
ufixed19	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<19, US, WRAP> ufixed19;$/;"	t	namespace:itpp
ufixed2	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<2, US, WRAP> ufixed2;$/;"	t	namespace:itpp
ufixed20	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<20, US, WRAP> ufixed20;$/;"	t	namespace:itpp
ufixed21	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<21, US, WRAP> ufixed21;$/;"	t	namespace:itpp
ufixed22	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<22, US, WRAP> ufixed22;$/;"	t	namespace:itpp
ufixed23	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<23, US, WRAP> ufixed23;$/;"	t	namespace:itpp
ufixed24	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<24, US, WRAP> ufixed24;$/;"	t	namespace:itpp
ufixed25	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<25, US, WRAP> ufixed25;$/;"	t	namespace:itpp
ufixed26	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<26, US, WRAP> ufixed26;$/;"	t	namespace:itpp
ufixed27	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<27, US, WRAP> ufixed27;$/;"	t	namespace:itpp
ufixed28	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<28, US, WRAP> ufixed28;$/;"	t	namespace:itpp
ufixed29	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<29, US, WRAP> ufixed29;$/;"	t	namespace:itpp
ufixed3	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<3, US, WRAP> ufixed3;$/;"	t	namespace:itpp
ufixed30	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<30, US, WRAP> ufixed30;$/;"	t	namespace:itpp
ufixed31	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<31, US, WRAP> ufixed31;$/;"	t	namespace:itpp
ufixed32	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<32, US, WRAP> ufixed32;$/;"	t	namespace:itpp
ufixed33	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<33, US, WRAP> ufixed33;$/;"	t	namespace:itpp
ufixed34	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<34, US, WRAP> ufixed34;$/;"	t	namespace:itpp
ufixed35	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<35, US, WRAP> ufixed35;$/;"	t	namespace:itpp
ufixed36	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<36, US, WRAP> ufixed36;$/;"	t	namespace:itpp
ufixed37	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<37, US, WRAP> ufixed37;$/;"	t	namespace:itpp
ufixed38	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<38, US, WRAP> ufixed38;$/;"	t	namespace:itpp
ufixed39	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<39, US, WRAP> ufixed39;$/;"	t	namespace:itpp
ufixed4	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<4, US, WRAP> ufixed4;$/;"	t	namespace:itpp
ufixed40	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<40, US, WRAP> ufixed40;$/;"	t	namespace:itpp
ufixed41	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<41, US, WRAP> ufixed41;$/;"	t	namespace:itpp
ufixed42	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<42, US, WRAP> ufixed42;$/;"	t	namespace:itpp
ufixed43	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<43, US, WRAP> ufixed43;$/;"	t	namespace:itpp
ufixed44	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<44, US, WRAP> ufixed44;$/;"	t	namespace:itpp
ufixed45	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<45, US, WRAP> ufixed45;$/;"	t	namespace:itpp
ufixed46	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<46, US, WRAP> ufixed46;$/;"	t	namespace:itpp
ufixed47	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<47, US, WRAP> ufixed47;$/;"	t	namespace:itpp
ufixed48	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<48, US, WRAP> ufixed48;$/;"	t	namespace:itpp
ufixed49	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<49, US, WRAP> ufixed49;$/;"	t	namespace:itpp
ufixed5	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<5, US, WRAP> ufixed5;$/;"	t	namespace:itpp
ufixed50	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<50, US, WRAP> ufixed50;$/;"	t	namespace:itpp
ufixed51	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<51, US, WRAP> ufixed51;$/;"	t	namespace:itpp
ufixed52	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<52, US, WRAP> ufixed52;$/;"	t	namespace:itpp
ufixed53	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<53, US, WRAP> ufixed53;$/;"	t	namespace:itpp
ufixed54	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<54, US, WRAP> ufixed54;$/;"	t	namespace:itpp
ufixed55	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<55, US, WRAP> ufixed55;$/;"	t	namespace:itpp
ufixed56	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<56, US, WRAP> ufixed56;$/;"	t	namespace:itpp
ufixed57	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<57, US, WRAP> ufixed57;$/;"	t	namespace:itpp
ufixed58	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<58, US, WRAP> ufixed58;$/;"	t	namespace:itpp
ufixed59	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<59, US, WRAP> ufixed59;$/;"	t	namespace:itpp
ufixed6	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<6, US, WRAP> ufixed6;$/;"	t	namespace:itpp
ufixed60	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<60, US, WRAP> ufixed60;$/;"	t	namespace:itpp
ufixed61	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<61, US, WRAP> ufixed61;$/;"	t	namespace:itpp
ufixed62	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<62, US, WRAP> ufixed62;$/;"	t	namespace:itpp
ufixed63	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<63, US, WRAP> ufixed63;$/;"	t	namespace:itpp
ufixed64	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<64, US, WRAP> ufixed64;$/;"	t	namespace:itpp
ufixed7	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<7, US, WRAP> ufixed7;$/;"	t	namespace:itpp
ufixed8	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<8, US, WRAP> ufixed8;$/;"	t	namespace:itpp
ufixed9	/usr/include/itpp/fixed/fixed.h	/^typedef Fixed<9, US, WRAP> ufixed9;$/;"	t	namespace:itpp
uint16_t	/usr/include/itpp/base/ittypes.h	/^typedef unsigned short          uint16_t;   \/\/!< 16-bit unsigned integer$/;"	t
uint32_t	/usr/include/itpp/base/ittypes.h	/^typedef unsigned int            uint32_t;   \/\/!< 32-bit unsigned integer$/;"	t
uint64_t	/usr/include/itpp/base/ittypes.h	/^typedef unsigned __int64        uint64_t;   \/\/!< 64-bit unsigned integer$/;"	t
uint64_t	/usr/include/itpp/base/ittypes.h	/^typedef unsigned long           uint64_t;   \/\/!< 64-bit unsigned integer$/;"	t
uint64_t	/usr/include/itpp/base/ittypes.h	/^typedef unsigned long long      uint64_t;   \/\/!< 64-bit unsigned integer$/;"	t
uint8_t	/usr/include/itpp/base/ittypes.h	/^typedef unsigned char           uint8_t;    \/\/!< 8-bit unsigned integer$/;"	t
unfix	/usr/include/itpp/fixed/cfix.h	/^  std::complex<double> unfix() const;$/;"	p	class:itpp::CFix	access:public	signature:() const
unfix	/usr/include/itpp/fixed/fix.h	/^  double unfix() const;$/;"	p	class:itpp::Fix	access:public	signature:() const
unfix	/usr/include/itpp/fixed/fix_functions.h	/^Array<typename Convert<T>::to_double> unfix(const Array<T> &x)$/;"	f	namespace:itpp	signature:(const Array<T> &x)
unfix	/usr/include/itpp/fixed/fix_functions.h	/^inline cmat unfix(const cfixmat &x) {return to_cmat(x);}$/;"	f	namespace:itpp	signature:(const cfixmat &x)
unfix	/usr/include/itpp/fixed/fix_functions.h	/^inline cmat unfix(const cmat &x) {return x;}$/;"	f	namespace:itpp	signature:(const cmat &x)
unfix	/usr/include/itpp/fixed/fix_functions.h	/^inline cvec unfix(const cfixvec &x) {return to_cvec(x);}$/;"	f	namespace:itpp	signature:(const cfixvec &x)
unfix	/usr/include/itpp/fixed/fix_functions.h	/^inline cvec unfix(const cvec &x) {return x;}$/;"	f	namespace:itpp	signature:(const cvec &x)
unfix	/usr/include/itpp/fixed/fix_functions.h	/^inline double unfix(const Fix &x) {return x.unfix();}$/;"	f	namespace:itpp	signature:(const Fix &x)
unfix	/usr/include/itpp/fixed/fix_functions.h	/^inline double unfix(double x) {return x;}$/;"	f	namespace:itpp	signature:(double x)
unfix	/usr/include/itpp/fixed/fix_functions.h	/^inline mat unfix(const fixmat &x) {return to_mat(x);}$/;"	f	namespace:itpp	signature:(const fixmat &x)
unfix	/usr/include/itpp/fixed/fix_functions.h	/^inline mat unfix(const mat &x) {return x;}$/;"	f	namespace:itpp	signature:(const mat &x)
unfix	/usr/include/itpp/fixed/fix_functions.h	/^inline std::complex<double> unfix(const CFix &x) {return x.unfix();}$/;"	f	namespace:itpp	signature:(const CFix &x)
unfix	/usr/include/itpp/fixed/fix_functions.h	/^inline std::complex<double> unfix(const std::complex<double> &x) {return x;}$/;"	f	namespace:itpp	signature:(const std::complex<double> &x)
unfix	/usr/include/itpp/fixed/fix_functions.h	/^inline vec unfix(const fixvec &x) {return to_vec(x);}$/;"	f	namespace:itpp	signature:(const fixvec &x)
unfix	/usr/include/itpp/fixed/fix_functions.h	/^inline vec unfix(const vec &x) {return x;}$/;"	f	namespace:itpp	signature:(const vec &x)
unnormalise_means	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  void unnormalise_means();$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:protected	signature:()
unnormalise_vectors	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  void unnormalise_vectors();$/;"	p	class:itpp::MOG_diag_kmeans_sup	access:protected	signature:()
update	/usr/include/itpp/stat/histogram.h	/^  void update(Mat<Num_T> values);$/;"	p	class:itpp::Histogram	access:public	signature:(Mat<Num_T> values)
update	/usr/include/itpp/stat/histogram.h	/^  void update(Num_T value);$/;"	p	class:itpp::Histogram	access:public	signature:(Num_T value)
update	/usr/include/itpp/stat/histogram.h	/^  void update(Vec<Num_T> values);$/;"	p	class:itpp::Histogram	access:public	signature:(Vec<Num_T> values)
update	/usr/include/itpp/stat/histogram.h	/^inline void Histogram<Num_T>::update(Mat<Num_T> values)$/;"	f	class:itpp::Histogram	signature:(Mat<Num_T> values)
update	/usr/include/itpp/stat/histogram.h	/^inline void Histogram<Num_T>::update(Num_T value)$/;"	f	class:itpp::Histogram	signature:(Num_T value)
update	/usr/include/itpp/stat/histogram.h	/^inline void Histogram<Num_T>::update(Vec<Num_T> values)$/;"	f	class:itpp::Histogram	signature:(Vec<Num_T> values)
update_LLR	/usr/include/itpp/comm/modulator_nd.h	/^  void update_LLR(const Array<QLLRvec> &logP_apriori, const ivec &s,$/;"	p	class:itpp::Modulator_ND	access:protected	signature:(const Array<QLLRvec> &logP_apriori, const ivec &s, QLLR scaled_norm, QLLRvec &num, QLLRvec &denom)
update_LLR	/usr/include/itpp/comm/modulator_nd.h	/^  void update_LLR(const Array<QLLRvec> &logP_apriori, int s,$/;"	p	class:itpp::Modulator_ND	access:protected	signature:(const Array<QLLRvec> &logP_apriori, int s, QLLR scaled_norm, int j, QLLRvec &num, QLLRvec &denom)
update_internals	/usr/include/itpp/stat/mog_diag_em.h	/^  void inline update_internals();$/;"	p	class:itpp::MOG_diag_EM_sup	access:protected	signature:()
update_norm	/usr/include/itpp/comm/modulator_nd.h	/^  void update_norm(double &norm, int k, int sold, int snew, const cvec &ytH,$/;"	p	class:itpp::Modulator_NCD	access:protected	signature:(double &norm, int k, int sold, int snew, const cvec &ytH, const cmat &HtH, const ivec &s)
update_norm	/usr/include/itpp/comm/modulator_nd.h	/^  void update_norm(double &norm, int k, int sold, int snew, const vec &ytH,$/;"	p	class:itpp::Modulator_NRD	access:protected	signature:(double &norm, int k, int sold, int snew, const vec &ytH, const mat &HtH, const ivec &s)
upsample	/usr/include/itpp/signal/resampling.h	/^Mat<T> upsample(const Mat<T> &v, int usf)$/;"	f	namespace:itpp	signature:(const Mat<T> &v, int usf)
upsample	/usr/include/itpp/signal/resampling.h	/^Vec<T> upsample(const Vec<T> &v, int usf)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, int usf)
upsample	/usr/include/itpp/signal/resampling.h	/^extern template bmat upsample(const bmat &v, int usf);$/;"	p	namespace:itpp	signature:(const bmat &v, int usf)
upsample	/usr/include/itpp/signal/resampling.h	/^extern template bvec upsample(const bvec &v, int usf);$/;"	p	namespace:itpp	signature:(const bvec &v, int usf)
upsample	/usr/include/itpp/signal/resampling.h	/^extern template cmat upsample(const cmat &v, int usf);$/;"	p	namespace:itpp	signature:(const cmat &v, int usf)
upsample	/usr/include/itpp/signal/resampling.h	/^extern template cvec upsample(const cvec &v, int usf);$/;"	p	namespace:itpp	signature:(const cvec &v, int usf)
upsample	/usr/include/itpp/signal/resampling.h	/^extern template imat upsample(const imat &v, int usf);$/;"	p	namespace:itpp	signature:(const imat &v, int usf)
upsample	/usr/include/itpp/signal/resampling.h	/^extern template ivec upsample(const ivec &v, int usf);$/;"	p	namespace:itpp	signature:(const ivec &v, int usf)
upsample	/usr/include/itpp/signal/resampling.h	/^extern template mat upsample(const mat &v, int usf);$/;"	p	namespace:itpp	signature:(const mat &v, int usf)
upsample	/usr/include/itpp/signal/resampling.h	/^extern template smat upsample(const smat &v, int usf);$/;"	p	namespace:itpp	signature:(const smat &v, int usf)
upsample	/usr/include/itpp/signal/resampling.h	/^extern template svec upsample(const svec &v, int usf);$/;"	p	namespace:itpp	signature:(const svec &v, int usf)
upsample	/usr/include/itpp/signal/resampling.h	/^extern template vec upsample(const vec &v, int usf);$/;"	p	namespace:itpp	signature:(const vec &v, int usf)
upsample	/usr/include/itpp/signal/resampling.h	/^extern template void upsample(const bmat &v, int usf,  bmat &u);$/;"	p	namespace:itpp	signature:(const bmat &v, int usf, bmat &u)
upsample	/usr/include/itpp/signal/resampling.h	/^extern template void upsample(const bvec &v, int usf,  bvec &u);$/;"	p	namespace:itpp	signature:(const bvec &v, int usf, bvec &u)
upsample	/usr/include/itpp/signal/resampling.h	/^extern template void upsample(const cmat &v, int usf,  cmat &u);$/;"	p	namespace:itpp	signature:(const cmat &v, int usf, cmat &u)
upsample	/usr/include/itpp/signal/resampling.h	/^extern template void upsample(const cvec &v, int usf,  cvec &u);$/;"	p	namespace:itpp	signature:(const cvec &v, int usf, cvec &u)
upsample	/usr/include/itpp/signal/resampling.h	/^extern template void upsample(const imat &v, int usf,  imat &u);$/;"	p	namespace:itpp	signature:(const imat &v, int usf, imat &u)
upsample	/usr/include/itpp/signal/resampling.h	/^extern template void upsample(const ivec &v, int usf,  ivec &u);$/;"	p	namespace:itpp	signature:(const ivec &v, int usf, ivec &u)
upsample	/usr/include/itpp/signal/resampling.h	/^extern template void upsample(const mat &v, int usf,  mat &u);$/;"	p	namespace:itpp	signature:(const mat &v, int usf, mat &u)
upsample	/usr/include/itpp/signal/resampling.h	/^extern template void upsample(const smat &v, int usf,  smat &u);$/;"	p	namespace:itpp	signature:(const smat &v, int usf, smat &u)
upsample	/usr/include/itpp/signal/resampling.h	/^extern template void upsample(const svec &v, int usf,  svec &u);$/;"	p	namespace:itpp	signature:(const svec &v, int usf, svec &u)
upsample	/usr/include/itpp/signal/resampling.h	/^extern template void upsample(const vec &v, int usf,  vec &u);$/;"	p	namespace:itpp	signature:(const vec &v, int usf, vec &u)
upsample	/usr/include/itpp/signal/resampling.h	/^void upsample(const Mat<T> &v, int usf, Mat<T> &u)$/;"	f	namespace:itpp	signature:(const Mat<T> &v, int usf, Mat<T> &u)
upsample	/usr/include/itpp/signal/resampling.h	/^void upsample(const Vec<T> &v, int usf, Vec<T> &u)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, int usf, Vec<T> &u)
upsample_rate	/usr/include/itpp/comm/channel.h	/^  int upsample_rate; \/\/!< Upsampling rate for linear interpolation$/;"	m	class:itpp::FIR_Fading_Generator	access:protected
upsampling_factor	/usr/include/itpp/comm/pulse_shape.h	/^  int upsampling_factor;$/;"	m	class:itpp::Pulse_Shape	access:protected
used_size	/usr/include/itpp/base/svec.h	/^  int v_size, used_size, data_size;$/;"	m	class:itpp::Sparse_Vec	access:private
v_size	/usr/include/itpp/base/svec.h	/^  int v_size, used_size, data_size;$/;"	m	class:itpp::Sparse_Vec	access:private
valid	/usr/include/itpp/stat/mog_generic.h	/^  bool valid;$/;"	m	class:itpp::MOG_generic	access:protected
valptr	/usr/include/itpp/base/stack.h	/^  int valptr;$/;"	m	class:itpp::Stack	access:private
value	/usr/include/itpp/base/binary.h	/^  char value() const { return b; }$/;"	f	class:itpp::bin	access:public	signature:() const
value	/usr/include/itpp/comm/galois.h	/^  int value;$/;"	m	class:itpp::GF	access:private
value	/usr/include/itpp/protocol/tcp.h	/^  int value() const { return seq; }$/;"	f	class:itpp::Sequence_Number	access:public	signature:() const
value_type	/usr/include/itpp/base/mat.h	/^  typedef Num_T value_type;$/;"	t	class:itpp::Mat	access:public
value_type	/usr/include/itpp/base/vec.h	/^  typedef Num_T value_type;$/;"	t	class:itpp::Vec	access:public
var	/usr/include/itpp/base/random.h	/^  double mean, var, sqrt_12var;$/;"	m	class:itpp::Laplace_RNG	access:private
var	/usr/include/itpp/base/random.h	/^  double mean, var;$/;"	m	class:itpp::Weibull_RNG	access:private
var	/usr/include/itpp/base/random.h	/^  double mem, r, factr, mean, var, r1, r2;$/;"	m	class:itpp::AR1_Normal_RNG	access:private
var	/usr/include/itpp/signal/source.h	/^  double mean, var;$/;"	m	class:itpp::Pattern_Source	access:private
var_floor	/usr/include/itpp/stat/mog_diag_em.h	/^  double var_floor;$/;"	m	class:itpp::MOG_diag_EM_sup	access:protected
variance	/usr/include/itpp/stat/misc_stat.h	/^double variance(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
variance	/usr/include/itpp/stat/misc_stat.h	/^double variance(const cvec &v);$/;"	p	namespace:itpp	signature:(const cvec &v)
vec	/usr/include/itpp/base/vec.h	/^typedef Vec<double> vec;$/;"	t	namespace:itpp
vec2mxArray	/usr/include/itpp/itmex.h	/^void vec2mxArray(const vec &in, mxArray *out)$/;"	f	namespace:itpp	signature:(const vec &in, mxArray *out)
vec2mxArray	/usr/include/itpp/itmex.h	/^void vec2mxArray(const vec &in, mxArray *out);$/;"	p	namespace:itpp	signature:(const vec &in, mxArray *out)
vec_1	/usr/include/itpp/base/specmat.h	/^Vec<T> vec_1(T v0)$/;"	f	namespace:itpp	signature:(T v0)
vec_2	/usr/include/itpp/base/specmat.h	/^Vec<T> vec_2(T v0, T v1)$/;"	f	namespace:itpp	signature:(T v0, T v1)
vec_3	/usr/include/itpp/base/specmat.h	/^Vec<T> vec_3(T v0, T v1, T v2)$/;"	f	namespace:itpp	signature:(T v0, T v1, T v2)
verbose	/usr/include/itpp/stat/mog_diag_em.h	/^  bool verbose;$/;"	m	class:itpp::MOG_diag_EM_sup	access:protected
verbose	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  bool verbose;$/;"	m	class:itpp::MOG_diag_kmeans_sup	access:protected
version	/usr/include/itpp/base/itfile.h	/^    char version;$/;"	m	struct:itpp::it_file_base::file_header	access:public
version	/usr/include/itpp/base/itfile.h	/^    char version;$/;"	m	struct:itpp::it_file_base_old::file_header	access:public
visited_state	/usr/include/itpp/comm/convcode.h	/^  Array<bool> visited_state;$/;"	m	class:itpp::Convolutional_Code	access:protected
vqtrain	/usr/include/itpp/srccode/vqtrain.h	/^mat vqtrain(Array<vec> &DB, int SIZE, int NOITER, double STARTSTEP = 0.2, bool VERBOSE = true);$/;"	p	namespace:itpp	signature:(Array<vec> &DB, int SIZE, int NOITER, double STARTSTEP = 0.2, bool VERBOSE = true)
w	/usr/include/itpp/srccode/gmm.h	/^  vec   m, sigma, w;$/;"	m	class:itpp::GMM	access:protected
waterfilling	/usr/include/itpp/comm/commfunc.h	/^vec waterfilling(const vec& alpha, double P);$/;"	p	namespace:itpp	signature:(const vec& alpha, double P)
wcdma_spreading_codes	/usr/include/itpp/comm/sequence.h	/^smat wcdma_spreading_codes(int SF);$/;"	p	namespace:itpp	signature:(int SF)
wcdma_turbo_interleaver_sequence	/usr/include/itpp/comm/turbo.h	/^ivec wcdma_turbo_interleaver_sequence(int interleaver_size);$/;"	p	namespace:itpp	signature:(int interleaver_size)
weight	/usr/include/itpp/comm/commfunc.h	/^int weight(const bvec &a);$/;"	p	namespace:itpp	signature:(const bvec &a)
weight	/usr/include/itpp/comm/convcode.h	/^  int weight(const int state, const int input);$/;"	p	class:itpp::Convolutional_Code	access:protected	signature:(const int state, const int input)
weight	/usr/include/itpp/comm/convcode.h	/^  void weight(const int state, int &w0, int &w1);$/;"	p	class:itpp::Convolutional_Code	access:protected	signature:(const int state, int &w0, int &w1)
weight	/usr/include/itpp/comm/punct_convcode.h	/^  int weight(const int state, const int input, int time);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:protected	signature:(const int state, const int input, int time)
weight	/usr/include/itpp/comm/punct_convcode.h	/^  void weight(const int state, int &w0, int &w1, int time);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:protected	signature:(const int state, int &w0, int &w1, int time)
weight_floor	/usr/include/itpp/stat/mog_diag_em.h	/^  double weight_floor;$/;"	m	class:itpp::MOG_diag_EM_sup	access:protected
weight_int	/usr/include/itpp/comm/convcode.h	/^int weight_int(int length, int in);$/;"	p	namespace:itpp	signature:(int length, int in)
weight_reverse	/usr/include/itpp/comm/convcode.h	/^  int weight_reverse(const int state, const int input);$/;"	p	class:itpp::Convolutional_Code	access:protected	signature:(const int state, const int input)
weight_reverse	/usr/include/itpp/comm/convcode.h	/^  void weight_reverse(const int state, int &w0, int &w1);$/;"	p	class:itpp::Convolutional_Code	access:protected	signature:(const int state, int &w0, int &w1)
weight_reverse	/usr/include/itpp/comm/punct_convcode.h	/^  int weight_reverse(const int state, const int input, int time);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:protected	signature:(const int state, const int input, int time)
weight_reverse	/usr/include/itpp/comm/punct_convcode.h	/^  void weight_reverse(const int state, int &w0, int &w1, int time);$/;"	p	class:itpp::Punctured_Convolutional_Code	access:protected	signature:(const int state, int &w0, int &w1, int time)
weights	/usr/include/itpp/stat/mog_generic.h	/^  vec weights;$/;"	m	class:itpp::MOG_generic	access:protected
whiteningMatrix	/usr/include/itpp/signal/fastica.h	/^  mat whiteningMatrix;$/;"	m	class:itpp::Fast_ICA	access:private
whitesig	/usr/include/itpp/signal/fastica.h	/^  mat whitesig;$/;"	m	class:itpp::Fast_ICA	access:private
window	/usr/include/itpp/protocol/tcp.h	/^  unsigned window() const;$/;"	p	class:itpp::TCP_Receiver_Buffer	access:public	signature:() const
within_tolerance	/usr/include/itpp/stat/misc_stat.h	/^inline bool within_tolerance(const cmat &X, const cmat &Xref, double tol = 1e-14)$/;"	f	namespace:itpp	signature:(const cmat &X, const cmat &Xref, double tol = 1e-14)
within_tolerance	/usr/include/itpp/stat/misc_stat.h	/^inline bool within_tolerance(const cvec &x, const cvec &xref, double tol = 1e-14)$/;"	f	namespace:itpp	signature:(const cvec &x, const cvec &xref, double tol = 1e-14)
within_tolerance	/usr/include/itpp/stat/misc_stat.h	/^inline bool within_tolerance(const mat &X, const mat &Xref, double tol = 1e-14)$/;"	f	namespace:itpp	signature:(const mat &X, const mat &Xref, double tol = 1e-14)
within_tolerance	/usr/include/itpp/stat/misc_stat.h	/^inline bool within_tolerance(const vec &x, const vec &xref, double tol = 1e-14)$/;"	f	namespace:itpp	signature:(const vec &x, const vec &xref, double tol = 1e-14)
within_tolerance	/usr/include/itpp/stat/misc_stat.h	/^inline bool within_tolerance(double x, double xref, double tol = 1e-14)$/;"	f	namespace:itpp	signature:(double x, double xref, double tol = 1e-14)
within_tolerance	/usr/include/itpp/stat/misc_stat.h	/^inline bool within_tolerance(std::complex<double> x, std::complex<double> xref, double tol = 1e-14)$/;"	f	namespace:itpp	signature:(std::complex<double> x, std::complex<double> xref, double tol = 1e-14)
wordlen	/usr/include/itpp/fixed/fix_base.h	/^  int wordlen;$/;"	m	class:itpp::Fix_Base	access:protected
wordlen	/usr/include/itpp/fixed/fix_factory.h	/^  int wordlen;$/;"	m	class:itpp::Fix_Factory	access:protected
write	/usr/include/itpp/base/gf2mat.h	/^  void write(const std::string &fname) const;$/;"	p	class:itpp::GF2mat_sparse_alist	access:public	signature:(const std::string &fname) const
write	/usr/include/itpp/protocol/tcp.h	/^  void write(TCP_Segment newBlock);  \/**< \\brief add segment to the queue *\/$/;"	p	class:itpp::TCP_Receiver_Buffer	access:public	signature:(TCP_Segment newBlock)
write	/usr/include/itpp/protocol/tcp_client_server.h	/^  Signal<itpp::Packet*> write;$/;"	m	class:itpp::TCP_Server_Application	access:public
write	/usr/include/itpp/srccode/audiofile.h	/^  virtual bool write(const vec &v);$/;"	p	class:itpp::SND_Out_File	access:public	signature:(const vec &v)
write_data_header	/usr/include/itpp/base/itfile.h	/^  void write_data_header(const std::string& type, const std::string& name,$/;"	p	class:itpp::it_file	access:public	signature:(const std::string& type, const std::string& name, uint64_t size, const std::string& description = Ó)
write_data_header	/usr/include/itpp/base/itfile.h	/^  void write_data_header(const std::string& type, const std::string& name,$/;"	p	class:itpp::it_file_old	access:public	signature:(const std::string& type, const std::string& name, uint32_t size)
write_data_header	/usr/include/itpp/base/itfile.h	/^  void write_data_header(const std::string& type, uint32_t size);$/;"	p	class:itpp::it_file_old	access:public	signature:(const std::string& type, uint32_t size)
write_data_header	/usr/include/itpp/base/itfile.h	/^  void write_data_header(const std::string& type, uint64_t size);$/;"	p	class:itpp::it_file	access:public	signature:(const std::string& type, uint64_t size)
write_data_header_here	/usr/include/itpp/base/itfile.h	/^  void write_data_header_here(const data_header& h);$/;"	p	class:itpp::it_file	access:protected	signature:(const data_header& h)
write_data_header_here	/usr/include/itpp/base/itfile.h	/^  void write_data_header_here(const data_header& h);$/;"	p	class:itpp::it_file_old	access:protected	signature:(const data_header& h)
write_endian	/usr/include/itpp/srccode/audiofile.h	/^inline void write_endian(std::ostream &s, T data, bool switch_endian = false)$/;"	f	namespace:itpp	signature:(std::ostream &s, T data, bool switch_endian = false)
write_file_header	/usr/include/itpp/base/itfile.h	/^  void write_file_header();$/;"	p	class:itpp::it_file	access:public	signature:()
write_file_header	/usr/include/itpp/base/itfile.h	/^  void write_file_header();$/;"	p	class:itpp::it_file_old	access:public	signature:()
write_header	/usr/include/itpp/srccode/audiofile.h	/^  bool write_header(std::ostream &f);$/;"	p	class:itpp::SND_Format	access:protected	signature:(std::ostream &f)
write_to_net	/usr/include/itpp/protocol/tcp_client_server.h	/^  void write_to_net(unsigned byte_size, double delta_time) {$/;"	f	class:itpp::TCP_Server_Application	access:public	signature:(unsigned byte_size, double delta_time)
wtab	/usr/include/itpp/base/random.h	/^  static const double wtab[128];$/;"	m	class:itpp::Normal_RNG	access:private
x_end	/usr/include/itpp/optim/newton_search.h	/^  vec x_end, g_end;$/;"	m	class:itpp::Line_Search	access:private
x_end	/usr/include/itpp/optim/newton_search.h	/^  vec x_end;$/;"	m	class:itpp::Newton_Search	access:private
x_start	/usr/include/itpp/optim/newton_search.h	/^  vec x_start, g_start, h_start;$/;"	m	class:itpp::Line_Search	access:private
x_start	/usr/include/itpp/optim/newton_search.h	/^  vec x_start;$/;"	m	class:itpp::Newton_Search	access:private
x_values	/usr/include/itpp/optim/newton_search.h	/^  Array<vec> x_values;$/;"	m	class:itpp::Newton_Search	access:private
xcorr	/usr/include/itpp/signal/sigfun.h	/^cvec xcorr(const cvec &x, const cvec &y, const int max_lag = -1, const std::string scaleopt = "none");$/;"	p	namespace:itpp	signature:(const cvec &x, const cvec &y, const int max_lag = -1, const std::string scaleopt = Ó)
xcorr	/usr/include/itpp/signal/sigfun.h	/^cvec xcorr(const cvec &x, const int max_lag = -1, const std::string scaleopt = "none");$/;"	p	namespace:itpp	signature:(const cvec &x, const int max_lag = -1, const std::string scaleopt = Ó)
xcorr	/usr/include/itpp/signal/sigfun.h	/^vec xcorr(const vec &x, const int max_lag = -1, const std::string scaleopt = "none");$/;"	p	namespace:itpp	signature:(const vec &x, const int max_lag = -1, const std::string scaleopt = Ó)
xcorr	/usr/include/itpp/signal/sigfun.h	/^vec xcorr(const vec &x, const vec &y, const int max_lag = -1, const std::string scaleopt = "none");$/;"	p	namespace:itpp	signature:(const vec &x, const vec &y, const int max_lag = -1, const std::string scaleopt = Ó)
xcorr	/usr/include/itpp/signal/sigfun.h	/^void xcorr(const cvec &x, const cvec &y, cvec &out, const int max_lag = -1, const std::string scaleopt = "none",$/;"	p	namespace:itpp	signature:(const cvec &x, const cvec &y, cvec &out, const int max_lag = -1, const std::string scaleopt = Ó, bool autoflag = true)
xcorr	/usr/include/itpp/signal/sigfun.h	/^void xcorr(const vec &x, const vec &y, vec &out, const int max_lag = -1, const std::string scaleopt = "none");$/;"	p	namespace:itpp	signature:(const vec &x, const vec &y, vec &out, const int max_lag = -1, const std::string scaleopt = Ó)
xcorr_old	/usr/include/itpp/signal/sigfun.h	/^vec xcorr_old(const vec &x, const int max_lag = -1, const std::string scaleopt = "none");$/;"	p	namespace:itpp	signature:(const vec &x, const int max_lag = -1, const std::string scaleopt = Ó)
xcorr_old	/usr/include/itpp/signal/sigfun.h	/^vec xcorr_old(const vec &x, const vec &y, const int max_lag = -1, const std::string scaleopt = "none");$/;"	p	namespace:itpp	signature:(const vec &x, const vec &y, const int max_lag = -1, const std::string scaleopt = Ó)
xcorr_old	/usr/include/itpp/signal/sigfun.h	/^void xcorr_old(const vec &x, const vec &y, vec &out, const int max_lag = -1, const std::string scaleopt = "none");$/;"	p	namespace:itpp	signature:(const vec &x, const vec &y, vec &out, const int max_lag = -1, const std::string scaleopt = Ó)
xor_int_table	/usr/include/itpp/comm/convcode.h	/^  bvec xor_int_table;$/;"	m	class:itpp::Convolutional_Code	access:protected
yn	/usr/include/itpp/config.h	248;"	d
ytab	/usr/include/itpp/base/random.h	/^  static const double ytab[128];$/;"	m	class:itpp::Normal_RNG	access:private
yulewalk	/usr/include/itpp/signal/filter_design.h	/^void yulewalk(const int N, const vec &f, const vec &m, vec &b, vec &a);$/;"	p	namespace:itpp	signature:(const int N, const vec &f, const vec &m, vec &b, vec &a)
zaxpy_	/usr/include/itpp/base/blas.h	/^  void zaxpy_(const int *n,$/;"	p	signature:(const int *n, const std::complex<double> *alpha, const std::complex<double> *x, const int *incx, std::complex<double> *y, const int *incy)
zcopy_	/usr/include/itpp/base/blas.h	/^  void zcopy_(const int *n,$/;"	p	signature:(const int *n, const std::complex<double> *x, const int *incx, std::complex<double> *y, const int *incy)
zdotusub_	/usr/include/itpp/base/blas.h	/^  void zdotusub_(std::complex<double> *dot,$/;"	p	signature:(std::complex<double> *dot, const int *n, const std::complex<double> *x, const int *incx, const std::complex<double> *y, const int *incy)
zdotusub_	/usr/include/itpp/base/blas.h	95;"	d
zero_all_ptrs	/usr/include/itpp/stat/mog_diag.h	/^  void zero_all_ptrs();$/;"	p	class:itpp::MOG_diag	access:protected	signature:()
zero_elem	/usr/include/itpp/base/smat.h	/^  void zero_elem(const int r, const int c);$/;"	p	class:itpp::Sparse_Mat	access:public	signature:(const int r, const int c)
zero_elem	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::zero_elem(const int r, const int c)$/;"	f	class:itpp::Sparse_Mat	signature:(const int r, const int c)
zero_elem	/usr/include/itpp/base/svec.h	/^  void zero_elem(const int i);$/;"	p	class:itpp::Sparse_Vec	access:public	signature:(const int i)
zero_elem	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::zero_elem(const int i)$/;"	f	class:itpp::Sparse_Vec	signature:(const int i)
zero_pad	/usr/include/itpp/base/matfunc.h	/^Mat<T> zero_pad(const Mat<T> &m, int rows, int cols)$/;"	f	namespace:itpp	signature:(const Mat<T> &m, int rows, int cols)
zero_pad	/usr/include/itpp/base/matfunc.h	/^Vec<T> zero_pad(const Vec<T> &v)$/;"	f	namespace:itpp	signature:(const Vec<T> &v)
zero_pad	/usr/include/itpp/base/matfunc.h	/^Vec<T> zero_pad(const Vec<T> &v, int n)$/;"	f	namespace:itpp	signature:(const Vec<T> &v, int n)
zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template bmat zero_pad(const bmat &, int, int);$/;"	p	namespace:itpp	signature:(const bmat &, int, int)
zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template bvec zero_pad(const bvec &v);$/;"	p	namespace:itpp	signature:(const bvec &v)
zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template bvec zero_pad(const bvec &v, int n);$/;"	p	namespace:itpp	signature:(const bvec &v, int n)
zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template cmat zero_pad(const cmat &, int, int);$/;"	p	namespace:itpp	signature:(const cmat &, int, int)
zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template cvec zero_pad(const cvec &v);$/;"	p	namespace:itpp	signature:(const cvec &v)
zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template cvec zero_pad(const cvec &v, int n);$/;"	p	namespace:itpp	signature:(const cvec &v, int n)
zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template imat zero_pad(const imat &, int, int);$/;"	p	namespace:itpp	signature:(const imat &, int, int)
zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template ivec zero_pad(const ivec &v);$/;"	p	namespace:itpp	signature:(const ivec &v)
zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template ivec zero_pad(const ivec &v, int n);$/;"	p	namespace:itpp	signature:(const ivec &v, int n)
zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template mat zero_pad(const mat &, int, int);$/;"	p	namespace:itpp	signature:(const mat &, int, int)
zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template smat zero_pad(const smat &, int, int);$/;"	p	namespace:itpp	signature:(const smat &, int, int)
zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template svec zero_pad(const svec &v);$/;"	p	namespace:itpp	signature:(const svec &v)
zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template svec zero_pad(const svec &v, int n);$/;"	p	namespace:itpp	signature:(const svec &v, int n)
zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template vec zero_pad(const vec &v);$/;"	p	namespace:itpp	signature:(const vec &v)
zero_pad	/usr/include/itpp/base/matfunc.h	/^extern template vec zero_pad(const vec &v, int n);$/;"	p	namespace:itpp	signature:(const vec &v, int n)
zeros	/usr/include/itpp/base/mat.h	/^  void zeros();$/;"	p	class:itpp::Mat	access:public	signature:()
zeros	/usr/include/itpp/base/mat.h	/^void Mat<Num_T>::zeros()$/;"	f	class:itpp::Mat	signature:()
zeros	/usr/include/itpp/base/smat.h	/^  void zeros();$/;"	p	class:itpp::Sparse_Mat	access:public	signature:()
zeros	/usr/include/itpp/base/smat.h	/^void Sparse_Mat<T>::zeros()$/;"	f	class:itpp::Sparse_Mat	signature:()
zeros	/usr/include/itpp/base/specmat.h	/^mat zeros(int rows, int cols);$/;"	p	namespace:itpp	signature:(int rows, int cols)
zeros	/usr/include/itpp/base/specmat.h	/^vec zeros(int size);$/;"	p	namespace:itpp	signature:(int size)
zeros	/usr/include/itpp/base/svec.h	/^  void zeros();$/;"	p	class:itpp::Sparse_Vec	access:public	signature:()
zeros	/usr/include/itpp/base/svec.h	/^void Sparse_Vec<T>::zeros()$/;"	f	class:itpp::Sparse_Vec	signature:()
zeros	/usr/include/itpp/base/vec.h	/^  void zeros();$/;"	p	class:itpp::Vec	access:public	signature:()
zeros	/usr/include/itpp/base/vec.h	/^void Vec<Num_T>::zeros()$/;"	f	class:itpp::Vec	signature:()
zeros_b	/usr/include/itpp/base/specmat.h	/^bmat zeros_b(int rows, int cols);$/;"	p	namespace:itpp	signature:(int rows, int cols)
zeros_b	/usr/include/itpp/base/specmat.h	/^bvec zeros_b(int size);$/;"	p	namespace:itpp	signature:(int size)
zeros_c	/usr/include/itpp/base/specmat.h	/^cmat zeros_c(int rows, int cols);$/;"	p	namespace:itpp	signature:(int rows, int cols)
zeros_c	/usr/include/itpp/base/specmat.h	/^cvec zeros_c(int size);$/;"	p	namespace:itpp	signature:(int size)
zeros_i	/usr/include/itpp/base/specmat.h	/^imat zeros_i(int rows, int cols);$/;"	p	namespace:itpp	signature:(int rows, int cols)
zeros_i	/usr/include/itpp/base/specmat.h	/^ivec zeros_i(int size);$/;"	p	namespace:itpp	signature:(int size)
zerostemp	/usr/include/itpp/comm/interleave.h	/^  Vec<T> tempvec, zerostemp;$/;"	m	class:itpp::Cross_Interleaver	access:private
zfinal	/usr/include/itpp/signal/freq_filt.h	/^  cvec zfinal;$/;"	m	class:itpp::Freq_Filt	access:private
zgemm_	/usr/include/itpp/base/blas.h	/^  void zgemm_(const char *transA, const char *transB,$/;"	p	signature:(const char *transA, const char *transB, const int *m, const int *n, const int *k, const std::complex<double> *alpha, const std::complex<double> *A, const int *ldA, const std::complex<double> *B, const int *ldB, const std::complex<double> *beta, std::complex<double> *C, const int *ldC)
zgemv_	/usr/include/itpp/base/blas.h	/^  void zgemv_(const char *transA, const int *m, const int *n,$/;"	p	signature:(const char *transA, const int *m, const int *n, const std::complex<double> *alpha, const std::complex<double> *A, const int *ldA, const std::complex<double> *x, const int *incx, const std::complex<double> *beta, std::complex<double> *y, const int *incy)
zgerc_	/usr/include/itpp/base/blas.h	/^  void zgerc_(const int *m, const int *n,$/;"	p	signature:(const int *m, const int *n, const std::complex<double> *alpha, const std::complex<double> *x, const int *inxx, const std::complex<double> *y, const int *incy, std::complex<double> *A, const int *ldA)
zgeru_	/usr/include/itpp/base/blas.h	/^  void zgeru_(const int *m, const int *n,$/;"	p	signature:(const int *m, const int *n, const std::complex<double> *alpha, const std::complex<double> *x, const int *inxx, const std::complex<double> *y, const int *incy, std::complex<double> *A, const int *ldA)
zigzag_space	/usr/include/itpp/base/specmat.h	/^vec zigzag_space(double t0, double t1, int K = 5);$/;"	p	namespace:itpp	signature:(double t0, double t1, int K = 5)
zscal_	/usr/include/itpp/base/blas.h	/^  void zscal_(const int *n,$/;"	p	signature:(const int *n, const std::complex<double> *alpha, std::complex<double> *x, const int *incx)
zswap_	/usr/include/itpp/base/blas.h	/^  void zswap_(const int *n,$/;"	p	signature:(const int *n, std::complex<double> *x, const int *incx, std::complex<double> *y, const int *incy)
~ACK	/usr/include/itpp/protocol/packet.h	/^  ~ACK() {}$/;"	f	class:itpp::ACK	access:public	signature:()
~ACK_Channel	/usr/include/itpp/protocol/packet_channel.h	/^  ~ACK_Channel();$/;"	p	class:itpp::ACK_Channel	access:public	signature:()
~ARMA_Filter	/usr/include/itpp/signal/filter.h	/^  virtual ~ARMA_Filter() { }$/;"	f	class:itpp::ARMA_Filter	access:public	signature:()
~AR_Filter	/usr/include/itpp/signal/filter.h	/^  virtual ~AR_Filter() { }$/;"	f	class:itpp::AR_Filter	access:public	signature:()
~Array	/usr/include/itpp/base/array.h	/^  virtual ~Array();$/;"	p	class:itpp::Array	access:public	signature:()
~Array	/usr/include/itpp/base/array.h	/^Array<T>::~Array()$/;"	f	class:itpp::Array	signature:()
~Audio_File	/usr/include/itpp/srccode/audiofile.h	/^  virtual ~Audio_File() { }$/;"	f	class:itpp::Audio_File	access:public	signature:()
~BCH	/usr/include/itpp/comm/bch.h	/^  virtual ~BCH() { }$/;"	f	class:itpp::BCH	access:public	signature:()
~BPSK	/usr/include/itpp/comm/modulator.h	/^  virtual ~BPSK() {}$/;"	f	class:itpp::BPSK	access:public	signature:()
~BPSK_c	/usr/include/itpp/comm/modulator.h	/^  virtual ~BPSK_c() {}$/;"	f	class:itpp::BPSK_c	access:public	signature:()
~Base_Event	/usr/include/itpp/protocol/events.h	/^  virtual ~Base_Event() {}$/;"	f	class:itpp::Base_Event	access:public	signature:()
~Base_Slot	/usr/include/itpp/protocol/signals_slots.h	/^  virtual ~Base_Slot();$/;"	p	class:itpp::Base_Slot	access:public	signature:()
~Base_Slot	/usr/include/itpp/protocol/signals_slots.h	/^Base_Slot<DataType>::~Base_Slot()$/;"	f	class:itpp::Base_Slot	signature:()
~Burst_WWW_Packet_Generator	/usr/include/itpp/protocol/packet_generator.h	/^  virtual ~Burst_WWW_Packet_Generator();$/;"	p	class:itpp::Burst_WWW_Packet_Generator	access:public	signature:()
~CFix	/usr/include/itpp/fixed/cfix.h	/^  virtual ~CFix() {}$/;"	f	class:itpp::CFix	access:public	signature:()
~CFixed	/usr/include/itpp/fixed/cfixed.h	/^  virtual ~CFixed() {}$/;"	f	class:itpp::CFixed	access:public	signature:()
~Channel_Code	/usr/include/itpp/comm/channel_code.h	/^  virtual ~Channel_Code() {}$/;"	f	class:itpp::Channel_Code	access:public	signature:()
~Channel_Specification	/usr/include/itpp/comm/channel.h	/^  virtual ~Channel_Specification() {}$/;"	f	class:itpp::Channel_Specification	access:public	signature:()
~Circular_Buffer	/usr/include/itpp/base/circular_buffer.h	/^  virtual ~Circular_Buffer();$/;"	p	class:itpp::Circular_Buffer	access:public	signature:()
~Circular_Buffer	/usr/include/itpp/base/circular_buffer.h	/^Circular_Buffer<T>::~Circular_Buffer()$/;"	f	class:itpp::Circular_Buffer	signature:()
~Constant_Rate_Packet_Generator	/usr/include/itpp/protocol/packet_generator.h	/^  virtual ~Constant_Rate_Packet_Generator();$/;"	p	class:itpp::Constant_Rate_Packet_Generator	access:public	signature:()
~Convolutional_Code	/usr/include/itpp/comm/convcode.h	/^  virtual ~Convolutional_Code(void) {}$/;"	f	class:itpp::Convolutional_Code	access:public	signature:(void)
~Correlated_Fading_Generator	/usr/include/itpp/comm/channel.h	/^  virtual ~Correlated_Fading_Generator() {}$/;"	f	class:itpp::Correlated_Fading_Generator	access:public	signature:()
~Data_Event	/usr/include/itpp/protocol/events.h	/^  virtual ~Data_Event() {}$/;"	f	class:itpp::Data_Event	access:public	signature:()
~Dummy_Code	/usr/include/itpp/comm/channel_code.h	/^  virtual ~Dummy_Code() {}$/;"	f	class:itpp::Dummy_Code	access:public	signature:()
~Event	/usr/include/itpp/protocol/events.h	/^  virtual ~Event() {}$/;"	f	class:itpp::Event	access:public	signature:()
~Event_Queue	/usr/include/itpp/protocol/events.h	/^  ~Event_Queue() {}$/;"	f	class:itpp::Event_Queue	access:public	signature:()
~Extended_Golay	/usr/include/itpp/comm/egolay.h	/^  virtual ~Extended_Golay() { }$/;"	f	class:itpp::Extended_Golay	access:public	signature:()
~FIR_Fading_Generator	/usr/include/itpp/comm/channel.h	/^  virtual ~FIR_Fading_Generator() {}$/;"	f	class:itpp::FIR_Fading_Generator	access:public	signature:()
~Factory	/usr/include/itpp/base/factory.h	/^  virtual ~Factory() {}$/;"	f	class:itpp::Factory	access:public	signature:()
~Fading_Generator	/usr/include/itpp/comm/channel.h	/^  virtual ~Fading_Generator() {}$/;"	f	class:itpp::Fading_Generator	access:public	signature:()
~Filter	/usr/include/itpp/signal/filter.h	/^  virtual ~Filter() {}$/;"	f	class:itpp::Filter	access:public	signature:()
~Fix	/usr/include/itpp/fixed/fix.h	/^  virtual ~Fix() {}$/;"	f	class:itpp::Fix	access:public	signature:()
~Fix_Base	/usr/include/itpp/fixed/fix_base.h	/^  virtual ~Fix_Base() {}$/;"	f	class:itpp::Fix_Base	access:public	signature:()
~Fix_Factory	/usr/include/itpp/fixed/fix_factory.h	/^  virtual ~Fix_Factory() {}$/;"	f	class:itpp::Fix_Factory	access:public	signature:()
~Fixed	/usr/include/itpp/fixed/fixed.h	/^  virtual ~Fixed() {}$/;"	f	class:itpp::Fixed	access:public	signature:()
~Freq_Filt	/usr/include/itpp/signal/freq_filt.h	/^  ~Freq_Filt() {}$/;"	f	class:itpp::Freq_Filt	access:public	signature:()
~Hamming_Code	/usr/include/itpp/comm/hammcode.h	/^  virtual ~Hamming_Code() { }$/;"	f	class:itpp::Hamming_Code	access:public	signature:()
~Histogram	/usr/include/itpp/stat/histogram.h	/^  ~Histogram() {};$/;"	f	class:itpp::Histogram	access:public	signature:()
~IFFT_Fading_Generator	/usr/include/itpp/comm/channel.h	/^  virtual ~IFFT_Fading_Generator() {}$/;"	f	class:itpp::IFFT_Fading_Generator	access:public	signature:()
~Independent_Fading_Generator	/usr/include/itpp/comm/channel.h	/^  virtual ~Independent_Fading_Generator() {}$/;"	f	class:itpp::Independent_Fading_Generator	access:public	signature:()
~L3_Packet_Info	/usr/include/itpp/protocol/packet.h	/^  ~L3_Packet_Info() {}$/;"	f	class:itpp::L3_Packet_Info	access:public	signature:()
~LDPC_Code	/usr/include/itpp/comm/ldpc.h	/^  virtual ~LDPC_Code() {}$/;"	f	class:itpp::LDPC_Code	access:public	signature:()
~LDPC_Generator	/usr/include/itpp/comm/ldpc.h	/^  virtual ~LDPC_Generator() {}$/;"	f	class:itpp::LDPC_Generator	access:public	signature:()
~LDPC_Generator_Systematic	/usr/include/itpp/comm/ldpc.h	/^  virtual ~LDPC_Generator_Systematic() {}$/;"	f	class:itpp::LDPC_Generator_Systematic	access:public	signature:()
~LDPC_Parity	/usr/include/itpp/comm/ldpc.h	/^  virtual ~LDPC_Parity() {}$/;"	f	class:itpp::LDPC_Parity	access:public	signature:()
~Line_Search	/usr/include/itpp/optim/newton_search.h	/^  ~Line_Search() {};$/;"	f	class:itpp::Line_Search	access:public	signature:()
~Link_Packet	/usr/include/itpp/protocol/packet.h	/^  ~Link_Packet() {}$/;"	f	class:itpp::Link_Packet	access:public	signature:()
~MA_Filter	/usr/include/itpp/signal/filter.h	/^  virtual ~MA_Filter() { }$/;"	f	class:itpp::MA_Filter	access:public	signature:()
~MOG_diag	/usr/include/itpp/stat/mog_diag.h	/^  ~MOG_diag() { cleanup(); }$/;"	f	class:itpp::MOG_diag	access:public	signature:()
~MOG_diag_EM_sup	/usr/include/itpp/stat/mog_diag_em.h	/^  ~MOG_diag_EM_sup() { }$/;"	f	class:itpp::MOG_diag_EM_sup	access:public	signature:()
~MOG_diag_kmeans_sup	/usr/include/itpp/stat/mog_diag_kmeans.h	/^  ~MOG_diag_kmeans_sup() { }$/;"	f	class:itpp::MOG_diag_kmeans_sup	access:public	signature:()
~MOG_generic	/usr/include/itpp/stat/mog_generic.h	/^  virtual ~MOG_generic() { cleanup(); }$/;"	f	class:itpp::MOG_generic	access:public	signature:()
~Mat	/usr/include/itpp/base/mat.h	/^  ~Mat();$/;"	p	class:itpp::Mat	access:public	signature:()
~Mat	/usr/include/itpp/base/mat.h	/^Mat<Num_T>::~Mat()$/;"	f	class:itpp::Mat	signature:()
~Modulator	/usr/include/itpp/comm/modulator.h	/^  virtual ~Modulator() {}$/;"	f	class:itpp::Modulator	access:public	signature:()
~Modulator_NCD	/usr/include/itpp/comm/modulator_nd.h	/^  ~Modulator_NCD() {}$/;"	f	class:itpp::Modulator_NCD	access:public	signature:()
~Modulator_ND	/usr/include/itpp/comm/modulator_nd.h	/^  ~Modulator_ND() {}$/;"	f	class:itpp::Modulator_ND	access:public	signature:()
~Modulator_NRD	/usr/include/itpp/comm/modulator_nd.h	/^  ~Modulator_NRD() {}$/;"	f	class:itpp::Modulator_NRD	access:public	signature:()
~ND_UPAM	/usr/include/itpp/comm/modulator_nd.h	/^  ~ND_UPAM() {}$/;"	f	class:itpp::ND_UPAM	access:public	signature:()
~ND_UPSK	/usr/include/itpp/comm/modulator_nd.h	/^  ~ND_UPSK() {}$/;"	f	class:itpp::ND_UPSK	access:public	signature:()
~ND_UQAM	/usr/include/itpp/comm/modulator_nd.h	/^  ~ND_UQAM() {}$/;"	f	class:itpp::ND_UQAM	access:public	signature:()
~Newton_Search	/usr/include/itpp/optim/newton_search.h	/^  ~Newton_Search() {};$/;"	f	class:itpp::Newton_Search	access:public	signature:()
~PAM	/usr/include/itpp/comm/modulator.h	/^  virtual ~PAM() {}$/;"	f	class:itpp::PAM	access:public	signature:()
~PAM_c	/usr/include/itpp/comm/modulator.h	/^  virtual ~PAM_c() {}$/;"	f	class:itpp::PAM_c	access:public	signature:()
~PSK	/usr/include/itpp/comm/modulator.h	/^  virtual ~PSK() { }$/;"	f	class:itpp::PSK	access:public	signature:()
~Packet	/usr/include/itpp/protocol/packet.h	/^  virtual ~Packet() {}$/;"	f	class:itpp::Packet	access:public	signature:()
~Packet_Channel	/usr/include/itpp/protocol/packet_channel.h	/^  ~Packet_Channel();$/;"	p	class:itpp::Packet_Channel	access:public	signature:()
~Packet_Generator	/usr/include/itpp/protocol/packet_generator.h	/^  virtual ~Packet_Generator();$/;"	p	class:itpp::Packet_Generator	access:public	signature:()
~Pattern_Source	/usr/include/itpp/signal/source.h	/^  virtual ~Pattern_Source() { }$/;"	f	class:itpp::Pattern_Source	access:public	signature:()
~Poisson_Packet_Generator	/usr/include/itpp/protocol/packet_generator.h	/^  virtual ~Poisson_Packet_Generator();$/;"	p	class:itpp::Poisson_Packet_Generator	access:public	signature:()
~Pulse_Shape	/usr/include/itpp/comm/pulse_shape.h	/^  virtual ~Pulse_Shape() {}$/;"	f	class:itpp::Pulse_Shape	access:public	signature:()
~Punctured_Convolutional_Code	/usr/include/itpp/comm/punct_convcode.h	/^  virtual ~Punctured_Convolutional_Code(void) {}$/;"	f	class:itpp::Punctured_Convolutional_Code	access:public	signature:(void)
~QAM	/usr/include/itpp/comm/modulator.h	/^  virtual ~QAM() { }$/;"	f	class:itpp::QAM	access:public	signature:()
~QPSK	/usr/include/itpp/comm/modulator.h	/^  virtual ~QPSK() {}$/;"	f	class:itpp::QPSK	access:public	signature:()
~Raised_Cosine	/usr/include/itpp/comm/pulse_shape.h	/^  virtual ~Raised_Cosine() {}$/;"	f	class:itpp::Raised_Cosine	access:public	signature:()
~Rec_Syst_Conv_Code	/usr/include/itpp/comm/rec_syst_conv_code.h	/^  virtual ~Rec_Syst_Conv_Code() {}$/;"	f	class:itpp::Rec_Syst_Conv_Code	access:public	signature:()
~Reed_Solomon	/usr/include/itpp/comm/reedsolomon.h	/^  virtual ~Reed_Solomon() { }$/;"	f	class:itpp::Reed_Solomon	access:public	signature:()
~Rice_Fading_Generator	/usr/include/itpp/comm/channel.h	/^  virtual ~Rice_Fading_Generator() {}$/;"	f	class:itpp::Rice_Fading_Generator	access:public	signature:()
~Root_Raised_Cosine	/usr/include/itpp/comm/pulse_shape.h	/^  virtual ~Root_Raised_Cosine() {}$/;"	f	class:itpp::Root_Raised_Cosine	access:public	signature:()
~SND_IO_File	/usr/include/itpp/srccode/audiofile.h	/^  virtual ~SND_IO_File() { close(); }$/;"	f	class:itpp::SND_IO_File	access:public	signature:()
~SND_In_File	/usr/include/itpp/srccode/audiofile.h	/^  virtual ~SND_In_File() { close(); }$/;"	f	class:itpp::SND_In_File	access:public	signature:()
~SND_Out_File	/usr/include/itpp/srccode/audiofile.h	/^  virtual ~SND_Out_File() { close(); }$/;"	f	class:itpp::SND_Out_File	access:public	signature:()
~Selective_Repeat_ARQ_Receiver	/usr/include/itpp/protocol/selective_repeat.h	/^  ~Selective_Repeat_ARQ_Receiver();$/;"	p	class:itpp::Selective_Repeat_ARQ_Receiver	access:public	signature:()
~Selective_Repeat_ARQ_Sender	/usr/include/itpp/protocol/selective_repeat.h	/^  ~Selective_Repeat_ARQ_Sender();$/;"	p	class:itpp::Selective_Repeat_ARQ_Sender	access:public	signature:()
~Signal	/usr/include/itpp/protocol/signals_slots.h	/^  ~Signal();$/;"	p	class:itpp::Signal	access:public	signature:()
~Signal	/usr/include/itpp/protocol/signals_slots.h	/^Signal<DataType>::~Signal()$/;"	f	class:itpp::Signal	signature:()
~Sink	/usr/include/itpp/protocol/packet_generator.h	/^  ~Sink();$/;"	p	class:itpp::Sink	access:public	signature:()
~Slot	/usr/include/itpp/protocol/signals_slots.h	/^  ~Slot();$/;"	p	class:itpp::Slot	access:public	signature:()
~Slot	/usr/include/itpp/protocol/signals_slots.h	/^Slot<ObjectType, DataType>::~Slot() {}$/;"	f	class:itpp::Slot	signature:()
~Sparse_Mat	/usr/include/itpp/base/smat.h	/^  ~Sparse_Mat();$/;"	p	class:itpp::Sparse_Mat	access:public	signature:()
~Sparse_Mat	/usr/include/itpp/base/smat.h	/^Sparse_Mat<T>::~Sparse_Mat()$/;"	f	class:itpp::Sparse_Mat	signature:()
~Sparse_Vec	/usr/include/itpp/base/svec.h	/^  ~Sparse_Vec();$/;"	p	class:itpp::Sparse_Vec	access:public	signature:()
~Sparse_Vec	/usr/include/itpp/base/svec.h	/^Sparse_Vec<T>::~Sparse_Vec()$/;"	f	class:itpp::Sparse_Vec	signature:()
~Stack	/usr/include/itpp/base/stack.h	/^  virtual ~Stack();$/;"	p	class:itpp::Stack	access:public	signature:()
~Stack	/usr/include/itpp/base/stack.h	/^Stack<T>::~Stack()$/;"	f	class:itpp::Stack	signature:()
~Stat	/usr/include/itpp/stat/misc_stat.h	/^  virtual ~Stat() {}$/;"	f	class:itpp::Stat	access:public	signature:()
~Static_Fading_Generator	/usr/include/itpp/comm/channel.h	/^  virtual ~Static_Fading_Generator() {}$/;"	f	class:itpp::Static_Fading_Generator	access:public	signature:()
~TCP_Client_Application	/usr/include/itpp/protocol/tcp_client_server.h	/^  ~TCP_Client_Application() { }$/;"	f	class:itpp::TCP_Client_Application	access:public	signature:()
~TCP_Packet	/usr/include/itpp/protocol/tcp.h	/^  virtual ~TCP_Packet();$/;"	p	class:itpp::TCP_Packet	access:public	signature:()
~TCP_Receiver	/usr/include/itpp/protocol/tcp.h	/^  virtual ~TCP_Receiver();$/;"	p	class:itpp::TCP_Receiver	access:public	signature:()
~TCP_Receiver_Buffer	/usr/include/itpp/protocol/tcp.h	/^  ~TCP_Receiver_Buffer();$/;"	p	class:itpp::TCP_Receiver_Buffer	access:public	signature:()
~TCP_Sender	/usr/include/itpp/protocol/tcp.h	/^  virtual ~TCP_Sender();$/;"	p	class:itpp::TCP_Sender	access:public	signature:()
~TCP_Server_Application	/usr/include/itpp/protocol/tcp_client_server.h	/^  ~TCP_Server_Application() { }$/;"	f	class:itpp::TCP_Server_Application	access:public	signature:()
~TDL_Channel	/usr/include/itpp/comm/channel.h	/^  virtual ~TDL_Channel();$/;"	p	class:itpp::TDL_Channel	access:public	signature:()
~TTimer	/usr/include/itpp/protocol/signals_slots.h	/^  virtual ~TTimer() {$/;"	f	class:itpp::TTimer	access:public	signature:()
~Timer	/usr/include/itpp/base/timing.h	/^  virtual ~Timer() { }$/;"	f	class:itpp::Timer	access:public	signature:()
~Turbo_Codec	/usr/include/itpp/comm/turbo.h	/^  virtual ~Turbo_Codec(void) {}$/;"	f	class:itpp::Turbo_Codec	access:public	signature:(void)
~Vec	/usr/include/itpp/base/vec.h	/^  ~Vec();$/;"	p	class:itpp::Vec	access:public	signature:()
~Vec	/usr/include/itpp/base/vec.h	/^Vec<Num_T>::~Vec()$/;"	f	class:itpp::Vec	signature:()
~bfstream	/usr/include/itpp/base/binfile.h	/^  ~bfstream() { }$/;"	f	class:itpp::bfstream	access:public	signature:()
~bifstream	/usr/include/itpp/base/binfile.h	/^  ~bifstream() { }$/;"	f	class:itpp::bifstream	access:public	signature:()
~bofstream	/usr/include/itpp/base/binfile.h	/^  ~bofstream() { }$/;"	f	class:itpp::bofstream	access:public	signature:()
~it_file	/usr/include/itpp/base/itfile.h	/^  virtual ~it_file() { }$/;"	f	class:itpp::it_file	access:public	signature:()
~it_file_old	/usr/include/itpp/base/itfile.h	/^  virtual ~it_file_old() { }$/;"	f	class:itpp::it_file_old	access:public	signature:()
~it_ifile	/usr/include/itpp/base/itfile.h	/^  virtual ~it_ifile() { }$/;"	f	class:itpp::it_ifile	access:public	signature:()
~it_ifile_old	/usr/include/itpp/base/itfile.h	/^  virtual ~it_ifile_old() { }$/;"	f	class:itpp::it_ifile_old	access:public	signature:()
